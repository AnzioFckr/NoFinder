var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb2, mod2) => function __require() {
  return mod2 || (0, cb2[__getOwnPropNames(cb2)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var require_index_001 = __commonJS({
  "assets/index-krSf2oo9.js"(exports, module) {
    ;
    !function() {
      try {
        var e2 = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}, n2 = new Error().stack;
        n2 && (e2._sentryDebugIds = e2._sentryDebugIds || {}, e2._sentryDebugIds[n2] = "f19d01cd-a411-4206-960f-fab0a16e82cc", e2._sentryDebugIdIdentifier = "sentry-dbid-f19d01cd-a411-4206-960f-fab0a16e82cc");
      } catch (e3) {
      }
    }();
    function _mergeNamespaces(n2, m2) {
      for (var i2 = 0; i2 < m2.length; i2++) {
        const e2 = m2[i2];
        if (typeof e2 !== "string" && !Array.isArray(e2)) {
          for (const k2 in e2) {
            if (k2 !== "default" && !(k2 in n2)) {
              const d = Object.getOwnPropertyDescriptor(e2, k2);
              if (d) {
                Object.defineProperty(n2, k2, d.get ? d : {
                  enumerable: true,
                  get: () => e2[k2]
                });
              }
            }
          }
        }
      }
      return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
    }
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function getDefaultExportFromCjs(x2) {
      return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
    }
    var jsxRuntime = { exports: {} };
    var reactJsxRuntime_production_min = {};
    var react = { exports: {} };
    var react_production_min = {};
    /**
     * @license React
     * react.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var l$1 = Symbol.for("react.element"), n$3 = Symbol.for("react.portal"), p$3 = Symbol.for("react.fragment"), q$2 = Symbol.for("react.strict_mode"), r$2 = Symbol.for("react.profiler"), t$2 = Symbol.for("react.provider"), u$1 = Symbol.for("react.context"), v$4 = Symbol.for("react.forward_ref"), w$2 = Symbol.for("react.suspense"), x = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), z$1 = Symbol.iterator;
    function A$1(a2) {
      if (null === a2 || "object" !== typeof a2)
        return null;
      a2 = z$1 && a2[z$1] || a2["@@iterator"];
      return "function" === typeof a2 ? a2 : null;
    }
    var B$1 = { isMounted: function() {
      return false;
    }, enqueueForceUpdate: function() {
    }, enqueueReplaceState: function() {
    }, enqueueSetState: function() {
    } }, C$1 = Object.assign, D$1 = {};
    function E$1(a2, b, e2) {
      this.props = a2;
      this.context = b;
      this.refs = D$1;
      this.updater = e2 || B$1;
    }
    E$1.prototype.isReactComponent = {};
    E$1.prototype.setState = function(a2, b) {
      if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, a2, b, "setState");
    };
    E$1.prototype.forceUpdate = function(a2) {
      this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
    };
    function F() {
    }
    F.prototype = E$1.prototype;
    function G$1(a2, b, e2) {
      this.props = a2;
      this.context = b;
      this.refs = D$1;
      this.updater = e2 || B$1;
    }
    var H$1 = G$1.prototype = new F();
    H$1.constructor = G$1;
    C$1(H$1, E$1.prototype);
    H$1.isPureReactComponent = true;
    var I$1 = Array.isArray, J = Object.prototype.hasOwnProperty, K$1 = { current: null }, L$1 = { key: true, ref: true, __self: true, __source: true };
    function M$1(a2, b, e2) {
      var d, c2 = {}, k2 = null, h2 = null;
      if (null != b)
        for (d in void 0 !== b.ref && (h2 = b.ref), void 0 !== b.key && (k2 = "" + b.key), b)
          J.call(b, d) && !L$1.hasOwnProperty(d) && (c2[d] = b[d]);
      var g2 = arguments.length - 2;
      if (1 === g2)
        c2.children = e2;
      else if (1 < g2) {
        for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
          f2[m2] = arguments[m2 + 2];
        c2.children = f2;
      }
      if (a2 && a2.defaultProps)
        for (d in g2 = a2.defaultProps, g2)
          void 0 === c2[d] && (c2[d] = g2[d]);
      return { $$typeof: l$1, type: a2, key: k2, ref: h2, props: c2, _owner: K$1.current };
    }
    function N$1(a2, b) {
      return { $$typeof: l$1, type: a2.type, key: b, ref: a2.ref, props: a2.props, _owner: a2._owner };
    }
    function O$1(a2) {
      return "object" === typeof a2 && null !== a2 && a2.$$typeof === l$1;
    }
    function escape$1(a2) {
      var b = { "=": "=0", ":": "=2" };
      return "$" + a2.replace(/[=:]/g, function(a3) {
        return b[a3];
      });
    }
    var P$1 = /\/+/g;
    function Q$1(a2, b) {
      return "object" === typeof a2 && null !== a2 && null != a2.key ? escape$1("" + a2.key) : b.toString(36);
    }
    function R$1(a2, b, e2, d, c2) {
      var k2 = typeof a2;
      if ("undefined" === k2 || "boolean" === k2)
        a2 = null;
      var h2 = false;
      if (null === a2)
        h2 = true;
      else
        switch (k2) {
          case "string":
          case "number":
            h2 = true;
            break;
          case "object":
            switch (a2.$$typeof) {
              case l$1:
              case n$3:
                h2 = true;
            }
        }
      if (h2)
        return h2 = a2, c2 = c2(h2), a2 = "" === d ? "." + Q$1(h2, 0) : d, I$1(c2) ? (e2 = "", null != a2 && (e2 = a2.replace(P$1, "$&/") + "/"), R$1(c2, b, e2, "", function(a3) {
          return a3;
        })) : null != c2 && (O$1(c2) && (c2 = N$1(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$1, "$&/") + "/") + a2)), b.push(c2)), 1;
      h2 = 0;
      d = "" === d ? "." : d + ":";
      if (I$1(a2))
        for (var g2 = 0; g2 < a2.length; g2++) {
          k2 = a2[g2];
          var f2 = d + Q$1(k2, g2);
          h2 += R$1(k2, b, e2, f2, c2);
        }
      else if (f2 = A$1(a2), "function" === typeof f2)
        for (a2 = f2.call(a2), g2 = 0; !(k2 = a2.next()).done; )
          k2 = k2.value, f2 = d + Q$1(k2, g2++), h2 += R$1(k2, b, e2, f2, c2);
      else if ("object" === k2)
        throw b = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
      return h2;
    }
    function S$1(a2, b, e2) {
      if (null == a2)
        return a2;
      var d = [], c2 = 0;
      R$1(a2, d, "", "", function(a3) {
        return b.call(e2, a3, c2++);
      });
      return d;
    }
    function T$1(a2) {
      if (-1 === a2._status) {
        var b = a2._result;
        b = b();
        b.then(function(b2) {
          if (0 === a2._status || -1 === a2._status)
            a2._status = 1, a2._result = b2;
        }, function(b2) {
          if (0 === a2._status || -1 === a2._status)
            a2._status = 2, a2._result = b2;
        });
        -1 === a2._status && (a2._status = 0, a2._result = b);
      }
      if (1 === a2._status)
        return a2._result.default;
      throw a2._result;
    }
    var U$1 = { current: null }, V$1 = { transition: null }, W$1 = { ReactCurrentDispatcher: U$1, ReactCurrentBatchConfig: V$1, ReactCurrentOwner: K$1 };
    function X$1() {
      throw Error("act(...) is not supported in production builds of React.");
    }
    react_production_min.Children = { map: S$1, forEach: function(a2, b, e2) {
      S$1(a2, function() {
        b.apply(this, arguments);
      }, e2);
    }, count: function(a2) {
      var b = 0;
      S$1(a2, function() {
        b++;
      });
      return b;
    }, toArray: function(a2) {
      return S$1(a2, function(a3) {
        return a3;
      }) || [];
    }, only: function(a2) {
      if (!O$1(a2))
        throw Error("React.Children.only expected to receive a single React element child.");
      return a2;
    } };
    react_production_min.Component = E$1;
    react_production_min.Fragment = p$3;
    react_production_min.Profiler = r$2;
    react_production_min.PureComponent = G$1;
    react_production_min.StrictMode = q$2;
    react_production_min.Suspense = w$2;
    react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
    react_production_min.act = X$1;
    react_production_min.cloneElement = function(a2, b, e2) {
      if (null === a2 || void 0 === a2)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
      var d = C$1({}, a2.props), c2 = a2.key, k2 = a2.ref, h2 = a2._owner;
      if (null != b) {
        void 0 !== b.ref && (k2 = b.ref, h2 = K$1.current);
        void 0 !== b.key && (c2 = "" + b.key);
        if (a2.type && a2.type.defaultProps)
          var g2 = a2.type.defaultProps;
        for (f2 in b)
          J.call(b, f2) && !L$1.hasOwnProperty(f2) && (d[f2] = void 0 === b[f2] && void 0 !== g2 ? g2[f2] : b[f2]);
      }
      var f2 = arguments.length - 2;
      if (1 === f2)
        d.children = e2;
      else if (1 < f2) {
        g2 = Array(f2);
        for (var m2 = 0; m2 < f2; m2++)
          g2[m2] = arguments[m2 + 2];
        d.children = g2;
      }
      return { $$typeof: l$1, type: a2.type, key: c2, ref: k2, props: d, _owner: h2 };
    };
    react_production_min.createContext = function(a2) {
      a2 = { $$typeof: u$1, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
      a2.Provider = { $$typeof: t$2, _context: a2 };
      return a2.Consumer = a2;
    };
    react_production_min.createElement = M$1;
    react_production_min.createFactory = function(a2) {
      var b = M$1.bind(null, a2);
      b.type = a2;
      return b;
    };
    react_production_min.createRef = function() {
      return { current: null };
    };
    react_production_min.forwardRef = function(a2) {
      return { $$typeof: v$4, render: a2 };
    };
    react_production_min.isValidElement = O$1;
    react_production_min.lazy = function(a2) {
      return { $$typeof: y, _payload: { _status: -1, _result: a2 }, _init: T$1 };
    };
    react_production_min.memo = function(a2, b) {
      return { $$typeof: x, type: a2, compare: void 0 === b ? null : b };
    };
    react_production_min.startTransition = function(a2) {
      var b = V$1.transition;
      V$1.transition = {};
      try {
        a2();
      } finally {
        V$1.transition = b;
      }
    };
    react_production_min.unstable_act = X$1;
    react_production_min.useCallback = function(a2, b) {
      return U$1.current.useCallback(a2, b);
    };
    react_production_min.useContext = function(a2) {
      return U$1.current.useContext(a2);
    };
    react_production_min.useDebugValue = function() {
    };
    react_production_min.useDeferredValue = function(a2) {
      return U$1.current.useDeferredValue(a2);
    };
    react_production_min.useEffect = function(a2, b) {
      return U$1.current.useEffect(a2, b);
    };
    react_production_min.useId = function() {
      return U$1.current.useId();
    };
    react_production_min.useImperativeHandle = function(a2, b, e2) {
      return U$1.current.useImperativeHandle(a2, b, e2);
    };
    react_production_min.useInsertionEffect = function(a2, b) {
      return U$1.current.useInsertionEffect(a2, b);
    };
    react_production_min.useLayoutEffect = function(a2, b) {
      return U$1.current.useLayoutEffect(a2, b);
    };
    react_production_min.useMemo = function(a2, b) {
      return U$1.current.useMemo(a2, b);
    };
    react_production_min.useReducer = function(a2, b, e2) {
      return U$1.current.useReducer(a2, b, e2);
    };
    react_production_min.useRef = function(a2) {
      return U$1.current.useRef(a2);
    };
    react_production_min.useState = function(a2) {
      return U$1.current.useState(a2);
    };
    react_production_min.useSyncExternalStore = function(a2, b, e2) {
      return U$1.current.useSyncExternalStore(a2, b, e2);
    };
    react_production_min.useTransition = function() {
      return U$1.current.useTransition();
    };
    react_production_min.version = "18.3.1";
    {
      react.exports = react_production_min;
    }
    var reactExports = react.exports;
    const React$1 = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
    const React$2 = /* @__PURE__ */ _mergeNamespaces({
      __proto__: null,
      default: React$1
    }, [reactExports]);
    /**
     * @license React
     * react-jsx-runtime.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var f = reactExports, k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m$1 = Object.prototype.hasOwnProperty, n$2 = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$2 = { key: true, ref: true, __self: true, __source: true };
    function q$1(c2, a2, g2) {
      var b, d = {}, e2 = null, h2 = null;
      void 0 !== g2 && (e2 = "" + g2);
      void 0 !== a2.key && (e2 = "" + a2.key);
      void 0 !== a2.ref && (h2 = a2.ref);
      for (b in a2)
        m$1.call(a2, b) && !p$2.hasOwnProperty(b) && (d[b] = a2[b]);
      if (c2 && c2.defaultProps)
        for (b in a2 = c2.defaultProps, a2)
          void 0 === d[b] && (d[b] = a2[b]);
      return { $$typeof: k, type: c2, key: e2, ref: h2, props: d, _owner: n$2.current };
    }
    reactJsxRuntime_production_min.Fragment = l;
    reactJsxRuntime_production_min.jsx = q$1;
    reactJsxRuntime_production_min.jsxs = q$1;
    {
      jsxRuntime.exports = reactJsxRuntime_production_min;
    }
    var jsxRuntimeExports = jsxRuntime.exports;
    var client = {};
    var reactDom = { exports: {} };
    var reactDom_production_min = {};
    var scheduler = { exports: {} };
    var scheduler_production_min = {};
    /**
     * @license React
     * scheduler.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    (function(exports2) {
      function f2(a2, b) {
        var c2 = a2.length;
        a2.push(b);
        a:
          for (; 0 < c2; ) {
            var d = c2 - 1 >>> 1, e2 = a2[d];
            if (0 < g2(e2, b))
              a2[d] = b, a2[c2] = e2, c2 = d;
            else
              break a;
          }
      }
      function h2(a2) {
        return 0 === a2.length ? null : a2[0];
      }
      function k2(a2) {
        if (0 === a2.length)
          return null;
        var b = a2[0], c2 = a2.pop();
        if (c2 !== b) {
          a2[0] = c2;
          a:
            for (var d = 0, e2 = a2.length, w2 = e2 >>> 1; d < w2; ) {
              var m2 = 2 * (d + 1) - 1, C2 = a2[m2], n2 = m2 + 1, x2 = a2[n2];
              if (0 > g2(C2, c2))
                n2 < e2 && 0 > g2(x2, C2) ? (a2[d] = x2, a2[n2] = c2, d = n2) : (a2[d] = C2, a2[m2] = c2, d = m2);
              else if (n2 < e2 && 0 > g2(x2, c2))
                a2[d] = x2, a2[n2] = c2, d = n2;
              else
                break a;
            }
        }
        return b;
      }
      function g2(a2, b) {
        var c2 = a2.sortIndex - b.sortIndex;
        return 0 !== c2 ? c2 : a2.id - b.id;
      }
      if ("object" === typeof performance && "function" === typeof performance.now) {
        var l2 = performance;
        exports2.unstable_now = function() {
          return l2.now();
        };
      } else {
        var p2 = Date, q2 = p2.now();
        exports2.unstable_now = function() {
          return p2.now() - q2;
        };
      }
      var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
      "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function G2(a2) {
        for (var b = h2(t2); null !== b; ) {
          if (null === b.callback)
            k2(t2);
          else if (b.startTime <= a2)
            k2(t2), b.sortIndex = b.expirationTime, f2(r2, b);
          else
            break;
          b = h2(t2);
        }
      }
      function H2(a2) {
        B2 = false;
        G2(a2);
        if (!A2)
          if (null !== h2(r2))
            A2 = true, I2(J2);
          else {
            var b = h2(t2);
            null !== b && K2(H2, b.startTime - a2);
          }
      }
      function J2(a2, b) {
        A2 = false;
        B2 && (B2 = false, E2(L2), L2 = -1);
        z2 = true;
        var c2 = y2;
        try {
          G2(b);
          for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b) || a2 && !M2()); ) {
            var d = v2.callback;
            if ("function" === typeof d) {
              v2.callback = null;
              y2 = v2.priorityLevel;
              var e2 = d(v2.expirationTime <= b);
              b = exports2.unstable_now();
              "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
              G2(b);
            } else
              k2(r2);
            v2 = h2(r2);
          }
          if (null !== v2)
            var w2 = true;
          else {
            var m2 = h2(t2);
            null !== m2 && K2(H2, m2.startTime - b);
            w2 = false;
          }
          return w2;
        } finally {
          v2 = null, y2 = c2, z2 = false;
        }
      }
      var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
      function M2() {
        return exports2.unstable_now() - Q2 < P2 ? false : true;
      }
      function R2() {
        if (null !== O2) {
          var a2 = exports2.unstable_now();
          Q2 = a2;
          var b = true;
          try {
            b = O2(true, a2);
          } finally {
            b ? S2() : (N2 = false, O2 = null);
          }
        } else
          N2 = false;
      }
      var S2;
      if ("function" === typeof F2)
        S2 = function() {
          F2(R2);
        };
      else if ("undefined" !== typeof MessageChannel) {
        var T2 = new MessageChannel(), U2 = T2.port2;
        T2.port1.onmessage = R2;
        S2 = function() {
          U2.postMessage(null);
        };
      } else
        S2 = function() {
          D2(R2, 0);
        };
      function I2(a2) {
        O2 = a2;
        N2 || (N2 = true, S2());
      }
      function K2(a2, b) {
        L2 = D2(function() {
          a2(exports2.unstable_now());
        }, b);
      }
      exports2.unstable_IdlePriority = 5;
      exports2.unstable_ImmediatePriority = 1;
      exports2.unstable_LowPriority = 4;
      exports2.unstable_NormalPriority = 3;
      exports2.unstable_Profiling = null;
      exports2.unstable_UserBlockingPriority = 2;
      exports2.unstable_cancelCallback = function(a2) {
        a2.callback = null;
      };
      exports2.unstable_continueExecution = function() {
        A2 || z2 || (A2 = true, I2(J2));
      };
      exports2.unstable_forceFrameRate = function(a2) {
        0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
      };
      exports2.unstable_getCurrentPriorityLevel = function() {
        return y2;
      };
      exports2.unstable_getFirstCallbackNode = function() {
        return h2(r2);
      };
      exports2.unstable_next = function(a2) {
        switch (y2) {
          case 1:
          case 2:
          case 3:
            var b = 3;
            break;
          default:
            b = y2;
        }
        var c2 = y2;
        y2 = b;
        try {
          return a2();
        } finally {
          y2 = c2;
        }
      };
      exports2.unstable_pauseExecution = function() {
      };
      exports2.unstable_requestPaint = function() {
      };
      exports2.unstable_runWithPriority = function(a2, b) {
        switch (a2) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            a2 = 3;
        }
        var c2 = y2;
        y2 = a2;
        try {
          return b();
        } finally {
          y2 = c2;
        }
      };
      exports2.unstable_scheduleCallback = function(a2, b, c2) {
        var d = exports2.unstable_now();
        "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d + c2 : d) : c2 = d;
        switch (a2) {
          case 1:
            var e2 = -1;
            break;
          case 2:
            e2 = 250;
            break;
          case 5:
            e2 = 1073741823;
            break;
          case 4:
            e2 = 1e4;
            break;
          default:
            e2 = 5e3;
        }
        e2 = c2 + e2;
        a2 = { id: u2++, callback: b, priorityLevel: a2, startTime: c2, expirationTime: e2, sortIndex: -1 };
        c2 > d ? (a2.sortIndex = c2, f2(t2, a2), null === h2(r2) && a2 === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d))) : (a2.sortIndex = e2, f2(r2, a2), A2 || z2 || (A2 = true, I2(J2)));
        return a2;
      };
      exports2.unstable_shouldYield = M2;
      exports2.unstable_wrapCallback = function(a2) {
        var b = y2;
        return function() {
          var c2 = y2;
          y2 = b;
          try {
            return a2.apply(this, arguments);
          } finally {
            y2 = c2;
          }
        };
      };
    })(scheduler_production_min);
    {
      scheduler.exports = scheduler_production_min;
    }
    var schedulerExports = scheduler.exports;
    /**
     * @license React
     * react-dom.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var aa = reactExports, ca = schedulerExports;
    function p$1(a2) {
      for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
        b += "&args[]=" + encodeURIComponent(arguments[c2]);
      return "Minified React error #" + a2 + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var da$1 = /* @__PURE__ */ new Set(), ea = {};
    function fa(a2, b) {
      ha(a2, b);
      ha(a2 + "Capture", b);
    }
    function ha(a2, b) {
      ea[a2] = b;
      for (a2 = 0; a2 < b.length; a2++)
        da$1.add(b[a2]);
    }
    var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
    function oa(a2) {
      if (ja.call(ma, a2))
        return true;
      if (ja.call(la, a2))
        return false;
      if (ka.test(a2))
        return ma[a2] = true;
      la[a2] = true;
      return false;
    }
    function pa(a2, b, c2, d) {
      if (null !== c2 && 0 === c2.type)
        return false;
      switch (typeof b) {
        case "function":
        case "symbol":
          return true;
        case "boolean":
          if (d)
            return false;
          if (null !== c2)
            return !c2.acceptsBooleans;
          a2 = a2.toLowerCase().slice(0, 5);
          return "data-" !== a2 && "aria-" !== a2;
        default:
          return false;
      }
    }
    function qa(a2, b, c2, d) {
      if (null === b || "undefined" === typeof b || pa(a2, b, c2, d))
        return true;
      if (d)
        return false;
      if (null !== c2)
        switch (c2.type) {
          case 3:
            return !b;
          case 4:
            return false === b;
          case 5:
            return isNaN(b);
          case 6:
            return isNaN(b) || 1 > b;
        }
      return false;
    }
    function v$3(a2, b, c2, d, e2, f2, g2) {
      this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
      this.attributeName = d;
      this.attributeNamespace = e2;
      this.mustUseProperty = c2;
      this.propertyName = a2;
      this.type = b;
      this.sanitizeURL = f2;
      this.removeEmptyString = g2;
    }
    var z = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
      z[a2] = new v$3(a2, 0, false, a2, null, false, false);
    });
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
      var b = a2[0];
      z[b] = new v$3(b, 1, false, a2[1], null, false, false);
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
      z[a2] = new v$3(a2, 2, false, a2.toLowerCase(), null, false, false);
    });
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
      z[a2] = new v$3(a2, 2, false, a2, null, false, false);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
      z[a2] = new v$3(a2, 3, false, a2.toLowerCase(), null, false, false);
    });
    ["checked", "multiple", "muted", "selected"].forEach(function(a2) {
      z[a2] = new v$3(a2, 3, true, a2, null, false, false);
    });
    ["capture", "download"].forEach(function(a2) {
      z[a2] = new v$3(a2, 4, false, a2, null, false, false);
    });
    ["cols", "rows", "size", "span"].forEach(function(a2) {
      z[a2] = new v$3(a2, 6, false, a2, null, false, false);
    });
    ["rowSpan", "start"].forEach(function(a2) {
      z[a2] = new v$3(a2, 5, false, a2.toLowerCase(), null, false, false);
    });
    var ra = /[\-:]([a-z])/g;
    function sa(a2) {
      return a2[1].toUpperCase();
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
      var b = a2.replace(
        ra,
        sa
      );
      z[b] = new v$3(b, 1, false, a2, null, false, false);
    });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
      var b = a2.replace(ra, sa);
      z[b] = new v$3(b, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
    });
    ["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
      var b = a2.replace(ra, sa);
      z[b] = new v$3(b, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
    });
    ["tabIndex", "crossOrigin"].forEach(function(a2) {
      z[a2] = new v$3(a2, 1, false, a2.toLowerCase(), null, false, false);
    });
    z.xlinkHref = new v$3("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
    ["src", "href", "action", "formAction"].forEach(function(a2) {
      z[a2] = new v$3(a2, 1, false, a2.toLowerCase(), null, true, true);
    });
    function ta(a2, b, c2, d) {
      var e2 = z.hasOwnProperty(b) ? z[b] : null;
      if (null !== e2 ? 0 !== e2.type : d || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1])
        qa(b, c2, e2, d) && (c2 = null), d || null === e2 ? oa(b) && (null === c2 ? a2.removeAttribute(b) : a2.setAttribute(b, "" + c2)) : e2.mustUseProperty ? a2[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b = e2.attributeName, d = e2.attributeNamespace, null === c2 ? a2.removeAttribute(b) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d ? a2.setAttributeNS(d, b, c2) : a2.setAttribute(b, c2)));
    }
    var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
    var Ia = Symbol.for("react.offscreen");
    var Ja = Symbol.iterator;
    function Ka(a2) {
      if (null === a2 || "object" !== typeof a2)
        return null;
      a2 = Ja && a2[Ja] || a2["@@iterator"];
      return "function" === typeof a2 ? a2 : null;
    }
    var A = Object.assign, La;
    function Ma(a2) {
      if (void 0 === La)
        try {
          throw Error();
        } catch (c2) {
          var b = c2.stack.trim().match(/\n( *(at )?)/);
          La = b && b[1] || "";
        }
      return "\n" + La + a2;
    }
    var Na = false;
    function Oa(a2, b) {
      if (!a2 || Na)
        return "";
      Na = true;
      var c2 = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (b)
          if (b = function() {
            throw Error();
          }, Object.defineProperty(b.prototype, "props", { set: function() {
            throw Error();
          } }), "object" === typeof Reflect && Reflect.construct) {
            try {
              Reflect.construct(b, []);
            } catch (l2) {
              var d = l2;
            }
            Reflect.construct(a2, [], b);
          } else {
            try {
              b.call();
            } catch (l2) {
              d = l2;
            }
            a2.call(b.prototype);
          }
        else {
          try {
            throw Error();
          } catch (l2) {
            d = l2;
          }
          a2();
        }
      } catch (l2) {
        if (l2 && d && "string" === typeof l2.stack) {
          for (var e2 = l2.stack.split("\n"), f2 = d.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
            h2--;
          for (; 1 <= g2 && 0 <= h2; g2--, h2--)
            if (e2[g2] !== f2[h2]) {
              if (1 !== g2 || 1 !== h2) {
                do
                  if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
                    var k2 = "\n" + e2[g2].replace(" at new ", " at ");
                    a2.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a2.displayName));
                    return k2;
                  }
                while (1 <= g2 && 0 <= h2);
              }
              break;
            }
        }
      } finally {
        Na = false, Error.prepareStackTrace = c2;
      }
      return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
    }
    function Pa(a2) {
      switch (a2.tag) {
        case 5:
          return Ma(a2.type);
        case 16:
          return Ma("Lazy");
        case 13:
          return Ma("Suspense");
        case 19:
          return Ma("SuspenseList");
        case 0:
        case 2:
        case 15:
          return a2 = Oa(a2.type, false), a2;
        case 11:
          return a2 = Oa(a2.type.render, false), a2;
        case 1:
          return a2 = Oa(a2.type, true), a2;
        default:
          return "";
      }
    }
    function Qa(a2) {
      if (null == a2)
        return null;
      if ("function" === typeof a2)
        return a2.displayName || a2.name || null;
      if ("string" === typeof a2)
        return a2;
      switch (a2) {
        case ya:
          return "Fragment";
        case wa:
          return "Portal";
        case Aa:
          return "Profiler";
        case za:
          return "StrictMode";
        case Ea:
          return "Suspense";
        case Fa:
          return "SuspenseList";
      }
      if ("object" === typeof a2)
        switch (a2.$$typeof) {
          case Ca:
            return (a2.displayName || "Context") + ".Consumer";
          case Ba:
            return (a2._context.displayName || "Context") + ".Provider";
          case Da:
            var b = a2.render;
            a2 = a2.displayName;
            a2 || (a2 = b.displayName || b.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
            return a2;
          case Ga:
            return b = a2.displayName || null, null !== b ? b : Qa(a2.type) || "Memo";
          case Ha:
            b = a2._payload;
            a2 = a2._init;
            try {
              return Qa(a2(b));
            } catch (c2) {
            }
        }
      return null;
    }
    function Ra(a2) {
      var b = a2.type;
      switch (a2.tag) {
        case 24:
          return "Cache";
        case 9:
          return (b.displayName || "Context") + ".Consumer";
        case 10:
          return (b._context.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return a2 = b.render, a2 = a2.displayName || a2.name || "", b.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 5:
          return b;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return Qa(b);
        case 8:
          return b === za ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
          if ("function" === typeof b)
            return b.displayName || b.name || null;
          if ("string" === typeof b)
            return b;
      }
      return null;
    }
    function Sa(a2) {
      switch (typeof a2) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return a2;
        case "object":
          return a2;
        default:
          return "";
      }
    }
    function Ta(a2) {
      var b = a2.type;
      return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b || "radio" === b);
    }
    function Ua(a2) {
      var b = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b), d = "" + a2[b];
      if (!a2.hasOwnProperty(b) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
        var e2 = c2.get, f2 = c2.set;
        Object.defineProperty(a2, b, { configurable: true, get: function() {
          return e2.call(this);
        }, set: function(a3) {
          d = "" + a3;
          f2.call(this, a3);
        } });
        Object.defineProperty(a2, b, { enumerable: c2.enumerable });
        return { getValue: function() {
          return d;
        }, setValue: function(a3) {
          d = "" + a3;
        }, stopTracking: function() {
          a2._valueTracker = null;
          delete a2[b];
        } };
      }
    }
    function Va(a2) {
      a2._valueTracker || (a2._valueTracker = Ua(a2));
    }
    function Wa(a2) {
      if (!a2)
        return false;
      var b = a2._valueTracker;
      if (!b)
        return true;
      var c2 = b.getValue();
      var d = "";
      a2 && (d = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
      a2 = d;
      return a2 !== c2 ? (b.setValue(a2), true) : false;
    }
    function Xa(a2) {
      a2 = a2 || ("undefined" !== typeof document ? document : void 0);
      if ("undefined" === typeof a2)
        return null;
      try {
        return a2.activeElement || a2.body;
      } catch (b) {
        return a2.body;
      }
    }
    function Ya(a2, b) {
      var c2 = b.checked;
      return A({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
    }
    function Za(a2, b) {
      var c2 = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
      c2 = Sa(null != b.value ? b.value : c2);
      a2._wrapperState = { initialChecked: d, initialValue: c2, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
    }
    function ab(a2, b) {
      b = b.checked;
      null != b && ta(a2, "checked", b, false);
    }
    function bb(a2, b) {
      ab(a2, b);
      var c2 = Sa(b.value), d = b.type;
      if (null != c2)
        if ("number" === d) {
          if (0 === c2 && "" === a2.value || a2.value != c2)
            a2.value = "" + c2;
        } else
          a2.value !== "" + c2 && (a2.value = "" + c2);
      else if ("submit" === d || "reset" === d) {
        a2.removeAttribute("value");
        return;
      }
      b.hasOwnProperty("value") ? cb(a2, b.type, c2) : b.hasOwnProperty("defaultValue") && cb(a2, b.type, Sa(b.defaultValue));
      null == b.checked && null != b.defaultChecked && (a2.defaultChecked = !!b.defaultChecked);
    }
    function db(a2, b, c2) {
      if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
        var d = b.type;
        if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value))
          return;
        b = "" + a2._wrapperState.initialValue;
        c2 || b === a2.value || (a2.value = b);
        a2.defaultValue = b;
      }
      c2 = a2.name;
      "" !== c2 && (a2.name = "");
      a2.defaultChecked = !!a2._wrapperState.initialChecked;
      "" !== c2 && (a2.name = c2);
    }
    function cb(a2, b, c2) {
      if ("number" !== b || Xa(a2.ownerDocument) !== a2)
        null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
    }
    var eb = Array.isArray;
    function fb(a2, b, c2, d) {
      a2 = a2.options;
      if (b) {
        b = {};
        for (var e2 = 0; e2 < c2.length; e2++)
          b["$" + c2[e2]] = true;
        for (c2 = 0; c2 < a2.length; c2++)
          e2 = b.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e2 && (a2[c2].selected = e2), e2 && d && (a2[c2].defaultSelected = true);
      } else {
        c2 = "" + Sa(c2);
        b = null;
        for (e2 = 0; e2 < a2.length; e2++) {
          if (a2[e2].value === c2) {
            a2[e2].selected = true;
            d && (a2[e2].defaultSelected = true);
            return;
          }
          null !== b || a2[e2].disabled || (b = a2[e2]);
        }
        null !== b && (b.selected = true);
      }
    }
    function gb(a2, b) {
      if (null != b.dangerouslySetInnerHTML)
        throw Error(p$1(91));
      return A({}, b, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
    }
    function hb(a2, b) {
      var c2 = b.value;
      if (null == c2) {
        c2 = b.children;
        b = b.defaultValue;
        if (null != c2) {
          if (null != b)
            throw Error(p$1(92));
          if (eb(c2)) {
            if (1 < c2.length)
              throw Error(p$1(93));
            c2 = c2[0];
          }
          b = c2;
        }
        null == b && (b = "");
        c2 = b;
      }
      a2._wrapperState = { initialValue: Sa(c2) };
    }
    function ib(a2, b) {
      var c2 = Sa(b.value), d = Sa(b.defaultValue);
      null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
      null != d && (a2.defaultValue = "" + d);
    }
    function jb(a2) {
      var b = a2.textContent;
      b === a2._wrapperState.initialValue && "" !== b && null !== b && (a2.value = b);
    }
    function kb(a2) {
      switch (a2) {
        case "svg":
          return "http://www.w3.org/2000/svg";
        case "math":
          return "http://www.w3.org/1998/Math/MathML";
        default:
          return "http://www.w3.org/1999/xhtml";
      }
    }
    function lb(a2, b) {
      return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a2;
    }
    var mb, nb = function(a2) {
      return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c2, d, e2) {
        MSApp.execUnsafeLocalFunction(function() {
          return a2(b, c2, d, e2);
        });
      } : a2;
    }(function(a2, b) {
      if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2)
        a2.innerHTML = b;
      else {
        mb = mb || document.createElement("div");
        mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
        for (b = mb.firstChild; a2.firstChild; )
          a2.removeChild(a2.firstChild);
        for (; b.firstChild; )
          a2.appendChild(b.firstChild);
      }
    });
    function ob(a2, b) {
      if (b) {
        var c2 = a2.firstChild;
        if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
          c2.nodeValue = b;
          return;
        }
      }
      a2.textContent = b;
    }
    var pb = {
      animationIterationCount: true,
      aspectRatio: true,
      borderImageOutset: true,
      borderImageSlice: true,
      borderImageWidth: true,
      boxFlex: true,
      boxFlexGroup: true,
      boxOrdinalGroup: true,
      columnCount: true,
      columns: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      flexOrder: true,
      gridArea: true,
      gridRow: true,
      gridRowEnd: true,
      gridRowSpan: true,
      gridRowStart: true,
      gridColumn: true,
      gridColumnEnd: true,
      gridColumnSpan: true,
      gridColumnStart: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      fillOpacity: true,
      floodOpacity: true,
      stopOpacity: true,
      strokeDasharray: true,
      strokeDashoffset: true,
      strokeMiterlimit: true,
      strokeOpacity: true,
      strokeWidth: true
    }, qb = ["Webkit", "ms", "Moz", "O"];
    Object.keys(pb).forEach(function(a2) {
      qb.forEach(function(b) {
        b = b + a2.charAt(0).toUpperCase() + a2.substring(1);
        pb[b] = pb[a2];
      });
    });
    function rb(a2, b, c2) {
      return null == b || "boolean" === typeof b || "" === b ? "" : c2 || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b).trim() : b + "px";
    }
    function sb(a2, b) {
      a2 = a2.style;
      for (var c2 in b)
        if (b.hasOwnProperty(c2)) {
          var d = 0 === c2.indexOf("--"), e2 = rb(c2, b[c2], d);
          "float" === c2 && (c2 = "cssFloat");
          d ? a2.setProperty(c2, e2) : a2[c2] = e2;
        }
    }
    var tb = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
    function ub(a2, b) {
      if (b) {
        if (tb[a2] && (null != b.children || null != b.dangerouslySetInnerHTML))
          throw Error(p$1(137, a2));
        if (null != b.dangerouslySetInnerHTML) {
          if (null != b.children)
            throw Error(p$1(60));
          if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML))
            throw Error(p$1(61));
        }
        if (null != b.style && "object" !== typeof b.style)
          throw Error(p$1(62));
      }
    }
    function vb(a2, b) {
      if (-1 === a2.indexOf("-"))
        return "string" === typeof b.is;
      switch (a2) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    var wb = null;
    function xb(a2) {
      a2 = a2.target || a2.srcElement || window;
      a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
      return 3 === a2.nodeType ? a2.parentNode : a2;
    }
    var yb = null, zb = null, Ab = null;
    function Bb(a2) {
      if (a2 = Cb(a2)) {
        if ("function" !== typeof yb)
          throw Error(p$1(280));
        var b = a2.stateNode;
        b && (b = Db(b), yb(a2.stateNode, a2.type, b));
      }
    }
    function Eb(a2) {
      zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
    }
    function Fb() {
      if (zb) {
        var a2 = zb, b = Ab;
        Ab = zb = null;
        Bb(a2);
        if (b)
          for (a2 = 0; a2 < b.length; a2++)
            Bb(b[a2]);
      }
    }
    function Gb(a2, b) {
      return a2(b);
    }
    function Hb() {
    }
    var Ib = false;
    function Jb(a2, b, c2) {
      if (Ib)
        return a2(b, c2);
      Ib = true;
      try {
        return Gb(a2, b, c2);
      } finally {
        if (Ib = false, null !== zb || null !== Ab)
          Hb(), Fb();
      }
    }
    function Kb(a2, b) {
      var c2 = a2.stateNode;
      if (null === c2)
        return null;
      var d = Db(c2);
      if (null === d)
        return null;
      c2 = d[b];
      a:
        switch (b) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (d = !d.disabled) || (a2 = a2.type, d = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
            a2 = !d;
            break a;
          default:
            a2 = false;
        }
      if (a2)
        return null;
      if (c2 && "function" !== typeof c2)
        throw Error(p$1(231, b, typeof c2));
      return c2;
    }
    var Lb = false;
    if (ia)
      try {
        var Mb = {};
        Object.defineProperty(Mb, "passive", { get: function() {
          Lb = true;
        } });
        window.addEventListener("test", Mb, Mb);
        window.removeEventListener("test", Mb, Mb);
      } catch (a2) {
        Lb = false;
      }
    function Nb(a2, b, c2, d, e2, f2, g2, h2, k2) {
      var l2 = Array.prototype.slice.call(arguments, 3);
      try {
        b.apply(c2, l2);
      } catch (m2) {
        this.onError(m2);
      }
    }
    var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a2) {
      Ob = true;
      Pb = a2;
    } };
    function Tb(a2, b, c2, d, e2, f2, g2, h2, k2) {
      Ob = false;
      Pb = null;
      Nb.apply(Sb, arguments);
    }
    function Ub(a2, b, c2, d, e2, f2, g2, h2, k2) {
      Tb.apply(this, arguments);
      if (Ob) {
        if (Ob) {
          var l2 = Pb;
          Ob = false;
          Pb = null;
        } else
          throw Error(p$1(198));
        Qb || (Qb = true, Rb = l2);
      }
    }
    function Vb(a2) {
      var b = a2, c2 = a2;
      if (a2.alternate)
        for (; b.return; )
          b = b.return;
      else {
        a2 = b;
        do
          b = a2, 0 !== (b.flags & 4098) && (c2 = b.return), a2 = b.return;
        while (a2);
      }
      return 3 === b.tag ? c2 : null;
    }
    function Wb(a2) {
      if (13 === a2.tag) {
        var b = a2.memoizedState;
        null === b && (a2 = a2.alternate, null !== a2 && (b = a2.memoizedState));
        if (null !== b)
          return b.dehydrated;
      }
      return null;
    }
    function Xb(a2) {
      if (Vb(a2) !== a2)
        throw Error(p$1(188));
    }
    function Yb(a2) {
      var b = a2.alternate;
      if (!b) {
        b = Vb(a2);
        if (null === b)
          throw Error(p$1(188));
        return b !== a2 ? null : a2;
      }
      for (var c2 = a2, d = b; ; ) {
        var e2 = c2.return;
        if (null === e2)
          break;
        var f2 = e2.alternate;
        if (null === f2) {
          d = e2.return;
          if (null !== d) {
            c2 = d;
            continue;
          }
          break;
        }
        if (e2.child === f2.child) {
          for (f2 = e2.child; f2; ) {
            if (f2 === c2)
              return Xb(e2), a2;
            if (f2 === d)
              return Xb(e2), b;
            f2 = f2.sibling;
          }
          throw Error(p$1(188));
        }
        if (c2.return !== d.return)
          c2 = e2, d = f2;
        else {
          for (var g2 = false, h2 = e2.child; h2; ) {
            if (h2 === c2) {
              g2 = true;
              c2 = e2;
              d = f2;
              break;
            }
            if (h2 === d) {
              g2 = true;
              d = e2;
              c2 = f2;
              break;
            }
            h2 = h2.sibling;
          }
          if (!g2) {
            for (h2 = f2.child; h2; ) {
              if (h2 === c2) {
                g2 = true;
                c2 = f2;
                d = e2;
                break;
              }
              if (h2 === d) {
                g2 = true;
                d = f2;
                c2 = e2;
                break;
              }
              h2 = h2.sibling;
            }
            if (!g2)
              throw Error(p$1(189));
          }
        }
        if (c2.alternate !== d)
          throw Error(p$1(190));
      }
      if (3 !== c2.tag)
        throw Error(p$1(188));
      return c2.stateNode.current === c2 ? a2 : b;
    }
    function Zb(a2) {
      a2 = Yb(a2);
      return null !== a2 ? $b(a2) : null;
    }
    function $b(a2) {
      if (5 === a2.tag || 6 === a2.tag)
        return a2;
      for (a2 = a2.child; null !== a2; ) {
        var b = $b(a2);
        if (null !== b)
          return b;
        a2 = a2.sibling;
      }
      return null;
    }
    var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
    function mc(a2) {
      if (lc && "function" === typeof lc.onCommitFiberRoot)
        try {
          lc.onCommitFiberRoot(kc, a2, void 0, 128 === (a2.current.flags & 128));
        } catch (b) {
        }
    }
    var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
    function nc(a2) {
      a2 >>>= 0;
      return 0 === a2 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
    }
    var rc = 64, sc = 4194304;
    function tc(a2) {
      switch (a2 & -a2) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return a2 & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return a2 & 130023424;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 1073741824;
        default:
          return a2;
      }
    }
    function uc(a2, b) {
      var c2 = a2.pendingLanes;
      if (0 === c2)
        return 0;
      var d = 0, e2 = a2.suspendedLanes, f2 = a2.pingedLanes, g2 = c2 & 268435455;
      if (0 !== g2) {
        var h2 = g2 & ~e2;
        0 !== h2 ? d = tc(h2) : (f2 &= g2, 0 !== f2 && (d = tc(f2)));
      } else
        g2 = c2 & ~e2, 0 !== g2 ? d = tc(g2) : 0 !== f2 && (d = tc(f2));
      if (0 === d)
        return 0;
      if (0 !== b && b !== d && 0 === (b & e2) && (e2 = d & -d, f2 = b & -b, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240)))
        return b;
      0 !== (d & 4) && (d |= c2 & 16);
      b = a2.entangledLanes;
      if (0 !== b)
        for (a2 = a2.entanglements, b &= d; 0 < b; )
          c2 = 31 - oc(b), e2 = 1 << c2, d |= a2[c2], b &= ~e2;
      return d;
    }
    function vc(a2, b) {
      switch (a2) {
        case 1:
        case 2:
        case 4:
          return b + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return b + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function wc(a2, b) {
      for (var c2 = a2.suspendedLanes, d = a2.pingedLanes, e2 = a2.expirationTimes, f2 = a2.pendingLanes; 0 < f2; ) {
        var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
        if (-1 === k2) {
          if (0 === (h2 & c2) || 0 !== (h2 & d))
            e2[g2] = vc(h2, b);
        } else
          k2 <= b && (a2.expiredLanes |= h2);
        f2 &= ~h2;
      }
    }
    function xc(a2) {
      a2 = a2.pendingLanes & -1073741825;
      return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
    }
    function yc() {
      var a2 = rc;
      rc <<= 1;
      0 === (rc & 4194240) && (rc = 64);
      return a2;
    }
    function zc(a2) {
      for (var b = [], c2 = 0; 31 > c2; c2++)
        b.push(a2);
      return b;
    }
    function Ac(a2, b, c2) {
      a2.pendingLanes |= b;
      536870912 !== b && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
      a2 = a2.eventTimes;
      b = 31 - oc(b);
      a2[b] = c2;
    }
    function Bc(a2, b) {
      var c2 = a2.pendingLanes & ~b;
      a2.pendingLanes = b;
      a2.suspendedLanes = 0;
      a2.pingedLanes = 0;
      a2.expiredLanes &= b;
      a2.mutableReadLanes &= b;
      a2.entangledLanes &= b;
      b = a2.entanglements;
      var d = a2.eventTimes;
      for (a2 = a2.expirationTimes; 0 < c2; ) {
        var e2 = 31 - oc(c2), f2 = 1 << e2;
        b[e2] = 0;
        d[e2] = -1;
        a2[e2] = -1;
        c2 &= ~f2;
      }
    }
    function Cc(a2, b) {
      var c2 = a2.entangledLanes |= b;
      for (a2 = a2.entanglements; c2; ) {
        var d = 31 - oc(c2), e2 = 1 << d;
        e2 & b | a2[d] & b && (a2[d] |= b);
        c2 &= ~e2;
      }
    }
    var C = 0;
    function Dc(a2) {
      a2 &= -a2;
      return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
    }
    var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
    function Sc(a2, b) {
      switch (a2) {
        case "focusin":
        case "focusout":
          Lc = null;
          break;
        case "dragenter":
        case "dragleave":
          Mc = null;
          break;
        case "mouseover":
        case "mouseout":
          Nc = null;
          break;
        case "pointerover":
        case "pointerout":
          Oc.delete(b.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          Pc.delete(b.pointerId);
      }
    }
    function Tc(a2, b, c2, d, e2, f2) {
      if (null === a2 || a2.nativeEvent !== f2)
        return a2 = { blockedOn: b, domEventName: c2, eventSystemFlags: d, nativeEvent: f2, targetContainers: [e2] }, null !== b && (b = Cb(b), null !== b && Fc(b)), a2;
      a2.eventSystemFlags |= d;
      b = a2.targetContainers;
      null !== e2 && -1 === b.indexOf(e2) && b.push(e2);
      return a2;
    }
    function Uc(a2, b, c2, d, e2) {
      switch (b) {
        case "focusin":
          return Lc = Tc(Lc, a2, b, c2, d, e2), true;
        case "dragenter":
          return Mc = Tc(Mc, a2, b, c2, d, e2), true;
        case "mouseover":
          return Nc = Tc(Nc, a2, b, c2, d, e2), true;
        case "pointerover":
          var f2 = e2.pointerId;
          Oc.set(f2, Tc(Oc.get(f2) || null, a2, b, c2, d, e2));
          return true;
        case "gotpointercapture":
          return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a2, b, c2, d, e2)), true;
      }
      return false;
    }
    function Vc(a2) {
      var b = Wc(a2.target);
      if (null !== b) {
        var c2 = Vb(b);
        if (null !== c2) {
          if (b = c2.tag, 13 === b) {
            if (b = Wb(c2), null !== b) {
              a2.blockedOn = b;
              Ic(a2.priority, function() {
                Gc(c2);
              });
              return;
            }
          } else if (3 === b && c2.stateNode.current.memoizedState.isDehydrated) {
            a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
            return;
          }
        }
      }
      a2.blockedOn = null;
    }
    function Xc(a2) {
      if (null !== a2.blockedOn)
        return false;
      for (var b = a2.targetContainers; 0 < b.length; ) {
        var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b[0], a2.nativeEvent);
        if (null === c2) {
          c2 = a2.nativeEvent;
          var d = new c2.constructor(c2.type, c2);
          wb = d;
          c2.target.dispatchEvent(d);
          wb = null;
        } else
          return b = Cb(c2), null !== b && Fc(b), a2.blockedOn = c2, false;
        b.shift();
      }
      return true;
    }
    function Zc(a2, b, c2) {
      Xc(a2) && c2.delete(b);
    }
    function $c() {
      Jc = false;
      null !== Lc && Xc(Lc) && (Lc = null);
      null !== Mc && Xc(Mc) && (Mc = null);
      null !== Nc && Xc(Nc) && (Nc = null);
      Oc.forEach(Zc);
      Pc.forEach(Zc);
    }
    function ad(a2, b) {
      a2.blockedOn === b && (a2.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
    }
    function bd(a2) {
      function b(b2) {
        return ad(b2, a2);
      }
      if (0 < Kc.length) {
        ad(Kc[0], a2);
        for (var c2 = 1; c2 < Kc.length; c2++) {
          var d = Kc[c2];
          d.blockedOn === a2 && (d.blockedOn = null);
        }
      }
      null !== Lc && ad(Lc, a2);
      null !== Mc && ad(Mc, a2);
      null !== Nc && ad(Nc, a2);
      Oc.forEach(b);
      Pc.forEach(b);
      for (c2 = 0; c2 < Qc.length; c2++)
        d = Qc[c2], d.blockedOn === a2 && (d.blockedOn = null);
      for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); )
        Vc(c2), null === c2.blockedOn && Qc.shift();
    }
    var cd = ua.ReactCurrentBatchConfig, dd = true;
    function ed(a2, b, c2, d) {
      var e2 = C, f2 = cd.transition;
      cd.transition = null;
      try {
        C = 1, fd(a2, b, c2, d);
      } finally {
        C = e2, cd.transition = f2;
      }
    }
    function gd(a2, b, c2, d) {
      var e2 = C, f2 = cd.transition;
      cd.transition = null;
      try {
        C = 4, fd(a2, b, c2, d);
      } finally {
        C = e2, cd.transition = f2;
      }
    }
    function fd(a2, b, c2, d) {
      if (dd) {
        var e2 = Yc(a2, b, c2, d);
        if (null === e2)
          hd(a2, b, d, id, c2), Sc(a2, d);
        else if (Uc(e2, a2, b, c2, d))
          d.stopPropagation();
        else if (Sc(a2, d), b & 4 && -1 < Rc.indexOf(a2)) {
          for (; null !== e2; ) {
            var f2 = Cb(e2);
            null !== f2 && Ec(f2);
            f2 = Yc(a2, b, c2, d);
            null === f2 && hd(a2, b, d, id, c2);
            if (f2 === e2)
              break;
            e2 = f2;
          }
          null !== e2 && d.stopPropagation();
        } else
          hd(a2, b, d, null, c2);
      }
    }
    var id = null;
    function Yc(a2, b, c2, d) {
      id = null;
      a2 = xb(d);
      a2 = Wc(a2);
      if (null !== a2)
        if (b = Vb(a2), null === b)
          a2 = null;
        else if (c2 = b.tag, 13 === c2) {
          a2 = Wb(b);
          if (null !== a2)
            return a2;
          a2 = null;
        } else if (3 === c2) {
          if (b.stateNode.current.memoizedState.isDehydrated)
            return 3 === b.tag ? b.stateNode.containerInfo : null;
          a2 = null;
        } else
          b !== a2 && (a2 = null);
      id = a2;
      return null;
    }
    function jd(a2) {
      switch (a2) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return 1;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return 4;
        case "message":
          switch (ec()) {
            case fc:
              return 1;
            case gc:
              return 4;
            case hc:
            case ic:
              return 16;
            case jc:
              return 536870912;
            default:
              return 16;
          }
        default:
          return 16;
      }
    }
    var kd = null, ld = null, md = null;
    function nd() {
      if (md)
        return md;
      var a2, b = ld, c2 = b.length, d, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
      for (a2 = 0; a2 < c2 && b[a2] === e2[a2]; a2++)
        ;
      var g2 = c2 - a2;
      for (d = 1; d <= g2 && b[c2 - d] === e2[f2 - d]; d++)
        ;
      return md = e2.slice(a2, 1 < d ? 1 - d : void 0);
    }
    function od(a2) {
      var b = a2.keyCode;
      "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b && (a2 = 13)) : a2 = b;
      10 === a2 && (a2 = 13);
      return 32 <= a2 || 13 === a2 ? a2 : 0;
    }
    function pd() {
      return true;
    }
    function qd() {
      return false;
    }
    function rd(a2) {
      function b(b2, d, e2, f2, g2) {
        this._reactName = b2;
        this._targetInst = e2;
        this.type = d;
        this.nativeEvent = f2;
        this.target = g2;
        this.currentTarget = null;
        for (var c2 in a2)
          a2.hasOwnProperty(c2) && (b2 = a2[c2], this[c2] = b2 ? b2(f2) : f2[c2]);
        this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
        this.isPropagationStopped = qd;
        return this;
      }
      A(b.prototype, { preventDefault: function() {
        this.defaultPrevented = true;
        var a3 = this.nativeEvent;
        a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
      }, stopPropagation: function() {
        var a3 = this.nativeEvent;
        a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
      }, persist: function() {
      }, isPersistent: pd });
      return b;
    }
    var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
      return a2.timeStamp || Date.now();
    }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
      return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
    }, movementX: function(a2) {
      if ("movementX" in a2)
        return a2.movementX;
      a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
      return wd;
    }, movementY: function(a2) {
      return "movementY" in a2 ? a2.movementY : xd;
    } }), Bd = rd(Ad), Cd = A({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A({}, sd, { clipboardData: function(a2) {
      return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
    } }), Jd = rd(Id), Kd = A({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, Nd = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
    function Pd(a2) {
      var b = this.nativeEvent;
      return b.getModifierState ? b.getModifierState(a2) : (a2 = Od[a2]) ? !!b[a2] : false;
    }
    function zd() {
      return Pd;
    }
    var Qd = A({}, ud, { key: function(a2) {
      if (a2.key) {
        var b = Md[a2.key] || a2.key;
        if ("Unidentified" !== b)
          return b;
      }
      return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
    }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
      return "keypress" === a2.type ? od(a2) : 0;
    }, keyCode: function(a2) {
      return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
    }, which: function(a2) {
      return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
    } }), Rd = rd(Qd), Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A({}, Ad, {
      deltaX: function(a2) {
        return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
      },
      deltaY: function(a2) {
        return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be$1 = null;
    ia && "documentMode" in document && (be$1 = document.documentMode);
    var ce = ia && "TextEvent" in window && !be$1, de = ia && (!ae || be$1 && 8 < be$1 && 11 >= be$1), ee = String.fromCharCode(32), fe = false;
    function ge(a2, b) {
      switch (a2) {
        case "keyup":
          return -1 !== $d.indexOf(b.keyCode);
        case "keydown":
          return 229 !== b.keyCode;
        case "keypress":
        case "mousedown":
        case "focusout":
          return true;
        default:
          return false;
      }
    }
    function he(a2) {
      a2 = a2.detail;
      return "object" === typeof a2 && "data" in a2 ? a2.data : null;
    }
    var ie = false;
    function je(a2, b) {
      switch (a2) {
        case "compositionend":
          return he(b);
        case "keypress":
          if (32 !== b.which)
            return null;
          fe = true;
          return ee;
        case "textInput":
          return a2 = b.data, a2 === ee && fe ? null : a2;
        default:
          return null;
      }
    }
    function ke(a2, b) {
      if (ie)
        return "compositionend" === a2 || !ae && ge(a2, b) ? (a2 = nd(), md = ld = kd = null, ie = false, a2) : null;
      switch (a2) {
        case "paste":
          return null;
        case "keypress":
          if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
            if (b.char && 1 < b.char.length)
              return b.char;
            if (b.which)
              return String.fromCharCode(b.which);
          }
          return null;
        case "compositionend":
          return de && "ko" !== b.locale ? null : b.data;
        default:
          return null;
      }
    }
    var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
    function me(a2) {
      var b = a2 && a2.nodeName && a2.nodeName.toLowerCase();
      return "input" === b ? !!le[a2.type] : "textarea" === b ? true : false;
    }
    function ne(a2, b, c2, d) {
      Eb(d);
      b = oe(b, "onChange");
      0 < b.length && (c2 = new td("onChange", "change", null, c2, d), a2.push({ event: c2, listeners: b }));
    }
    var pe = null, qe = null;
    function re(a2) {
      se(a2, 0);
    }
    function te(a2) {
      var b = ue(a2);
      if (Wa(b))
        return a2;
    }
    function ve(a2, b) {
      if ("change" === a2)
        return b;
    }
    var we = false;
    if (ia) {
      var xe;
      if (ia) {
        var ye = "oninput" in document;
        if (!ye) {
          var ze = document.createElement("div");
          ze.setAttribute("oninput", "return;");
          ye = "function" === typeof ze.oninput;
        }
        xe = ye;
      } else
        xe = false;
      we = xe && (!document.documentMode || 9 < document.documentMode);
    }
    function Ae() {
      pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
    }
    function Be(a2) {
      if ("value" === a2.propertyName && te(qe)) {
        var b = [];
        ne(b, qe, a2, xb(a2));
        Jb(re, b);
      }
    }
    function Ce(a2, b, c2) {
      "focusin" === a2 ? (Ae(), pe = b, qe = c2, pe.attachEvent("onpropertychange", Be)) : "focusout" === a2 && Ae();
    }
    function De(a2) {
      if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2)
        return te(qe);
    }
    function Ee(a2, b) {
      if ("click" === a2)
        return te(b);
    }
    function Fe(a2, b) {
      if ("input" === a2 || "change" === a2)
        return te(b);
    }
    function Ge(a2, b) {
      return a2 === b && (0 !== a2 || 1 / a2 === 1 / b) || a2 !== a2 && b !== b;
    }
    var He = "function" === typeof Object.is ? Object.is : Ge;
    function Ie(a2, b) {
      if (He(a2, b))
        return true;
      if ("object" !== typeof a2 || null === a2 || "object" !== typeof b || null === b)
        return false;
      var c2 = Object.keys(a2), d = Object.keys(b);
      if (c2.length !== d.length)
        return false;
      for (d = 0; d < c2.length; d++) {
        var e2 = c2[d];
        if (!ja.call(b, e2) || !He(a2[e2], b[e2]))
          return false;
      }
      return true;
    }
    function Je(a2) {
      for (; a2 && a2.firstChild; )
        a2 = a2.firstChild;
      return a2;
    }
    function Ke(a2, b) {
      var c2 = Je(a2);
      a2 = 0;
      for (var d; c2; ) {
        if (3 === c2.nodeType) {
          d = a2 + c2.textContent.length;
          if (a2 <= b && d >= b)
            return { node: c2, offset: b - a2 };
          a2 = d;
        }
        a: {
          for (; c2; ) {
            if (c2.nextSibling) {
              c2 = c2.nextSibling;
              break a;
            }
            c2 = c2.parentNode;
          }
          c2 = void 0;
        }
        c2 = Je(c2);
      }
    }
    function Le(a2, b) {
      return a2 && b ? a2 === b ? true : a2 && 3 === a2.nodeType ? false : b && 3 === b.nodeType ? Le(a2, b.parentNode) : "contains" in a2 ? a2.contains(b) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b) & 16) : false : false;
    }
    function Me() {
      for (var a2 = window, b = Xa(); b instanceof a2.HTMLIFrameElement; ) {
        try {
          var c2 = "string" === typeof b.contentWindow.location.href;
        } catch (d) {
          c2 = false;
        }
        if (c2)
          a2 = b.contentWindow;
        else
          break;
        b = Xa(a2.document);
      }
      return b;
    }
    function Ne(a2) {
      var b = a2 && a2.nodeName && a2.nodeName.toLowerCase();
      return b && ("input" === b && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b || "true" === a2.contentEditable);
    }
    function Oe(a2) {
      var b = Me(), c2 = a2.focusedElem, d = a2.selectionRange;
      if (b !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
        if (null !== d && Ne(c2)) {
          if (b = d.start, a2 = d.end, void 0 === a2 && (a2 = b), "selectionStart" in c2)
            c2.selectionStart = b, c2.selectionEnd = Math.min(a2, c2.value.length);
          else if (a2 = (b = c2.ownerDocument || document) && b.defaultView || window, a2.getSelection) {
            a2 = a2.getSelection();
            var e2 = c2.textContent.length, f2 = Math.min(d.start, e2);
            d = void 0 === d.end ? f2 : Math.min(d.end, e2);
            !a2.extend && f2 > d && (e2 = d, d = f2, f2 = e2);
            e2 = Ke(c2, f2);
            var g2 = Ke(
              c2,
              d
            );
            e2 && g2 && (1 !== a2.rangeCount || a2.anchorNode !== e2.node || a2.anchorOffset !== e2.offset || a2.focusNode !== g2.node || a2.focusOffset !== g2.offset) && (b = b.createRange(), b.setStart(e2.node, e2.offset), a2.removeAllRanges(), f2 > d ? (a2.addRange(b), a2.extend(g2.node, g2.offset)) : (b.setEnd(g2.node, g2.offset), a2.addRange(b)));
          }
        }
        b = [];
        for (a2 = c2; a2 = a2.parentNode; )
          1 === a2.nodeType && b.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
        "function" === typeof c2.focus && c2.focus();
        for (c2 = 0; c2 < b.length; c2++)
          a2 = b[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
      }
    }
    var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
    function Ue(a2, b, c2) {
      var d = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
      Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Ne(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Ie(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c2), a2.push({ event: b, listeners: d }), b.target = Qe)));
    }
    function Ve(a2, b) {
      var c2 = {};
      c2[a2.toLowerCase()] = b.toLowerCase();
      c2["Webkit" + a2] = "webkit" + b;
      c2["Moz" + a2] = "moz" + b;
      return c2;
    }
    var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
    ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
    function Ze(a2) {
      if (Xe[a2])
        return Xe[a2];
      if (!We[a2])
        return a2;
      var b = We[a2], c2;
      for (c2 in b)
        if (b.hasOwnProperty(c2) && c2 in Ye)
          return Xe[a2] = b[c2];
      return a2;
    }
    var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    function ff(a2, b) {
      df.set(a2, b);
      fa(b, [a2]);
    }
    for (var gf = 0; gf < ef.length; gf++) {
      var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
      ff(jf, "on" + kf);
    }
    ff($e, "onAnimationEnd");
    ff(af, "onAnimationIteration");
    ff(bf, "onAnimationStart");
    ff("dblclick", "onDoubleClick");
    ff("focusin", "onFocus");
    ff("focusout", "onBlur");
    ff(cf, "onTransitionEnd");
    ha("onMouseEnter", ["mouseout", "mouseover"]);
    ha("onMouseLeave", ["mouseout", "mouseover"]);
    ha("onPointerEnter", ["pointerout", "pointerover"]);
    ha("onPointerLeave", ["pointerout", "pointerover"]);
    fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
    fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
    fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
    fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
    fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
    fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
    function nf(a2, b, c2) {
      var d = a2.type || "unknown-event";
      a2.currentTarget = c2;
      Ub(d, b, void 0, a2);
      a2.currentTarget = null;
    }
    function se(a2, b) {
      b = 0 !== (b & 4);
      for (var c2 = 0; c2 < a2.length; c2++) {
        var d = a2[c2], e2 = d.event;
        d = d.listeners;
        a: {
          var f2 = void 0;
          if (b)
            for (var g2 = d.length - 1; 0 <= g2; g2--) {
              var h2 = d[g2], k2 = h2.instance, l2 = h2.currentTarget;
              h2 = h2.listener;
              if (k2 !== f2 && e2.isPropagationStopped())
                break a;
              nf(e2, h2, l2);
              f2 = k2;
            }
          else
            for (g2 = 0; g2 < d.length; g2++) {
              h2 = d[g2];
              k2 = h2.instance;
              l2 = h2.currentTarget;
              h2 = h2.listener;
              if (k2 !== f2 && e2.isPropagationStopped())
                break a;
              nf(e2, h2, l2);
              f2 = k2;
            }
        }
      }
      if (Qb)
        throw a2 = Rb, Qb = false, Rb = null, a2;
    }
    function D(a2, b) {
      var c2 = b[of];
      void 0 === c2 && (c2 = b[of] = /* @__PURE__ */ new Set());
      var d = a2 + "__bubble";
      c2.has(d) || (pf(b, a2, 2, false), c2.add(d));
    }
    function qf(a2, b, c2) {
      var d = 0;
      b && (d |= 4);
      pf(c2, a2, d, b);
    }
    var rf = "_reactListening" + Math.random().toString(36).slice(2);
    function sf(a2) {
      if (!a2[rf]) {
        a2[rf] = true;
        da$1.forEach(function(b2) {
          "selectionchange" !== b2 && (mf.has(b2) || qf(b2, false, a2), qf(b2, true, a2));
        });
        var b = 9 === a2.nodeType ? a2 : a2.ownerDocument;
        null === b || b[rf] || (b[rf] = true, qf("selectionchange", false, b));
      }
    }
    function pf(a2, b, c2, d) {
      switch (jd(b)) {
        case 1:
          var e2 = ed;
          break;
        case 4:
          e2 = gd;
          break;
        default:
          e2 = fd;
      }
      c2 = e2.bind(null, b, c2, a2);
      e2 = void 0;
      !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e2 = true);
      d ? void 0 !== e2 ? a2.addEventListener(b, c2, { capture: true, passive: e2 }) : a2.addEventListener(b, c2, true) : void 0 !== e2 ? a2.addEventListener(b, c2, { passive: e2 }) : a2.addEventListener(b, c2, false);
    }
    function hd(a2, b, c2, d, e2) {
      var f2 = d;
      if (0 === (b & 1) && 0 === (b & 2) && null !== d)
        a:
          for (; ; ) {
            if (null === d)
              return;
            var g2 = d.tag;
            if (3 === g2 || 4 === g2) {
              var h2 = d.stateNode.containerInfo;
              if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2)
                break;
              if (4 === g2)
                for (g2 = d.return; null !== g2; ) {
                  var k2 = g2.tag;
                  if (3 === k2 || 4 === k2) {
                    if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2)
                      return;
                  }
                  g2 = g2.return;
                }
              for (; null !== h2; ) {
                g2 = Wc(h2);
                if (null === g2)
                  return;
                k2 = g2.tag;
                if (5 === k2 || 6 === k2) {
                  d = f2 = g2;
                  continue a;
                }
                h2 = h2.parentNode;
              }
            }
            d = d.return;
          }
      Jb(function() {
        var d2 = f2, e3 = xb(c2), g3 = [];
        a: {
          var h3 = df.get(a2);
          if (void 0 !== h3) {
            var k3 = td, n2 = a2;
            switch (a2) {
              case "keypress":
                if (0 === od(c2))
                  break a;
              case "keydown":
              case "keyup":
                k3 = Rd;
                break;
              case "focusin":
                n2 = "focus";
                k3 = Fd;
                break;
              case "focusout":
                n2 = "blur";
                k3 = Fd;
                break;
              case "beforeblur":
              case "afterblur":
                k3 = Fd;
                break;
              case "click":
                if (2 === c2.button)
                  break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                k3 = Bd;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                k3 = Dd;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                k3 = Vd;
                break;
              case $e:
              case af:
              case bf:
                k3 = Hd;
                break;
              case cf:
                k3 = Xd;
                break;
              case "scroll":
                k3 = vd;
                break;
              case "wheel":
                k3 = Zd;
                break;
              case "copy":
              case "cut":
              case "paste":
                k3 = Jd;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                k3 = Td;
            }
            var t2 = 0 !== (b & 4), J2 = !t2 && "scroll" === a2, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
            t2 = [];
            for (var w2 = d2, u2; null !== w2; ) {
              u2 = w2;
              var F2 = u2.stateNode;
              5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
              if (J2)
                break;
              w2 = w2.return;
            }
            0 < t2.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
          }
        }
        if (0 === (b & 7)) {
          a: {
            h3 = "mouseover" === a2 || "pointerover" === a2;
            k3 = "mouseout" === a2 || "pointerout" === a2;
            if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf]))
              break a;
            if (k3 || h3) {
              h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
              if (k3) {
                if (n2 = c2.relatedTarget || c2.toElement, k3 = d2, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
                  n2 = null;
              } else
                k3 = null, n2 = d2;
              if (k3 !== n2) {
                t2 = Bd;
                F2 = "onMouseLeave";
                x2 = "onMouseEnter";
                w2 = "mouse";
                if ("pointerout" === a2 || "pointerover" === a2)
                  t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
                J2 = null == k3 ? h3 : ue(k3);
                u2 = null == n2 ? h3 : ue(n2);
                h3 = new t2(F2, w2 + "leave", k3, c2, e3);
                h3.target = J2;
                h3.relatedTarget = u2;
                F2 = null;
                Wc(e3) === d2 && (t2 = new t2(x2, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
                J2 = F2;
                if (k3 && n2)
                  b: {
                    t2 = k3;
                    x2 = n2;
                    w2 = 0;
                    for (u2 = t2; u2; u2 = vf(u2))
                      w2++;
                    u2 = 0;
                    for (F2 = x2; F2; F2 = vf(F2))
                      u2++;
                    for (; 0 < w2 - u2; )
                      t2 = vf(t2), w2--;
                    for (; 0 < u2 - w2; )
                      x2 = vf(x2), u2--;
                    for (; w2--; ) {
                      if (t2 === x2 || null !== x2 && t2 === x2.alternate)
                        break b;
                      t2 = vf(t2);
                      x2 = vf(x2);
                    }
                    t2 = null;
                  }
                else
                  t2 = null;
                null !== k3 && wf(g3, h3, k3, t2, false);
                null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
              }
            }
          }
          a: {
            h3 = d2 ? ue(d2) : window;
            k3 = h3.nodeName && h3.nodeName.toLowerCase();
            if ("select" === k3 || "input" === k3 && "file" === h3.type)
              var na = ve;
            else if (me(h3))
              if (we)
                na = Fe;
              else {
                na = De;
                var xa = Ce;
              }
            else
              (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee);
            if (na && (na = na(a2, d2))) {
              ne(g3, na, c2, e3);
              break a;
            }
            xa && xa(a2, h3, d2);
            "focusout" === a2 && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
          }
          xa = d2 ? ue(d2) : window;
          switch (a2) {
            case "focusin":
              if (me(xa) || "true" === xa.contentEditable)
                Qe = xa, Re = d2, Se = null;
              break;
            case "focusout":
              Se = Re = Qe = null;
              break;
            case "mousedown":
              Te = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              Te = false;
              Ue(g3, c2, e3);
              break;
            case "selectionchange":
              if (Pe)
                break;
            case "keydown":
            case "keyup":
              Ue(g3, c2, e3);
          }
          var $a;
          if (ae)
            b: {
              switch (a2) {
                case "compositionstart":
                  var ba = "onCompositionStart";
                  break b;
                case "compositionend":
                  ba = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  ba = "onCompositionUpdate";
                  break b;
              }
              ba = void 0;
            }
          else
            ie ? ge(a2, c2) && (ba = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (ba = "onCompositionStart");
          ba && (de && "ko" !== c2.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d2, ba), 0 < xa.length && (ba = new Ld(ba, a2, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c2), null !== $a && (ba.data = $a))));
          if ($a = ce ? je(a2, c2) : ke(a2, c2))
            d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d2 }), e3.data = $a);
        }
        se(g3, b);
      });
    }
    function tf(a2, b, c2) {
      return { instance: a2, listener: b, currentTarget: c2 };
    }
    function oe(a2, b) {
      for (var c2 = b + "Capture", d = []; null !== a2; ) {
        var e2 = a2, f2 = e2.stateNode;
        5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a2, c2), null != f2 && d.unshift(tf(a2, f2, e2)), f2 = Kb(a2, b), null != f2 && d.push(tf(a2, f2, e2)));
        a2 = a2.return;
      }
      return d;
    }
    function vf(a2) {
      if (null === a2)
        return null;
      do
        a2 = a2.return;
      while (a2 && 5 !== a2.tag);
      return a2 ? a2 : null;
    }
    function wf(a2, b, c2, d, e2) {
      for (var f2 = b._reactName, g2 = []; null !== c2 && c2 !== d; ) {
        var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
        if (null !== k2 && k2 === d)
          break;
        5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
        c2 = c2.return;
      }
      0 !== g2.length && a2.push({ event: b, listeners: g2 });
    }
    var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
    function zf(a2) {
      return ("string" === typeof a2 ? a2 : "" + a2).replace(xf, "\n").replace(yf, "");
    }
    function Af(a2, b, c2) {
      b = zf(b);
      if (zf(a2) !== b && c2)
        throw Error(p$1(425));
    }
    function Bf() {
    }
    var Cf = null, Df = null;
    function Ef(a2, b) {
      return "textarea" === a2 || "noscript" === a2 || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
    }
    var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a2) {
      return Hf.resolve(null).then(a2).catch(If);
    } : Ff;
    function If(a2) {
      setTimeout(function() {
        throw a2;
      });
    }
    function Kf(a2, b) {
      var c2 = b, d = 0;
      do {
        var e2 = c2.nextSibling;
        a2.removeChild(c2);
        if (e2 && 8 === e2.nodeType)
          if (c2 = e2.data, "/$" === c2) {
            if (0 === d) {
              a2.removeChild(e2);
              bd(b);
              return;
            }
            d--;
          } else
            "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d++;
        c2 = e2;
      } while (c2);
      bd(b);
    }
    function Lf(a2) {
      for (; null != a2; a2 = a2.nextSibling) {
        var b = a2.nodeType;
        if (1 === b || 3 === b)
          break;
        if (8 === b) {
          b = a2.data;
          if ("$" === b || "$!" === b || "$?" === b)
            break;
          if ("/$" === b)
            return null;
        }
      }
      return a2;
    }
    function Mf(a2) {
      a2 = a2.previousSibling;
      for (var b = 0; a2; ) {
        if (8 === a2.nodeType) {
          var c2 = a2.data;
          if ("$" === c2 || "$!" === c2 || "$?" === c2) {
            if (0 === b)
              return a2;
            b--;
          } else
            "/$" === c2 && b++;
        }
        a2 = a2.previousSibling;
      }
      return null;
    }
    var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
    function Wc(a2) {
      var b = a2[Of];
      if (b)
        return b;
      for (var c2 = a2.parentNode; c2; ) {
        if (b = c2[uf] || c2[Of]) {
          c2 = b.alternate;
          if (null !== b.child || null !== c2 && null !== c2.child)
            for (a2 = Mf(a2); null !== a2; ) {
              if (c2 = a2[Of])
                return c2;
              a2 = Mf(a2);
            }
          return b;
        }
        a2 = c2;
        c2 = a2.parentNode;
      }
      return null;
    }
    function Cb(a2) {
      a2 = a2[Of] || a2[uf];
      return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
    }
    function ue(a2) {
      if (5 === a2.tag || 6 === a2.tag)
        return a2.stateNode;
      throw Error(p$1(33));
    }
    function Db(a2) {
      return a2[Pf] || null;
    }
    var Sf = [], Tf = -1;
    function Uf(a2) {
      return { current: a2 };
    }
    function E(a2) {
      0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
    }
    function G(a2, b) {
      Tf++;
      Sf[Tf] = a2.current;
      a2.current = b;
    }
    var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
    function Yf(a2, b) {
      var c2 = a2.type.contextTypes;
      if (!c2)
        return Vf;
      var d = a2.stateNode;
      if (d && d.__reactInternalMemoizedUnmaskedChildContext === b)
        return d.__reactInternalMemoizedMaskedChildContext;
      var e2 = {}, f2;
      for (f2 in c2)
        e2[f2] = b[f2];
      d && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b, a2.__reactInternalMemoizedMaskedChildContext = e2);
      return e2;
    }
    function Zf(a2) {
      a2 = a2.childContextTypes;
      return null !== a2 && void 0 !== a2;
    }
    function $f() {
      E(Wf);
      E(H);
    }
    function ag(a2, b, c2) {
      if (H.current !== Vf)
        throw Error(p$1(168));
      G(H, b);
      G(Wf, c2);
    }
    function bg(a2, b, c2) {
      var d = a2.stateNode;
      b = b.childContextTypes;
      if ("function" !== typeof d.getChildContext)
        return c2;
      d = d.getChildContext();
      for (var e2 in d)
        if (!(e2 in b))
          throw Error(p$1(108, Ra(a2) || "Unknown", e2));
      return A({}, c2, d);
    }
    function cg(a2) {
      a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf;
      Xf = H.current;
      G(H, a2);
      G(Wf, Wf.current);
      return true;
    }
    function dg(a2, b, c2) {
      var d = a2.stateNode;
      if (!d)
        throw Error(p$1(169));
      c2 ? (a2 = bg(a2, b, Xf), d.__reactInternalMemoizedMergedChildContext = a2, E(Wf), E(H), G(H, a2)) : E(Wf);
      G(Wf, c2);
    }
    var eg = null, fg = false, gg = false;
    function hg(a2) {
      null === eg ? eg = [a2] : eg.push(a2);
    }
    function ig(a2) {
      fg = true;
      hg(a2);
    }
    function jg() {
      if (!gg && null !== eg) {
        gg = true;
        var a2 = 0, b = C;
        try {
          var c2 = eg;
          for (C = 1; a2 < c2.length; a2++) {
            var d = c2[a2];
            do
              d = d(true);
            while (null !== d);
          }
          eg = null;
          fg = false;
        } catch (e2) {
          throw null !== eg && (eg = eg.slice(a2 + 1)), ac(fc, jg), e2;
        } finally {
          C = b, gg = false;
        }
      }
      return null;
    }
    var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
    function tg(a2, b) {
      kg[lg++] = ng;
      kg[lg++] = mg;
      mg = a2;
      ng = b;
    }
    function ug(a2, b, c2) {
      og[pg++] = rg;
      og[pg++] = sg;
      og[pg++] = qg;
      qg = a2;
      var d = rg;
      a2 = sg;
      var e2 = 32 - oc(d) - 1;
      d &= ~(1 << e2);
      c2 += 1;
      var f2 = 32 - oc(b) + e2;
      if (30 < f2) {
        var g2 = e2 - e2 % 5;
        f2 = (d & (1 << g2) - 1).toString(32);
        d >>= g2;
        e2 -= g2;
        rg = 1 << 32 - oc(b) + e2 | c2 << e2 | d;
        sg = f2 + a2;
      } else
        rg = 1 << f2 | c2 << e2 | d, sg = a2;
    }
    function vg(a2) {
      null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
    }
    function wg(a2) {
      for (; a2 === mg; )
        mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
      for (; a2 === qg; )
        qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
    }
    var xg = null, yg = null, I = false, zg = null;
    function Ag(a2, b) {
      var c2 = Bg(5, null, null, 0);
      c2.elementType = "DELETED";
      c2.stateNode = b;
      c2.return = a2;
      b = a2.deletions;
      null === b ? (a2.deletions = [c2], a2.flags |= 16) : b.push(c2);
    }
    function Cg(a2, b) {
      switch (a2.tag) {
        case 5:
          var c2 = a2.type;
          b = 1 !== b.nodeType || c2.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
          return null !== b ? (a2.stateNode = b, xg = a2, yg = Lf(b.firstChild), true) : false;
        case 6:
          return b = "" === a2.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a2.stateNode = b, xg = a2, yg = null, true) : false;
        case 13:
          return b = 8 !== b.nodeType ? null : b, null !== b ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b, c2.return = a2, a2.child = c2, xg = a2, yg = null, true) : false;
        default:
          return false;
      }
    }
    function Dg(a2) {
      return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
    }
    function Eg(a2) {
      if (I) {
        var b = yg;
        if (b) {
          var c2 = b;
          if (!Cg(a2, b)) {
            if (Dg(a2))
              throw Error(p$1(418));
            b = Lf(c2.nextSibling);
            var d = xg;
            b && Cg(a2, b) ? Ag(d, c2) : (a2.flags = a2.flags & -4097 | 2, I = false, xg = a2);
          }
        } else {
          if (Dg(a2))
            throw Error(p$1(418));
          a2.flags = a2.flags & -4097 | 2;
          I = false;
          xg = a2;
        }
      }
    }
    function Fg(a2) {
      for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; )
        a2 = a2.return;
      xg = a2;
    }
    function Gg(a2) {
      if (a2 !== xg)
        return false;
      if (!I)
        return Fg(a2), I = true, false;
      var b;
      (b = 3 !== a2.tag) && !(b = 5 !== a2.tag) && (b = a2.type, b = "head" !== b && "body" !== b && !Ef(a2.type, a2.memoizedProps));
      if (b && (b = yg)) {
        if (Dg(a2))
          throw Hg(), Error(p$1(418));
        for (; b; )
          Ag(a2, b), b = Lf(b.nextSibling);
      }
      Fg(a2);
      if (13 === a2.tag) {
        a2 = a2.memoizedState;
        a2 = null !== a2 ? a2.dehydrated : null;
        if (!a2)
          throw Error(p$1(317));
        a: {
          a2 = a2.nextSibling;
          for (b = 0; a2; ) {
            if (8 === a2.nodeType) {
              var c2 = a2.data;
              if ("/$" === c2) {
                if (0 === b) {
                  yg = Lf(a2.nextSibling);
                  break a;
                }
                b--;
              } else
                "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b++;
            }
            a2 = a2.nextSibling;
          }
          yg = null;
        }
      } else
        yg = xg ? Lf(a2.stateNode.nextSibling) : null;
      return true;
    }
    function Hg() {
      for (var a2 = yg; a2; )
        a2 = Lf(a2.nextSibling);
    }
    function Ig() {
      yg = xg = null;
      I = false;
    }
    function Jg(a2) {
      null === zg ? zg = [a2] : zg.push(a2);
    }
    var Kg = ua.ReactCurrentBatchConfig;
    function Lg(a2, b, c2) {
      a2 = c2.ref;
      if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
        if (c2._owner) {
          c2 = c2._owner;
          if (c2) {
            if (1 !== c2.tag)
              throw Error(p$1(309));
            var d = c2.stateNode;
          }
          if (!d)
            throw Error(p$1(147, a2));
          var e2 = d, f2 = "" + a2;
          if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f2)
            return b.ref;
          b = function(a3) {
            var b2 = e2.refs;
            null === a3 ? delete b2[f2] : b2[f2] = a3;
          };
          b._stringRef = f2;
          return b;
        }
        if ("string" !== typeof a2)
          throw Error(p$1(284));
        if (!c2._owner)
          throw Error(p$1(290, a2));
      }
      return a2;
    }
    function Mg(a2, b) {
      a2 = Object.prototype.toString.call(b);
      throw Error(p$1(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b).join(", ") + "}" : a2));
    }
    function Ng(a2) {
      var b = a2._init;
      return b(a2._payload);
    }
    function Og(a2) {
      function b(b2, c3) {
        if (a2) {
          var d2 = b2.deletions;
          null === d2 ? (b2.deletions = [c3], b2.flags |= 16) : d2.push(c3);
        }
      }
      function c2(c3, d2) {
        if (!a2)
          return null;
        for (; null !== d2; )
          b(c3, d2), d2 = d2.sibling;
        return null;
      }
      function d(a3, b2) {
        for (a3 = /* @__PURE__ */ new Map(); null !== b2; )
          null !== b2.key ? a3.set(b2.key, b2) : a3.set(b2.index, b2), b2 = b2.sibling;
        return a3;
      }
      function e2(a3, b2) {
        a3 = Pg(a3, b2);
        a3.index = 0;
        a3.sibling = null;
        return a3;
      }
      function f2(b2, c3, d2) {
        b2.index = d2;
        if (!a2)
          return b2.flags |= 1048576, c3;
        d2 = b2.alternate;
        if (null !== d2)
          return d2 = d2.index, d2 < c3 ? (b2.flags |= 2, c3) : d2;
        b2.flags |= 2;
        return c3;
      }
      function g2(b2) {
        a2 && null === b2.alternate && (b2.flags |= 2);
        return b2;
      }
      function h2(a3, b2, c3, d2) {
        if (null === b2 || 6 !== b2.tag)
          return b2 = Qg(c3, a3.mode, d2), b2.return = a3, b2;
        b2 = e2(b2, c3);
        b2.return = a3;
        return b2;
      }
      function k2(a3, b2, c3, d2) {
        var f3 = c3.type;
        if (f3 === ya)
          return m2(a3, b2, c3.props.children, d2, c3.key);
        if (null !== b2 && (b2.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && Ng(f3) === b2.type))
          return d2 = e2(b2, c3.props), d2.ref = Lg(a3, b2, c3), d2.return = a3, d2;
        d2 = Rg(c3.type, c3.key, c3.props, null, a3.mode, d2);
        d2.ref = Lg(a3, b2, c3);
        d2.return = a3;
        return d2;
      }
      function l2(a3, b2, c3, d2) {
        if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c3.containerInfo || b2.stateNode.implementation !== c3.implementation)
          return b2 = Sg(c3, a3.mode, d2), b2.return = a3, b2;
        b2 = e2(b2, c3.children || []);
        b2.return = a3;
        return b2;
      }
      function m2(a3, b2, c3, d2, f3) {
        if (null === b2 || 7 !== b2.tag)
          return b2 = Tg(c3, a3.mode, d2, f3), b2.return = a3, b2;
        b2 = e2(b2, c3);
        b2.return = a3;
        return b2;
      }
      function q2(a3, b2, c3) {
        if ("string" === typeof b2 && "" !== b2 || "number" === typeof b2)
          return b2 = Qg("" + b2, a3.mode, c3), b2.return = a3, b2;
        if ("object" === typeof b2 && null !== b2) {
          switch (b2.$$typeof) {
            case va:
              return c3 = Rg(b2.type, b2.key, b2.props, null, a3.mode, c3), c3.ref = Lg(a3, null, b2), c3.return = a3, c3;
            case wa:
              return b2 = Sg(b2, a3.mode, c3), b2.return = a3, b2;
            case Ha:
              var d2 = b2._init;
              return q2(a3, d2(b2._payload), c3);
          }
          if (eb(b2) || Ka(b2))
            return b2 = Tg(b2, a3.mode, c3, null), b2.return = a3, b2;
          Mg(a3, b2);
        }
        return null;
      }
      function r2(a3, b2, c3, d2) {
        var e3 = null !== b2 ? b2.key : null;
        if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3)
          return null !== e3 ? null : h2(a3, b2, "" + c3, d2);
        if ("object" === typeof c3 && null !== c3) {
          switch (c3.$$typeof) {
            case va:
              return c3.key === e3 ? k2(a3, b2, c3, d2) : null;
            case wa:
              return c3.key === e3 ? l2(a3, b2, c3, d2) : null;
            case Ha:
              return e3 = c3._init, r2(
                a3,
                b2,
                e3(c3._payload),
                d2
              );
          }
          if (eb(c3) || Ka(c3))
            return null !== e3 ? null : m2(a3, b2, c3, d2, null);
          Mg(a3, c3);
        }
        return null;
      }
      function y2(a3, b2, c3, d2, e3) {
        if ("string" === typeof d2 && "" !== d2 || "number" === typeof d2)
          return a3 = a3.get(c3) || null, h2(b2, a3, "" + d2, e3);
        if ("object" === typeof d2 && null !== d2) {
          switch (d2.$$typeof) {
            case va:
              return a3 = a3.get(null === d2.key ? c3 : d2.key) || null, k2(b2, a3, d2, e3);
            case wa:
              return a3 = a3.get(null === d2.key ? c3 : d2.key) || null, l2(b2, a3, d2, e3);
            case Ha:
              var f3 = d2._init;
              return y2(a3, b2, c3, f3(d2._payload), e3);
          }
          if (eb(d2) || Ka(d2))
            return a3 = a3.get(c3) || null, m2(b2, a3, d2, e3, null);
          Mg(b2, d2);
        }
        return null;
      }
      function n2(e3, g3, h3, k3) {
        for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
          u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
          var n3 = r2(e3, u2, h3[w2], k3);
          if (null === n3) {
            null === u2 && (u2 = x2);
            break;
          }
          a2 && u2 && null === n3.alternate && b(e3, u2);
          g3 = f2(n3, g3, w2);
          null === m3 ? l3 = n3 : m3.sibling = n3;
          m3 = n3;
          u2 = x2;
        }
        if (w2 === h3.length)
          return c2(e3, u2), I && tg(e3, w2), l3;
        if (null === u2) {
          for (; w2 < h3.length; w2++)
            u2 = q2(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
          I && tg(e3, w2);
          return l3;
        }
        for (u2 = d(e3, u2); w2 < h3.length; w2++)
          x2 = y2(u2, e3, w2, h3[w2], k3), null !== x2 && (a2 && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
        a2 && u2.forEach(function(a3) {
          return b(e3, a3);
        });
        I && tg(e3, w2);
        return l3;
      }
      function t2(e3, g3, h3, k3) {
        var l3 = Ka(h3);
        if ("function" !== typeof l3)
          throw Error(p$1(150));
        h3 = l3.call(h3);
        if (null == h3)
          throw Error(p$1(151));
        for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
          m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
          var t3 = r2(e3, m3, n3.value, k3);
          if (null === t3) {
            null === m3 && (m3 = x2);
            break;
          }
          a2 && m3 && null === t3.alternate && b(e3, m3);
          g3 = f2(t3, g3, w2);
          null === u2 ? l3 = t3 : u2.sibling = t3;
          u2 = t3;
          m3 = x2;
        }
        if (n3.done)
          return c2(
            e3,
            m3
          ), I && tg(e3, w2), l3;
        if (null === m3) {
          for (; !n3.done; w2++, n3 = h3.next())
            n3 = q2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
          I && tg(e3, w2);
          return l3;
        }
        for (m3 = d(e3, m3); !n3.done; w2++, n3 = h3.next())
          n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a2 && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
        a2 && m3.forEach(function(a3) {
          return b(e3, a3);
        });
        I && tg(e3, w2);
        return l3;
      }
      function J2(a3, d2, f3, h3) {
        "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
        if ("object" === typeof f3 && null !== f3) {
          switch (f3.$$typeof) {
            case va:
              a: {
                for (var k3 = f3.key, l3 = d2; null !== l3; ) {
                  if (l3.key === k3) {
                    k3 = f3.type;
                    if (k3 === ya) {
                      if (7 === l3.tag) {
                        c2(a3, l3.sibling);
                        d2 = e2(l3, f3.props.children);
                        d2.return = a3;
                        a3 = d2;
                        break a;
                      }
                    } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && Ng(k3) === l3.type) {
                      c2(a3, l3.sibling);
                      d2 = e2(l3, f3.props);
                      d2.ref = Lg(a3, l3, f3);
                      d2.return = a3;
                      a3 = d2;
                      break a;
                    }
                    c2(a3, l3);
                    break;
                  } else
                    b(a3, l3);
                  l3 = l3.sibling;
                }
                f3.type === ya ? (d2 = Tg(f3.props.children, a3.mode, h3, f3.key), d2.return = a3, a3 = d2) : (h3 = Rg(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = Lg(a3, d2, f3), h3.return = a3, a3 = h3);
              }
              return g2(a3);
            case wa:
              a: {
                for (l3 = f3.key; null !== d2; ) {
                  if (d2.key === l3)
                    if (4 === d2.tag && d2.stateNode.containerInfo === f3.containerInfo && d2.stateNode.implementation === f3.implementation) {
                      c2(a3, d2.sibling);
                      d2 = e2(d2, f3.children || []);
                      d2.return = a3;
                      a3 = d2;
                      break a;
                    } else {
                      c2(a3, d2);
                      break;
                    }
                  else
                    b(a3, d2);
                  d2 = d2.sibling;
                }
                d2 = Sg(f3, a3.mode, h3);
                d2.return = a3;
                a3 = d2;
              }
              return g2(a3);
            case Ha:
              return l3 = f3._init, J2(a3, d2, l3(f3._payload), h3);
          }
          if (eb(f3))
            return n2(a3, d2, f3, h3);
          if (Ka(f3))
            return t2(a3, d2, f3, h3);
          Mg(a3, f3);
        }
        return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d2 && 6 === d2.tag ? (c2(a3, d2.sibling), d2 = e2(d2, f3), d2.return = a3, a3 = d2) : (c2(a3, d2), d2 = Qg(f3, a3.mode, h3), d2.return = a3, a3 = d2), g2(a3)) : c2(a3, d2);
      }
      return J2;
    }
    var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
    function $g() {
      Zg = Yg = Xg = null;
    }
    function ah(a2) {
      var b = Wg.current;
      E(Wg);
      a2._currentValue = b;
    }
    function bh(a2, b, c2) {
      for (; null !== a2; ) {
        var d = a2.alternate;
        (a2.childLanes & b) !== b ? (a2.childLanes |= b, null !== d && (d.childLanes |= b)) : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
        if (a2 === c2)
          break;
        a2 = a2.return;
      }
    }
    function ch(a2, b) {
      Xg = a2;
      Zg = Yg = null;
      a2 = a2.dependencies;
      null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b) && (dh = true), a2.firstContext = null);
    }
    function eh(a2) {
      var b = a2._currentValue;
      if (Zg !== a2)
        if (a2 = { context: a2, memoizedValue: b, next: null }, null === Yg) {
          if (null === Xg)
            throw Error(p$1(308));
          Yg = a2;
          Xg.dependencies = { lanes: 0, firstContext: a2 };
        } else
          Yg = Yg.next = a2;
      return b;
    }
    var fh = null;
    function gh(a2) {
      null === fh ? fh = [a2] : fh.push(a2);
    }
    function hh(a2, b, c2, d) {
      var e2 = b.interleaved;
      null === e2 ? (c2.next = c2, gh(b)) : (c2.next = e2.next, e2.next = c2);
      b.interleaved = c2;
      return ih(a2, d);
    }
    function ih(a2, b) {
      a2.lanes |= b;
      var c2 = a2.alternate;
      null !== c2 && (c2.lanes |= b);
      c2 = a2;
      for (a2 = a2.return; null !== a2; )
        a2.childLanes |= b, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b), c2 = a2, a2 = a2.return;
      return 3 === c2.tag ? c2.stateNode : null;
    }
    var jh = false;
    function kh(a2) {
      a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
    }
    function lh(a2, b) {
      a2 = a2.updateQueue;
      b.updateQueue === a2 && (b.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
    }
    function mh(a2, b) {
      return { eventTime: a2, lane: b, tag: 0, payload: null, callback: null, next: null };
    }
    function nh(a2, b, c2) {
      var d = a2.updateQueue;
      if (null === d)
        return null;
      d = d.shared;
      if (0 !== (K & 2)) {
        var e2 = d.pending;
        null === e2 ? b.next = b : (b.next = e2.next, e2.next = b);
        d.pending = b;
        return ih(a2, c2);
      }
      e2 = d.interleaved;
      null === e2 ? (b.next = b, gh(d)) : (b.next = e2.next, e2.next = b);
      d.interleaved = b;
      return ih(a2, c2);
    }
    function oh(a2, b, c2) {
      b = b.updateQueue;
      if (null !== b && (b = b.shared, 0 !== (c2 & 4194240))) {
        var d = b.lanes;
        d &= a2.pendingLanes;
        c2 |= d;
        b.lanes = c2;
        Cc(a2, c2);
      }
    }
    function ph(a2, b) {
      var c2 = a2.updateQueue, d = a2.alternate;
      if (null !== d && (d = d.updateQueue, c2 === d)) {
        var e2 = null, f2 = null;
        c2 = c2.firstBaseUpdate;
        if (null !== c2) {
          do {
            var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
            null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
            c2 = c2.next;
          } while (null !== c2);
          null === f2 ? e2 = f2 = b : f2 = f2.next = b;
        } else
          e2 = f2 = b;
        c2 = { baseState: d.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d.shared, effects: d.effects };
        a2.updateQueue = c2;
        return;
      }
      a2 = c2.lastBaseUpdate;
      null === a2 ? c2.firstBaseUpdate = b : a2.next = b;
      c2.lastBaseUpdate = b;
    }
    function qh(a2, b, c2, d) {
      var e2 = a2.updateQueue;
      jh = false;
      var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
      if (null !== h2) {
        e2.shared.pending = null;
        var k2 = h2, l2 = k2.next;
        k2.next = null;
        null === g2 ? f2 = l2 : g2.next = l2;
        g2 = k2;
        var m2 = a2.alternate;
        null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
      }
      if (null !== f2) {
        var q2 = e2.baseState;
        g2 = 0;
        m2 = l2 = k2 = null;
        h2 = f2;
        do {
          var r2 = h2.lane, y2 = h2.eventTime;
          if ((d & r2) === r2) {
            null !== m2 && (m2 = m2.next = {
              eventTime: y2,
              lane: 0,
              tag: h2.tag,
              payload: h2.payload,
              callback: h2.callback,
              next: null
            });
            a: {
              var n2 = a2, t2 = h2;
              r2 = b;
              y2 = c2;
              switch (t2.tag) {
                case 1:
                  n2 = t2.payload;
                  if ("function" === typeof n2) {
                    q2 = n2.call(y2, q2, r2);
                    break a;
                  }
                  q2 = n2;
                  break a;
                case 3:
                  n2.flags = n2.flags & -65537 | 128;
                case 0:
                  n2 = t2.payload;
                  r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
                  if (null === r2 || void 0 === r2)
                    break a;
                  q2 = A({}, q2, r2);
                  break a;
                case 2:
                  jh = true;
              }
            }
            null !== h2.callback && 0 !== h2.lane && (a2.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
          } else
            y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
          h2 = h2.next;
          if (null === h2)
            if (h2 = e2.shared.pending, null === h2)
              break;
            else
              r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
        } while (1);
        null === m2 && (k2 = q2);
        e2.baseState = k2;
        e2.firstBaseUpdate = l2;
        e2.lastBaseUpdate = m2;
        b = e2.shared.interleaved;
        if (null !== b) {
          e2 = b;
          do
            g2 |= e2.lane, e2 = e2.next;
          while (e2 !== b);
        } else
          null === f2 && (e2.shared.lanes = 0);
        rh |= g2;
        a2.lanes = g2;
        a2.memoizedState = q2;
      }
    }
    function sh(a2, b, c2) {
      a2 = b.effects;
      b.effects = null;
      if (null !== a2)
        for (b = 0; b < a2.length; b++) {
          var d = a2[b], e2 = d.callback;
          if (null !== e2) {
            d.callback = null;
            d = c2;
            if ("function" !== typeof e2)
              throw Error(p$1(191, e2));
            e2.call(d);
          }
        }
    }
    var th = {}, uh = Uf(th), vh = Uf(th), wh = Uf(th);
    function xh(a2) {
      if (a2 === th)
        throw Error(p$1(174));
      return a2;
    }
    function yh(a2, b) {
      G(wh, b);
      G(vh, a2);
      G(uh, th);
      a2 = b.nodeType;
      switch (a2) {
        case 9:
        case 11:
          b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
          break;
        default:
          a2 = 8 === a2 ? b.parentNode : b, b = a2.namespaceURI || null, a2 = a2.tagName, b = lb(b, a2);
      }
      E(uh);
      G(uh, b);
    }
    function zh() {
      E(uh);
      E(vh);
      E(wh);
    }
    function Ah(a2) {
      xh(wh.current);
      var b = xh(uh.current);
      var c2 = lb(b, a2.type);
      b !== c2 && (G(vh, a2), G(uh, c2));
    }
    function Bh(a2) {
      vh.current === a2 && (E(uh), E(vh));
    }
    var L = Uf(0);
    function Ch(a2) {
      for (var b = a2; null !== b; ) {
        if (13 === b.tag) {
          var c2 = b.memoizedState;
          if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
            return b;
        } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
          if (0 !== (b.flags & 128))
            return b;
        } else if (null !== b.child) {
          b.child.return = b;
          b = b.child;
          continue;
        }
        if (b === a2)
          break;
        for (; null === b.sibling; ) {
          if (null === b.return || b.return === a2)
            return null;
          b = b.return;
        }
        b.sibling.return = b.return;
        b = b.sibling;
      }
      return null;
    }
    var Dh = [];
    function Eh() {
      for (var a2 = 0; a2 < Dh.length; a2++)
        Dh[a2]._workInProgressVersionPrimary = null;
      Dh.length = 0;
    }
    var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M = null, N = null, O = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
    function P() {
      throw Error(p$1(321));
    }
    function Mh(a2, b) {
      if (null === b)
        return false;
      for (var c2 = 0; c2 < b.length && c2 < a2.length; c2++)
        if (!He(a2[c2], b[c2]))
          return false;
      return true;
    }
    function Nh(a2, b, c2, d, e2, f2) {
      Hh = f2;
      M = b;
      b.memoizedState = null;
      b.updateQueue = null;
      b.lanes = 0;
      Fh.current = null === a2 || null === a2.memoizedState ? Oh : Ph;
      a2 = c2(d, e2);
      if (Jh) {
        f2 = 0;
        do {
          Jh = false;
          Kh = 0;
          if (25 <= f2)
            throw Error(p$1(301));
          f2 += 1;
          O = N = null;
          b.updateQueue = null;
          Fh.current = Qh;
          a2 = c2(d, e2);
        } while (Jh);
      }
      Fh.current = Rh;
      b = null !== N && null !== N.next;
      Hh = 0;
      O = N = M = null;
      Ih = false;
      if (b)
        throw Error(p$1(300));
      return a2;
    }
    function Sh() {
      var a2 = 0 !== Kh;
      Kh = 0;
      return a2;
    }
    function Th() {
      var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      null === O ? M.memoizedState = O = a2 : O = O.next = a2;
      return O;
    }
    function Uh() {
      if (null === N) {
        var a2 = M.alternate;
        a2 = null !== a2 ? a2.memoizedState : null;
      } else
        a2 = N.next;
      var b = null === O ? M.memoizedState : O.next;
      if (null !== b)
        O = b, N = a2;
      else {
        if (null === a2)
          throw Error(p$1(310));
        N = a2;
        a2 = { memoizedState: N.memoizedState, baseState: N.baseState, baseQueue: N.baseQueue, queue: N.queue, next: null };
        null === O ? M.memoizedState = O = a2 : O = O.next = a2;
      }
      return O;
    }
    function Vh(a2, b) {
      return "function" === typeof b ? b(a2) : b;
    }
    function Wh(a2) {
      var b = Uh(), c2 = b.queue;
      if (null === c2)
        throw Error(p$1(311));
      c2.lastRenderedReducer = a2;
      var d = N, e2 = d.baseQueue, f2 = c2.pending;
      if (null !== f2) {
        if (null !== e2) {
          var g2 = e2.next;
          e2.next = f2.next;
          f2.next = g2;
        }
        d.baseQueue = e2 = f2;
        c2.pending = null;
      }
      if (null !== e2) {
        f2 = e2.next;
        d = d.baseState;
        var h2 = g2 = null, k2 = null, l2 = f2;
        do {
          var m2 = l2.lane;
          if ((Hh & m2) === m2)
            null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d = l2.hasEagerState ? l2.eagerState : a2(d, l2.action);
          else {
            var q2 = {
              lane: m2,
              action: l2.action,
              hasEagerState: l2.hasEagerState,
              eagerState: l2.eagerState,
              next: null
            };
            null === k2 ? (h2 = k2 = q2, g2 = d) : k2 = k2.next = q2;
            M.lanes |= m2;
            rh |= m2;
          }
          l2 = l2.next;
        } while (null !== l2 && l2 !== f2);
        null === k2 ? g2 = d : k2.next = h2;
        He(d, b.memoizedState) || (dh = true);
        b.memoizedState = d;
        b.baseState = g2;
        b.baseQueue = k2;
        c2.lastRenderedState = d;
      }
      a2 = c2.interleaved;
      if (null !== a2) {
        e2 = a2;
        do
          f2 = e2.lane, M.lanes |= f2, rh |= f2, e2 = e2.next;
        while (e2 !== a2);
      } else
        null === e2 && (c2.lanes = 0);
      return [b.memoizedState, c2.dispatch];
    }
    function Xh(a2) {
      var b = Uh(), c2 = b.queue;
      if (null === c2)
        throw Error(p$1(311));
      c2.lastRenderedReducer = a2;
      var d = c2.dispatch, e2 = c2.pending, f2 = b.memoizedState;
      if (null !== e2) {
        c2.pending = null;
        var g2 = e2 = e2.next;
        do
          f2 = a2(f2, g2.action), g2 = g2.next;
        while (g2 !== e2);
        He(f2, b.memoizedState) || (dh = true);
        b.memoizedState = f2;
        null === b.baseQueue && (b.baseState = f2);
        c2.lastRenderedState = f2;
      }
      return [f2, d];
    }
    function Yh() {
    }
    function Zh(a2, b) {
      var c2 = M, d = Uh(), e2 = b(), f2 = !He(d.memoizedState, e2);
      f2 && (d.memoizedState = e2, dh = true);
      d = d.queue;
      $h(ai.bind(null, c2, d, a2), [a2]);
      if (d.getSnapshot !== b || f2 || null !== O && O.memoizedState.tag & 1) {
        c2.flags |= 2048;
        bi(9, ci.bind(null, c2, d, e2, b), void 0, null);
        if (null === Q)
          throw Error(p$1(349));
        0 !== (Hh & 30) || di(c2, b, e2);
      }
      return e2;
    }
    function di(a2, b, c2) {
      a2.flags |= 16384;
      a2 = { getSnapshot: b, value: c2 };
      b = M.updateQueue;
      null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.stores = [a2]) : (c2 = b.stores, null === c2 ? b.stores = [a2] : c2.push(a2));
    }
    function ci(a2, b, c2, d) {
      b.value = c2;
      b.getSnapshot = d;
      ei(b) && fi(a2);
    }
    function ai(a2, b, c2) {
      return c2(function() {
        ei(b) && fi(a2);
      });
    }
    function ei(a2) {
      var b = a2.getSnapshot;
      a2 = a2.value;
      try {
        var c2 = b();
        return !He(a2, c2);
      } catch (d) {
        return true;
      }
    }
    function fi(a2) {
      var b = ih(a2, 1);
      null !== b && gi(b, a2, 1, -1);
    }
    function hi(a2) {
      var b = Th();
      "function" === typeof a2 && (a2 = a2());
      b.memoizedState = b.baseState = a2;
      a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a2 };
      b.queue = a2;
      a2 = a2.dispatch = ii.bind(null, M, a2);
      return [b.memoizedState, a2];
    }
    function bi(a2, b, c2, d) {
      a2 = { tag: a2, create: b, destroy: c2, deps: d, next: null };
      b = M.updateQueue;
      null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.lastEffect = a2.next = a2) : (c2 = b.lastEffect, null === c2 ? b.lastEffect = a2.next = a2 : (d = c2.next, c2.next = a2, a2.next = d, b.lastEffect = a2));
      return a2;
    }
    function ji() {
      return Uh().memoizedState;
    }
    function ki(a2, b, c2, d) {
      var e2 = Th();
      M.flags |= a2;
      e2.memoizedState = bi(1 | b, c2, void 0, void 0 === d ? null : d);
    }
    function li(a2, b, c2, d) {
      var e2 = Uh();
      d = void 0 === d ? null : d;
      var f2 = void 0;
      if (null !== N) {
        var g2 = N.memoizedState;
        f2 = g2.destroy;
        if (null !== d && Mh(d, g2.deps)) {
          e2.memoizedState = bi(b, c2, f2, d);
          return;
        }
      }
      M.flags |= a2;
      e2.memoizedState = bi(1 | b, c2, f2, d);
    }
    function mi(a2, b) {
      return ki(8390656, 8, a2, b);
    }
    function $h(a2, b) {
      return li(2048, 8, a2, b);
    }
    function ni(a2, b) {
      return li(4, 2, a2, b);
    }
    function oi(a2, b) {
      return li(4, 4, a2, b);
    }
    function pi(a2, b) {
      if ("function" === typeof b)
        return a2 = a2(), b(a2), function() {
          b(null);
        };
      if (null !== b && void 0 !== b)
        return a2 = a2(), b.current = a2, function() {
          b.current = null;
        };
    }
    function qi(a2, b, c2) {
      c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
      return li(4, 4, pi.bind(null, b, a2), c2);
    }
    function ri() {
    }
    function si(a2, b) {
      var c2 = Uh();
      b = void 0 === b ? null : b;
      var d = c2.memoizedState;
      if (null !== d && null !== b && Mh(b, d[1]))
        return d[0];
      c2.memoizedState = [a2, b];
      return a2;
    }
    function ti(a2, b) {
      var c2 = Uh();
      b = void 0 === b ? null : b;
      var d = c2.memoizedState;
      if (null !== d && null !== b && Mh(b, d[1]))
        return d[0];
      a2 = a2();
      c2.memoizedState = [a2, b];
      return a2;
    }
    function ui(a2, b, c2) {
      if (0 === (Hh & 21))
        return a2.baseState && (a2.baseState = false, dh = true), a2.memoizedState = c2;
      He(c2, b) || (c2 = yc(), M.lanes |= c2, rh |= c2, a2.baseState = true);
      return b;
    }
    function vi(a2, b) {
      var c2 = C;
      C = 0 !== c2 && 4 > c2 ? c2 : 4;
      a2(true);
      var d = Gh.transition;
      Gh.transition = {};
      try {
        a2(false), b();
      } finally {
        C = c2, Gh.transition = d;
      }
    }
    function wi() {
      return Uh().memoizedState;
    }
    function xi(a2, b, c2) {
      var d = yi(a2);
      c2 = { lane: d, action: c2, hasEagerState: false, eagerState: null, next: null };
      if (zi(a2))
        Ai(b, c2);
      else if (c2 = hh(a2, b, c2, d), null !== c2) {
        var e2 = R();
        gi(c2, a2, d, e2);
        Bi(c2, b, d);
      }
    }
    function ii(a2, b, c2) {
      var d = yi(a2), e2 = { lane: d, action: c2, hasEagerState: false, eagerState: null, next: null };
      if (zi(a2))
        Ai(b, e2);
      else {
        var f2 = a2.alternate;
        if (0 === a2.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b.lastRenderedReducer, null !== f2))
          try {
            var g2 = b.lastRenderedState, h2 = f2(g2, c2);
            e2.hasEagerState = true;
            e2.eagerState = h2;
            if (He(h2, g2)) {
              var k2 = b.interleaved;
              null === k2 ? (e2.next = e2, gh(b)) : (e2.next = k2.next, k2.next = e2);
              b.interleaved = e2;
              return;
            }
          } catch (l2) {
          } finally {
          }
        c2 = hh(a2, b, e2, d);
        null !== c2 && (e2 = R(), gi(c2, a2, d, e2), Bi(c2, b, d));
      }
    }
    function zi(a2) {
      var b = a2.alternate;
      return a2 === M || null !== b && b === M;
    }
    function Ai(a2, b) {
      Jh = Ih = true;
      var c2 = a2.pending;
      null === c2 ? b.next = b : (b.next = c2.next, c2.next = b);
      a2.pending = b;
    }
    function Bi(a2, b, c2) {
      if (0 !== (c2 & 4194240)) {
        var d = b.lanes;
        d &= a2.pendingLanes;
        c2 |= d;
        b.lanes = c2;
        Cc(a2, c2);
      }
    }
    var Rh = { readContext: eh, useCallback: P, useContext: P, useEffect: P, useImperativeHandle: P, useInsertionEffect: P, useLayoutEffect: P, useMemo: P, useReducer: P, useRef: P, useState: P, useDebugValue: P, useDeferredValue: P, useTransition: P, useMutableSource: P, useSyncExternalStore: P, useId: P, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a2, b) {
      Th().memoizedState = [a2, void 0 === b ? null : b];
      return a2;
    }, useContext: eh, useEffect: mi, useImperativeHandle: function(a2, b, c2) {
      c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
      return ki(
        4194308,
        4,
        pi.bind(null, b, a2),
        c2
      );
    }, useLayoutEffect: function(a2, b) {
      return ki(4194308, 4, a2, b);
    }, useInsertionEffect: function(a2, b) {
      return ki(4, 2, a2, b);
    }, useMemo: function(a2, b) {
      var c2 = Th();
      b = void 0 === b ? null : b;
      a2 = a2();
      c2.memoizedState = [a2, b];
      return a2;
    }, useReducer: function(a2, b, c2) {
      var d = Th();
      b = void 0 !== c2 ? c2(b) : b;
      d.memoizedState = d.baseState = b;
      a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b };
      d.queue = a2;
      a2 = a2.dispatch = xi.bind(null, M, a2);
      return [d.memoizedState, a2];
    }, useRef: function(a2) {
      var b = Th();
      a2 = { current: a2 };
      return b.memoizedState = a2;
    }, useState: hi, useDebugValue: ri, useDeferredValue: function(a2) {
      return Th().memoizedState = a2;
    }, useTransition: function() {
      var a2 = hi(false), b = a2[0];
      a2 = vi.bind(null, a2[1]);
      Th().memoizedState = a2;
      return [b, a2];
    }, useMutableSource: function() {
    }, useSyncExternalStore: function(a2, b, c2) {
      var d = M, e2 = Th();
      if (I) {
        if (void 0 === c2)
          throw Error(p$1(407));
        c2 = c2();
      } else {
        c2 = b();
        if (null === Q)
          throw Error(p$1(349));
        0 !== (Hh & 30) || di(d, b, c2);
      }
      e2.memoizedState = c2;
      var f2 = { value: c2, getSnapshot: b };
      e2.queue = f2;
      mi(ai.bind(
        null,
        d,
        f2,
        a2
      ), [a2]);
      d.flags |= 2048;
      bi(9, ci.bind(null, d, f2, c2, b), void 0, null);
      return c2;
    }, useId: function() {
      var a2 = Th(), b = Q.identifierPrefix;
      if (I) {
        var c2 = sg;
        var d = rg;
        c2 = (d & ~(1 << 32 - oc(d) - 1)).toString(32) + c2;
        b = ":" + b + "R" + c2;
        c2 = Kh++;
        0 < c2 && (b += "H" + c2.toString(32));
        b += ":";
      } else
        c2 = Lh++, b = ":" + b + "r" + c2.toString(32) + ":";
      return a2.memoizedState = b;
    }, unstable_isNewReconciler: false }, Ph = {
      readContext: eh,
      useCallback: si,
      useContext: eh,
      useEffect: $h,
      useImperativeHandle: qi,
      useInsertionEffect: ni,
      useLayoutEffect: oi,
      useMemo: ti,
      useReducer: Wh,
      useRef: ji,
      useState: function() {
        return Wh(Vh);
      },
      useDebugValue: ri,
      useDeferredValue: function(a2) {
        var b = Uh();
        return ui(b, N.memoizedState, a2);
      },
      useTransition: function() {
        var a2 = Wh(Vh)[0], b = Uh().memoizedState;
        return [a2, b];
      },
      useMutableSource: Yh,
      useSyncExternalStore: Zh,
      useId: wi,
      unstable_isNewReconciler: false
    }, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
      return Xh(Vh);
    }, useDebugValue: ri, useDeferredValue: function(a2) {
      var b = Uh();
      return null === N ? b.memoizedState = a2 : ui(b, N.memoizedState, a2);
    }, useTransition: function() {
      var a2 = Xh(Vh)[0], b = Uh().memoizedState;
      return [a2, b];
    }, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
    function Ci(a2, b) {
      if (a2 && a2.defaultProps) {
        b = A({}, b);
        a2 = a2.defaultProps;
        for (var c2 in a2)
          void 0 === b[c2] && (b[c2] = a2[c2]);
        return b;
      }
      return b;
    }
    function Di(a2, b, c2, d) {
      b = a2.memoizedState;
      c2 = c2(d, b);
      c2 = null === c2 || void 0 === c2 ? b : A({}, b, c2);
      a2.memoizedState = c2;
      0 === a2.lanes && (a2.updateQueue.baseState = c2);
    }
    var Ei = { isMounted: function(a2) {
      return (a2 = a2._reactInternals) ? Vb(a2) === a2 : false;
    }, enqueueSetState: function(a2, b, c2) {
      a2 = a2._reactInternals;
      var d = R(), e2 = yi(a2), f2 = mh(d, e2);
      f2.payload = b;
      void 0 !== c2 && null !== c2 && (f2.callback = c2);
      b = nh(a2, f2, e2);
      null !== b && (gi(b, a2, e2, d), oh(b, a2, e2));
    }, enqueueReplaceState: function(a2, b, c2) {
      a2 = a2._reactInternals;
      var d = R(), e2 = yi(a2), f2 = mh(d, e2);
      f2.tag = 1;
      f2.payload = b;
      void 0 !== c2 && null !== c2 && (f2.callback = c2);
      b = nh(a2, f2, e2);
      null !== b && (gi(b, a2, e2, d), oh(b, a2, e2));
    }, enqueueForceUpdate: function(a2, b) {
      a2 = a2._reactInternals;
      var c2 = R(), d = yi(a2), e2 = mh(c2, d);
      e2.tag = 2;
      void 0 !== b && null !== b && (e2.callback = b);
      b = nh(a2, e2, d);
      null !== b && (gi(b, a2, d, c2), oh(b, a2, d));
    } };
    function Fi(a2, b, c2, d, e2, f2, g2) {
      a2 = a2.stateNode;
      return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d, f2, g2) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c2, d) || !Ie(e2, f2) : true;
    }
    function Gi(a2, b, c2) {
      var d = false, e2 = Vf;
      var f2 = b.contextType;
      "object" === typeof f2 && null !== f2 ? f2 = eh(f2) : (e2 = Zf(b) ? Xf : H.current, d = b.contextTypes, f2 = (d = null !== d && void 0 !== d) ? Yf(a2, e2) : Vf);
      b = new b(c2, f2);
      a2.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
      b.updater = Ei;
      a2.stateNode = b;
      b._reactInternals = a2;
      d && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e2, a2.__reactInternalMemoizedMaskedChildContext = f2);
      return b;
    }
    function Hi(a2, b, c2, d) {
      a2 = b.state;
      "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c2, d);
      "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c2, d);
      b.state !== a2 && Ei.enqueueReplaceState(b, b.state, null);
    }
    function Ii(a2, b, c2, d) {
      var e2 = a2.stateNode;
      e2.props = c2;
      e2.state = a2.memoizedState;
      e2.refs = {};
      kh(a2);
      var f2 = b.contextType;
      "object" === typeof f2 && null !== f2 ? e2.context = eh(f2) : (f2 = Zf(b) ? Xf : H.current, e2.context = Yf(a2, f2));
      e2.state = a2.memoizedState;
      f2 = b.getDerivedStateFromProps;
      "function" === typeof f2 && (Di(a2, b, f2, c2), e2.state = a2.memoizedState);
      "function" === typeof b.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b !== e2.state && Ei.enqueueReplaceState(e2, e2.state, null), qh(a2, c2, e2, d), e2.state = a2.memoizedState);
      "function" === typeof e2.componentDidMount && (a2.flags |= 4194308);
    }
    function Ji(a2, b) {
      try {
        var c2 = "", d = b;
        do
          c2 += Pa(d), d = d.return;
        while (d);
        var e2 = c2;
      } catch (f2) {
        e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
      }
      return { value: a2, source: b, stack: e2, digest: null };
    }
    function Ki(a2, b, c2) {
      return { value: a2, source: null, stack: null != c2 ? c2 : null, digest: null != b ? b : null };
    }
    function Li(a2, b) {
      try {
        console.error(b.value);
      } catch (c2) {
        setTimeout(function() {
          throw c2;
        });
      }
    }
    var Mi = "function" === typeof WeakMap ? WeakMap : Map;
    function Ni(a2, b, c2) {
      c2 = mh(-1, c2);
      c2.tag = 3;
      c2.payload = { element: null };
      var d = b.value;
      c2.callback = function() {
        Oi || (Oi = true, Pi = d);
        Li(a2, b);
      };
      return c2;
    }
    function Qi(a2, b, c2) {
      c2 = mh(-1, c2);
      c2.tag = 3;
      var d = a2.type.getDerivedStateFromError;
      if ("function" === typeof d) {
        var e2 = b.value;
        c2.payload = function() {
          return d(e2);
        };
        c2.callback = function() {
          Li(a2, b);
        };
      }
      var f2 = a2.stateNode;
      null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
        Li(a2, b);
        "function" !== typeof d && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
        var c3 = b.stack;
        this.componentDidCatch(b.value, { componentStack: null !== c3 ? c3 : "" });
      });
      return c2;
    }
    function Si(a2, b, c2) {
      var d = a2.pingCache;
      if (null === d) {
        d = a2.pingCache = new Mi();
        var e2 = /* @__PURE__ */ new Set();
        d.set(b, e2);
      } else
        e2 = d.get(b), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d.set(b, e2));
      e2.has(c2) || (e2.add(c2), a2 = Ti.bind(null, a2, b, c2), b.then(a2, a2));
    }
    function Ui(a2) {
      do {
        var b;
        if (b = 13 === a2.tag)
          b = a2.memoizedState, b = null !== b ? null !== b.dehydrated ? true : false : true;
        if (b)
          return a2;
        a2 = a2.return;
      } while (null !== a2);
      return null;
    }
    function Vi(a2, b, c2, d, e2) {
      if (0 === (a2.mode & 1))
        return a2 === b ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b = mh(-1, 1), b.tag = 2, nh(c2, b, 1))), c2.lanes |= 1), a2;
      a2.flags |= 65536;
      a2.lanes = e2;
      return a2;
    }
    var Wi = ua.ReactCurrentOwner, dh = false;
    function Xi(a2, b, c2, d) {
      b.child = null === a2 ? Vg(b, null, c2, d) : Ug(b, a2.child, c2, d);
    }
    function Yi(a2, b, c2, d, e2) {
      c2 = c2.render;
      var f2 = b.ref;
      ch(b, e2);
      d = Nh(a2, b, c2, d, f2, e2);
      c2 = Sh();
      if (null !== a2 && !dh)
        return b.updateQueue = a2.updateQueue, b.flags &= -2053, a2.lanes &= ~e2, Zi(a2, b, e2);
      I && c2 && vg(b);
      b.flags |= 1;
      Xi(a2, b, d, e2);
      return b.child;
    }
    function $i(a2, b, c2, d, e2) {
      if (null === a2) {
        var f2 = c2.type;
        if ("function" === typeof f2 && !aj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
          return b.tag = 15, b.type = f2, bj(a2, b, f2, d, e2);
        a2 = Rg(c2.type, null, d, b, b.mode, e2);
        a2.ref = b.ref;
        a2.return = b;
        return b.child = a2;
      }
      f2 = a2.child;
      if (0 === (a2.lanes & e2)) {
        var g2 = f2.memoizedProps;
        c2 = c2.compare;
        c2 = null !== c2 ? c2 : Ie;
        if (c2(g2, d) && a2.ref === b.ref)
          return Zi(a2, b, e2);
      }
      b.flags |= 1;
      a2 = Pg(f2, d);
      a2.ref = b.ref;
      a2.return = b;
      return b.child = a2;
    }
    function bj(a2, b, c2, d, e2) {
      if (null !== a2) {
        var f2 = a2.memoizedProps;
        if (Ie(f2, d) && a2.ref === b.ref)
          if (dh = false, b.pendingProps = d = f2, 0 !== (a2.lanes & e2))
            0 !== (a2.flags & 131072) && (dh = true);
          else
            return b.lanes = a2.lanes, Zi(a2, b, e2);
      }
      return cj(a2, b, c2, d, e2);
    }
    function dj(a2, b, c2) {
      var d = b.pendingProps, e2 = d.children, f2 = null !== a2 ? a2.memoizedState : null;
      if ("hidden" === d.mode)
        if (0 === (b.mode & 1))
          b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c2;
        else {
          if (0 === (c2 & 1073741824))
            return a2 = null !== f2 ? f2.baseLanes | c2 : c2, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b.updateQueue = null, G(ej, fj), fj |= a2, null;
          b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
          d = null !== f2 ? f2.baseLanes : c2;
          G(ej, fj);
          fj |= d;
        }
      else
        null !== f2 ? (d = f2.baseLanes | c2, b.memoizedState = null) : d = c2, G(ej, fj), fj |= d;
      Xi(a2, b, e2, c2);
      return b.child;
    }
    function gj(a2, b) {
      var c2 = b.ref;
      if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2)
        b.flags |= 512, b.flags |= 2097152;
    }
    function cj(a2, b, c2, d, e2) {
      var f2 = Zf(c2) ? Xf : H.current;
      f2 = Yf(b, f2);
      ch(b, e2);
      c2 = Nh(a2, b, c2, d, f2, e2);
      d = Sh();
      if (null !== a2 && !dh)
        return b.updateQueue = a2.updateQueue, b.flags &= -2053, a2.lanes &= ~e2, Zi(a2, b, e2);
      I && d && vg(b);
      b.flags |= 1;
      Xi(a2, b, c2, e2);
      return b.child;
    }
    function hj(a2, b, c2, d, e2) {
      if (Zf(c2)) {
        var f2 = true;
        cg(b);
      } else
        f2 = false;
      ch(b, e2);
      if (null === b.stateNode)
        ij(a2, b), Gi(b, c2, d), Ii(b, c2, d, e2), d = true;
      else if (null === a2) {
        var g2 = b.stateNode, h2 = b.memoizedProps;
        g2.props = h2;
        var k2 = g2.context, l2 = c2.contextType;
        "object" === typeof l2 && null !== l2 ? l2 = eh(l2) : (l2 = Zf(c2) ? Xf : H.current, l2 = Yf(b, l2));
        var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
        q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d || k2 !== l2) && Hi(b, g2, d, l2);
        jh = false;
        var r2 = b.memoizedState;
        g2.state = r2;
        qh(b, d, g2, e2);
        k2 = b.memoizedState;
        h2 !== d || r2 !== k2 || Wf.current || jh ? ("function" === typeof m2 && (Di(b, c2, m2, d), k2 = b.memoizedState), (h2 = jh || Fi(b, c2, h2, d, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k2), g2.props = d, g2.state = k2, g2.context = l2, d = h2) : ("function" === typeof g2.componentDidMount && (b.flags |= 4194308), d = false);
      } else {
        g2 = b.stateNode;
        lh(a2, b);
        h2 = b.memoizedProps;
        l2 = b.type === b.elementType ? h2 : Ci(b.type, h2);
        g2.props = l2;
        q2 = b.pendingProps;
        r2 = g2.context;
        k2 = c2.contextType;
        "object" === typeof k2 && null !== k2 ? k2 = eh(k2) : (k2 = Zf(c2) ? Xf : H.current, k2 = Yf(b, k2));
        var y2 = c2.getDerivedStateFromProps;
        (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && Hi(b, g2, d, k2);
        jh = false;
        r2 = b.memoizedState;
        g2.state = r2;
        qh(b, d, g2, e2);
        var n2 = b.memoizedState;
        h2 !== q2 || r2 !== n2 || Wf.current || jh ? ("function" === typeof y2 && (Di(b, c2, y2, d), n2 = b.memoizedState), (l2 = jh || Fi(b, c2, l2, d, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d, n2, k2)), "function" === typeof g2.componentDidUpdate && (b.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n2), g2.props = d, g2.state = n2, g2.context = k2, d = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b.flags |= 1024), d = false);
      }
      return jj(a2, b, c2, d, f2, e2);
    }
    function jj(a2, b, c2, d, e2, f2) {
      gj(a2, b);
      var g2 = 0 !== (b.flags & 128);
      if (!d && !g2)
        return e2 && dg(b, c2, false), Zi(a2, b, f2);
      d = b.stateNode;
      Wi.current = b;
      var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d.render();
      b.flags |= 1;
      null !== a2 && g2 ? (b.child = Ug(b, a2.child, null, f2), b.child = Ug(b, null, h2, f2)) : Xi(a2, b, h2, f2);
      b.memoizedState = d.state;
      e2 && dg(b, c2, true);
      return b.child;
    }
    function kj(a2) {
      var b = a2.stateNode;
      b.pendingContext ? ag(a2, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a2, b.context, false);
      yh(a2, b.containerInfo);
    }
    function lj(a2, b, c2, d, e2) {
      Ig();
      Jg(e2);
      b.flags |= 256;
      Xi(a2, b, c2, d);
      return b.child;
    }
    var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
    function nj(a2) {
      return { baseLanes: a2, cachePool: null, transitions: null };
    }
    function oj(a2, b, c2) {
      var d = b.pendingProps, e2 = L.current, f2 = false, g2 = 0 !== (b.flags & 128), h2;
      (h2 = g2) || (h2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e2 & 2));
      if (h2)
        f2 = true, b.flags &= -129;
      else if (null === a2 || null !== a2.memoizedState)
        e2 |= 1;
      G(L, e2 & 1);
      if (null === a2) {
        Eg(b);
        a2 = b.memoizedState;
        if (null !== a2 && (a2 = a2.dehydrated, null !== a2))
          return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a2.data ? b.lanes = 8 : b.lanes = 1073741824, null;
        g2 = d.children;
        a2 = d.fallback;
        return f2 ? (d = b.mode, f2 = b.child, g2 = { mode: "hidden", children: g2 }, 0 === (d & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = pj(g2, d, 0, null), a2 = Tg(a2, d, c2, null), f2.return = b, a2.return = b, f2.sibling = a2, b.child = f2, b.child.memoizedState = nj(c2), b.memoizedState = mj, a2) : qj(b, g2);
      }
      e2 = a2.memoizedState;
      if (null !== e2 && (h2 = e2.dehydrated, null !== h2))
        return rj(a2, b, g2, d, h2, e2, c2);
      if (f2) {
        f2 = d.fallback;
        g2 = b.mode;
        e2 = a2.child;
        h2 = e2.sibling;
        var k2 = { mode: "hidden", children: d.children };
        0 === (g2 & 1) && b.child !== e2 ? (d = b.child, d.childLanes = 0, d.pendingProps = k2, b.deletions = null) : (d = Pg(e2, k2), d.subtreeFlags = e2.subtreeFlags & 14680064);
        null !== h2 ? f2 = Pg(h2, f2) : (f2 = Tg(f2, g2, c2, null), f2.flags |= 2);
        f2.return = b;
        d.return = b;
        d.sibling = f2;
        b.child = d;
        d = f2;
        f2 = b.child;
        g2 = a2.child.memoizedState;
        g2 = null === g2 ? nj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
        f2.memoizedState = g2;
        f2.childLanes = a2.childLanes & ~c2;
        b.memoizedState = mj;
        return d;
      }
      f2 = a2.child;
      a2 = f2.sibling;
      d = Pg(f2, { mode: "visible", children: d.children });
      0 === (b.mode & 1) && (d.lanes = c2);
      d.return = b;
      d.sibling = null;
      null !== a2 && (c2 = b.deletions, null === c2 ? (b.deletions = [a2], b.flags |= 16) : c2.push(a2));
      b.child = d;
      b.memoizedState = null;
      return d;
    }
    function qj(a2, b) {
      b = pj({ mode: "visible", children: b }, a2.mode, 0, null);
      b.return = a2;
      return a2.child = b;
    }
    function sj(a2, b, c2, d) {
      null !== d && Jg(d);
      Ug(b, a2.child, null, c2);
      a2 = qj(b, b.pendingProps.children);
      a2.flags |= 2;
      b.memoizedState = null;
      return a2;
    }
    function rj(a2, b, c2, d, e2, f2, g2) {
      if (c2) {
        if (b.flags & 256)
          return b.flags &= -257, d = Ki(Error(p$1(422))), sj(a2, b, g2, d);
        if (null !== b.memoizedState)
          return b.child = a2.child, b.flags |= 128, null;
        f2 = d.fallback;
        e2 = b.mode;
        d = pj({ mode: "visible", children: d.children }, e2, 0, null);
        f2 = Tg(f2, e2, g2, null);
        f2.flags |= 2;
        d.return = b;
        f2.return = b;
        d.sibling = f2;
        b.child = d;
        0 !== (b.mode & 1) && Ug(b, a2.child, null, g2);
        b.child.memoizedState = nj(g2);
        b.memoizedState = mj;
        return f2;
      }
      if (0 === (b.mode & 1))
        return sj(a2, b, g2, null);
      if ("$!" === e2.data) {
        d = e2.nextSibling && e2.nextSibling.dataset;
        if (d)
          var h2 = d.dgst;
        d = h2;
        f2 = Error(p$1(419));
        d = Ki(f2, d, void 0);
        return sj(a2, b, g2, d);
      }
      h2 = 0 !== (g2 & a2.childLanes);
      if (dh || h2) {
        d = Q;
        if (null !== d) {
          switch (g2 & -g2) {
            case 4:
              e2 = 2;
              break;
            case 16:
              e2 = 8;
              break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              e2 = 32;
              break;
            case 536870912:
              e2 = 268435456;
              break;
            default:
              e2 = 0;
          }
          e2 = 0 !== (e2 & (d.suspendedLanes | g2)) ? 0 : e2;
          0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, ih(a2, e2), gi(d, a2, e2, -1));
        }
        tj();
        d = Ki(Error(p$1(421)));
        return sj(a2, b, g2, d);
      }
      if ("$?" === e2.data)
        return b.flags |= 128, b.child = a2.child, b = uj.bind(null, a2), e2._reactRetry = b, null;
      a2 = f2.treeContext;
      yg = Lf(e2.nextSibling);
      xg = b;
      I = true;
      zg = null;
      null !== a2 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b);
      b = qj(b, d.children);
      b.flags |= 4096;
      return b;
    }
    function vj(a2, b, c2) {
      a2.lanes |= b;
      var d = a2.alternate;
      null !== d && (d.lanes |= b);
      bh(a2.return, b, c2);
    }
    function wj(a2, b, c2, d, e2) {
      var f2 = a2.memoizedState;
      null === f2 ? a2.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c2, tailMode: e2 } : (f2.isBackwards = b, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d, f2.tail = c2, f2.tailMode = e2);
    }
    function xj(a2, b, c2) {
      var d = b.pendingProps, e2 = d.revealOrder, f2 = d.tail;
      Xi(a2, b, d.children, c2);
      d = L.current;
      if (0 !== (d & 2))
        d = d & 1 | 2, b.flags |= 128;
      else {
        if (null !== a2 && 0 !== (a2.flags & 128))
          a:
            for (a2 = b.child; null !== a2; ) {
              if (13 === a2.tag)
                null !== a2.memoizedState && vj(a2, c2, b);
              else if (19 === a2.tag)
                vj(a2, c2, b);
              else if (null !== a2.child) {
                a2.child.return = a2;
                a2 = a2.child;
                continue;
              }
              if (a2 === b)
                break a;
              for (; null === a2.sibling; ) {
                if (null === a2.return || a2.return === b)
                  break a;
                a2 = a2.return;
              }
              a2.sibling.return = a2.return;
              a2 = a2.sibling;
            }
        d &= 1;
      }
      G(L, d);
      if (0 === (b.mode & 1))
        b.memoizedState = null;
      else
        switch (e2) {
          case "forwards":
            c2 = b.child;
            for (e2 = null; null !== c2; )
              a2 = c2.alternate, null !== a2 && null === Ch(a2) && (e2 = c2), c2 = c2.sibling;
            c2 = e2;
            null === c2 ? (e2 = b.child, b.child = null) : (e2 = c2.sibling, c2.sibling = null);
            wj(b, false, e2, c2, f2);
            break;
          case "backwards":
            c2 = null;
            e2 = b.child;
            for (b.child = null; null !== e2; ) {
              a2 = e2.alternate;
              if (null !== a2 && null === Ch(a2)) {
                b.child = e2;
                break;
              }
              a2 = e2.sibling;
              e2.sibling = c2;
              c2 = e2;
              e2 = a2;
            }
            wj(b, true, c2, null, f2);
            break;
          case "together":
            wj(b, false, null, null, void 0);
            break;
          default:
            b.memoizedState = null;
        }
      return b.child;
    }
    function ij(a2, b) {
      0 === (b.mode & 1) && null !== a2 && (a2.alternate = null, b.alternate = null, b.flags |= 2);
    }
    function Zi(a2, b, c2) {
      null !== a2 && (b.dependencies = a2.dependencies);
      rh |= b.lanes;
      if (0 === (c2 & b.childLanes))
        return null;
      if (null !== a2 && b.child !== a2.child)
        throw Error(p$1(153));
      if (null !== b.child) {
        a2 = b.child;
        c2 = Pg(a2, a2.pendingProps);
        b.child = c2;
        for (c2.return = b; null !== a2.sibling; )
          a2 = a2.sibling, c2 = c2.sibling = Pg(a2, a2.pendingProps), c2.return = b;
        c2.sibling = null;
      }
      return b.child;
    }
    function yj(a2, b, c2) {
      switch (b.tag) {
        case 3:
          kj(b);
          Ig();
          break;
        case 5:
          Ah(b);
          break;
        case 1:
          Zf(b.type) && cg(b);
          break;
        case 4:
          yh(b, b.stateNode.containerInfo);
          break;
        case 10:
          var d = b.type._context, e2 = b.memoizedProps.value;
          G(Wg, d._currentValue);
          d._currentValue = e2;
          break;
        case 13:
          d = b.memoizedState;
          if (null !== d) {
            if (null !== d.dehydrated)
              return G(L, L.current & 1), b.flags |= 128, null;
            if (0 !== (c2 & b.child.childLanes))
              return oj(a2, b, c2);
            G(L, L.current & 1);
            a2 = Zi(a2, b, c2);
            return null !== a2 ? a2.sibling : null;
          }
          G(L, L.current & 1);
          break;
        case 19:
          d = 0 !== (c2 & b.childLanes);
          if (0 !== (a2.flags & 128)) {
            if (d)
              return xj(a2, b, c2);
            b.flags |= 128;
          }
          e2 = b.memoizedState;
          null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
          G(L, L.current);
          if (d)
            break;
          else
            return null;
        case 22:
        case 23:
          return b.lanes = 0, dj(a2, b, c2);
      }
      return Zi(a2, b, c2);
    }
    var zj, Aj, Bj, Cj;
    zj = function(a2, b) {
      for (var c2 = b.child; null !== c2; ) {
        if (5 === c2.tag || 6 === c2.tag)
          a2.appendChild(c2.stateNode);
        else if (4 !== c2.tag && null !== c2.child) {
          c2.child.return = c2;
          c2 = c2.child;
          continue;
        }
        if (c2 === b)
          break;
        for (; null === c2.sibling; ) {
          if (null === c2.return || c2.return === b)
            return;
          c2 = c2.return;
        }
        c2.sibling.return = c2.return;
        c2 = c2.sibling;
      }
    };
    Aj = function() {
    };
    Bj = function(a2, b, c2, d) {
      var e2 = a2.memoizedProps;
      if (e2 !== d) {
        a2 = b.stateNode;
        xh(uh.current);
        var f2 = null;
        switch (c2) {
          case "input":
            e2 = Ya(a2, e2);
            d = Ya(a2, d);
            f2 = [];
            break;
          case "select":
            e2 = A({}, e2, { value: void 0 });
            d = A({}, d, { value: void 0 });
            f2 = [];
            break;
          case "textarea":
            e2 = gb(a2, e2);
            d = gb(a2, d);
            f2 = [];
            break;
          default:
            "function" !== typeof e2.onClick && "function" === typeof d.onClick && (a2.onclick = Bf);
        }
        ub(c2, d);
        var g2;
        c2 = null;
        for (l2 in e2)
          if (!d.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
            if ("style" === l2) {
              var h2 = e2[l2];
              for (g2 in h2)
                h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
            } else
              "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
        for (l2 in d) {
          var k2 = d[l2];
          h2 = null != e2 ? e2[l2] : void 0;
          if (d.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
            if ("style" === l2)
              if (h2) {
                for (g2 in h2)
                  !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
                for (g2 in k2)
                  k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
              } else
                c2 || (f2 || (f2 = []), f2.push(
                  l2,
                  c2
                )), c2 = k2;
            else
              "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D("scroll", a2), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
        }
        c2 && (f2 = f2 || []).push("style", c2);
        var l2 = f2;
        if (b.updateQueue = l2)
          b.flags |= 4;
      }
    };
    Cj = function(a2, b, c2, d) {
      c2 !== d && (b.flags |= 4);
    };
    function Dj(a2, b) {
      if (!I)
        switch (a2.tailMode) {
          case "hidden":
            b = a2.tail;
            for (var c2 = null; null !== b; )
              null !== b.alternate && (c2 = b), b = b.sibling;
            null === c2 ? a2.tail = null : c2.sibling = null;
            break;
          case "collapsed":
            c2 = a2.tail;
            for (var d = null; null !== c2; )
              null !== c2.alternate && (d = c2), c2 = c2.sibling;
            null === d ? b || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d.sibling = null;
        }
    }
    function S(a2) {
      var b = null !== a2.alternate && a2.alternate.child === a2.child, c2 = 0, d = 0;
      if (b)
        for (var e2 = a2.child; null !== e2; )
          c2 |= e2.lanes | e2.childLanes, d |= e2.subtreeFlags & 14680064, d |= e2.flags & 14680064, e2.return = a2, e2 = e2.sibling;
      else
        for (e2 = a2.child; null !== e2; )
          c2 |= e2.lanes | e2.childLanes, d |= e2.subtreeFlags, d |= e2.flags, e2.return = a2, e2 = e2.sibling;
      a2.subtreeFlags |= d;
      a2.childLanes = c2;
      return b;
    }
    function Ej(a2, b, c2) {
      var d = b.pendingProps;
      wg(b);
      switch (b.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return S(b), null;
        case 1:
          return Zf(b.type) && $f(), S(b), null;
        case 3:
          d = b.stateNode;
          zh();
          E(Wf);
          E(H);
          Eh();
          d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
          if (null === a2 || null === a2.child)
            Gg(b) ? b.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg && (Fj(zg), zg = null));
          Aj(a2, b);
          S(b);
          return null;
        case 5:
          Bh(b);
          var e2 = xh(wh.current);
          c2 = b.type;
          if (null !== a2 && null != b.stateNode)
            Bj(a2, b, c2, d, e2), a2.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
          else {
            if (!d) {
              if (null === b.stateNode)
                throw Error(p$1(166));
              S(b);
              return null;
            }
            a2 = xh(uh.current);
            if (Gg(b)) {
              d = b.stateNode;
              c2 = b.type;
              var f2 = b.memoizedProps;
              d[Of] = b;
              d[Pf] = f2;
              a2 = 0 !== (b.mode & 1);
              switch (c2) {
                case "dialog":
                  D("cancel", d);
                  D("close", d);
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D("load", d);
                  break;
                case "video":
                case "audio":
                  for (e2 = 0; e2 < lf.length; e2++)
                    D(lf[e2], d);
                  break;
                case "source":
                  D("error", d);
                  break;
                case "img":
                case "image":
                case "link":
                  D(
                    "error",
                    d
                  );
                  D("load", d);
                  break;
                case "details":
                  D("toggle", d);
                  break;
                case "input":
                  Za(d, f2);
                  D("invalid", d);
                  break;
                case "select":
                  d._wrapperState = { wasMultiple: !!f2.multiple };
                  D("invalid", d);
                  break;
                case "textarea":
                  hb(d, f2), D("invalid", d);
              }
              ub(c2, f2);
              e2 = null;
              for (var g2 in f2)
                if (f2.hasOwnProperty(g2)) {
                  var h2 = f2[g2];
                  "children" === g2 ? "string" === typeof h2 ? d.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d.textContent, h2, a2), e2 = ["children", h2]) : "number" === typeof h2 && d.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                    d.textContent,
                    h2,
                    a2
                  ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D("scroll", d);
                }
              switch (c2) {
                case "input":
                  Va(d);
                  db(d, f2, true);
                  break;
                case "textarea":
                  Va(d);
                  jb(d);
                  break;
                case "select":
                case "option":
                  break;
                default:
                  "function" === typeof f2.onClick && (d.onclick = Bf);
              }
              d = e2;
              b.updateQueue = d;
              null !== d && (b.flags |= 4);
            } else {
              g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
              "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c2));
              "http://www.w3.org/1999/xhtml" === a2 ? "script" === c2 ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d.is ? a2 = g2.createElement(c2, { is: d.is }) : (a2 = g2.createElement(c2), "select" === c2 && (g2 = a2, d.multiple ? g2.multiple = true : d.size && (g2.size = d.size))) : a2 = g2.createElementNS(a2, c2);
              a2[Of] = b;
              a2[Pf] = d;
              zj(a2, b, false, false);
              b.stateNode = a2;
              a: {
                g2 = vb(c2, d);
                switch (c2) {
                  case "dialog":
                    D("cancel", a2);
                    D("close", a2);
                    e2 = d;
                    break;
                  case "iframe":
                  case "object":
                  case "embed":
                    D("load", a2);
                    e2 = d;
                    break;
                  case "video":
                  case "audio":
                    for (e2 = 0; e2 < lf.length; e2++)
                      D(lf[e2], a2);
                    e2 = d;
                    break;
                  case "source":
                    D("error", a2);
                    e2 = d;
                    break;
                  case "img":
                  case "image":
                  case "link":
                    D(
                      "error",
                      a2
                    );
                    D("load", a2);
                    e2 = d;
                    break;
                  case "details":
                    D("toggle", a2);
                    e2 = d;
                    break;
                  case "input":
                    Za(a2, d);
                    e2 = Ya(a2, d);
                    D("invalid", a2);
                    break;
                  case "option":
                    e2 = d;
                    break;
                  case "select":
                    a2._wrapperState = { wasMultiple: !!d.multiple };
                    e2 = A({}, d, { value: void 0 });
                    D("invalid", a2);
                    break;
                  case "textarea":
                    hb(a2, d);
                    e2 = gb(a2, d);
                    D("invalid", a2);
                    break;
                  default:
                    e2 = d;
                }
                ub(c2, e2);
                h2 = e2;
                for (f2 in h2)
                  if (h2.hasOwnProperty(f2)) {
                    var k2 = h2[f2];
                    "style" === f2 ? sb(a2, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a2, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a2, k2) : "number" === typeof k2 && ob(a2, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D("scroll", a2) : null != k2 && ta(a2, f2, k2, g2));
                  }
                switch (c2) {
                  case "input":
                    Va(a2);
                    db(a2, d, false);
                    break;
                  case "textarea":
                    Va(a2);
                    jb(a2);
                    break;
                  case "option":
                    null != d.value && a2.setAttribute("value", "" + Sa(d.value));
                    break;
                  case "select":
                    a2.multiple = !!d.multiple;
                    f2 = d.value;
                    null != f2 ? fb(a2, !!d.multiple, f2, false) : null != d.defaultValue && fb(
                      a2,
                      !!d.multiple,
                      d.defaultValue,
                      true
                    );
                    break;
                  default:
                    "function" === typeof e2.onClick && (a2.onclick = Bf);
                }
                switch (c2) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    d = !!d.autoFocus;
                    break a;
                  case "img":
                    d = true;
                    break a;
                  default:
                    d = false;
                }
              }
              d && (b.flags |= 4);
            }
            null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
          }
          S(b);
          return null;
        case 6:
          if (a2 && null != b.stateNode)
            Cj(a2, b, a2.memoizedProps, d);
          else {
            if ("string" !== typeof d && null === b.stateNode)
              throw Error(p$1(166));
            c2 = xh(wh.current);
            xh(uh.current);
            if (Gg(b)) {
              d = b.stateNode;
              c2 = b.memoizedProps;
              d[Of] = b;
              if (f2 = d.nodeValue !== c2) {
                if (a2 = xg, null !== a2)
                  switch (a2.tag) {
                    case 3:
                      Af(d.nodeValue, c2, 0 !== (a2.mode & 1));
                      break;
                    case 5:
                      true !== a2.memoizedProps.suppressHydrationWarning && Af(d.nodeValue, c2, 0 !== (a2.mode & 1));
                  }
              }
              f2 && (b.flags |= 4);
            } else
              d = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d), d[Of] = b, b.stateNode = d;
          }
          S(b);
          return null;
        case 13:
          E(L);
          d = b.memoizedState;
          if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
            if (I && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128))
              Hg(), Ig(), b.flags |= 98560, f2 = false;
            else if (f2 = Gg(b), null !== d && null !== d.dehydrated) {
              if (null === a2) {
                if (!f2)
                  throw Error(p$1(318));
                f2 = b.memoizedState;
                f2 = null !== f2 ? f2.dehydrated : null;
                if (!f2)
                  throw Error(p$1(317));
                f2[Of] = b;
              } else
                Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
              S(b);
              f2 = false;
            } else
              null !== zg && (Fj(zg), zg = null), f2 = true;
            if (!f2)
              return b.flags & 65536 ? b : null;
          }
          if (0 !== (b.flags & 128))
            return b.lanes = c2, b;
          d = null !== d;
          d !== (null !== a2 && null !== a2.memoizedState) && d && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a2 || 0 !== (L.current & 1) ? 0 === T && (T = 3) : tj()));
          null !== b.updateQueue && (b.flags |= 4);
          S(b);
          return null;
        case 4:
          return zh(), Aj(a2, b), null === a2 && sf(b.stateNode.containerInfo), S(b), null;
        case 10:
          return ah(b.type._context), S(b), null;
        case 17:
          return Zf(b.type) && $f(), S(b), null;
        case 19:
          E(L);
          f2 = b.memoizedState;
          if (null === f2)
            return S(b), null;
          d = 0 !== (b.flags & 128);
          g2 = f2.rendering;
          if (null === g2)
            if (d)
              Dj(f2, false);
            else {
              if (0 !== T || null !== a2 && 0 !== (a2.flags & 128))
                for (a2 = b.child; null !== a2; ) {
                  g2 = Ch(a2);
                  if (null !== g2) {
                    b.flags |= 128;
                    Dj(f2, false);
                    d = g2.updateQueue;
                    null !== d && (b.updateQueue = d, b.flags |= 4);
                    b.subtreeFlags = 0;
                    d = c2;
                    for (c2 = b.child; null !== c2; )
                      f2 = c2, a2 = d, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
                    G(L, L.current & 1 | 2);
                    return b.child;
                  }
                  a2 = a2.sibling;
                }
              null !== f2.tail && B() > Gj && (b.flags |= 128, d = true, Dj(f2, false), b.lanes = 4194304);
            }
          else {
            if (!d)
              if (a2 = Ch(g2), null !== a2) {
                if (b.flags |= 128, d = true, c2 = a2.updateQueue, null !== c2 && (b.updateQueue = c2, b.flags |= 4), Dj(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I)
                  return S(b), null;
              } else
                2 * B() - f2.renderingStartTime > Gj && 1073741824 !== c2 && (b.flags |= 128, d = true, Dj(f2, false), b.lanes = 4194304);
            f2.isBackwards ? (g2.sibling = b.child, b.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b.child = g2, f2.last = g2);
          }
          if (null !== f2.tail)
            return b = f2.tail, f2.rendering = b, f2.tail = b.sibling, f2.renderingStartTime = B(), b.sibling = null, c2 = L.current, G(L, d ? c2 & 1 | 2 : c2 & 1), b;
          S(b);
          return null;
        case 22:
        case 23:
          return Hj(), d = null !== b.memoizedState, null !== a2 && null !== a2.memoizedState !== d && (b.flags |= 8192), d && 0 !== (b.mode & 1) ? 0 !== (fj & 1073741824) && (S(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S(b), null;
        case 24:
          return null;
        case 25:
          return null;
      }
      throw Error(p$1(156, b.tag));
    }
    function Ij(a2, b) {
      wg(b);
      switch (b.tag) {
        case 1:
          return Zf(b.type) && $f(), a2 = b.flags, a2 & 65536 ? (b.flags = a2 & -65537 | 128, b) : null;
        case 3:
          return zh(), E(Wf), E(H), Eh(), a2 = b.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b.flags = a2 & -65537 | 128, b) : null;
        case 5:
          return Bh(b), null;
        case 13:
          E(L);
          a2 = b.memoizedState;
          if (null !== a2 && null !== a2.dehydrated) {
            if (null === b.alternate)
              throw Error(p$1(340));
            Ig();
          }
          a2 = b.flags;
          return a2 & 65536 ? (b.flags = a2 & -65537 | 128, b) : null;
        case 19:
          return E(L), null;
        case 4:
          return zh(), null;
        case 10:
          return ah(b.type._context), null;
        case 22:
        case 23:
          return Hj(), null;
        case 24:
          return null;
        default:
          return null;
      }
    }
    var Jj = false, U = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
    function Lj(a2, b) {
      var c2 = a2.ref;
      if (null !== c2)
        if ("function" === typeof c2)
          try {
            c2(null);
          } catch (d) {
            W(a2, b, d);
          }
        else
          c2.current = null;
    }
    function Mj(a2, b, c2) {
      try {
        c2();
      } catch (d) {
        W(a2, b, d);
      }
    }
    var Nj = false;
    function Oj(a2, b) {
      Cf = dd;
      a2 = Me();
      if (Ne(a2)) {
        if ("selectionStart" in a2)
          var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
        else
          a: {
            c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
            var d = c2.getSelection && c2.getSelection();
            if (d && 0 !== d.rangeCount) {
              c2 = d.anchorNode;
              var e2 = d.anchorOffset, f2 = d.focusNode;
              d = d.focusOffset;
              try {
                c2.nodeType, f2.nodeType;
              } catch (F2) {
                c2 = null;
                break a;
              }
              var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a2, r2 = null;
              b:
                for (; ; ) {
                  for (var y2; ; ) {
                    q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h2 = g2 + e2);
                    q2 !== f2 || 0 !== d && 3 !== q2.nodeType || (k2 = g2 + d);
                    3 === q2.nodeType && (g2 += q2.nodeValue.length);
                    if (null === (y2 = q2.firstChild))
                      break;
                    r2 = q2;
                    q2 = y2;
                  }
                  for (; ; ) {
                    if (q2 === a2)
                      break b;
                    r2 === c2 && ++l2 === e2 && (h2 = g2);
                    r2 === f2 && ++m2 === d && (k2 = g2);
                    if (null !== (y2 = q2.nextSibling))
                      break;
                    q2 = r2;
                    r2 = q2.parentNode;
                  }
                  q2 = y2;
                }
              c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
            } else
              c2 = null;
          }
        c2 = c2 || { start: 0, end: 0 };
      } else
        c2 = null;
      Df = { focusedElem: a2, selectionRange: c2 };
      dd = false;
      for (V = b; null !== V; )
        if (b = V, a2 = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a2)
          a2.return = b, V = a2;
        else
          for (; null !== V; ) {
            b = V;
            try {
              var n2 = b.alternate;
              if (0 !== (b.flags & 1024))
                switch (b.tag) {
                  case 0:
                  case 11:
                  case 15:
                    break;
                  case 1:
                    if (null !== n2) {
                      var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b.stateNode, w2 = x2.getSnapshotBeforeUpdate(b.elementType === b.type ? t2 : Ci(b.type, t2), J2);
                      x2.__reactInternalSnapshotBeforeUpdate = w2;
                    }
                    break;
                  case 3:
                    var u2 = b.stateNode.containerInfo;
                    1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                    break;
                  case 5:
                  case 6:
                  case 4:
                  case 17:
                    break;
                  default:
                    throw Error(p$1(163));
                }
            } catch (F2) {
              W(b, b.return, F2);
            }
            a2 = b.sibling;
            if (null !== a2) {
              a2.return = b.return;
              V = a2;
              break;
            }
            V = b.return;
          }
      n2 = Nj;
      Nj = false;
      return n2;
    }
    function Pj(a2, b, c2) {
      var d = b.updateQueue;
      d = null !== d ? d.lastEffect : null;
      if (null !== d) {
        var e2 = d = d.next;
        do {
          if ((e2.tag & a2) === a2) {
            var f2 = e2.destroy;
            e2.destroy = void 0;
            void 0 !== f2 && Mj(b, c2, f2);
          }
          e2 = e2.next;
        } while (e2 !== d);
      }
    }
    function Qj(a2, b) {
      b = b.updateQueue;
      b = null !== b ? b.lastEffect : null;
      if (null !== b) {
        var c2 = b = b.next;
        do {
          if ((c2.tag & a2) === a2) {
            var d = c2.create;
            c2.destroy = d();
          }
          c2 = c2.next;
        } while (c2 !== b);
      }
    }
    function Rj(a2) {
      var b = a2.ref;
      if (null !== b) {
        var c2 = a2.stateNode;
        switch (a2.tag) {
          case 5:
            a2 = c2;
            break;
          default:
            a2 = c2;
        }
        "function" === typeof b ? b(a2) : b.current = a2;
      }
    }
    function Sj(a2) {
      var b = a2.alternate;
      null !== b && (a2.alternate = null, Sj(b));
      a2.child = null;
      a2.deletions = null;
      a2.sibling = null;
      5 === a2.tag && (b = a2.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf]));
      a2.stateNode = null;
      a2.return = null;
      a2.dependencies = null;
      a2.memoizedProps = null;
      a2.memoizedState = null;
      a2.pendingProps = null;
      a2.stateNode = null;
      a2.updateQueue = null;
    }
    function Tj(a2) {
      return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
    }
    function Uj(a2) {
      a:
        for (; ; ) {
          for (; null === a2.sibling; ) {
            if (null === a2.return || Tj(a2.return))
              return null;
            a2 = a2.return;
          }
          a2.sibling.return = a2.return;
          for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
            if (a2.flags & 2)
              continue a;
            if (null === a2.child || 4 === a2.tag)
              continue a;
            else
              a2.child.return = a2, a2 = a2.child;
          }
          if (!(a2.flags & 2))
            return a2.stateNode;
        }
    }
    function Vj(a2, b, c2) {
      var d = a2.tag;
      if (5 === d || 6 === d)
        a2 = a2.stateNode, b ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b) : c2.insertBefore(a2, b) : (8 === c2.nodeType ? (b = c2.parentNode, b.insertBefore(a2, c2)) : (b = c2, b.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b.onclick || (b.onclick = Bf));
      else if (4 !== d && (a2 = a2.child, null !== a2))
        for (Vj(a2, b, c2), a2 = a2.sibling; null !== a2; )
          Vj(a2, b, c2), a2 = a2.sibling;
    }
    function Wj(a2, b, c2) {
      var d = a2.tag;
      if (5 === d || 6 === d)
        a2 = a2.stateNode, b ? c2.insertBefore(a2, b) : c2.appendChild(a2);
      else if (4 !== d && (a2 = a2.child, null !== a2))
        for (Wj(a2, b, c2), a2 = a2.sibling; null !== a2; )
          Wj(a2, b, c2), a2 = a2.sibling;
    }
    var X = null, Xj = false;
    function Yj(a2, b, c2) {
      for (c2 = c2.child; null !== c2; )
        Zj(a2, b, c2), c2 = c2.sibling;
    }
    function Zj(a2, b, c2) {
      if (lc && "function" === typeof lc.onCommitFiberUnmount)
        try {
          lc.onCommitFiberUnmount(kc, c2);
        } catch (h2) {
        }
      switch (c2.tag) {
        case 5:
          U || Lj(c2, b);
        case 6:
          var d = X, e2 = Xj;
          X = null;
          Yj(a2, b, c2);
          X = d;
          Xj = e2;
          null !== X && (Xj ? (a2 = X, c2 = c2.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X.removeChild(c2.stateNode));
          break;
        case 18:
          null !== X && (Xj ? (a2 = X, c2 = c2.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c2) : 1 === a2.nodeType && Kf(a2, c2), bd(a2)) : Kf(X, c2.stateNode));
          break;
        case 4:
          d = X;
          e2 = Xj;
          X = c2.stateNode.containerInfo;
          Xj = true;
          Yj(a2, b, c2);
          X = d;
          Xj = e2;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          if (!U && (d = c2.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
            e2 = d = d.next;
            do {
              var f2 = e2, g2 = f2.destroy;
              f2 = f2.tag;
              void 0 !== g2 && (0 !== (f2 & 2) ? Mj(c2, b, g2) : 0 !== (f2 & 4) && Mj(c2, b, g2));
              e2 = e2.next;
            } while (e2 !== d);
          }
          Yj(a2, b, c2);
          break;
        case 1:
          if (!U && (Lj(c2, b), d = c2.stateNode, "function" === typeof d.componentWillUnmount))
            try {
              d.props = c2.memoizedProps, d.state = c2.memoizedState, d.componentWillUnmount();
            } catch (h2) {
              W(c2, b, h2);
            }
          Yj(a2, b, c2);
          break;
        case 21:
          Yj(a2, b, c2);
          break;
        case 22:
          c2.mode & 1 ? (U = (d = U) || null !== c2.memoizedState, Yj(a2, b, c2), U = d) : Yj(a2, b, c2);
          break;
        default:
          Yj(a2, b, c2);
      }
    }
    function ak(a2) {
      var b = a2.updateQueue;
      if (null !== b) {
        a2.updateQueue = null;
        var c2 = a2.stateNode;
        null === c2 && (c2 = a2.stateNode = new Kj());
        b.forEach(function(b2) {
          var d = bk.bind(null, a2, b2);
          c2.has(b2) || (c2.add(b2), b2.then(d, d));
        });
      }
    }
    function ck(a2, b) {
      var c2 = b.deletions;
      if (null !== c2)
        for (var d = 0; d < c2.length; d++) {
          var e2 = c2[d];
          try {
            var f2 = a2, g2 = b, h2 = g2;
            a:
              for (; null !== h2; ) {
                switch (h2.tag) {
                  case 5:
                    X = h2.stateNode;
                    Xj = false;
                    break a;
                  case 3:
                    X = h2.stateNode.containerInfo;
                    Xj = true;
                    break a;
                  case 4:
                    X = h2.stateNode.containerInfo;
                    Xj = true;
                    break a;
                }
                h2 = h2.return;
              }
            if (null === X)
              throw Error(p$1(160));
            Zj(f2, g2, e2);
            X = null;
            Xj = false;
            var k2 = e2.alternate;
            null !== k2 && (k2.return = null);
            e2.return = null;
          } catch (l2) {
            W(e2, b, l2);
          }
        }
      if (b.subtreeFlags & 12854)
        for (b = b.child; null !== b; )
          dk(b, a2), b = b.sibling;
    }
    function dk(a2, b) {
      var c2 = a2.alternate, d = a2.flags;
      switch (a2.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          ck(b, a2);
          ek(a2);
          if (d & 4) {
            try {
              Pj(3, a2, a2.return), Qj(3, a2);
            } catch (t2) {
              W(a2, a2.return, t2);
            }
            try {
              Pj(5, a2, a2.return);
            } catch (t2) {
              W(a2, a2.return, t2);
            }
          }
          break;
        case 1:
          ck(b, a2);
          ek(a2);
          d & 512 && null !== c2 && Lj(c2, c2.return);
          break;
        case 5:
          ck(b, a2);
          ek(a2);
          d & 512 && null !== c2 && Lj(c2, c2.return);
          if (a2.flags & 32) {
            var e2 = a2.stateNode;
            try {
              ob(e2, "");
            } catch (t2) {
              W(a2, a2.return, t2);
            }
          }
          if (d & 4 && (e2 = a2.stateNode, null != e2)) {
            var f2 = a2.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a2.type, k2 = a2.updateQueue;
            a2.updateQueue = null;
            if (null !== k2)
              try {
                "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
                vb(h2, g2);
                var l2 = vb(h2, f2);
                for (g2 = 0; g2 < k2.length; g2 += 2) {
                  var m2 = k2[g2], q2 = k2[g2 + 1];
                  "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
                }
                switch (h2) {
                  case "input":
                    bb(e2, f2);
                    break;
                  case "textarea":
                    ib(e2, f2);
                    break;
                  case "select":
                    var r2 = e2._wrapperState.wasMultiple;
                    e2._wrapperState.wasMultiple = !!f2.multiple;
                    var y2 = f2.value;
                    null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                      e2,
                      !!f2.multiple,
                      f2.defaultValue,
                      true
                    ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
                }
                e2[Pf] = f2;
              } catch (t2) {
                W(a2, a2.return, t2);
              }
          }
          break;
        case 6:
          ck(b, a2);
          ek(a2);
          if (d & 4) {
            if (null === a2.stateNode)
              throw Error(p$1(162));
            e2 = a2.stateNode;
            f2 = a2.memoizedProps;
            try {
              e2.nodeValue = f2;
            } catch (t2) {
              W(a2, a2.return, t2);
            }
          }
          break;
        case 3:
          ck(b, a2);
          ek(a2);
          if (d & 4 && null !== c2 && c2.memoizedState.isDehydrated)
            try {
              bd(b.containerInfo);
            } catch (t2) {
              W(a2, a2.return, t2);
            }
          break;
        case 4:
          ck(b, a2);
          ek(a2);
          break;
        case 13:
          ck(b, a2);
          ek(a2);
          e2 = a2.child;
          e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (fk = B()));
          d & 4 && ak(a2);
          break;
        case 22:
          m2 = null !== c2 && null !== c2.memoizedState;
          a2.mode & 1 ? (U = (l2 = U) || m2, ck(b, a2), U = l2) : ck(b, a2);
          ek(a2);
          if (d & 8192) {
            l2 = null !== a2.memoizedState;
            if ((a2.stateNode.isHidden = l2) && !m2 && 0 !== (a2.mode & 1))
              for (V = a2, m2 = a2.child; null !== m2; ) {
                for (q2 = V = m2; null !== V; ) {
                  r2 = V;
                  y2 = r2.child;
                  switch (r2.tag) {
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                      Pj(4, r2, r2.return);
                      break;
                    case 1:
                      Lj(r2, r2.return);
                      var n2 = r2.stateNode;
                      if ("function" === typeof n2.componentWillUnmount) {
                        d = r2;
                        c2 = r2.return;
                        try {
                          b = d, n2.props = b.memoizedProps, n2.state = b.memoizedState, n2.componentWillUnmount();
                        } catch (t2) {
                          W(d, c2, t2);
                        }
                      }
                      break;
                    case 5:
                      Lj(r2, r2.return);
                      break;
                    case 22:
                      if (null !== r2.memoizedState) {
                        gk(q2);
                        continue;
                      }
                  }
                  null !== y2 ? (y2.return = r2, V = y2) : gk(q2);
                }
                m2 = m2.sibling;
              }
            a:
              for (m2 = null, q2 = a2; ; ) {
                if (5 === q2.tag) {
                  if (null === m2) {
                    m2 = q2;
                    try {
                      e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                    } catch (t2) {
                      W(a2, a2.return, t2);
                    }
                  }
                } else if (6 === q2.tag) {
                  if (null === m2)
                    try {
                      q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                    } catch (t2) {
                      W(a2, a2.return, t2);
                    }
                } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a2) && null !== q2.child) {
                  q2.child.return = q2;
                  q2 = q2.child;
                  continue;
                }
                if (q2 === a2)
                  break a;
                for (; null === q2.sibling; ) {
                  if (null === q2.return || q2.return === a2)
                    break a;
                  m2 === q2 && (m2 = null);
                  q2 = q2.return;
                }
                m2 === q2 && (m2 = null);
                q2.sibling.return = q2.return;
                q2 = q2.sibling;
              }
          }
          break;
        case 19:
          ck(b, a2);
          ek(a2);
          d & 4 && ak(a2);
          break;
        case 21:
          break;
        default:
          ck(
            b,
            a2
          ), ek(a2);
      }
    }
    function ek(a2) {
      var b = a2.flags;
      if (b & 2) {
        try {
          a: {
            for (var c2 = a2.return; null !== c2; ) {
              if (Tj(c2)) {
                var d = c2;
                break a;
              }
              c2 = c2.return;
            }
            throw Error(p$1(160));
          }
          switch (d.tag) {
            case 5:
              var e2 = d.stateNode;
              d.flags & 32 && (ob(e2, ""), d.flags &= -33);
              var f2 = Uj(a2);
              Wj(a2, f2, e2);
              break;
            case 3:
            case 4:
              var g2 = d.stateNode.containerInfo, h2 = Uj(a2);
              Vj(a2, h2, g2);
              break;
            default:
              throw Error(p$1(161));
          }
        } catch (k2) {
          W(a2, a2.return, k2);
        }
        a2.flags &= -3;
      }
      b & 4096 && (a2.flags &= -4097);
    }
    function hk(a2, b, c2) {
      V = a2;
      ik(a2);
    }
    function ik(a2, b, c2) {
      for (var d = 0 !== (a2.mode & 1); null !== V; ) {
        var e2 = V, f2 = e2.child;
        if (22 === e2.tag && d) {
          var g2 = null !== e2.memoizedState || Jj;
          if (!g2) {
            var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U;
            h2 = Jj;
            var l2 = U;
            Jj = g2;
            if ((U = k2) && !l2)
              for (V = e2; null !== V; )
                g2 = V, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? jk(e2) : null !== k2 ? (k2.return = g2, V = k2) : jk(e2);
            for (; null !== f2; )
              V = f2, ik(f2), f2 = f2.sibling;
            V = e2;
            Jj = h2;
            U = l2;
          }
          kk(a2);
        } else
          0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V = f2) : kk(a2);
      }
    }
    function kk(a2) {
      for (; null !== V; ) {
        var b = V;
        if (0 !== (b.flags & 8772)) {
          var c2 = b.alternate;
          try {
            if (0 !== (b.flags & 8772))
              switch (b.tag) {
                case 0:
                case 11:
                case 15:
                  U || Qj(5, b);
                  break;
                case 1:
                  var d = b.stateNode;
                  if (b.flags & 4 && !U)
                    if (null === c2)
                      d.componentDidMount();
                    else {
                      var e2 = b.elementType === b.type ? c2.memoizedProps : Ci(b.type, c2.memoizedProps);
                      d.componentDidUpdate(e2, c2.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
                    }
                  var f2 = b.updateQueue;
                  null !== f2 && sh(b, f2, d);
                  break;
                case 3:
                  var g2 = b.updateQueue;
                  if (null !== g2) {
                    c2 = null;
                    if (null !== b.child)
                      switch (b.child.tag) {
                        case 5:
                          c2 = b.child.stateNode;
                          break;
                        case 1:
                          c2 = b.child.stateNode;
                      }
                    sh(b, g2, c2);
                  }
                  break;
                case 5:
                  var h2 = b.stateNode;
                  if (null === c2 && b.flags & 4) {
                    c2 = h2;
                    var k2 = b.memoizedProps;
                    switch (b.type) {
                      case "button":
                      case "input":
                      case "select":
                      case "textarea":
                        k2.autoFocus && c2.focus();
                        break;
                      case "img":
                        k2.src && (c2.src = k2.src);
                    }
                  }
                  break;
                case 6:
                  break;
                case 4:
                  break;
                case 12:
                  break;
                case 13:
                  if (null === b.memoizedState) {
                    var l2 = b.alternate;
                    if (null !== l2) {
                      var m2 = l2.memoizedState;
                      if (null !== m2) {
                        var q2 = m2.dehydrated;
                        null !== q2 && bd(q2);
                      }
                    }
                  }
                  break;
                case 19:
                case 17:
                case 21:
                case 22:
                case 23:
                case 25:
                  break;
                default:
                  throw Error(p$1(163));
              }
            U || b.flags & 512 && Rj(b);
          } catch (r2) {
            W(b, b.return, r2);
          }
        }
        if (b === a2) {
          V = null;
          break;
        }
        c2 = b.sibling;
        if (null !== c2) {
          c2.return = b.return;
          V = c2;
          break;
        }
        V = b.return;
      }
    }
    function gk(a2) {
      for (; null !== V; ) {
        var b = V;
        if (b === a2) {
          V = null;
          break;
        }
        var c2 = b.sibling;
        if (null !== c2) {
          c2.return = b.return;
          V = c2;
          break;
        }
        V = b.return;
      }
    }
    function jk(a2) {
      for (; null !== V; ) {
        var b = V;
        try {
          switch (b.tag) {
            case 0:
            case 11:
            case 15:
              var c2 = b.return;
              try {
                Qj(4, b);
              } catch (k2) {
                W(b, c2, k2);
              }
              break;
            case 1:
              var d = b.stateNode;
              if ("function" === typeof d.componentDidMount) {
                var e2 = b.return;
                try {
                  d.componentDidMount();
                } catch (k2) {
                  W(b, e2, k2);
                }
              }
              var f2 = b.return;
              try {
                Rj(b);
              } catch (k2) {
                W(b, f2, k2);
              }
              break;
            case 5:
              var g2 = b.return;
              try {
                Rj(b);
              } catch (k2) {
                W(b, g2, k2);
              }
          }
        } catch (k2) {
          W(b, b.return, k2);
        }
        if (b === a2) {
          V = null;
          break;
        }
        var h2 = b.sibling;
        if (null !== h2) {
          h2.return = b.return;
          V = h2;
          break;
        }
        V = b.return;
      }
    }
    var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok = ua.ReactCurrentBatchConfig, K = 0, Q = null, Y = null, Z = 0, fj = 0, ej = Uf(0), T = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
    function R() {
      return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
    }
    function yi(a2) {
      if (0 === (a2.mode & 1))
        return 1;
      if (0 !== (K & 2) && 0 !== Z)
        return Z & -Z;
      if (null !== Kg.transition)
        return 0 === Bk && (Bk = yc()), Bk;
      a2 = C;
      if (0 !== a2)
        return a2;
      a2 = window.event;
      a2 = void 0 === a2 ? 16 : jd(a2.type);
      return a2;
    }
    function gi(a2, b, c2, d) {
      if (50 < yk)
        throw yk = 0, zk = null, Error(p$1(185));
      Ac(a2, c2, d);
      if (0 === (K & 2) || a2 !== Q)
        a2 === Q && (0 === (K & 2) && (qk |= c2), 4 === T && Ck(a2, Z)), Dk(a2, d), 1 === c2 && 0 === K && 0 === (b.mode & 1) && (Gj = B() + 500, fg && jg());
    }
    function Dk(a2, b) {
      var c2 = a2.callbackNode;
      wc(a2, b);
      var d = uc(a2, a2 === Q ? Z : 0);
      if (0 === d)
        null !== c2 && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
      else if (b = d & -d, a2.callbackPriority !== b) {
        null != c2 && bc(c2);
        if (1 === b)
          0 === a2.tag ? ig(Ek.bind(null, a2)) : hg(Ek.bind(null, a2)), Jf(function() {
            0 === (K & 6) && jg();
          }), c2 = null;
        else {
          switch (Dc(d)) {
            case 1:
              c2 = fc;
              break;
            case 4:
              c2 = gc;
              break;
            case 16:
              c2 = hc;
              break;
            case 536870912:
              c2 = jc;
              break;
            default:
              c2 = hc;
          }
          c2 = Fk(c2, Gk.bind(null, a2));
        }
        a2.callbackPriority = b;
        a2.callbackNode = c2;
      }
    }
    function Gk(a2, b) {
      Ak = -1;
      Bk = 0;
      if (0 !== (K & 6))
        throw Error(p$1(327));
      var c2 = a2.callbackNode;
      if (Hk() && a2.callbackNode !== c2)
        return null;
      var d = uc(a2, a2 === Q ? Z : 0);
      if (0 === d)
        return null;
      if (0 !== (d & 30) || 0 !== (d & a2.expiredLanes) || b)
        b = Ik(a2, d);
      else {
        b = d;
        var e2 = K;
        K |= 2;
        var f2 = Jk();
        if (Q !== a2 || Z !== b)
          uk = null, Gj = B() + 500, Kk(a2, b);
        do
          try {
            Lk();
            break;
          } catch (h2) {
            Mk(a2, h2);
          }
        while (1);
        $g();
        mk.current = f2;
        K = e2;
        null !== Y ? b = 0 : (Q = null, Z = 0, b = T);
      }
      if (0 !== b) {
        2 === b && (e2 = xc(a2), 0 !== e2 && (d = e2, b = Nk(a2, e2)));
        if (1 === b)
          throw c2 = pk, Kk(a2, 0), Ck(a2, d), Dk(a2, B()), c2;
        if (6 === b)
          Ck(a2, d);
        else {
          e2 = a2.current.alternate;
          if (0 === (d & 30) && !Ok(e2) && (b = Ik(a2, d), 2 === b && (f2 = xc(a2), 0 !== f2 && (d = f2, b = Nk(a2, f2))), 1 === b))
            throw c2 = pk, Kk(a2, 0), Ck(a2, d), Dk(a2, B()), c2;
          a2.finishedWork = e2;
          a2.finishedLanes = d;
          switch (b) {
            case 0:
            case 1:
              throw Error(p$1(345));
            case 2:
              Pk(a2, tk, uk);
              break;
            case 3:
              Ck(a2, d);
              if ((d & 130023424) === d && (b = fk + 500 - B(), 10 < b)) {
                if (0 !== uc(a2, 0))
                  break;
                e2 = a2.suspendedLanes;
                if ((e2 & d) !== d) {
                  R();
                  a2.pingedLanes |= a2.suspendedLanes & e2;
                  break;
                }
                a2.timeoutHandle = Ff(Pk.bind(null, a2, tk, uk), b);
                break;
              }
              Pk(a2, tk, uk);
              break;
            case 4:
              Ck(a2, d);
              if ((d & 4194240) === d)
                break;
              b = a2.eventTimes;
              for (e2 = -1; 0 < d; ) {
                var g2 = 31 - oc(d);
                f2 = 1 << g2;
                g2 = b[g2];
                g2 > e2 && (e2 = g2);
                d &= ~f2;
              }
              d = e2;
              d = B() - d;
              d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * lk(d / 1960)) - d;
              if (10 < d) {
                a2.timeoutHandle = Ff(Pk.bind(null, a2, tk, uk), d);
                break;
              }
              Pk(a2, tk, uk);
              break;
            case 5:
              Pk(a2, tk, uk);
              break;
            default:
              throw Error(p$1(329));
          }
        }
      }
      Dk(a2, B());
      return a2.callbackNode === c2 ? Gk.bind(null, a2) : null;
    }
    function Nk(a2, b) {
      var c2 = sk;
      a2.current.memoizedState.isDehydrated && (Kk(a2, b).flags |= 256);
      a2 = Ik(a2, b);
      2 !== a2 && (b = tk, tk = c2, null !== b && Fj(b));
      return a2;
    }
    function Fj(a2) {
      null === tk ? tk = a2 : tk.push.apply(tk, a2);
    }
    function Ok(a2) {
      for (var b = a2; ; ) {
        if (b.flags & 16384) {
          var c2 = b.updateQueue;
          if (null !== c2 && (c2 = c2.stores, null !== c2))
            for (var d = 0; d < c2.length; d++) {
              var e2 = c2[d], f2 = e2.getSnapshot;
              e2 = e2.value;
              try {
                if (!He(f2(), e2))
                  return false;
              } catch (g2) {
                return false;
              }
            }
        }
        c2 = b.child;
        if (b.subtreeFlags & 16384 && null !== c2)
          c2.return = b, b = c2;
        else {
          if (b === a2)
            break;
          for (; null === b.sibling; ) {
            if (null === b.return || b.return === a2)
              return true;
            b = b.return;
          }
          b.sibling.return = b.return;
          b = b.sibling;
        }
      }
      return true;
    }
    function Ck(a2, b) {
      b &= ~rk;
      b &= ~qk;
      a2.suspendedLanes |= b;
      a2.pingedLanes &= ~b;
      for (a2 = a2.expirationTimes; 0 < b; ) {
        var c2 = 31 - oc(b), d = 1 << c2;
        a2[c2] = -1;
        b &= ~d;
      }
    }
    function Ek(a2) {
      if (0 !== (K & 6))
        throw Error(p$1(327));
      Hk();
      var b = uc(a2, 0);
      if (0 === (b & 1))
        return Dk(a2, B()), null;
      var c2 = Ik(a2, b);
      if (0 !== a2.tag && 2 === c2) {
        var d = xc(a2);
        0 !== d && (b = d, c2 = Nk(a2, d));
      }
      if (1 === c2)
        throw c2 = pk, Kk(a2, 0), Ck(a2, b), Dk(a2, B()), c2;
      if (6 === c2)
        throw Error(p$1(345));
      a2.finishedWork = a2.current.alternate;
      a2.finishedLanes = b;
      Pk(a2, tk, uk);
      Dk(a2, B());
      return null;
    }
    function Qk(a2, b) {
      var c2 = K;
      K |= 1;
      try {
        return a2(b);
      } finally {
        K = c2, 0 === K && (Gj = B() + 500, fg && jg());
      }
    }
    function Rk(a2) {
      null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
      var b = K;
      K |= 1;
      var c2 = ok.transition, d = C;
      try {
        if (ok.transition = null, C = 1, a2)
          return a2();
      } finally {
        C = d, ok.transition = c2, K = b, 0 === (K & 6) && jg();
      }
    }
    function Hj() {
      fj = ej.current;
      E(ej);
    }
    function Kk(a2, b) {
      a2.finishedWork = null;
      a2.finishedLanes = 0;
      var c2 = a2.timeoutHandle;
      -1 !== c2 && (a2.timeoutHandle = -1, Gf(c2));
      if (null !== Y)
        for (c2 = Y.return; null !== c2; ) {
          var d = c2;
          wg(d);
          switch (d.tag) {
            case 1:
              d = d.type.childContextTypes;
              null !== d && void 0 !== d && $f();
              break;
            case 3:
              zh();
              E(Wf);
              E(H);
              Eh();
              break;
            case 5:
              Bh(d);
              break;
            case 4:
              zh();
              break;
            case 13:
              E(L);
              break;
            case 19:
              E(L);
              break;
            case 10:
              ah(d.type._context);
              break;
            case 22:
            case 23:
              Hj();
          }
          c2 = c2.return;
        }
      Q = a2;
      Y = a2 = Pg(a2.current, null);
      Z = fj = b;
      T = 0;
      pk = null;
      rk = qk = rh = 0;
      tk = sk = null;
      if (null !== fh) {
        for (b = 0; b < fh.length; b++)
          if (c2 = fh[b], d = c2.interleaved, null !== d) {
            c2.interleaved = null;
            var e2 = d.next, f2 = c2.pending;
            if (null !== f2) {
              var g2 = f2.next;
              f2.next = e2;
              d.next = g2;
            }
            c2.pending = d;
          }
        fh = null;
      }
      return a2;
    }
    function Mk(a2, b) {
      do {
        var c2 = Y;
        try {
          $g();
          Fh.current = Rh;
          if (Ih) {
            for (var d = M.memoizedState; null !== d; ) {
              var e2 = d.queue;
              null !== e2 && (e2.pending = null);
              d = d.next;
            }
            Ih = false;
          }
          Hh = 0;
          O = N = M = null;
          Jh = false;
          Kh = 0;
          nk.current = null;
          if (null === c2 || null === c2.return) {
            T = 1;
            pk = b;
            Y = null;
            break;
          }
          a: {
            var f2 = a2, g2 = c2.return, h2 = c2, k2 = b;
            b = Z;
            h2.flags |= 32768;
            if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
              var l2 = k2, m2 = h2, q2 = m2.tag;
              if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
                var r2 = m2.alternate;
                r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
              }
              var y2 = Ui(g2);
              if (null !== y2) {
                y2.flags &= -257;
                Vi(y2, g2, h2, f2, b);
                y2.mode & 1 && Si(f2, l2, b);
                b = y2;
                k2 = l2;
                var n2 = b.updateQueue;
                if (null === n2) {
                  var t2 = /* @__PURE__ */ new Set();
                  t2.add(k2);
                  b.updateQueue = t2;
                } else
                  n2.add(k2);
                break a;
              } else {
                if (0 === (b & 1)) {
                  Si(f2, l2, b);
                  tj();
                  break a;
                }
                k2 = Error(p$1(426));
              }
            } else if (I && h2.mode & 1) {
              var J2 = Ui(g2);
              if (null !== J2) {
                0 === (J2.flags & 65536) && (J2.flags |= 256);
                Vi(J2, g2, h2, f2, b);
                Jg(Ji(k2, h2));
                break a;
              }
            }
            f2 = k2 = Ji(k2, h2);
            4 !== T && (T = 2);
            null === sk ? sk = [f2] : sk.push(f2);
            f2 = g2;
            do {
              switch (f2.tag) {
                case 3:
                  f2.flags |= 65536;
                  b &= -b;
                  f2.lanes |= b;
                  var x2 = Ni(f2, k2, b);
                  ph(f2, x2);
                  break a;
                case 1:
                  h2 = k2;
                  var w2 = f2.type, u2 = f2.stateNode;
                  if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Ri || !Ri.has(u2)))) {
                    f2.flags |= 65536;
                    b &= -b;
                    f2.lanes |= b;
                    var F2 = Qi(f2, h2, b);
                    ph(f2, F2);
                    break a;
                  }
              }
              f2 = f2.return;
            } while (null !== f2);
          }
          Sk(c2);
        } catch (na) {
          b = na;
          Y === c2 && null !== c2 && (Y = c2 = c2.return);
          continue;
        }
        break;
      } while (1);
    }
    function Jk() {
      var a2 = mk.current;
      mk.current = Rh;
      return null === a2 ? Rh : a2;
    }
    function tj() {
      if (0 === T || 3 === T || 2 === T)
        T = 4;
      null === Q || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
    }
    function Ik(a2, b) {
      var c2 = K;
      K |= 2;
      var d = Jk();
      if (Q !== a2 || Z !== b)
        uk = null, Kk(a2, b);
      do
        try {
          Tk();
          break;
        } catch (e2) {
          Mk(a2, e2);
        }
      while (1);
      $g();
      K = c2;
      mk.current = d;
      if (null !== Y)
        throw Error(p$1(261));
      Q = null;
      Z = 0;
      return T;
    }
    function Tk() {
      for (; null !== Y; )
        Uk(Y);
    }
    function Lk() {
      for (; null !== Y && !cc(); )
        Uk(Y);
    }
    function Uk(a2) {
      var b = Vk(a2.alternate, a2, fj);
      a2.memoizedProps = a2.pendingProps;
      null === b ? Sk(a2) : Y = b;
      nk.current = null;
    }
    function Sk(a2) {
      var b = a2;
      do {
        var c2 = b.alternate;
        a2 = b.return;
        if (0 === (b.flags & 32768)) {
          if (c2 = Ej(c2, b, fj), null !== c2) {
            Y = c2;
            return;
          }
        } else {
          c2 = Ij(c2, b);
          if (null !== c2) {
            c2.flags &= 32767;
            Y = c2;
            return;
          }
          if (null !== a2)
            a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
          else {
            T = 6;
            Y = null;
            return;
          }
        }
        b = b.sibling;
        if (null !== b) {
          Y = b;
          return;
        }
        Y = b = a2;
      } while (null !== b);
      0 === T && (T = 5);
    }
    function Pk(a2, b, c2) {
      var d = C, e2 = ok.transition;
      try {
        ok.transition = null, C = 1, Wk(a2, b, c2, d);
      } finally {
        ok.transition = e2, C = d;
      }
      return null;
    }
    function Wk(a2, b, c2, d) {
      do
        Hk();
      while (null !== wk);
      if (0 !== (K & 6))
        throw Error(p$1(327));
      c2 = a2.finishedWork;
      var e2 = a2.finishedLanes;
      if (null === c2)
        return null;
      a2.finishedWork = null;
      a2.finishedLanes = 0;
      if (c2 === a2.current)
        throw Error(p$1(177));
      a2.callbackNode = null;
      a2.callbackPriority = 0;
      var f2 = c2.lanes | c2.childLanes;
      Bc(a2, f2);
      a2 === Q && (Y = Q = null, Z = 0);
      0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || vk || (vk = true, Fk(hc, function() {
        Hk();
        return null;
      }));
      f2 = 0 !== (c2.flags & 15990);
      if (0 !== (c2.subtreeFlags & 15990) || f2) {
        f2 = ok.transition;
        ok.transition = null;
        var g2 = C;
        C = 1;
        var h2 = K;
        K |= 4;
        nk.current = null;
        Oj(a2, c2);
        dk(c2, a2);
        Oe(Df);
        dd = !!Cf;
        Df = Cf = null;
        a2.current = c2;
        hk(c2);
        dc();
        K = h2;
        C = g2;
        ok.transition = f2;
      } else
        a2.current = c2;
      vk && (vk = false, wk = a2, xk = e2);
      f2 = a2.pendingLanes;
      0 === f2 && (Ri = null);
      mc(c2.stateNode);
      Dk(a2, B());
      if (null !== b)
        for (d = a2.onRecoverableError, c2 = 0; c2 < b.length; c2++)
          e2 = b[c2], d(e2.value, { componentStack: e2.stack, digest: e2.digest });
      if (Oi)
        throw Oi = false, a2 = Pi, Pi = null, a2;
      0 !== (xk & 1) && 0 !== a2.tag && Hk();
      f2 = a2.pendingLanes;
      0 !== (f2 & 1) ? a2 === zk ? yk++ : (yk = 0, zk = a2) : yk = 0;
      jg();
      return null;
    }
    function Hk() {
      if (null !== wk) {
        var a2 = Dc(xk), b = ok.transition, c2 = C;
        try {
          ok.transition = null;
          C = 16 > a2 ? 16 : a2;
          if (null === wk)
            var d = false;
          else {
            a2 = wk;
            wk = null;
            xk = 0;
            if (0 !== (K & 6))
              throw Error(p$1(331));
            var e2 = K;
            K |= 4;
            for (V = a2.current; null !== V; ) {
              var f2 = V, g2 = f2.child;
              if (0 !== (V.flags & 16)) {
                var h2 = f2.deletions;
                if (null !== h2) {
                  for (var k2 = 0; k2 < h2.length; k2++) {
                    var l2 = h2[k2];
                    for (V = l2; null !== V; ) {
                      var m2 = V;
                      switch (m2.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Pj(8, m2, f2);
                      }
                      var q2 = m2.child;
                      if (null !== q2)
                        q2.return = m2, V = q2;
                      else
                        for (; null !== V; ) {
                          m2 = V;
                          var r2 = m2.sibling, y2 = m2.return;
                          Sj(m2);
                          if (m2 === l2) {
                            V = null;
                            break;
                          }
                          if (null !== r2) {
                            r2.return = y2;
                            V = r2;
                            break;
                          }
                          V = y2;
                        }
                    }
                  }
                  var n2 = f2.alternate;
                  if (null !== n2) {
                    var t2 = n2.child;
                    if (null !== t2) {
                      n2.child = null;
                      do {
                        var J2 = t2.sibling;
                        t2.sibling = null;
                        t2 = J2;
                      } while (null !== t2);
                    }
                  }
                  V = f2;
                }
              }
              if (0 !== (f2.subtreeFlags & 2064) && null !== g2)
                g2.return = f2, V = g2;
              else
                b:
                  for (; null !== V; ) {
                    f2 = V;
                    if (0 !== (f2.flags & 2048))
                      switch (f2.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Pj(9, f2, f2.return);
                      }
                    var x2 = f2.sibling;
                    if (null !== x2) {
                      x2.return = f2.return;
                      V = x2;
                      break b;
                    }
                    V = f2.return;
                  }
            }
            var w2 = a2.current;
            for (V = w2; null !== V; ) {
              g2 = V;
              var u2 = g2.child;
              if (0 !== (g2.subtreeFlags & 2064) && null !== u2)
                u2.return = g2, V = u2;
              else
                b:
                  for (g2 = w2; null !== V; ) {
                    h2 = V;
                    if (0 !== (h2.flags & 2048))
                      try {
                        switch (h2.tag) {
                          case 0:
                          case 11:
                          case 15:
                            Qj(9, h2);
                        }
                      } catch (na) {
                        W(h2, h2.return, na);
                      }
                    if (h2 === g2) {
                      V = null;
                      break b;
                    }
                    var F2 = h2.sibling;
                    if (null !== F2) {
                      F2.return = h2.return;
                      V = F2;
                      break b;
                    }
                    V = h2.return;
                  }
            }
            K = e2;
            jg();
            if (lc && "function" === typeof lc.onPostCommitFiberRoot)
              try {
                lc.onPostCommitFiberRoot(kc, a2);
              } catch (na) {
              }
            d = true;
          }
          return d;
        } finally {
          C = c2, ok.transition = b;
        }
      }
      return false;
    }
    function Xk(a2, b, c2) {
      b = Ji(c2, b);
      b = Ni(a2, b, 1);
      a2 = nh(a2, b, 1);
      b = R();
      null !== a2 && (Ac(a2, 1, b), Dk(a2, b));
    }
    function W(a2, b, c2) {
      if (3 === a2.tag)
        Xk(a2, a2, c2);
      else
        for (; null !== b; ) {
          if (3 === b.tag) {
            Xk(b, a2, c2);
            break;
          } else if (1 === b.tag) {
            var d = b.stateNode;
            if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ri || !Ri.has(d))) {
              a2 = Ji(c2, a2);
              a2 = Qi(b, a2, 1);
              b = nh(b, a2, 1);
              a2 = R();
              null !== b && (Ac(b, 1, a2), Dk(b, a2));
              break;
            }
          }
          b = b.return;
        }
    }
    function Ti(a2, b, c2) {
      var d = a2.pingCache;
      null !== d && d.delete(b);
      b = R();
      a2.pingedLanes |= a2.suspendedLanes & c2;
      Q === a2 && (Z & c2) === c2 && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a2, 0) : rk |= c2);
      Dk(a2, b);
    }
    function Yk(a2, b) {
      0 === b && (0 === (a2.mode & 1) ? b = 1 : (b = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
      var c2 = R();
      a2 = ih(a2, b);
      null !== a2 && (Ac(a2, b, c2), Dk(a2, c2));
    }
    function uj(a2) {
      var b = a2.memoizedState, c2 = 0;
      null !== b && (c2 = b.retryLane);
      Yk(a2, c2);
    }
    function bk(a2, b) {
      var c2 = 0;
      switch (a2.tag) {
        case 13:
          var d = a2.stateNode;
          var e2 = a2.memoizedState;
          null !== e2 && (c2 = e2.retryLane);
          break;
        case 19:
          d = a2.stateNode;
          break;
        default:
          throw Error(p$1(314));
      }
      null !== d && d.delete(b);
      Yk(a2, c2);
    }
    var Vk;
    Vk = function(a2, b, c2) {
      if (null !== a2)
        if (a2.memoizedProps !== b.pendingProps || Wf.current)
          dh = true;
        else {
          if (0 === (a2.lanes & c2) && 0 === (b.flags & 128))
            return dh = false, yj(a2, b, c2);
          dh = 0 !== (a2.flags & 131072) ? true : false;
        }
      else
        dh = false, I && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
      b.lanes = 0;
      switch (b.tag) {
        case 2:
          var d = b.type;
          ij(a2, b);
          a2 = b.pendingProps;
          var e2 = Yf(b, H.current);
          ch(b, c2);
          e2 = Nh(null, b, d, a2, e2, c2);
          var f2 = Sh();
          b.flags |= 1;
          "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f2 = true, cg(b)) : f2 = false, b.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, kh(b), e2.updater = Ei, b.stateNode = e2, e2._reactInternals = b, Ii(b, d, a2, c2), b = jj(null, b, d, true, f2, c2)) : (b.tag = 0, I && f2 && vg(b), Xi(null, b, e2, c2), b = b.child);
          return b;
        case 16:
          d = b.elementType;
          a: {
            ij(a2, b);
            a2 = b.pendingProps;
            e2 = d._init;
            d = e2(d._payload);
            b.type = d;
            e2 = b.tag = Zk(d);
            a2 = Ci(d, a2);
            switch (e2) {
              case 0:
                b = cj(null, b, d, a2, c2);
                break a;
              case 1:
                b = hj(null, b, d, a2, c2);
                break a;
              case 11:
                b = Yi(null, b, d, a2, c2);
                break a;
              case 14:
                b = $i(null, b, d, Ci(d.type, a2), c2);
                break a;
            }
            throw Error(p$1(
              306,
              d,
              ""
            ));
          }
          return b;
        case 0:
          return d = b.type, e2 = b.pendingProps, e2 = b.elementType === d ? e2 : Ci(d, e2), cj(a2, b, d, e2, c2);
        case 1:
          return d = b.type, e2 = b.pendingProps, e2 = b.elementType === d ? e2 : Ci(d, e2), hj(a2, b, d, e2, c2);
        case 3:
          a: {
            kj(b);
            if (null === a2)
              throw Error(p$1(387));
            d = b.pendingProps;
            f2 = b.memoizedState;
            e2 = f2.element;
            lh(a2, b);
            qh(b, d, null, c2);
            var g2 = b.memoizedState;
            d = g2.element;
            if (f2.isDehydrated)
              if (f2 = { element: d, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b.updateQueue.baseState = f2, b.memoizedState = f2, b.flags & 256) {
                e2 = Ji(Error(p$1(423)), b);
                b = lj(a2, b, d, c2, e2);
                break a;
              } else if (d !== e2) {
                e2 = Ji(Error(p$1(424)), b);
                b = lj(a2, b, d, c2, e2);
                break a;
              } else
                for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = true, zg = null, c2 = Vg(b, null, d, c2), b.child = c2; c2; )
                  c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
            else {
              Ig();
              if (d === e2) {
                b = Zi(a2, b, c2);
                break a;
              }
              Xi(a2, b, d, c2);
            }
            b = b.child;
          }
          return b;
        case 5:
          return Ah(b), null === a2 && Eg(b), d = b.type, e2 = b.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g2 = e2.children, Ef(d, e2) ? g2 = null : null !== f2 && Ef(d, f2) && (b.flags |= 32), gj(a2, b), Xi(a2, b, g2, c2), b.child;
        case 6:
          return null === a2 && Eg(b), null;
        case 13:
          return oj(a2, b, c2);
        case 4:
          return yh(b, b.stateNode.containerInfo), d = b.pendingProps, null === a2 ? b.child = Ug(b, null, d, c2) : Xi(a2, b, d, c2), b.child;
        case 11:
          return d = b.type, e2 = b.pendingProps, e2 = b.elementType === d ? e2 : Ci(d, e2), Yi(a2, b, d, e2, c2);
        case 7:
          return Xi(a2, b, b.pendingProps, c2), b.child;
        case 8:
          return Xi(a2, b, b.pendingProps.children, c2), b.child;
        case 12:
          return Xi(a2, b, b.pendingProps.children, c2), b.child;
        case 10:
          a: {
            d = b.type._context;
            e2 = b.pendingProps;
            f2 = b.memoizedProps;
            g2 = e2.value;
            G(Wg, d._currentValue);
            d._currentValue = g2;
            if (null !== f2)
              if (He(f2.value, g2)) {
                if (f2.children === e2.children && !Wf.current) {
                  b = Zi(a2, b, c2);
                  break a;
                }
              } else
                for (f2 = b.child, null !== f2 && (f2.return = b); null !== f2; ) {
                  var h2 = f2.dependencies;
                  if (null !== h2) {
                    g2 = f2.child;
                    for (var k2 = h2.firstContext; null !== k2; ) {
                      if (k2.context === d) {
                        if (1 === f2.tag) {
                          k2 = mh(-1, c2 & -c2);
                          k2.tag = 2;
                          var l2 = f2.updateQueue;
                          if (null !== l2) {
                            l2 = l2.shared;
                            var m2 = l2.pending;
                            null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                            l2.pending = k2;
                          }
                        }
                        f2.lanes |= c2;
                        k2 = f2.alternate;
                        null !== k2 && (k2.lanes |= c2);
                        bh(
                          f2.return,
                          c2,
                          b
                        );
                        h2.lanes |= c2;
                        break;
                      }
                      k2 = k2.next;
                    }
                  } else if (10 === f2.tag)
                    g2 = f2.type === b.type ? null : f2.child;
                  else if (18 === f2.tag) {
                    g2 = f2.return;
                    if (null === g2)
                      throw Error(p$1(341));
                    g2.lanes |= c2;
                    h2 = g2.alternate;
                    null !== h2 && (h2.lanes |= c2);
                    bh(g2, c2, b);
                    g2 = f2.sibling;
                  } else
                    g2 = f2.child;
                  if (null !== g2)
                    g2.return = f2;
                  else
                    for (g2 = f2; null !== g2; ) {
                      if (g2 === b) {
                        g2 = null;
                        break;
                      }
                      f2 = g2.sibling;
                      if (null !== f2) {
                        f2.return = g2.return;
                        g2 = f2;
                        break;
                      }
                      g2 = g2.return;
                    }
                  f2 = g2;
                }
            Xi(a2, b, e2.children, c2);
            b = b.child;
          }
          return b;
        case 9:
          return e2 = b.type, d = b.pendingProps.children, ch(b, c2), e2 = eh(e2), d = d(e2), b.flags |= 1, Xi(a2, b, d, c2), b.child;
        case 14:
          return d = b.type, e2 = Ci(d, b.pendingProps), e2 = Ci(d.type, e2), $i(a2, b, d, e2, c2);
        case 15:
          return bj(a2, b, b.type, b.pendingProps, c2);
        case 17:
          return d = b.type, e2 = b.pendingProps, e2 = b.elementType === d ? e2 : Ci(d, e2), ij(a2, b), b.tag = 1, Zf(d) ? (a2 = true, cg(b)) : a2 = false, ch(b, c2), Gi(b, d, e2), Ii(b, d, e2, c2), jj(null, b, d, true, a2, c2);
        case 19:
          return xj(a2, b, c2);
        case 22:
          return dj(a2, b, c2);
      }
      throw Error(p$1(156, b.tag));
    };
    function Fk(a2, b) {
      return ac(a2, b);
    }
    function $k(a2, b, c2, d) {
      this.tag = a2;
      this.key = c2;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.ref = null;
      this.pendingProps = b;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = d;
      this.subtreeFlags = this.flags = 0;
      this.deletions = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
    }
    function Bg(a2, b, c2, d) {
      return new $k(a2, b, c2, d);
    }
    function aj(a2) {
      a2 = a2.prototype;
      return !(!a2 || !a2.isReactComponent);
    }
    function Zk(a2) {
      if ("function" === typeof a2)
        return aj(a2) ? 1 : 0;
      if (void 0 !== a2 && null !== a2) {
        a2 = a2.$$typeof;
        if (a2 === Da)
          return 11;
        if (a2 === Ga)
          return 14;
      }
      return 2;
    }
    function Pg(a2, b) {
      var c2 = a2.alternate;
      null === c2 ? (c2 = Bg(a2.tag, b, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
      c2.flags = a2.flags & 14680064;
      c2.childLanes = a2.childLanes;
      c2.lanes = a2.lanes;
      c2.child = a2.child;
      c2.memoizedProps = a2.memoizedProps;
      c2.memoizedState = a2.memoizedState;
      c2.updateQueue = a2.updateQueue;
      b = a2.dependencies;
      c2.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
      c2.sibling = a2.sibling;
      c2.index = a2.index;
      c2.ref = a2.ref;
      return c2;
    }
    function Rg(a2, b, c2, d, e2, f2) {
      var g2 = 2;
      d = a2;
      if ("function" === typeof a2)
        aj(a2) && (g2 = 1);
      else if ("string" === typeof a2)
        g2 = 5;
      else
        a:
          switch (a2) {
            case ya:
              return Tg(c2.children, e2, f2, b);
            case za:
              g2 = 8;
              e2 |= 8;
              break;
            case Aa:
              return a2 = Bg(12, c2, b, e2 | 2), a2.elementType = Aa, a2.lanes = f2, a2;
            case Ea:
              return a2 = Bg(13, c2, b, e2), a2.elementType = Ea, a2.lanes = f2, a2;
            case Fa:
              return a2 = Bg(19, c2, b, e2), a2.elementType = Fa, a2.lanes = f2, a2;
            case Ia:
              return pj(c2, e2, f2, b);
            default:
              if ("object" === typeof a2 && null !== a2)
                switch (a2.$$typeof) {
                  case Ba:
                    g2 = 10;
                    break a;
                  case Ca:
                    g2 = 9;
                    break a;
                  case Da:
                    g2 = 11;
                    break a;
                  case Ga:
                    g2 = 14;
                    break a;
                  case Ha:
                    g2 = 16;
                    d = null;
                    break a;
                }
              throw Error(p$1(130, null == a2 ? a2 : typeof a2, ""));
          }
      b = Bg(g2, c2, b, e2);
      b.elementType = a2;
      b.type = d;
      b.lanes = f2;
      return b;
    }
    function Tg(a2, b, c2, d) {
      a2 = Bg(7, a2, d, b);
      a2.lanes = c2;
      return a2;
    }
    function pj(a2, b, c2, d) {
      a2 = Bg(22, a2, d, b);
      a2.elementType = Ia;
      a2.lanes = c2;
      a2.stateNode = { isHidden: false };
      return a2;
    }
    function Qg(a2, b, c2) {
      a2 = Bg(6, a2, null, b);
      a2.lanes = c2;
      return a2;
    }
    function Sg(a2, b, c2) {
      b = Bg(4, null !== a2.children ? a2.children : [], a2.key, b);
      b.lanes = c2;
      b.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
      return b;
    }
    function al(a2, b, c2, d, e2) {
      this.tag = b;
      this.containerInfo = a2;
      this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = -1;
      this.callbackNode = this.pendingContext = this.context = null;
      this.callbackPriority = 0;
      this.eventTimes = zc(0);
      this.expirationTimes = zc(-1);
      this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
      this.entanglements = zc(0);
      this.identifierPrefix = d;
      this.onRecoverableError = e2;
      this.mutableSourceEagerHydrationData = null;
    }
    function bl(a2, b, c2, d, e2, f2, g2, h2, k2) {
      a2 = new al(a2, b, c2, h2, k2);
      1 === b ? (b = 1, true === f2 && (b |= 8)) : b = 0;
      f2 = Bg(3, null, null, b);
      a2.current = f2;
      f2.stateNode = a2;
      f2.memoizedState = { element: d, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
      kh(f2);
      return a2;
    }
    function cl(a2, b, c2) {
      var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      return { $$typeof: wa, key: null == d ? null : "" + d, children: a2, containerInfo: b, implementation: c2 };
    }
    function dl(a2) {
      if (!a2)
        return Vf;
      a2 = a2._reactInternals;
      a: {
        if (Vb(a2) !== a2 || 1 !== a2.tag)
          throw Error(p$1(170));
        var b = a2;
        do {
          switch (b.tag) {
            case 3:
              b = b.stateNode.context;
              break a;
            case 1:
              if (Zf(b.type)) {
                b = b.stateNode.__reactInternalMemoizedMergedChildContext;
                break a;
              }
          }
          b = b.return;
        } while (null !== b);
        throw Error(p$1(171));
      }
      if (1 === a2.tag) {
        var c2 = a2.type;
        if (Zf(c2))
          return bg(a2, c2, b);
      }
      return b;
    }
    function el(a2, b, c2, d, e2, f2, g2, h2, k2) {
      a2 = bl(c2, d, true, a2, e2, f2, g2, h2, k2);
      a2.context = dl(null);
      c2 = a2.current;
      d = R();
      e2 = yi(c2);
      f2 = mh(d, e2);
      f2.callback = void 0 !== b && null !== b ? b : null;
      nh(c2, f2, e2);
      a2.current.lanes = e2;
      Ac(a2, e2, d);
      Dk(a2, d);
      return a2;
    }
    function fl(a2, b, c2, d) {
      var e2 = b.current, f2 = R(), g2 = yi(e2);
      c2 = dl(c2);
      null === b.context ? b.context = c2 : b.pendingContext = c2;
      b = mh(f2, g2);
      b.payload = { element: a2 };
      d = void 0 === d ? null : d;
      null !== d && (b.callback = d);
      a2 = nh(e2, b, g2);
      null !== a2 && (gi(a2, e2, g2, f2), oh(a2, e2, g2));
      return g2;
    }
    function gl(a2) {
      a2 = a2.current;
      if (!a2.child)
        return null;
      switch (a2.child.tag) {
        case 5:
          return a2.child.stateNode;
        default:
          return a2.child.stateNode;
      }
    }
    function hl(a2, b) {
      a2 = a2.memoizedState;
      if (null !== a2 && null !== a2.dehydrated) {
        var c2 = a2.retryLane;
        a2.retryLane = 0 !== c2 && c2 < b ? c2 : b;
      }
    }
    function il(a2, b) {
      hl(a2, b);
      (a2 = a2.alternate) && hl(a2, b);
    }
    function jl() {
      return null;
    }
    var kl = "function" === typeof reportError ? reportError : function(a2) {
      console.error(a2);
    };
    function ll(a2) {
      this._internalRoot = a2;
    }
    ml.prototype.render = ll.prototype.render = function(a2) {
      var b = this._internalRoot;
      if (null === b)
        throw Error(p$1(409));
      fl(a2, b, null, null);
    };
    ml.prototype.unmount = ll.prototype.unmount = function() {
      var a2 = this._internalRoot;
      if (null !== a2) {
        this._internalRoot = null;
        var b = a2.containerInfo;
        Rk(function() {
          fl(null, a2, null, null);
        });
        b[uf] = null;
      }
    };
    function ml(a2) {
      this._internalRoot = a2;
    }
    ml.prototype.unstable_scheduleHydration = function(a2) {
      if (a2) {
        var b = Hc();
        a2 = { blockedOn: null, target: a2, priority: b };
        for (var c2 = 0; c2 < Qc.length && 0 !== b && b < Qc[c2].priority; c2++)
          ;
        Qc.splice(c2, 0, a2);
        0 === c2 && Vc(a2);
      }
    };
    function nl(a2) {
      return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
    }
    function ol(a2) {
      return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
    }
    function pl$1() {
    }
    function ql(a2, b, c2, d, e2) {
      if (e2) {
        if ("function" === typeof d) {
          var f2 = d;
          d = function() {
            var a3 = gl(g2);
            f2.call(a3);
          };
        }
        var g2 = el(b, d, a2, 0, null, false, false, "", pl$1);
        a2._reactRootContainer = g2;
        a2[uf] = g2.current;
        sf(8 === a2.nodeType ? a2.parentNode : a2);
        Rk();
        return g2;
      }
      for (; e2 = a2.lastChild; )
        a2.removeChild(e2);
      if ("function" === typeof d) {
        var h2 = d;
        d = function() {
          var a3 = gl(k2);
          h2.call(a3);
        };
      }
      var k2 = bl(a2, 0, false, null, null, false, false, "", pl$1);
      a2._reactRootContainer = k2;
      a2[uf] = k2.current;
      sf(8 === a2.nodeType ? a2.parentNode : a2);
      Rk(function() {
        fl(b, k2, c2, d);
      });
      return k2;
    }
    function rl(a2, b, c2, d, e2) {
      var f2 = c2._reactRootContainer;
      if (f2) {
        var g2 = f2;
        if ("function" === typeof e2) {
          var h2 = e2;
          e2 = function() {
            var a3 = gl(g2);
            h2.call(a3);
          };
        }
        fl(b, g2, a2, e2);
      } else
        g2 = ql(c2, b, a2, e2, d);
      return gl(g2);
    }
    Ec = function(a2) {
      switch (a2.tag) {
        case 3:
          var b = a2.stateNode;
          if (b.current.memoizedState.isDehydrated) {
            var c2 = tc(b.pendingLanes);
            0 !== c2 && (Cc(b, c2 | 1), Dk(b, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
          }
          break;
        case 13:
          Rk(function() {
            var b2 = ih(a2, 1);
            if (null !== b2) {
              var c3 = R();
              gi(b2, a2, 1, c3);
            }
          }), il(a2, 1);
      }
    };
    Fc = function(a2) {
      if (13 === a2.tag) {
        var b = ih(a2, 134217728);
        if (null !== b) {
          var c2 = R();
          gi(b, a2, 134217728, c2);
        }
        il(a2, 134217728);
      }
    };
    Gc = function(a2) {
      if (13 === a2.tag) {
        var b = yi(a2), c2 = ih(a2, b);
        if (null !== c2) {
          var d = R();
          gi(c2, a2, b, d);
        }
        il(a2, b);
      }
    };
    Hc = function() {
      return C;
    };
    Ic = function(a2, b) {
      var c2 = C;
      try {
        return C = a2, b();
      } finally {
        C = c2;
      }
    };
    yb = function(a2, b, c2) {
      switch (b) {
        case "input":
          bb(a2, c2);
          b = c2.name;
          if ("radio" === c2.type && null != b) {
            for (c2 = a2; c2.parentNode; )
              c2 = c2.parentNode;
            c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
            for (b = 0; b < c2.length; b++) {
              var d = c2[b];
              if (d !== a2 && d.form === a2.form) {
                var e2 = Db(d);
                if (!e2)
                  throw Error(p$1(90));
                Wa(d);
                bb(d, e2);
              }
            }
          }
          break;
        case "textarea":
          ib(a2, c2);
          break;
        case "select":
          b = c2.value, null != b && fb(a2, !!c2.multiple, b, false);
      }
    };
    Gb = Qk;
    Hb = Rk;
    var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
    var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
      a2 = Zb(a2);
      return null === a2 ? null : a2.stateNode;
    }, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
    if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
      var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!vl.isDisabled && vl.supportsFiber)
        try {
          kc = vl.inject(ul), lc = vl;
        } catch (a2) {
        }
    }
    reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
    reactDom_production_min.createPortal = function(a2, b) {
      var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (!nl(b))
        throw Error(p$1(200));
      return cl(a2, b, null, c2);
    };
    reactDom_production_min.createRoot = function(a2, b) {
      if (!nl(a2))
        throw Error(p$1(299));
      var c2 = false, d = "", e2 = kl;
      null !== b && void 0 !== b && (true === b.unstable_strictMode && (c2 = true), void 0 !== b.identifierPrefix && (d = b.identifierPrefix), void 0 !== b.onRecoverableError && (e2 = b.onRecoverableError));
      b = bl(a2, 1, false, null, null, c2, false, d, e2);
      a2[uf] = b.current;
      sf(8 === a2.nodeType ? a2.parentNode : a2);
      return new ll(b);
    };
    reactDom_production_min.findDOMNode = function(a2) {
      if (null == a2)
        return null;
      if (1 === a2.nodeType)
        return a2;
      var b = a2._reactInternals;
      if (void 0 === b) {
        if ("function" === typeof a2.render)
          throw Error(p$1(188));
        a2 = Object.keys(a2).join(",");
        throw Error(p$1(268, a2));
      }
      a2 = Zb(b);
      a2 = null === a2 ? null : a2.stateNode;
      return a2;
    };
    reactDom_production_min.flushSync = function(a2) {
      return Rk(a2);
    };
    reactDom_production_min.hydrate = function(a2, b, c2) {
      if (!ol(b))
        throw Error(p$1(200));
      return rl(null, a2, b, true, c2);
    };
    reactDom_production_min.hydrateRoot = function(a2, b, c2) {
      if (!nl(a2))
        throw Error(p$1(405));
      var d = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = kl;
      null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
      b = el(b, null, a2, 1, null != c2 ? c2 : null, e2, false, f2, g2);
      a2[uf] = b.current;
      sf(a2);
      if (d)
        for (a2 = 0; a2 < d.length; a2++)
          c2 = d[a2], e2 = c2._getVersion, e2 = e2(c2._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c2, e2] : b.mutableSourceEagerHydrationData.push(
            c2,
            e2
          );
      return new ml(b);
    };
    reactDom_production_min.render = function(a2, b, c2) {
      if (!ol(b))
        throw Error(p$1(200));
      return rl(null, a2, b, false, c2);
    };
    reactDom_production_min.unmountComponentAtNode = function(a2) {
      if (!ol(a2))
        throw Error(p$1(40));
      return a2._reactRootContainer ? (Rk(function() {
        rl(null, null, a2, false, function() {
          a2._reactRootContainer = null;
          a2[uf] = null;
        });
      }), true) : false;
    };
    reactDom_production_min.unstable_batchedUpdates = Qk;
    reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b, c2, d) {
      if (!ol(c2))
        throw Error(p$1(200));
      if (null == a2 || void 0 === a2._reactInternals)
        throw Error(p$1(38));
      return rl(a2, b, c2, false, d);
    };
    reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
    function checkDCE() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
        return;
      }
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
      } catch (err) {
        console.error(err);
      }
    }
    {
      checkDCE();
      reactDom.exports = reactDom_production_min;
    }
    var reactDomExports = reactDom.exports;
    var m = reactDomExports;
    {
      client.createRoot = m.createRoot;
      client.hydrateRoot = m.hydrateRoot;
    }
    const consoleLogger = {
      type: "logger",
      log(args) {
        this.output("log", args);
      },
      warn(args) {
        this.output("warn", args);
      },
      error(args) {
        this.output("error", args);
      },
      output(type, args) {
        if (console && console[type])
          console[type].apply(console, args);
      }
    };
    class Logger {
      constructor(concreteLogger) {
        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.init(concreteLogger, options);
      }
      init(concreteLogger) {
        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.prefix = options.prefix || "i18next:";
        this.logger = concreteLogger || consoleLogger;
        this.options = options;
        this.debug = options.debug;
      }
      log() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return this.forward(args, "log", "", true);
      }
      warn() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return this.forward(args, "warn", "", true);
      }
      error() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }
        return this.forward(args, "error", "");
      }
      deprecate() {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }
        return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
      }
      forward(args, lvl, prefix, debugOnly) {
        if (debugOnly && !this.debug)
          return null;
        if (typeof args[0] === "string")
          args[0] = `${prefix}${this.prefix} ${args[0]}`;
        return this.logger[lvl](args);
      }
      create(moduleName) {
        return new Logger(this.logger, {
          ...{
            prefix: `${this.prefix}:${moduleName}:`
          },
          ...this.options
        });
      }
      clone(options) {
        options = options || this.options;
        options.prefix = options.prefix || this.prefix;
        return new Logger(this.logger, options);
      }
    }
    var baseLogger = new Logger();
    class EventEmitter {
      constructor() {
        this.observers = {};
      }
      on(events, listener) {
        events.split(" ").forEach((event) => {
          if (!this.observers[event])
            this.observers[event] = /* @__PURE__ */ new Map();
          const numListeners = this.observers[event].get(listener) || 0;
          this.observers[event].set(listener, numListeners + 1);
        });
        return this;
      }
      off(event, listener) {
        if (!this.observers[event])
          return;
        if (!listener) {
          delete this.observers[event];
          return;
        }
        this.observers[event].delete(listener);
      }
      emit(event) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        if (this.observers[event]) {
          const cloned = Array.from(this.observers[event].entries());
          cloned.forEach((_ref) => {
            let [observer, numTimesAdded] = _ref;
            for (let i2 = 0; i2 < numTimesAdded; i2++) {
              observer(...args);
            }
          });
        }
        if (this.observers["*"]) {
          const cloned = Array.from(this.observers["*"].entries());
          cloned.forEach((_ref2) => {
            let [observer, numTimesAdded] = _ref2;
            for (let i2 = 0; i2 < numTimesAdded; i2++) {
              observer.apply(observer, [event, ...args]);
            }
          });
        }
      }
    }
    function defer() {
      let res;
      let rej;
      const promise2 = new Promise((resolve, reject) => {
        res = resolve;
        rej = reject;
      });
      promise2.resolve = res;
      promise2.reject = rej;
      return promise2;
    }
    function makeString(object) {
      if (object == null)
        return "";
      return "" + object;
    }
    function copy(a2, s2, t2) {
      a2.forEach((m2) => {
        if (s2[m2])
          t2[m2] = s2[m2];
      });
    }
    const lastOfPathSeparatorRegExp = /###/g;
    function getLastOfPath(object, path2, Empty) {
      function cleanKey(key2) {
        return key2 && key2.indexOf("###") > -1 ? key2.replace(lastOfPathSeparatorRegExp, ".") : key2;
      }
      function canNotTraverseDeeper() {
        return !object || typeof object === "string";
      }
      const stack = typeof path2 !== "string" ? path2 : path2.split(".");
      let stackIndex = 0;
      while (stackIndex < stack.length - 1) {
        if (canNotTraverseDeeper())
          return {};
        const key2 = cleanKey(stack[stackIndex]);
        if (!object[key2] && Empty)
          object[key2] = new Empty();
        if (Object.prototype.hasOwnProperty.call(object, key2)) {
          object = object[key2];
        } else {
          object = {};
        }
        ++stackIndex;
      }
      if (canNotTraverseDeeper())
        return {};
      return {
        obj: object,
        k: cleanKey(stack[stackIndex])
      };
    }
    function setPath(object, path2, newValue) {
      const {
        obj,
        k: k2
      } = getLastOfPath(object, path2, Object);
      if (obj !== void 0 || path2.length === 1) {
        obj[k2] = newValue;
        return;
      }
      let e2 = path2[path2.length - 1];
      let p2 = path2.slice(0, path2.length - 1);
      let last = getLastOfPath(object, p2, Object);
      while (last.obj === void 0 && p2.length) {
        e2 = `${p2[p2.length - 1]}.${e2}`;
        p2 = p2.slice(0, p2.length - 1);
        last = getLastOfPath(object, p2, Object);
        if (last && last.obj && typeof last.obj[`${last.k}.${e2}`] !== "undefined") {
          last.obj = void 0;
        }
      }
      last.obj[`${last.k}.${e2}`] = newValue;
    }
    function pushPath(object, path2, newValue, concat2) {
      const {
        obj,
        k: k2
      } = getLastOfPath(object, path2, Object);
      obj[k2] = obj[k2] || [];
      obj[k2].push(newValue);
    }
    function getPath(object, path2) {
      const {
        obj,
        k: k2
      } = getLastOfPath(object, path2);
      if (!obj)
        return void 0;
      return obj[k2];
    }
    function getPathWithDefaults(data2, defaultData, key2) {
      const value2 = getPath(data2, key2);
      if (value2 !== void 0) {
        return value2;
      }
      return getPath(defaultData, key2);
    }
    function deepExtend(target, source, overwrite) {
      for (const prop in source) {
        if (prop !== "__proto__" && prop !== "constructor") {
          if (prop in target) {
            if (typeof target[prop] === "string" || target[prop] instanceof String || typeof source[prop] === "string" || source[prop] instanceof String) {
              if (overwrite)
                target[prop] = source[prop];
            } else {
              deepExtend(target[prop], source[prop], overwrite);
            }
          } else {
            target[prop] = source[prop];
          }
        }
      }
      return target;
    }
    function regexEscape(str) {
      return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
    }
    var _entityMap = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;",
      "/": "&#x2F;"
    };
    function escape(data2) {
      if (typeof data2 === "string") {
        return data2.replace(/[&<>"'\/]/g, (s2) => _entityMap[s2]);
      }
      return data2;
    }
    class RegExpCache {
      constructor(capacity) {
        this.capacity = capacity;
        this.regExpMap = /* @__PURE__ */ new Map();
        this.regExpQueue = [];
      }
      getRegExp(pattern) {
        const regExpFromCache = this.regExpMap.get(pattern);
        if (regExpFromCache !== void 0) {
          return regExpFromCache;
        }
        const regExpNew = new RegExp(pattern);
        if (this.regExpQueue.length === this.capacity) {
          this.regExpMap.delete(this.regExpQueue.shift());
        }
        this.regExpMap.set(pattern, regExpNew);
        this.regExpQueue.push(pattern);
        return regExpNew;
      }
    }
    const chars$2 = [" ", ",", "?", "!", ";"];
    const looksLikeObjectPathRegExpCache = new RegExpCache(20);
    function looksLikeObjectPath(key2, nsSeparator, keySeparator) {
      nsSeparator = nsSeparator || "";
      keySeparator = keySeparator || "";
      const possibleChars = chars$2.filter((c2) => nsSeparator.indexOf(c2) < 0 && keySeparator.indexOf(c2) < 0);
      if (possibleChars.length === 0)
        return true;
      const r2 = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map((c2) => c2 === "?" ? "\\?" : c2).join("|")})`);
      let matched = !r2.test(key2);
      if (!matched) {
        const ki2 = key2.indexOf(keySeparator);
        if (ki2 > 0 && !r2.test(key2.substring(0, ki2))) {
          matched = true;
        }
      }
      return matched;
    }
    function deepFind(obj, path2) {
      let keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
      if (!obj)
        return void 0;
      if (obj[path2])
        return obj[path2];
      const tokens = path2.split(keySeparator);
      let current2 = obj;
      for (let i2 = 0; i2 < tokens.length; ) {
        if (!current2 || typeof current2 !== "object") {
          return void 0;
        }
        let next;
        let nextPath = "";
        for (let j = i2; j < tokens.length; ++j) {
          if (j !== i2) {
            nextPath += keySeparator;
          }
          nextPath += tokens[j];
          next = current2[nextPath];
          if (next !== void 0) {
            if (["string", "number", "boolean"].indexOf(typeof next) > -1 && j < tokens.length - 1) {
              continue;
            }
            i2 += j - i2 + 1;
            break;
          }
        }
        current2 = next;
      }
      return current2;
    }
    function getCleanedCode(code) {
      if (code && code.indexOf("_") > 0)
        return code.replace("_", "-");
      return code;
    }
    class ResourceStore extends EventEmitter {
      constructor(data2) {
        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
          ns: ["translation"],
          defaultNS: "translation"
        };
        super();
        this.data = data2 || {};
        this.options = options;
        if (this.options.keySeparator === void 0) {
          this.options.keySeparator = ".";
        }
        if (this.options.ignoreJSONStructure === void 0) {
          this.options.ignoreJSONStructure = true;
        }
      }
      addNamespaces(ns) {
        if (this.options.ns.indexOf(ns) < 0) {
          this.options.ns.push(ns);
        }
      }
      removeNamespaces(ns) {
        const index2 = this.options.ns.indexOf(ns);
        if (index2 > -1) {
          this.options.ns.splice(index2, 1);
        }
      }
      getResource(lng, ns, key2) {
        let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
        const ignoreJSONStructure = options.ignoreJSONStructure !== void 0 ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
        let path2;
        if (lng.indexOf(".") > -1) {
          path2 = lng.split(".");
        } else {
          path2 = [lng, ns];
          if (key2) {
            if (Array.isArray(key2)) {
              path2.push(...key2);
            } else if (typeof key2 === "string" && keySeparator) {
              path2.push(...key2.split(keySeparator));
            } else {
              path2.push(key2);
            }
          }
        }
        const result = getPath(this.data, path2);
        if (!result && !ns && !key2 && lng.indexOf(".") > -1) {
          lng = path2[0];
          ns = path2[1];
          key2 = path2.slice(2).join(".");
        }
        if (result || !ignoreJSONStructure || typeof key2 !== "string")
          return result;
        return deepFind(this.data && this.data[lng] && this.data[lng][ns], key2, keySeparator);
      }
      addResource(lng, ns, key2, value2) {
        let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
          silent: false
        };
        const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
        let path2 = [lng, ns];
        if (key2)
          path2 = path2.concat(keySeparator ? key2.split(keySeparator) : key2);
        if (lng.indexOf(".") > -1) {
          path2 = lng.split(".");
          value2 = ns;
          ns = path2[1];
        }
        this.addNamespaces(ns);
        setPath(this.data, path2, value2);
        if (!options.silent)
          this.emit("added", lng, ns, key2, value2);
      }
      addResources(lng, ns, resources2) {
        let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
          silent: false
        };
        for (const m2 in resources2) {
          if (typeof resources2[m2] === "string" || Object.prototype.toString.apply(resources2[m2]) === "[object Array]")
            this.addResource(lng, ns, m2, resources2[m2], {
              silent: true
            });
        }
        if (!options.silent)
          this.emit("added", lng, ns, resources2);
      }
      addResourceBundle(lng, ns, resources2, deep, overwrite) {
        let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
          silent: false,
          skipCopy: false
        };
        let path2 = [lng, ns];
        if (lng.indexOf(".") > -1) {
          path2 = lng.split(".");
          deep = resources2;
          resources2 = ns;
          ns = path2[1];
        }
        this.addNamespaces(ns);
        let pack = getPath(this.data, path2) || {};
        if (!options.skipCopy)
          resources2 = JSON.parse(JSON.stringify(resources2));
        if (deep) {
          deepExtend(pack, resources2, overwrite);
        } else {
          pack = {
            ...pack,
            ...resources2
          };
        }
        setPath(this.data, path2, pack);
        if (!options.silent)
          this.emit("added", lng, ns, resources2);
      }
      removeResourceBundle(lng, ns) {
        if (this.hasResourceBundle(lng, ns)) {
          delete this.data[lng][ns];
        }
        this.removeNamespaces(ns);
        this.emit("removed", lng, ns);
      }
      hasResourceBundle(lng, ns) {
        return this.getResource(lng, ns) !== void 0;
      }
      getResourceBundle(lng, ns) {
        if (!ns)
          ns = this.options.defaultNS;
        if (this.options.compatibilityAPI === "v1")
          return {
            ...{},
            ...this.getResource(lng, ns)
          };
        return this.getResource(lng, ns);
      }
      getDataByLanguage(lng) {
        return this.data[lng];
      }
      hasLanguageSomeTranslations(lng) {
        const data2 = this.getDataByLanguage(lng);
        const n2 = data2 && Object.keys(data2) || [];
        return !!n2.find((v2) => data2[v2] && Object.keys(data2[v2]).length > 0);
      }
      toJSON() {
        return this.data;
      }
    }
    var postProcessor = {
      processors: {},
      addPostProcessor(module2) {
        this.processors[module2.name] = module2;
      },
      handle(processors, value2, key2, options, translator) {
        processors.forEach((processor) => {
          if (this.processors[processor])
            value2 = this.processors[processor].process(value2, key2, options, translator);
        });
        return value2;
      }
    };
    const checkedLoadedFor = {};
    class Translator extends EventEmitter {
      constructor(services) {
        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        super();
        copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, this);
        this.options = options;
        if (this.options.keySeparator === void 0) {
          this.options.keySeparator = ".";
        }
        this.logger = baseLogger.create("translator");
      }
      changeLanguage(lng) {
        if (lng)
          this.language = lng;
      }
      exists(key2) {
        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
          interpolation: {}
        };
        if (key2 === void 0 || key2 === null) {
          return false;
        }
        const resolved = this.resolve(key2, options);
        return resolved && resolved.res !== void 0;
      }
      extractFromKey(key2, options) {
        let nsSeparator = options.nsSeparator !== void 0 ? options.nsSeparator : this.options.nsSeparator;
        if (nsSeparator === void 0)
          nsSeparator = ":";
        const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
        let namespaces = options.ns || this.options.defaultNS || [];
        const wouldCheckForNsInKey = nsSeparator && key2.indexOf(nsSeparator) > -1;
        const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key2, nsSeparator, keySeparator);
        if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
          const m2 = key2.match(this.interpolator.nestingRegexp);
          if (m2 && m2.length > 0) {
            return {
              key: key2,
              namespaces
            };
          }
          const parts = key2.split(nsSeparator);
          if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1)
            namespaces = parts.shift();
          key2 = parts.join(keySeparator);
        }
        if (typeof namespaces === "string")
          namespaces = [namespaces];
        return {
          key: key2,
          namespaces
        };
      }
      translate(keys2, options, lastKey) {
        if (typeof options !== "object" && this.options.overloadTranslationOptionHandler) {
          options = this.options.overloadTranslationOptionHandler(arguments);
        }
        if (typeof options === "object")
          options = {
            ...options
          };
        if (!options)
          options = {};
        if (keys2 === void 0 || keys2 === null)
          return "";
        if (!Array.isArray(keys2))
          keys2 = [String(keys2)];
        const returnDetails = options.returnDetails !== void 0 ? options.returnDetails : this.options.returnDetails;
        const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
        const {
          key: key2,
          namespaces
        } = this.extractFromKey(keys2[keys2.length - 1], options);
        const namespace = namespaces[namespaces.length - 1];
        const lng = options.lng || this.language;
        const appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
        if (lng && lng.toLowerCase() === "cimode") {
          if (appendNamespaceToCIMode) {
            const nsSeparator = options.nsSeparator || this.options.nsSeparator;
            if (returnDetails) {
              return {
                res: `${namespace}${nsSeparator}${key2}`,
                usedKey: key2,
                exactUsedKey: key2,
                usedLng: lng,
                usedNS: namespace,
                usedParams: this.getUsedParamsDetails(options)
              };
            }
            return `${namespace}${nsSeparator}${key2}`;
          }
          if (returnDetails) {
            return {
              res: key2,
              usedKey: key2,
              exactUsedKey: key2,
              usedLng: lng,
              usedNS: namespace,
              usedParams: this.getUsedParamsDetails(options)
            };
          }
          return key2;
        }
        const resolved = this.resolve(keys2, options);
        let res = resolved && resolved.res;
        const resUsedKey = resolved && resolved.usedKey || key2;
        const resExactUsedKey = resolved && resolved.exactUsedKey || key2;
        const resType = Object.prototype.toString.apply(res);
        const noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
        const joinArrays = options.joinArrays !== void 0 ? options.joinArrays : this.options.joinArrays;
        const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
        const handleAsObject = typeof res !== "string" && typeof res !== "boolean" && typeof res !== "number";
        if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === "string" && resType === "[object Array]")) {
          if (!options.returnObjects && !this.options.returnObjects) {
            if (!this.options.returnedObjectHandler) {
              this.logger.warn("accessing an object - but returnObjects options is not enabled!");
            }
            const r2 = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, {
              ...options,
              ns: namespaces
            }) : `key '${key2} (${this.language})' returned an object instead of string.`;
            if (returnDetails) {
              resolved.res = r2;
              resolved.usedParams = this.getUsedParamsDetails(options);
              return resolved;
            }
            return r2;
          }
          if (keySeparator) {
            const resTypeIsArray = resType === "[object Array]";
            const copy2 = resTypeIsArray ? [] : {};
            const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
            for (const m2 in res) {
              if (Object.prototype.hasOwnProperty.call(res, m2)) {
                const deepKey = `${newKeyToUse}${keySeparator}${m2}`;
                copy2[m2] = this.translate(deepKey, {
                  ...options,
                  ...{
                    joinArrays: false,
                    ns: namespaces
                  }
                });
                if (copy2[m2] === deepKey)
                  copy2[m2] = res[m2];
              }
            }
            res = copy2;
          }
        } else if (handleAsObjectInI18nFormat && typeof joinArrays === "string" && resType === "[object Array]") {
          res = res.join(joinArrays);
          if (res)
            res = this.extendTranslation(res, keys2, options, lastKey);
        } else {
          let usedDefault = false;
          let usedKey = false;
          const needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
          const hasDefaultValue = Translator.hasDefaultValue(options);
          const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : "";
          const defaultValueSuffixOrdinalFallback = options.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, {
            ordinal: false
          }) : "";
          const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();
          const defaultValue = needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] || options[`defaultValue${defaultValueSuffix}`] || options[`defaultValue${defaultValueSuffixOrdinalFallback}`] || options.defaultValue;
          if (!this.isValidLookup(res) && hasDefaultValue) {
            usedDefault = true;
            res = defaultValue;
          }
          if (!this.isValidLookup(res)) {
            usedKey = true;
            res = key2;
          }
          const missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
          const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
          const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
          if (usedKey || usedDefault || updateMissing) {
            this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key2, updateMissing ? defaultValue : res);
            if (keySeparator) {
              const fk2 = this.resolve(key2, {
                ...options,
                keySeparator: false
              });
              if (fk2 && fk2.res)
                this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
            }
            let lngs = [];
            const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
            if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
              for (let i2 = 0; i2 < fallbackLngs.length; i2++) {
                lngs.push(fallbackLngs[i2]);
              }
            } else if (this.options.saveMissingTo === "all") {
              lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
            } else {
              lngs.push(options.lng || this.language);
            }
            const send = (l2, k2, specificDefaultValue) => {
              const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
              if (this.options.missingKeyHandler) {
                this.options.missingKeyHandler(l2, namespace, k2, defaultForMissing, updateMissing, options);
              } else if (this.backendConnector && this.backendConnector.saveMissing) {
                this.backendConnector.saveMissing(l2, namespace, k2, defaultForMissing, updateMissing, options);
              }
              this.emit("missingKey", l2, namespace, k2, res);
            };
            if (this.options.saveMissing) {
              if (this.options.saveMissingPlurals && needsPluralHandling) {
                lngs.forEach((language) => {
                  const suffixes = this.pluralResolver.getSuffixes(language, options);
                  if (needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] && suffixes.indexOf(`${this.options.pluralSeparator}zero`) < 0) {
                    suffixes.push(`${this.options.pluralSeparator}zero`);
                  }
                  suffixes.forEach((suffix) => {
                    send([language], key2 + suffix, options[`defaultValue${suffix}`] || defaultValue);
                  });
                });
              } else {
                send(lngs, key2, defaultValue);
              }
            }
          }
          res = this.extendTranslation(res, keys2, options, resolved, lastKey);
          if (usedKey && res === key2 && this.options.appendNamespaceToMissingKey)
            res = `${namespace}:${key2}`;
          if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
            if (this.options.compatibilityAPI !== "v1") {
              res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}:${key2}` : key2, usedDefault ? res : void 0);
            } else {
              res = this.options.parseMissingKeyHandler(res);
            }
          }
        }
        if (returnDetails) {
          resolved.res = res;
          resolved.usedParams = this.getUsedParamsDetails(options);
          return resolved;
        }
        return res;
      }
      extendTranslation(res, key2, options, resolved, lastKey) {
        var _this = this;
        if (this.i18nFormat && this.i18nFormat.parse) {
          res = this.i18nFormat.parse(res, {
            ...this.options.interpolation.defaultVariables,
            ...options
          }, options.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {
            resolved
          });
        } else if (!options.skipInterpolation) {
          if (options.interpolation)
            this.interpolator.init({
              ...options,
              ...{
                interpolation: {
                  ...this.options.interpolation,
                  ...options.interpolation
                }
              }
            });
          const skipOnVariables = typeof res === "string" && (options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
          let nestBef;
          if (skipOnVariables) {
            const nb2 = res.match(this.interpolator.nestingRegexp);
            nestBef = nb2 && nb2.length;
          }
          let data2 = options.replace && typeof options.replace !== "string" ? options.replace : options;
          if (this.options.interpolation.defaultVariables)
            data2 = {
              ...this.options.interpolation.defaultVariables,
              ...data2
            };
          res = this.interpolator.interpolate(res, data2, options.lng || this.language, options);
          if (skipOnVariables) {
            const na = res.match(this.interpolator.nestingRegexp);
            const nestAft = na && na.length;
            if (nestBef < nestAft)
              options.nest = false;
          }
          if (!options.lng && this.options.compatibilityAPI !== "v1" && resolved && resolved.res)
            options.lng = resolved.usedLng;
          if (options.nest !== false)
            res = this.interpolator.nest(res, function() {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              if (lastKey && lastKey[0] === args[0] && !options.context) {
                _this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key2[0]}`);
                return null;
              }
              return _this.translate(...args, key2);
            }, options);
          if (options.interpolation)
            this.interpolator.reset();
        }
        const postProcess = options.postProcess || this.options.postProcess;
        const postProcessorNames = typeof postProcess === "string" ? [postProcess] : postProcess;
        if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
          res = postProcessor.handle(postProcessorNames, res, key2, this.options && this.options.postProcessPassResolved ? {
            i18nResolved: {
              ...resolved,
              usedParams: this.getUsedParamsDetails(options)
            },
            ...options
          } : options, this);
        }
        return res;
      }
      resolve(keys2) {
        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let found;
        let usedKey;
        let exactUsedKey;
        let usedLng;
        let usedNS;
        if (typeof keys2 === "string")
          keys2 = [keys2];
        keys2.forEach((k2) => {
          if (this.isValidLookup(found))
            return;
          const extracted = this.extractFromKey(k2, options);
          const key2 = extracted.key;
          usedKey = key2;
          let namespaces = extracted.namespaces;
          if (this.options.fallbackNS)
            namespaces = namespaces.concat(this.options.fallbackNS);
          const needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
          const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();
          const needsContextHandling = options.context !== void 0 && (typeof options.context === "string" || typeof options.context === "number") && options.context !== "";
          const codes = options.lngs ? options.lngs : this.languageUtils.toResolveHierarchy(options.lng || this.language, options.fallbackLng);
          namespaces.forEach((ns) => {
            if (this.isValidLookup(found))
              return;
            usedNS = ns;
            if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(usedNS)) {
              checkedLoadedFor[`${codes[0]}-${ns}`] = true;
              this.logger.warn(`key "${usedKey}" for languages "${codes.join(", ")}" won't get resolved as namespace "${usedNS}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
            }
            codes.forEach((code) => {
              if (this.isValidLookup(found))
                return;
              usedLng = code;
              const finalKeys = [key2];
              if (this.i18nFormat && this.i18nFormat.addLookupKeys) {
                this.i18nFormat.addLookupKeys(finalKeys, key2, code, ns, options);
              } else {
                let pluralSuffix;
                if (needsPluralHandling)
                  pluralSuffix = this.pluralResolver.getSuffix(code, options.count, options);
                const zeroSuffix = `${this.options.pluralSeparator}zero`;
                const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
                if (needsPluralHandling) {
                  finalKeys.push(key2 + pluralSuffix);
                  if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                    finalKeys.push(key2 + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                  }
                  if (needsZeroSuffixLookup) {
                    finalKeys.push(key2 + zeroSuffix);
                  }
                }
                if (needsContextHandling) {
                  const contextKey = `${key2}${this.options.contextSeparator}${options.context}`;
                  finalKeys.push(contextKey);
                  if (needsPluralHandling) {
                    finalKeys.push(contextKey + pluralSuffix);
                    if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                      finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                    }
                    if (needsZeroSuffixLookup) {
                      finalKeys.push(contextKey + zeroSuffix);
                    }
                  }
                }
              }
              let possibleKey;
              while (possibleKey = finalKeys.pop()) {
                if (!this.isValidLookup(found)) {
                  exactUsedKey = possibleKey;
                  found = this.getResource(code, ns, possibleKey, options);
                }
              }
            });
          });
        });
        return {
          res: found,
          usedKey,
          exactUsedKey,
          usedLng,
          usedNS
        };
      }
      isValidLookup(res) {
        return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
      }
      getResource(code, ns, key2) {
        let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        if (this.i18nFormat && this.i18nFormat.getResource)
          return this.i18nFormat.getResource(code, ns, key2, options);
        return this.resourceStore.getResource(code, ns, key2, options);
      }
      getUsedParamsDetails() {
        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const optionsKeys = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"];
        const useOptionsReplaceForData = options.replace && typeof options.replace !== "string";
        let data2 = useOptionsReplaceForData ? options.replace : options;
        if (useOptionsReplaceForData && typeof options.count !== "undefined") {
          data2.count = options.count;
        }
        if (this.options.interpolation.defaultVariables) {
          data2 = {
            ...this.options.interpolation.defaultVariables,
            ...data2
          };
        }
        if (!useOptionsReplaceForData) {
          data2 = {
            ...data2
          };
          for (const key2 of optionsKeys) {
            delete data2[key2];
          }
        }
        return data2;
      }
      static hasDefaultValue(options) {
        const prefix = "defaultValue";
        for (const option2 in options) {
          if (Object.prototype.hasOwnProperty.call(options, option2) && prefix === option2.substring(0, prefix.length) && void 0 !== options[option2]) {
            return true;
          }
        }
        return false;
      }
    }
    function capitalize(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    }
    class LanguageUtil {
      constructor(options) {
        this.options = options;
        this.supportedLngs = this.options.supportedLngs || false;
        this.logger = baseLogger.create("languageUtils");
      }
      getScriptPartFromCode(code) {
        code = getCleanedCode(code);
        if (!code || code.indexOf("-") < 0)
          return null;
        const p2 = code.split("-");
        if (p2.length === 2)
          return null;
        p2.pop();
        if (p2[p2.length - 1].toLowerCase() === "x")
          return null;
        return this.formatLanguageCode(p2.join("-"));
      }
      getLanguagePartFromCode(code) {
        code = getCleanedCode(code);
        if (!code || code.indexOf("-") < 0)
          return code;
        const p2 = code.split("-");
        return this.formatLanguageCode(p2[0]);
      }
      formatLanguageCode(code) {
        if (typeof code === "string" && code.indexOf("-") > -1) {
          const specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
          let p2 = code.split("-");
          if (this.options.lowerCaseLng) {
            p2 = p2.map((part) => part.toLowerCase());
          } else if (p2.length === 2) {
            p2[0] = p2[0].toLowerCase();
            p2[1] = p2[1].toUpperCase();
            if (specialCases.indexOf(p2[1].toLowerCase()) > -1)
              p2[1] = capitalize(p2[1].toLowerCase());
          } else if (p2.length === 3) {
            p2[0] = p2[0].toLowerCase();
            if (p2[1].length === 2)
              p2[1] = p2[1].toUpperCase();
            if (p2[0] !== "sgn" && p2[2].length === 2)
              p2[2] = p2[2].toUpperCase();
            if (specialCases.indexOf(p2[1].toLowerCase()) > -1)
              p2[1] = capitalize(p2[1].toLowerCase());
            if (specialCases.indexOf(p2[2].toLowerCase()) > -1)
              p2[2] = capitalize(p2[2].toLowerCase());
          }
          return p2.join("-");
        }
        return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
      }
      isSupportedCode(code) {
        if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
          code = this.getLanguagePartFromCode(code);
        }
        return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
      }
      getBestMatchFromCodes(codes) {
        if (!codes)
          return null;
        let found;
        codes.forEach((code) => {
          if (found)
            return;
          const cleanedLng = this.formatLanguageCode(code);
          if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng))
            found = cleanedLng;
        });
        if (!found && this.options.supportedLngs) {
          codes.forEach((code) => {
            if (found)
              return;
            const lngOnly = this.getLanguagePartFromCode(code);
            if (this.isSupportedCode(lngOnly))
              return found = lngOnly;
            found = this.options.supportedLngs.find((supportedLng) => {
              if (supportedLng === lngOnly)
                return supportedLng;
              if (supportedLng.indexOf("-") < 0 && lngOnly.indexOf("-") < 0)
                return;
              if (supportedLng.indexOf("-") > 0 && lngOnly.indexOf("-") < 0 && supportedLng.substring(0, supportedLng.indexOf("-")) === lngOnly)
                return supportedLng;
              if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1)
                return supportedLng;
            });
          });
        }
        if (!found)
          found = this.getFallbackCodes(this.options.fallbackLng)[0];
        return found;
      }
      getFallbackCodes(fallbacks, code) {
        if (!fallbacks)
          return [];
        if (typeof fallbacks === "function")
          fallbacks = fallbacks(code);
        if (typeof fallbacks === "string")
          fallbacks = [fallbacks];
        if (Object.prototype.toString.apply(fallbacks) === "[object Array]")
          return fallbacks;
        if (!code)
          return fallbacks.default || [];
        let found = fallbacks[code];
        if (!found)
          found = fallbacks[this.getScriptPartFromCode(code)];
        if (!found)
          found = fallbacks[this.formatLanguageCode(code)];
        if (!found)
          found = fallbacks[this.getLanguagePartFromCode(code)];
        if (!found)
          found = fallbacks.default;
        return found || [];
      }
      toResolveHierarchy(code, fallbackCode) {
        const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
        const codes = [];
        const addCode = (c2) => {
          if (!c2)
            return;
          if (this.isSupportedCode(c2)) {
            codes.push(c2);
          } else {
            this.logger.warn(`rejecting language code not found in supportedLngs: ${c2}`);
          }
        };
        if (typeof code === "string" && (code.indexOf("-") > -1 || code.indexOf("_") > -1)) {
          if (this.options.load !== "languageOnly")
            addCode(this.formatLanguageCode(code));
          if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly")
            addCode(this.getScriptPartFromCode(code));
          if (this.options.load !== "currentOnly")
            addCode(this.getLanguagePartFromCode(code));
        } else if (typeof code === "string") {
          addCode(this.formatLanguageCode(code));
        }
        fallbackCodes.forEach((fc2) => {
          if (codes.indexOf(fc2) < 0)
            addCode(this.formatLanguageCode(fc2));
        });
        return codes;
      }
    }
    let sets = [{
      lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
      nr: [1, 2],
      fc: 1
    }, {
      lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
      nr: [1, 2],
      fc: 2
    }, {
      lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
      nr: [1],
      fc: 3
    }, {
      lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
      nr: [1, 2, 5],
      fc: 4
    }, {
      lngs: ["ar"],
      nr: [0, 1, 2, 3, 11, 100],
      fc: 5
    }, {
      lngs: ["cs", "sk"],
      nr: [1, 2, 5],
      fc: 6
    }, {
      lngs: ["csb", "pl"],
      nr: [1, 2, 5],
      fc: 7
    }, {
      lngs: ["cy"],
      nr: [1, 2, 3, 8],
      fc: 8
    }, {
      lngs: ["fr"],
      nr: [1, 2],
      fc: 9
    }, {
      lngs: ["ga"],
      nr: [1, 2, 3, 7, 11],
      fc: 10
    }, {
      lngs: ["gd"],
      nr: [1, 2, 3, 20],
      fc: 11
    }, {
      lngs: ["is"],
      nr: [1, 2],
      fc: 12
    }, {
      lngs: ["jv"],
      nr: [0, 1],
      fc: 13
    }, {
      lngs: ["kw"],
      nr: [1, 2, 3, 4],
      fc: 14
    }, {
      lngs: ["lt"],
      nr: [1, 2, 10],
      fc: 15
    }, {
      lngs: ["lv"],
      nr: [1, 2, 0],
      fc: 16
    }, {
      lngs: ["mk"],
      nr: [1, 2],
      fc: 17
    }, {
      lngs: ["mnk"],
      nr: [0, 1, 2],
      fc: 18
    }, {
      lngs: ["mt"],
      nr: [1, 2, 11, 20],
      fc: 19
    }, {
      lngs: ["or"],
      nr: [2, 1],
      fc: 2
    }, {
      lngs: ["ro"],
      nr: [1, 2, 20],
      fc: 20
    }, {
      lngs: ["sl"],
      nr: [5, 1, 2, 3],
      fc: 21
    }, {
      lngs: ["he", "iw"],
      nr: [1, 2, 20, 21],
      fc: 22
    }];
    let _rulesPluralsTypes = {
      1: function(n2) {
        return Number(n2 > 1);
      },
      2: function(n2) {
        return Number(n2 != 1);
      },
      3: function(n2) {
        return 0;
      },
      4: function(n2) {
        return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
      },
      5: function(n2) {
        return Number(n2 == 0 ? 0 : n2 == 1 ? 1 : n2 == 2 ? 2 : n2 % 100 >= 3 && n2 % 100 <= 10 ? 3 : n2 % 100 >= 11 ? 4 : 5);
      },
      6: function(n2) {
        return Number(n2 == 1 ? 0 : n2 >= 2 && n2 <= 4 ? 1 : 2);
      },
      7: function(n2) {
        return Number(n2 == 1 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
      },
      8: function(n2) {
        return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 != 8 && n2 != 11 ? 2 : 3);
      },
      9: function(n2) {
        return Number(n2 >= 2);
      },
      10: function(n2) {
        return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 < 7 ? 2 : n2 < 11 ? 3 : 4);
      },
      11: function(n2) {
        return Number(n2 == 1 || n2 == 11 ? 0 : n2 == 2 || n2 == 12 ? 1 : n2 > 2 && n2 < 20 ? 2 : 3);
      },
      12: function(n2) {
        return Number(n2 % 10 != 1 || n2 % 100 == 11);
      },
      13: function(n2) {
        return Number(n2 !== 0);
      },
      14: function(n2) {
        return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 == 3 ? 2 : 3);
      },
      15: function(n2) {
        return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
      },
      16: function(n2) {
        return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 !== 0 ? 1 : 2);
      },
      17: function(n2) {
        return Number(n2 == 1 || n2 % 10 == 1 && n2 % 100 != 11 ? 0 : 1);
      },
      18: function(n2) {
        return Number(n2 == 0 ? 0 : n2 == 1 ? 1 : 2);
      },
      19: function(n2) {
        return Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 1 && n2 % 100 < 11 ? 1 : n2 % 100 > 10 && n2 % 100 < 20 ? 2 : 3);
      },
      20: function(n2) {
        return Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 0 && n2 % 100 < 20 ? 1 : 2);
      },
      21: function(n2) {
        return Number(n2 % 100 == 1 ? 1 : n2 % 100 == 2 ? 2 : n2 % 100 == 3 || n2 % 100 == 4 ? 3 : 0);
      },
      22: function(n2) {
        return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : (n2 < 0 || n2 > 10) && n2 % 10 == 0 ? 2 : 3);
      }
    };
    const nonIntlVersions = ["v1", "v2", "v3"];
    const intlVersions = ["v4"];
    const suffixesOrder = {
      zero: 0,
      one: 1,
      two: 2,
      few: 3,
      many: 4,
      other: 5
    };
    function createRules() {
      const rules = {};
      sets.forEach((set2) => {
        set2.lngs.forEach((l2) => {
          rules[l2] = {
            numbers: set2.nr,
            plurals: _rulesPluralsTypes[set2.fc]
          };
        });
      });
      return rules;
    }
    class PluralResolver {
      constructor(languageUtils) {
        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.languageUtils = languageUtils;
        this.options = options;
        this.logger = baseLogger.create("pluralResolver");
        if ((!this.options.compatibilityJSON || intlVersions.includes(this.options.compatibilityJSON)) && (typeof Intl === "undefined" || !Intl.PluralRules)) {
          this.options.compatibilityJSON = "v3";
          this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.");
        }
        this.rules = createRules();
      }
      addRule(lng, obj) {
        this.rules[lng] = obj;
      }
      getRule(code) {
        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (this.shouldUseIntlApi()) {
          try {
            return new Intl.PluralRules(getCleanedCode(code === "dev" ? "en" : code), {
              type: options.ordinal ? "ordinal" : "cardinal"
            });
          } catch (err) {
            return;
          }
        }
        return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
      }
      needsPlural(code) {
        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const rule = this.getRule(code, options);
        if (this.shouldUseIntlApi()) {
          return rule && rule.resolvedOptions().pluralCategories.length > 1;
        }
        return rule && rule.numbers.length > 1;
      }
      getPluralFormsOfKey(code, key2) {
        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return this.getSuffixes(code, options).map((suffix) => `${key2}${suffix}`);
      }
      getSuffixes(code) {
        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const rule = this.getRule(code, options);
        if (!rule) {
          return [];
        }
        if (this.shouldUseIntlApi()) {
          return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2) => suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory) => `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${pluralCategory}`);
        }
        return rule.numbers.map((number) => this.getSuffix(code, number, options));
      }
      getSuffix(code, count) {
        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        const rule = this.getRule(code, options);
        if (rule) {
          if (this.shouldUseIntlApi()) {
            return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${rule.select(count)}`;
          }
          return this.getSuffixRetroCompatible(rule, count);
        }
        this.logger.warn(`no plural rule found for: ${code}`);
        return "";
      }
      getSuffixRetroCompatible(rule, count) {
        const idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
        let suffix = rule.numbers[idx];
        if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
          if (suffix === 2) {
            suffix = "plural";
          } else if (suffix === 1) {
            suffix = "";
          }
        }
        const returnSuffix = () => this.options.prepend && suffix.toString() ? this.options.prepend + suffix.toString() : suffix.toString();
        if (this.options.compatibilityJSON === "v1") {
          if (suffix === 1)
            return "";
          if (typeof suffix === "number")
            return `_plural_${suffix.toString()}`;
          return returnSuffix();
        } else if (this.options.compatibilityJSON === "v2") {
          return returnSuffix();
        } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
          return returnSuffix();
        }
        return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
      }
      shouldUseIntlApi() {
        return !nonIntlVersions.includes(this.options.compatibilityJSON);
      }
    }
    function deepFindWithDefaults(data2, defaultData, key2) {
      let keySeparator = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".";
      let ignoreJSONStructure = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
      let path2 = getPathWithDefaults(data2, defaultData, key2);
      if (!path2 && ignoreJSONStructure && typeof key2 === "string") {
        path2 = deepFind(data2, key2, keySeparator);
        if (path2 === void 0)
          path2 = deepFind(defaultData, key2, keySeparator);
      }
      return path2;
    }
    class Interpolator {
      constructor() {
        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this.logger = baseLogger.create("interpolator");
        this.options = options;
        this.format = options.interpolation && options.interpolation.format || ((value2) => value2);
        this.init(options);
      }
      init() {
        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (!options.interpolation)
          options.interpolation = {
            escapeValue: true
          };
        const {
          escape: escape$12,
          escapeValue,
          useRawValueToEscape,
          prefix,
          prefixEscaped,
          suffix,
          suffixEscaped,
          formatSeparator,
          unescapeSuffix,
          unescapePrefix,
          nestingPrefix,
          nestingPrefixEscaped,
          nestingSuffix,
          nestingSuffixEscaped,
          nestingOptionsSeparator,
          maxReplaces,
          alwaysFormat
        } = options.interpolation;
        this.escape = escape$12 !== void 0 ? escape$12 : escape;
        this.escapeValue = escapeValue !== void 0 ? escapeValue : true;
        this.useRawValueToEscape = useRawValueToEscape !== void 0 ? useRawValueToEscape : false;
        this.prefix = prefix ? regexEscape(prefix) : prefixEscaped || "{{";
        this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || "}}";
        this.formatSeparator = formatSeparator || ",";
        this.unescapePrefix = unescapeSuffix ? "" : unescapePrefix || "-";
        this.unescapeSuffix = this.unescapePrefix ? "" : unescapeSuffix || "";
        this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape("$t(");
        this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(")");
        this.nestingOptionsSeparator = nestingOptionsSeparator || ",";
        this.maxReplaces = maxReplaces || 1e3;
        this.alwaysFormat = alwaysFormat !== void 0 ? alwaysFormat : false;
        this.resetRegExp();
      }
      reset() {
        if (this.options)
          this.init(this.options);
      }
      resetRegExp() {
        const getOrResetRegExp = (existingRegExp, pattern) => {
          if (existingRegExp && existingRegExp.source === pattern) {
            existingRegExp.lastIndex = 0;
            return existingRegExp;
          }
          return new RegExp(pattern, "g");
        };
        this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`);
        this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`);
        this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);
      }
      interpolate(str, data2, lng, options) {
        let match2;
        let value2;
        let replaces;
        const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
        function regexSafe(val2) {
          return val2.replace(/\$/g, "$$$$");
        }
        const handleFormat = (key2) => {
          if (key2.indexOf(this.formatSeparator) < 0) {
            const path2 = deepFindWithDefaults(data2, defaultData, key2, this.options.keySeparator, this.options.ignoreJSONStructure);
            return this.alwaysFormat ? this.format(path2, void 0, lng, {
              ...options,
              ...data2,
              interpolationkey: key2
            }) : path2;
          }
          const p2 = key2.split(this.formatSeparator);
          const k2 = p2.shift().trim();
          const f2 = p2.join(this.formatSeparator).trim();
          return this.format(deepFindWithDefaults(data2, defaultData, k2, this.options.keySeparator, this.options.ignoreJSONStructure), f2, lng, {
            ...options,
            ...data2,
            interpolationkey: k2
          });
        };
        this.resetRegExp();
        const missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
        const skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
        const todos = [{
          regex: this.regexpUnescape,
          safeValue: (val2) => regexSafe(val2)
        }, {
          regex: this.regexp,
          safeValue: (val2) => this.escapeValue ? regexSafe(this.escape(val2)) : regexSafe(val2)
        }];
        todos.forEach((todo) => {
          replaces = 0;
          while (match2 = todo.regex.exec(str)) {
            const matchedVar = match2[1].trim();
            value2 = handleFormat(matchedVar);
            if (value2 === void 0) {
              if (typeof missingInterpolationHandler === "function") {
                const temp = missingInterpolationHandler(str, match2, options);
                value2 = typeof temp === "string" ? temp : "";
              } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {
                value2 = "";
              } else if (skipOnVariables) {
                value2 = match2[0];
                continue;
              } else {
                this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);
                value2 = "";
              }
            } else if (typeof value2 !== "string" && !this.useRawValueToEscape) {
              value2 = makeString(value2);
            }
            const safeValue = todo.safeValue(value2);
            str = str.replace(match2[0], safeValue);
            if (skipOnVariables) {
              todo.regex.lastIndex += value2.length;
              todo.regex.lastIndex -= match2[0].length;
            } else {
              todo.regex.lastIndex = 0;
            }
            replaces++;
            if (replaces >= this.maxReplaces) {
              break;
            }
          }
        });
        return str;
      }
      nest(str, fc2) {
        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        let match2;
        let value2;
        let clonedOptions;
        function handleHasOptions(key2, inheritedOptions) {
          const sep = this.nestingOptionsSeparator;
          if (key2.indexOf(sep) < 0)
            return key2;
          const c2 = key2.split(new RegExp(`${sep}[ ]*{`));
          let optionsString = `{${c2[1]}`;
          key2 = c2[0];
          optionsString = this.interpolate(optionsString, clonedOptions);
          const matchedSingleQuotes = optionsString.match(/'/g);
          const matchedDoubleQuotes = optionsString.match(/"/g);
          if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
            optionsString = optionsString.replace(/'/g, '"');
          }
          try {
            clonedOptions = JSON.parse(optionsString);
            if (inheritedOptions)
              clonedOptions = {
                ...inheritedOptions,
                ...clonedOptions
              };
          } catch (e2) {
            this.logger.warn(`failed parsing options string in nesting for key ${key2}`, e2);
            return `${key2}${sep}${optionsString}`;
          }
          if (clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(this.prefix) > -1)
            delete clonedOptions.defaultValue;
          return key2;
        }
        while (match2 = this.nestingRegexp.exec(str)) {
          let formatters2 = [];
          clonedOptions = {
            ...options
          };
          clonedOptions = clonedOptions.replace && typeof clonedOptions.replace !== "string" ? clonedOptions.replace : clonedOptions;
          clonedOptions.applyPostProcessor = false;
          delete clonedOptions.defaultValue;
          let doReduce = false;
          if (match2[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match2[1])) {
            const r2 = match2[1].split(this.formatSeparator).map((elem2) => elem2.trim());
            match2[1] = r2.shift();
            formatters2 = r2;
            doReduce = true;
          }
          value2 = fc2(handleHasOptions.call(this, match2[1].trim(), clonedOptions), clonedOptions);
          if (value2 && match2[0] === str && typeof value2 !== "string")
            return value2;
          if (typeof value2 !== "string")
            value2 = makeString(value2);
          if (!value2) {
            this.logger.warn(`missed to resolve ${match2[1]} for nesting ${str}`);
            value2 = "";
          }
          if (doReduce) {
            value2 = formatters2.reduce((v2, f2) => this.format(v2, f2, options.lng, {
              ...options,
              interpolationkey: match2[1].trim()
            }), value2.trim());
          }
          str = str.replace(match2[0], value2);
          this.regexp.lastIndex = 0;
        }
        return str;
      }
    }
    function parseFormatStr(formatStr) {
      let formatName = formatStr.toLowerCase().trim();
      const formatOptions = {};
      if (formatStr.indexOf("(") > -1) {
        const p2 = formatStr.split("(");
        formatName = p2[0].toLowerCase().trim();
        const optStr = p2[1].substring(0, p2[1].length - 1);
        if (formatName === "currency" && optStr.indexOf(":") < 0) {
          if (!formatOptions.currency)
            formatOptions.currency = optStr.trim();
        } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
          if (!formatOptions.range)
            formatOptions.range = optStr.trim();
        } else {
          const opts = optStr.split(";");
          opts.forEach((opt) => {
            if (!opt)
              return;
            const [key2, ...rest] = opt.split(":");
            const val2 = rest.join(":").trim().replace(/^'+|'+$/g, "");
            if (!formatOptions[key2.trim()])
              formatOptions[key2.trim()] = val2;
            if (val2 === "false")
              formatOptions[key2.trim()] = false;
            if (val2 === "true")
              formatOptions[key2.trim()] = true;
            if (!isNaN(val2))
              formatOptions[key2.trim()] = parseInt(val2, 10);
          });
        }
      }
      return {
        formatName,
        formatOptions
      };
    }
    function createCachedFormatter(fn) {
      const cache = {};
      return function invokeFormatter(val2, lng, options) {
        const key2 = lng + JSON.stringify(options);
        let formatter = cache[key2];
        if (!formatter) {
          formatter = fn(getCleanedCode(lng), options);
          cache[key2] = formatter;
        }
        return formatter(val2);
      };
    }
    class Formatter {
      constructor() {
        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this.logger = baseLogger.create("formatter");
        this.options = options;
        this.formats = {
          number: createCachedFormatter((lng, opt) => {
            const formatter = new Intl.NumberFormat(lng, {
              ...opt
            });
            return (val2) => formatter.format(val2);
          }),
          currency: createCachedFormatter((lng, opt) => {
            const formatter = new Intl.NumberFormat(lng, {
              ...opt,
              style: "currency"
            });
            return (val2) => formatter.format(val2);
          }),
          datetime: createCachedFormatter((lng, opt) => {
            const formatter = new Intl.DateTimeFormat(lng, {
              ...opt
            });
            return (val2) => formatter.format(val2);
          }),
          relativetime: createCachedFormatter((lng, opt) => {
            const formatter = new Intl.RelativeTimeFormat(lng, {
              ...opt
            });
            return (val2) => formatter.format(val2, opt.range || "day");
          }),
          list: createCachedFormatter((lng, opt) => {
            const formatter = new Intl.ListFormat(lng, {
              ...opt
            });
            return (val2) => formatter.format(val2);
          })
        };
        this.init(options);
      }
      init(services) {
        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
          interpolation: {}
        };
        const iOpts = options.interpolation;
        this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
      }
      add(name2, fc2) {
        this.formats[name2.toLowerCase().trim()] = fc2;
      }
      addCached(name2, fc2) {
        this.formats[name2.toLowerCase().trim()] = createCachedFormatter(fc2);
      }
      format(value2, format2, lng) {
        let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        const formats = format2.split(this.formatSeparator);
        const result = formats.reduce((mem, f2) => {
          const {
            formatName,
            formatOptions
          } = parseFormatStr(f2);
          if (this.formats[formatName]) {
            let formatted = mem;
            try {
              const valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};
              const l2 = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
              formatted = this.formats[formatName](mem, l2, {
                ...formatOptions,
                ...options,
                ...valOptions
              });
            } catch (error) {
              this.logger.warn(error);
            }
            return formatted;
          } else {
            this.logger.warn(`there was no format function for ${formatName}`);
          }
          return mem;
        }, value2);
        return result;
      }
    }
    function removePending(q2, name2) {
      if (q2.pending[name2] !== void 0) {
        delete q2.pending[name2];
        q2.pendingCount--;
      }
    }
    class Connector extends EventEmitter {
      constructor(backend, store2, services) {
        let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        super();
        this.backend = backend;
        this.store = store2;
        this.services = services;
        this.languageUtils = services.languageUtils;
        this.options = options;
        this.logger = baseLogger.create("backendConnector");
        this.waitingReads = [];
        this.maxParallelReads = options.maxParallelReads || 10;
        this.readingCalls = 0;
        this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
        this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
        this.state = {};
        this.queue = [];
        if (this.backend && this.backend.init) {
          this.backend.init(services, options.backend, options);
        }
      }
      queueLoad(languages, namespaces, options, callback) {
        const toLoad = {};
        const pending = {};
        const toLoadLanguages = {};
        const toLoadNamespaces = {};
        languages.forEach((lng) => {
          let hasAllNamespaces = true;
          namespaces.forEach((ns) => {
            const name2 = `${lng}|${ns}`;
            if (!options.reload && this.store.hasResourceBundle(lng, ns)) {
              this.state[name2] = 2;
            } else if (this.state[name2] < 0)
              ;
            else if (this.state[name2] === 1) {
              if (pending[name2] === void 0)
                pending[name2] = true;
            } else {
              this.state[name2] = 1;
              hasAllNamespaces = false;
              if (pending[name2] === void 0)
                pending[name2] = true;
              if (toLoad[name2] === void 0)
                toLoad[name2] = true;
              if (toLoadNamespaces[ns] === void 0)
                toLoadNamespaces[ns] = true;
            }
          });
          if (!hasAllNamespaces)
            toLoadLanguages[lng] = true;
        });
        if (Object.keys(toLoad).length || Object.keys(pending).length) {
          this.queue.push({
            pending,
            pendingCount: Object.keys(pending).length,
            loaded: {},
            errors: [],
            callback
          });
        }
        return {
          toLoad: Object.keys(toLoad),
          pending: Object.keys(pending),
          toLoadLanguages: Object.keys(toLoadLanguages),
          toLoadNamespaces: Object.keys(toLoadNamespaces)
        };
      }
      loaded(name2, err, data2) {
        const s2 = name2.split("|");
        const lng = s2[0];
        const ns = s2[1];
        if (err)
          this.emit("failedLoading", lng, ns, err);
        if (data2) {
          this.store.addResourceBundle(lng, ns, data2, void 0, void 0, {
            skipCopy: true
          });
        }
        this.state[name2] = err ? -1 : 2;
        const loaded = {};
        this.queue.forEach((q2) => {
          pushPath(q2.loaded, [lng], ns);
          removePending(q2, name2);
          if (err)
            q2.errors.push(err);
          if (q2.pendingCount === 0 && !q2.done) {
            Object.keys(q2.loaded).forEach((l2) => {
              if (!loaded[l2])
                loaded[l2] = {};
              const loadedKeys = q2.loaded[l2];
              if (loadedKeys.length) {
                loadedKeys.forEach((n2) => {
                  if (loaded[l2][n2] === void 0)
                    loaded[l2][n2] = true;
                });
              }
            });
            q2.done = true;
            if (q2.errors.length) {
              q2.callback(q2.errors);
            } else {
              q2.callback();
            }
          }
        });
        this.emit("loaded", loaded);
        this.queue = this.queue.filter((q2) => !q2.done);
      }
      read(lng, ns, fcName) {
        let tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
        let wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout;
        let callback = arguments.length > 5 ? arguments[5] : void 0;
        if (!lng.length)
          return callback(null, {});
        if (this.readingCalls >= this.maxParallelReads) {
          this.waitingReads.push({
            lng,
            ns,
            fcName,
            tried,
            wait,
            callback
          });
          return;
        }
        this.readingCalls++;
        const resolver = (err, data2) => {
          this.readingCalls--;
          if (this.waitingReads.length > 0) {
            const next = this.waitingReads.shift();
            this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
          }
          if (err && data2 && tried < this.maxRetries) {
            setTimeout(() => {
              this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);
            }, wait);
            return;
          }
          callback(err, data2);
        };
        const fc2 = this.backend[fcName].bind(this.backend);
        if (fc2.length === 2) {
          try {
            const r2 = fc2(lng, ns);
            if (r2 && typeof r2.then === "function") {
              r2.then((data2) => resolver(null, data2)).catch(resolver);
            } else {
              resolver(null, r2);
            }
          } catch (err) {
            resolver(err);
          }
          return;
        }
        return fc2(lng, ns, resolver);
      }
      prepareLoading(languages, namespaces) {
        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        let callback = arguments.length > 3 ? arguments[3] : void 0;
        if (!this.backend) {
          this.logger.warn("No backend was added via i18next.use. Will not load resources.");
          return callback && callback();
        }
        if (typeof languages === "string")
          languages = this.languageUtils.toResolveHierarchy(languages);
        if (typeof namespaces === "string")
          namespaces = [namespaces];
        const toLoad = this.queueLoad(languages, namespaces, options, callback);
        if (!toLoad.toLoad.length) {
          if (!toLoad.pending.length)
            callback();
          return null;
        }
        toLoad.toLoad.forEach((name2) => {
          this.loadOne(name2);
        });
      }
      load(languages, namespaces, callback) {
        this.prepareLoading(languages, namespaces, {}, callback);
      }
      reload(languages, namespaces, callback) {
        this.prepareLoading(languages, namespaces, {
          reload: true
        }, callback);
      }
      loadOne(name2) {
        let prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
        const s2 = name2.split("|");
        const lng = s2[0];
        const ns = s2[1];
        this.read(lng, ns, "read", void 0, void 0, (err, data2) => {
          if (err)
            this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);
          if (!err && data2)
            this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data2);
          this.loaded(name2, err, data2);
        });
      }
      saveMissing(languages, namespace, key2, fallbackValue, isUpdate) {
        let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
        let clb = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
        };
        if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
          this.logger.warn(`did not save key "${key2}" as the namespace "${namespace}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
          return;
        }
        if (key2 === void 0 || key2 === null || key2 === "")
          return;
        if (this.backend && this.backend.create) {
          const opts = {
            ...options,
            isUpdate
          };
          const fc2 = this.backend.create.bind(this.backend);
          if (fc2.length < 6) {
            try {
              let r2;
              if (fc2.length === 5) {
                r2 = fc2(languages, namespace, key2, fallbackValue, opts);
              } else {
                r2 = fc2(languages, namespace, key2, fallbackValue);
              }
              if (r2 && typeof r2.then === "function") {
                r2.then((data2) => clb(null, data2)).catch(clb);
              } else {
                clb(null, r2);
              }
            } catch (err) {
              clb(err);
            }
          } else {
            fc2(languages, namespace, key2, fallbackValue, clb, opts);
          }
        }
        if (!languages || !languages[0])
          return;
        this.store.addResource(languages[0], namespace, key2, fallbackValue);
      }
    }
    function get$1() {
      return {
        debug: false,
        initImmediate: true,
        ns: ["translation"],
        defaultNS: ["translation"],
        fallbackLng: ["dev"],
        fallbackNS: false,
        supportedLngs: false,
        nonExplicitSupportedLngs: false,
        load: "all",
        preload: false,
        simplifyPluralSuffix: true,
        keySeparator: ".",
        nsSeparator: ":",
        pluralSeparator: "_",
        contextSeparator: "_",
        partialBundledLanguages: false,
        saveMissing: false,
        updateMissing: false,
        saveMissingTo: "fallback",
        saveMissingPlurals: true,
        missingKeyHandler: false,
        missingInterpolationHandler: false,
        postProcess: false,
        postProcessPassResolved: false,
        returnNull: false,
        returnEmptyString: true,
        returnObjects: false,
        joinArrays: false,
        returnedObjectHandler: false,
        parseMissingKeyHandler: false,
        appendNamespaceToMissingKey: false,
        appendNamespaceToCIMode: false,
        overloadTranslationOptionHandler: function handle2(args) {
          let ret = {};
          if (typeof args[1] === "object")
            ret = args[1];
          if (typeof args[1] === "string")
            ret.defaultValue = args[1];
          if (typeof args[2] === "string")
            ret.tDescription = args[2];
          if (typeof args[2] === "object" || typeof args[3] === "object") {
            const options = args[3] || args[2];
            Object.keys(options).forEach((key2) => {
              ret[key2] = options[key2];
            });
          }
          return ret;
        },
        interpolation: {
          escapeValue: true,
          format: (value2) => value2,
          prefix: "{{",
          suffix: "}}",
          formatSeparator: ",",
          unescapePrefix: "-",
          nestingPrefix: "$t(",
          nestingSuffix: ")",
          nestingOptionsSeparator: ",",
          maxReplaces: 1e3,
          skipOnVariables: true
        }
      };
    }
    function transformOptions(options) {
      if (typeof options.ns === "string")
        options.ns = [options.ns];
      if (typeof options.fallbackLng === "string")
        options.fallbackLng = [options.fallbackLng];
      if (typeof options.fallbackNS === "string")
        options.fallbackNS = [options.fallbackNS];
      if (options.supportedLngs && options.supportedLngs.indexOf("cimode") < 0) {
        options.supportedLngs = options.supportedLngs.concat(["cimode"]);
      }
      return options;
    }
    function noop$1() {
    }
    function bindMemberFunctions(inst) {
      const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
      mems.forEach((mem) => {
        if (typeof inst[mem] === "function") {
          inst[mem] = inst[mem].bind(inst);
        }
      });
    }
    class I18n extends EventEmitter {
      constructor() {
        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        let callback = arguments.length > 1 ? arguments[1] : void 0;
        super();
        this.options = transformOptions(options);
        this.services = {};
        this.logger = baseLogger;
        this.modules = {
          external: []
        };
        bindMemberFunctions(this);
        if (callback && !this.isInitialized && !options.isClone) {
          if (!this.options.initImmediate) {
            this.init(options, callback);
            return this;
          }
          setTimeout(() => {
            this.init(options, callback);
          }, 0);
        }
      }
      init() {
        var _this = this;
        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        let callback = arguments.length > 1 ? arguments[1] : void 0;
        this.isInitializing = true;
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        if (!options.defaultNS && options.defaultNS !== false && options.ns) {
          if (typeof options.ns === "string") {
            options.defaultNS = options.ns;
          } else if (options.ns.indexOf("translation") < 0) {
            options.defaultNS = options.ns[0];
          }
        }
        const defOpts = get$1();
        this.options = {
          ...defOpts,
          ...this.options,
          ...transformOptions(options)
        };
        if (this.options.compatibilityAPI !== "v1") {
          this.options.interpolation = {
            ...defOpts.interpolation,
            ...this.options.interpolation
          };
        }
        if (options.keySeparator !== void 0) {
          this.options.userDefinedKeySeparator = options.keySeparator;
        }
        if (options.nsSeparator !== void 0) {
          this.options.userDefinedNsSeparator = options.nsSeparator;
        }
        function createClassOnDemand(ClassOrObject) {
          if (!ClassOrObject)
            return null;
          if (typeof ClassOrObject === "function")
            return new ClassOrObject();
          return ClassOrObject;
        }
        if (!this.options.isClone) {
          if (this.modules.logger) {
            baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
          } else {
            baseLogger.init(null, this.options);
          }
          let formatter;
          if (this.modules.formatter) {
            formatter = this.modules.formatter;
          } else if (typeof Intl !== "undefined") {
            formatter = Formatter;
          }
          const lu = new LanguageUtil(this.options);
          this.store = new ResourceStore(this.options.resources, this.options);
          const s2 = this.services;
          s2.logger = baseLogger;
          s2.resourceStore = this.store;
          s2.languageUtils = lu;
          s2.pluralResolver = new PluralResolver(lu, {
            prepend: this.options.pluralSeparator,
            compatibilityJSON: this.options.compatibilityJSON,
            simplifyPluralSuffix: this.options.simplifyPluralSuffix
          });
          if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
            s2.formatter = createClassOnDemand(formatter);
            s2.formatter.init(s2, this.options);
            this.options.interpolation.format = s2.formatter.format.bind(s2.formatter);
          }
          s2.interpolator = new Interpolator(this.options);
          s2.utils = {
            hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
          };
          s2.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s2.resourceStore, s2, this.options);
          s2.backendConnector.on("*", function(event) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            _this.emit(event, ...args);
          });
          if (this.modules.languageDetector) {
            s2.languageDetector = createClassOnDemand(this.modules.languageDetector);
            if (s2.languageDetector.init)
              s2.languageDetector.init(s2, this.options.detection, this.options);
          }
          if (this.modules.i18nFormat) {
            s2.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
            if (s2.i18nFormat.init)
              s2.i18nFormat.init(this);
          }
          this.translator = new Translator(this.services, this.options);
          this.translator.on("*", function(event) {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            _this.emit(event, ...args);
          });
          this.modules.external.forEach((m2) => {
            if (m2.init)
              m2.init(this);
          });
        }
        this.format = this.options.interpolation.format;
        if (!callback)
          callback = noop$1;
        if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
          const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          if (codes.length > 0 && codes[0] !== "dev")
            this.options.lng = codes[0];
        }
        if (!this.services.languageDetector && !this.options.lng) {
          this.logger.warn("init: no languageDetector is used and no lng is defined");
        }
        const storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
        storeApi.forEach((fcName) => {
          this[fcName] = function() {
            return _this.store[fcName](...arguments);
          };
        });
        const storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
        storeApiChained.forEach((fcName) => {
          this[fcName] = function() {
            _this.store[fcName](...arguments);
            return _this;
          };
        });
        const deferred = defer();
        const load = () => {
          const finish = (err, t2) => {
            this.isInitializing = false;
            if (this.isInitialized && !this.initializedStoreOnce)
              this.logger.warn("init: i18next is already initialized. You should call init just once!");
            this.isInitialized = true;
            if (!this.options.isClone)
              this.logger.log("initialized", this.options);
            this.emit("initialized", this.options);
            deferred.resolve(t2);
            callback(err, t2);
          };
          if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized)
            return finish(null, this.t.bind(this));
          this.changeLanguage(this.options.lng, finish);
        };
        if (this.options.resources || !this.options.initImmediate) {
          load();
        } else {
          setTimeout(load, 0);
        }
        return deferred;
      }
      loadResources(language) {
        let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop$1;
        let usedCallback = callback;
        const usedLng = typeof language === "string" ? language : this.language;
        if (typeof language === "function")
          usedCallback = language;
        if (!this.options.resources || this.options.partialBundledLanguages) {
          if (usedLng && usedLng.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0))
            return usedCallback();
          const toLoad = [];
          const append = (lng) => {
            if (!lng)
              return;
            if (lng === "cimode")
              return;
            const lngs = this.services.languageUtils.toResolveHierarchy(lng);
            lngs.forEach((l2) => {
              if (l2 === "cimode")
                return;
              if (toLoad.indexOf(l2) < 0)
                toLoad.push(l2);
            });
          };
          if (!usedLng) {
            const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
            fallbacks.forEach((l2) => append(l2));
          } else {
            append(usedLng);
          }
          if (this.options.preload) {
            this.options.preload.forEach((l2) => append(l2));
          }
          this.services.backendConnector.load(toLoad, this.options.ns, (e2) => {
            if (!e2 && !this.resolvedLanguage && this.language)
              this.setResolvedLanguage(this.language);
            usedCallback(e2);
          });
        } else {
          usedCallback(null);
        }
      }
      reloadResources(lngs, ns, callback) {
        const deferred = defer();
        if (!lngs)
          lngs = this.languages;
        if (!ns)
          ns = this.options.ns;
        if (!callback)
          callback = noop$1;
        this.services.backendConnector.reload(lngs, ns, (err) => {
          deferred.resolve();
          callback(err);
        });
        return deferred;
      }
      use(module2) {
        if (!module2)
          throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
        if (!module2.type)
          throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
        if (module2.type === "backend") {
          this.modules.backend = module2;
        }
        if (module2.type === "logger" || module2.log && module2.warn && module2.error) {
          this.modules.logger = module2;
        }
        if (module2.type === "languageDetector") {
          this.modules.languageDetector = module2;
        }
        if (module2.type === "i18nFormat") {
          this.modules.i18nFormat = module2;
        }
        if (module2.type === "postProcessor") {
          postProcessor.addPostProcessor(module2);
        }
        if (module2.type === "formatter") {
          this.modules.formatter = module2;
        }
        if (module2.type === "3rdParty") {
          this.modules.external.push(module2);
        }
        return this;
      }
      setResolvedLanguage(l2) {
        if (!l2 || !this.languages)
          return;
        if (["cimode", "dev"].indexOf(l2) > -1)
          return;
        for (let li2 = 0; li2 < this.languages.length; li2++) {
          const lngInLngs = this.languages[li2];
          if (["cimode", "dev"].indexOf(lngInLngs) > -1)
            continue;
          if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
            this.resolvedLanguage = lngInLngs;
            break;
          }
        }
      }
      changeLanguage(lng, callback) {
        var _this2 = this;
        this.isLanguageChangingTo = lng;
        const deferred = defer();
        this.emit("languageChanging", lng);
        const setLngProps = (l2) => {
          this.language = l2;
          this.languages = this.services.languageUtils.toResolveHierarchy(l2);
          this.resolvedLanguage = void 0;
          this.setResolvedLanguage(l2);
        };
        const done = (err, l2) => {
          if (l2) {
            setLngProps(l2);
            this.translator.changeLanguage(l2);
            this.isLanguageChangingTo = void 0;
            this.emit("languageChanged", l2);
            this.logger.log("languageChanged", l2);
          } else {
            this.isLanguageChangingTo = void 0;
          }
          deferred.resolve(function() {
            return _this2.t(...arguments);
          });
          if (callback)
            callback(err, function() {
              return _this2.t(...arguments);
            });
        };
        const setLng = (lngs) => {
          if (!lng && !lngs && this.services.languageDetector)
            lngs = [];
          const l2 = typeof lngs === "string" ? lngs : this.services.languageUtils.getBestMatchFromCodes(lngs);
          if (l2) {
            if (!this.language) {
              setLngProps(l2);
            }
            if (!this.translator.language)
              this.translator.changeLanguage(l2);
            if (this.services.languageDetector && this.services.languageDetector.cacheUserLanguage)
              this.services.languageDetector.cacheUserLanguage(l2);
          }
          this.loadResources(l2, (err) => {
            done(err, l2);
          });
        };
        if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
          setLng(this.services.languageDetector.detect());
        } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
          if (this.services.languageDetector.detect.length === 0) {
            this.services.languageDetector.detect().then(setLng);
          } else {
            this.services.languageDetector.detect(setLng);
          }
        } else {
          setLng(lng);
        }
        return deferred;
      }
      getFixedT(lng, ns, keyPrefix) {
        var _this3 = this;
        const fixedT = function(key2, opts) {
          let options;
          if (typeof opts !== "object") {
            for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
              rest[_key3 - 2] = arguments[_key3];
            }
            options = _this3.options.overloadTranslationOptionHandler([key2, opts].concat(rest));
          } else {
            options = {
              ...opts
            };
          }
          options.lng = options.lng || fixedT.lng;
          options.lngs = options.lngs || fixedT.lngs;
          options.ns = options.ns || fixedT.ns;
          options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;
          const keySeparator = _this3.options.keySeparator || ".";
          let resultKey;
          if (options.keyPrefix && Array.isArray(key2)) {
            resultKey = key2.map((k2) => `${options.keyPrefix}${keySeparator}${k2}`);
          } else {
            resultKey = options.keyPrefix ? `${options.keyPrefix}${keySeparator}${key2}` : key2;
          }
          return _this3.t(resultKey, options);
        };
        if (typeof lng === "string") {
          fixedT.lng = lng;
        } else {
          fixedT.lngs = lng;
        }
        fixedT.ns = ns;
        fixedT.keyPrefix = keyPrefix;
        return fixedT;
      }
      t() {
        return this.translator && this.translator.translate(...arguments);
      }
      exists() {
        return this.translator && this.translator.exists(...arguments);
      }
      setDefaultNamespace(ns) {
        this.options.defaultNS = ns;
      }
      hasLoadedNamespace(ns) {
        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (!this.isInitialized) {
          this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
          return false;
        }
        if (!this.languages || !this.languages.length) {
          this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
          return false;
        }
        const lng = options.lng || this.resolvedLanguage || this.languages[0];
        const fallbackLng = this.options ? this.options.fallbackLng : false;
        const lastLng = this.languages[this.languages.length - 1];
        if (lng.toLowerCase() === "cimode")
          return true;
        const loadNotPending = (l2, n2) => {
          const loadState = this.services.backendConnector.state[`${l2}|${n2}`];
          return loadState === -1 || loadState === 2;
        };
        if (options.precheck) {
          const preResult = options.precheck(this, loadNotPending);
          if (preResult !== void 0)
            return preResult;
        }
        if (this.hasResourceBundle(lng, ns))
          return true;
        if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages)
          return true;
        if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns)))
          return true;
        return false;
      }
      loadNamespaces(ns, callback) {
        const deferred = defer();
        if (!this.options.ns) {
          if (callback)
            callback();
          return Promise.resolve();
        }
        if (typeof ns === "string")
          ns = [ns];
        ns.forEach((n2) => {
          if (this.options.ns.indexOf(n2) < 0)
            this.options.ns.push(n2);
        });
        this.loadResources((err) => {
          deferred.resolve();
          if (callback)
            callback(err);
        });
        return deferred;
      }
      loadLanguages(lngs, callback) {
        const deferred = defer();
        if (typeof lngs === "string")
          lngs = [lngs];
        const preloaded = this.options.preload || [];
        const newLngs = lngs.filter((lng) => preloaded.indexOf(lng) < 0 && this.services.languageUtils.isSupportedCode(lng));
        if (!newLngs.length) {
          if (callback)
            callback();
          return Promise.resolve();
        }
        this.options.preload = preloaded.concat(newLngs);
        this.loadResources((err) => {
          deferred.resolve();
          if (callback)
            callback(err);
        });
        return deferred;
      }
      dir(lng) {
        if (!lng)
          lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
        if (!lng)
          return "rtl";
        const rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
        const languageUtils = this.services && this.services.languageUtils || new LanguageUtil(get$1());
        return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
      }
      static createInstance() {
        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        let callback = arguments.length > 1 ? arguments[1] : void 0;
        return new I18n(options, callback);
      }
      cloneInstance() {
        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop$1;
        const forkResourceStore = options.forkResourceStore;
        if (forkResourceStore)
          delete options.forkResourceStore;
        const mergedOptions = {
          ...this.options,
          ...options,
          ...{
            isClone: true
          }
        };
        const clone = new I18n(mergedOptions);
        if (options.debug !== void 0 || options.prefix !== void 0) {
          clone.logger = clone.logger.clone(options);
        }
        const membersToCopy = ["store", "services", "language"];
        membersToCopy.forEach((m2) => {
          clone[m2] = this[m2];
        });
        clone.services = {
          ...this.services
        };
        clone.services.utils = {
          hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
        };
        if (forkResourceStore) {
          clone.store = new ResourceStore(this.store.data, mergedOptions);
          clone.services.resourceStore = clone.store;
        }
        clone.translator = new Translator(clone.services, mergedOptions);
        clone.translator.on("*", function(event) {
          for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
            args[_key4 - 1] = arguments[_key4];
          }
          clone.emit(event, ...args);
        });
        clone.init(mergedOptions, callback);
        clone.translator.options = mergedOptions;
        clone.translator.backendConnector.services.utils = {
          hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
        };
        return clone;
      }
      toJSON() {
        return {
          options: this.options,
          store: this.store,
          language: this.language,
          languages: this.languages,
          resolvedLanguage: this.resolvedLanguage
        };
      }
    }
    const instance = I18n.createInstance();
    instance.createInstance = I18n.createInstance;
    instance.createInstance;
    instance.dir;
    instance.init;
    instance.loadResources;
    instance.reloadResources;
    instance.use;
    const changeLanguage = instance.changeLanguage;
    instance.getFixedT;
    instance.t;
    instance.exists;
    instance.setDefaultNamespace;
    instance.hasLoadedNamespace;
    instance.loadNamespaces;
    instance.loadLanguages;
    var voidElements = {
      "area": true,
      "base": true,
      "br": true,
      "col": true,
      "embed": true,
      "hr": true,
      "img": true,
      "input": true,
      "link": true,
      "meta": true,
      "param": true,
      "source": true,
      "track": true,
      "wbr": true
    };
    const e = /* @__PURE__ */ getDefaultExportFromCjs(voidElements);
    var t$1 = /\s([^'"/\s><]+?)[\s/>]|([^\s=]+)=\s?(".*?"|'.*?')/g;
    function n$1(n2) {
      var r2 = { type: "tag", name: "", voidElement: false, attrs: {}, children: [] }, i2 = n2.match(/<\/?([^\s]+?)[/\s>]/);
      if (i2 && (r2.name = i2[1], (e[i2[1]] || "/" === n2.charAt(n2.length - 2)) && (r2.voidElement = true), r2.name.startsWith("!--"))) {
        var s2 = n2.indexOf("-->");
        return { type: "comment", comment: -1 !== s2 ? n2.slice(4, s2) : "" };
      }
      for (var a2 = new RegExp(t$1), c2 = null; null !== (c2 = a2.exec(n2)); )
        if (c2[0].trim())
          if (c2[1]) {
            var o = c2[1].trim(), l2 = [o, ""];
            o.indexOf("=") > -1 && (l2 = o.split("=")), r2.attrs[l2[0]] = l2[1], a2.lastIndex--;
          } else
            c2[2] && (r2.attrs[c2[2]] = c2[3].trim().substring(1, c2[3].length - 1));
      return r2;
    }
    var r$1 = /<[a-zA-Z0-9\-\!\/](?:"[^"]*"|'[^']*'|[^'">])*>/g, i$1 = /^\s*$/, s = /* @__PURE__ */ Object.create(null);
    function a(e2, t2) {
      switch (t2.type) {
        case "text":
          return e2 + t2.content;
        case "tag":
          return e2 += "<" + t2.name + (t2.attrs ? function(e3) {
            var t3 = [];
            for (var n2 in e3)
              t3.push(n2 + '="' + e3[n2] + '"');
            return t3.length ? " " + t3.join(" ") : "";
          }(t2.attrs) : "") + (t2.voidElement ? "/>" : ">"), t2.voidElement ? e2 : e2 + t2.children.reduce(a, "") + "</" + t2.name + ">";
        case "comment":
          return e2 + "<!--" + t2.comment + "-->";
      }
    }
    var c = { parse: function(e2, t2) {
      t2 || (t2 = {}), t2.components || (t2.components = s);
      var a2, c2 = [], o = [], l2 = -1, m2 = false;
      if (0 !== e2.indexOf("<")) {
        var u2 = e2.indexOf("<");
        c2.push({ type: "text", content: -1 === u2 ? e2 : e2.substring(0, u2) });
      }
      return e2.replace(r$1, function(r2, s2) {
        if (m2) {
          if (r2 !== "</" + a2.name + ">")
            return;
          m2 = false;
        }
        var u3, f2 = "/" !== r2.charAt(1), h2 = r2.startsWith("<!--"), p2 = s2 + r2.length, d = e2.charAt(p2);
        if (h2) {
          var v2 = n$1(r2);
          return l2 < 0 ? (c2.push(v2), c2) : ((u3 = o[l2]).children.push(v2), c2);
        }
        if (f2 && (l2++, "tag" === (a2 = n$1(r2)).type && t2.components[a2.name] && (a2.type = "component", m2 = true), a2.voidElement || m2 || !d || "<" === d || a2.children.push({ type: "text", content: e2.slice(p2, e2.indexOf("<", p2)) }), 0 === l2 && c2.push(a2), (u3 = o[l2 - 1]) && u3.children.push(a2), o[l2] = a2), (!f2 || a2.voidElement) && (l2 > -1 && (a2.voidElement || a2.name === r2.slice(2, -1)) && (l2--, a2 = -1 === l2 ? c2 : o[l2]), !m2 && "<" !== d && d)) {
          u3 = -1 === l2 ? c2 : o[l2].children;
          var x2 = e2.indexOf("<", p2), g2 = e2.slice(p2, -1 === x2 ? void 0 : x2);
          i$1.test(g2) && (g2 = " "), (x2 > -1 && l2 + u3.length >= 0 || " " !== g2) && u3.push({ type: "text", content: g2 });
        }
      }), c2;
    }, stringify: function(e2) {
      return e2.reduce(function(e3, t2) {
        return e3 + a("", t2);
      }, "");
    } };
    function warn() {
      if (console && console.warn) {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (typeof args[0] === "string")
          args[0] = `react-i18next:: ${args[0]}`;
        console.warn(...args);
      }
    }
    const alreadyWarned = {};
    function warnOnce() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      if (typeof args[0] === "string" && alreadyWarned[args[0]])
        return;
      if (typeof args[0] === "string")
        alreadyWarned[args[0]] = /* @__PURE__ */ new Date();
      warn(...args);
    }
    const loadedClb = (i18n, cb2) => () => {
      if (i18n.isInitialized) {
        cb2();
      } else {
        const initialized = () => {
          setTimeout(() => {
            i18n.off("initialized", initialized);
          }, 0);
          cb2();
        };
        i18n.on("initialized", initialized);
      }
    };
    function loadNamespaces(i18n, ns, cb2) {
      i18n.loadNamespaces(ns, loadedClb(i18n, cb2));
    }
    function loadLanguages(i18n, lng, ns, cb2) {
      if (typeof ns === "string")
        ns = [ns];
      ns.forEach((n2) => {
        if (i18n.options.ns.indexOf(n2) < 0)
          i18n.options.ns.push(n2);
      });
      i18n.loadLanguages(lng, loadedClb(i18n, cb2));
    }
    function oldI18nextHasLoadedNamespace(ns, i18n) {
      let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      const lng = i18n.languages[0];
      const fallbackLng = i18n.options ? i18n.options.fallbackLng : false;
      const lastLng = i18n.languages[i18n.languages.length - 1];
      if (lng.toLowerCase() === "cimode")
        return true;
      const loadNotPending = (l2, n2) => {
        const loadState = i18n.services.backendConnector.state[`${l2}|${n2}`];
        return loadState === -1 || loadState === 2;
      };
      if (options.bindI18n && options.bindI18n.indexOf("languageChanging") > -1 && i18n.services.backendConnector.backend && i18n.isLanguageChangingTo && !loadNotPending(i18n.isLanguageChangingTo, ns))
        return false;
      if (i18n.hasResourceBundle(lng, ns))
        return true;
      if (!i18n.services.backendConnector.backend || i18n.options.resources && !i18n.options.partialBundledLanguages)
        return true;
      if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns)))
        return true;
      return false;
    }
    function hasLoadedNamespace(ns, i18n) {
      let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      if (!i18n.languages || !i18n.languages.length) {
        warnOnce("i18n.languages were undefined or empty", i18n.languages);
        return true;
      }
      const isNewerI18next = i18n.options.ignoreJSONStructure !== void 0;
      if (!isNewerI18next) {
        return oldI18nextHasLoadedNamespace(ns, i18n, options);
      }
      return i18n.hasLoadedNamespace(ns, {
        lng: options.lng,
        precheck: (i18nInstance2, loadNotPending) => {
          if (options.bindI18n && options.bindI18n.indexOf("languageChanging") > -1 && i18nInstance2.services.backendConnector.backend && i18nInstance2.isLanguageChangingTo && !loadNotPending(i18nInstance2.isLanguageChangingTo, ns))
            return false;
        }
      });
    }
    const matchHtmlEntity = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g;
    const htmlEntities = {
      "&amp;": "&",
      "&#38;": "&",
      "&lt;": "<",
      "&#60;": "<",
      "&gt;": ">",
      "&#62;": ">",
      "&apos;": "'",
      "&#39;": "'",
      "&quot;": '"',
      "&#34;": '"',
      "&nbsp;": " ",
      "&#160;": " ",
      "&copy;": "©",
      "&#169;": "©",
      "&reg;": "®",
      "&#174;": "®",
      "&hellip;": "…",
      "&#8230;": "…",
      "&#x2F;": "/",
      "&#47;": "/"
    };
    const unescapeHtmlEntity = (m2) => htmlEntities[m2];
    const unescape = (text2) => text2.replace(matchHtmlEntity, unescapeHtmlEntity);
    let defaultOptions$1 = {
      bindI18n: "languageChanged",
      bindI18nStore: "",
      transEmptyNodeValue: "",
      transSupportBasicHtmlNodes: true,
      transWrapTextNodes: "",
      transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
      useSuspense: true,
      unescape
    };
    function setDefaults() {
      let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      defaultOptions$1 = {
        ...defaultOptions$1,
        ...options
      };
    }
    function getDefaults$1() {
      return defaultOptions$1;
    }
    let i18nInstance;
    function setI18n(instance2) {
      i18nInstance = instance2;
    }
    function getI18n() {
      return i18nInstance;
    }
    function hasChildren(node2, checkLength) {
      if (!node2)
        return false;
      const base = node2.props ? node2.props.children : node2.children;
      if (checkLength)
        return base.length > 0;
      return !!base;
    }
    function getChildren(node2) {
      if (!node2)
        return [];
      const children = node2.props ? node2.props.children : node2.children;
      return node2.props && node2.props.i18nIsDynamicList ? getAsArray(children) : children;
    }
    function hasValidReactChildren(children) {
      if (Object.prototype.toString.call(children) !== "[object Array]")
        return false;
      return children.every((child) => reactExports.isValidElement(child));
    }
    function getAsArray(data2) {
      return Array.isArray(data2) ? data2 : [data2];
    }
    function mergeProps(source, target) {
      const newTarget = {
        ...target
      };
      newTarget.props = Object.assign(source.props, target.props);
      return newTarget;
    }
    function nodesToString(children, i18nOptions) {
      if (!children)
        return "";
      let stringNode = "";
      const childrenArray = getAsArray(children);
      const keepArray = i18nOptions.transSupportBasicHtmlNodes && i18nOptions.transKeepBasicHtmlNodesFor ? i18nOptions.transKeepBasicHtmlNodesFor : [];
      childrenArray.forEach((child, childIndex) => {
        if (typeof child === "string") {
          stringNode += `${child}`;
        } else if (reactExports.isValidElement(child)) {
          const childPropsCount = Object.keys(child.props).length;
          const shouldKeepChild = keepArray.indexOf(child.type) > -1;
          const childChildren = child.props.children;
          if (!childChildren && shouldKeepChild && childPropsCount === 0) {
            stringNode += `<${child.type}/>`;
          } else if (!childChildren && (!shouldKeepChild || childPropsCount !== 0)) {
            stringNode += `<${childIndex}></${childIndex}>`;
          } else if (child.props.i18nIsDynamicList) {
            stringNode += `<${childIndex}></${childIndex}>`;
          } else if (shouldKeepChild && childPropsCount === 1 && typeof childChildren === "string") {
            stringNode += `<${child.type}>${childChildren}</${child.type}>`;
          } else {
            const content2 = nodesToString(childChildren, i18nOptions);
            stringNode += `<${childIndex}>${content2}</${childIndex}>`;
          }
        } else if (child === null) {
          warn(`Trans: the passed in value is invalid - seems you passed in a null child.`);
        } else if (typeof child === "object") {
          const {
            format: format2,
            ...clone
          } = child;
          const keys2 = Object.keys(clone);
          if (keys2.length === 1) {
            const value2 = format2 ? `${keys2[0]}, ${format2}` : keys2[0];
            stringNode += `{{${value2}}}`;
          } else {
            warn(`react-i18next: the passed in object contained more than one variable - the object should look like {{ value, format }} where format is optional.`, child);
          }
        } else {
          warn(`Trans: the passed in value is invalid - seems you passed in a variable like {number} - please pass in variables for interpolation as full objects like {{number}}.`, child);
        }
      });
      return stringNode;
    }
    function renderNodes(children, targetString, i18n, i18nOptions, combinedTOpts, shouldUnescape) {
      if (targetString === "")
        return [];
      const keepArray = i18nOptions.transKeepBasicHtmlNodesFor || [];
      const emptyChildrenButNeedsHandling = targetString && new RegExp(keepArray.map((keep) => `<${keep}`).join("|")).test(targetString);
      if (!children && !emptyChildrenButNeedsHandling && !shouldUnescape)
        return [targetString];
      const data2 = {};
      function getData(childs) {
        const childrenArray = getAsArray(childs);
        childrenArray.forEach((child) => {
          if (typeof child === "string")
            return;
          if (hasChildren(child))
            getData(getChildren(child));
          else if (typeof child === "object" && !reactExports.isValidElement(child))
            Object.assign(data2, child);
        });
      }
      getData(children);
      const ast = c.parse(`<0>${targetString}</0>`);
      const opts = {
        ...data2,
        ...combinedTOpts
      };
      function renderInner(child, node2, rootReactNode) {
        const childs = getChildren(child);
        const mappedChildren = mapAST(childs, node2.children, rootReactNode);
        return hasValidReactChildren(childs) && mappedChildren.length === 0 || child.props && child.props.i18nIsDynamicList ? childs : mappedChildren;
      }
      function pushTranslatedJSX(child, inner, mem, i2, isVoid) {
        if (child.dummy) {
          child.children = inner;
          mem.push(reactExports.cloneElement(child, {
            key: i2
          }, isVoid ? void 0 : inner));
        } else {
          mem.push(...reactExports.Children.map([child], (c2) => {
            const props = {
              ...c2.props
            };
            delete props.i18nIsDynamicList;
            return reactExports.createElement(c2.type, {
              ...props,
              key: i2,
              ref: c2.ref
            }, isVoid ? null : inner);
          }));
        }
      }
      function mapAST(reactNode, astNode, rootReactNode) {
        const reactNodes = getAsArray(reactNode);
        const astNodes = getAsArray(astNode);
        return astNodes.reduce((mem, node2, i2) => {
          const translationContent = node2.children && node2.children[0] && node2.children[0].content && i18n.services.interpolator.interpolate(node2.children[0].content, opts, i18n.language);
          if (node2.type === "tag") {
            let tmp = reactNodes[parseInt(node2.name, 10)];
            if (rootReactNode.length === 1 && !tmp)
              tmp = rootReactNode[0][node2.name];
            if (!tmp)
              tmp = {};
            const child = Object.keys(node2.attrs).length !== 0 ? mergeProps({
              props: node2.attrs
            }, tmp) : tmp;
            const isElement2 = reactExports.isValidElement(child);
            const isValidTranslationWithChildren = isElement2 && hasChildren(node2, true) && !node2.voidElement;
            const isEmptyTransWithHTML = emptyChildrenButNeedsHandling && typeof child === "object" && child.dummy && !isElement2;
            const isKnownComponent = typeof children === "object" && children !== null && Object.hasOwnProperty.call(children, node2.name);
            if (typeof child === "string") {
              const value2 = i18n.services.interpolator.interpolate(child, opts, i18n.language);
              mem.push(value2);
            } else if (hasChildren(child) || isValidTranslationWithChildren) {
              const inner = renderInner(child, node2, rootReactNode);
              pushTranslatedJSX(child, inner, mem, i2);
            } else if (isEmptyTransWithHTML) {
              const inner = mapAST(reactNodes, node2.children, rootReactNode);
              pushTranslatedJSX(child, inner, mem, i2);
            } else if (Number.isNaN(parseFloat(node2.name))) {
              if (isKnownComponent) {
                const inner = renderInner(child, node2, rootReactNode);
                pushTranslatedJSX(child, inner, mem, i2, node2.voidElement);
              } else if (i18nOptions.transSupportBasicHtmlNodes && keepArray.indexOf(node2.name) > -1) {
                if (node2.voidElement) {
                  mem.push(reactExports.createElement(node2.name, {
                    key: `${node2.name}-${i2}`
                  }));
                } else {
                  const inner = mapAST(reactNodes, node2.children, rootReactNode);
                  mem.push(reactExports.createElement(node2.name, {
                    key: `${node2.name}-${i2}`
                  }, inner));
                }
              } else if (node2.voidElement) {
                mem.push(`<${node2.name} />`);
              } else {
                const inner = mapAST(reactNodes, node2.children, rootReactNode);
                mem.push(`<${node2.name}>${inner}</${node2.name}>`);
              }
            } else if (typeof child === "object" && !isElement2) {
              const content2 = node2.children[0] ? translationContent : null;
              if (content2)
                mem.push(content2);
            } else {
              pushTranslatedJSX(child, translationContent, mem, i2, node2.children.length !== 1 || !translationContent);
            }
          } else if (node2.type === "text") {
            const wrapTextNodes = i18nOptions.transWrapTextNodes;
            const content2 = shouldUnescape ? i18nOptions.unescape(i18n.services.interpolator.interpolate(node2.content, opts, i18n.language)) : i18n.services.interpolator.interpolate(node2.content, opts, i18n.language);
            if (wrapTextNodes) {
              mem.push(reactExports.createElement(wrapTextNodes, {
                key: `${node2.name}-${i2}`
              }, content2));
            } else {
              mem.push(content2);
            }
          }
          return mem;
        }, []);
      }
      const result = mapAST([{
        dummy: true,
        children: children || []
      }], ast, getAsArray(children || []));
      return getChildren(result[0]);
    }
    function Trans$1(_ref) {
      let {
        children,
        count,
        parent: parent2,
        i18nKey,
        context,
        tOptions = {},
        values,
        defaults: defaults2,
        components,
        ns,
        i18n: i18nFromProps,
        t: tFromProps,
        shouldUnescape,
        ...additionalProps
      } = _ref;
      const i18n = i18nFromProps || getI18n();
      if (!i18n) {
        warnOnce("You will need to pass in an i18next instance by using i18nextReactModule");
        return children;
      }
      const t2 = tFromProps || i18n.t.bind(i18n) || ((k2) => k2);
      const reactI18nextOptions = {
        ...getDefaults$1(),
        ...i18n.options && i18n.options.react
      };
      let namespaces = ns || t2.ns || i18n.options && i18n.options.defaultNS;
      namespaces = typeof namespaces === "string" ? [namespaces] : namespaces || ["translation"];
      const nodeAsString = nodesToString(children, reactI18nextOptions);
      const defaultValue = defaults2 || nodeAsString || reactI18nextOptions.transEmptyNodeValue || i18nKey;
      const {
        hashTransKey
      } = reactI18nextOptions;
      const key2 = i18nKey || (hashTransKey ? hashTransKey(nodeAsString || defaultValue) : nodeAsString || defaultValue);
      if (i18n.options && i18n.options.interpolation && i18n.options.interpolation.defaultVariables) {
        values = values && Object.keys(values).length > 0 ? {
          ...values,
          ...i18n.options.interpolation.defaultVariables
        } : {
          ...i18n.options.interpolation.defaultVariables
        };
      }
      const combinedTOpts = {
        ...tOptions,
        context: context || tOptions.context,
        count,
        ...values,
        defaultValue,
        ns: namespaces
      };
      const translation2 = key2 ? t2(key2, combinedTOpts) : defaultValue;
      if (components) {
        Object.keys(components).forEach((c2) => {
          const comp2 = components[c2];
          if (typeof comp2.type === "function" || !comp2.props || !comp2.props.children || translation2.indexOf(`${c2}/>`) < 0 && translation2.indexOf(`${c2} />`) < 0)
            return;
          function Componentized() {
            return reactExports.createElement(reactExports.Fragment, null, comp2);
          }
          components[c2] = reactExports.createElement(Componentized);
        });
      }
      const content2 = renderNodes(components || children, translation2, i18n, reactI18nextOptions, combinedTOpts, shouldUnescape);
      const useAsParent = parent2 !== void 0 ? parent2 : reactI18nextOptions.defaultTransParent;
      return useAsParent ? reactExports.createElement(useAsParent, additionalProps, content2) : content2;
    }
    const initReactI18next = {
      type: "3rdParty",
      init(instance2) {
        setDefaults(instance2.options.react);
        setI18n(instance2);
      }
    };
    const I18nContext = reactExports.createContext();
    class ReportNamespaces {
      constructor() {
        this.usedNamespaces = {};
      }
      addUsedNamespaces(namespaces) {
        namespaces.forEach((ns) => {
          if (!this.usedNamespaces[ns])
            this.usedNamespaces[ns] = true;
        });
      }
      getUsedNamespaces() {
        return Object.keys(this.usedNamespaces);
      }
    }
    function Trans(_ref) {
      let {
        children,
        count,
        parent: parent2,
        i18nKey,
        context,
        tOptions = {},
        values,
        defaults: defaults2,
        components,
        ns,
        i18n: i18nFromProps,
        t: tFromProps,
        shouldUnescape,
        ...additionalProps
      } = _ref;
      const {
        i18n: i18nFromContext,
        defaultNS: defaultNSFromContext
      } = reactExports.useContext(I18nContext) || {};
      const i18n = i18nFromProps || i18nFromContext || getI18n();
      const t2 = tFromProps || i18n && i18n.t.bind(i18n);
      return Trans$1({
        children,
        count,
        parent: parent2,
        i18nKey,
        context,
        tOptions,
        values,
        defaults: defaults2,
        components,
        ns: ns || t2 && t2.ns || defaultNSFromContext || i18n && i18n.options && i18n.options.defaultNS,
        i18n,
        t: tFromProps,
        shouldUnescape,
        ...additionalProps
      });
    }
    const usePrevious = (value2, ignore) => {
      const ref = reactExports.useRef();
      reactExports.useEffect(() => {
        ref.current = value2;
      }, [value2, ignore]);
      return ref.current;
    };
    function alwaysNewT(i18n, language, namespace, keyPrefix) {
      return i18n.getFixedT(language, namespace, keyPrefix);
    }
    function useMemoizedT(i18n, language, namespace, keyPrefix) {
      return reactExports.useCallback(alwaysNewT(i18n, language, namespace, keyPrefix), [i18n, language, namespace, keyPrefix]);
    }
    function useTranslation(ns) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const {
        i18n: i18nFromProps
      } = props;
      const {
        i18n: i18nFromContext,
        defaultNS: defaultNSFromContext
      } = reactExports.useContext(I18nContext) || {};
      const i18n = i18nFromProps || i18nFromContext || getI18n();
      if (i18n && !i18n.reportNamespaces)
        i18n.reportNamespaces = new ReportNamespaces();
      if (!i18n) {
        warnOnce("You will need to pass in an i18next instance by using initReactI18next");
        const notReadyT = (k2, optsOrDefaultValue) => {
          if (typeof optsOrDefaultValue === "string")
            return optsOrDefaultValue;
          if (optsOrDefaultValue && typeof optsOrDefaultValue === "object" && typeof optsOrDefaultValue.defaultValue === "string")
            return optsOrDefaultValue.defaultValue;
          return Array.isArray(k2) ? k2[k2.length - 1] : k2;
        };
        const retNotReady = [notReadyT, {}, false];
        retNotReady.t = notReadyT;
        retNotReady.i18n = {};
        retNotReady.ready = false;
        return retNotReady;
      }
      if (i18n.options.react && i18n.options.react.wait !== void 0)
        warnOnce("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
      const i18nOptions = {
        ...getDefaults$1(),
        ...i18n.options.react,
        ...props
      };
      const {
        useSuspense,
        keyPrefix
      } = i18nOptions;
      let namespaces = ns || defaultNSFromContext || i18n.options && i18n.options.defaultNS;
      namespaces = typeof namespaces === "string" ? [namespaces] : namespaces || ["translation"];
      if (i18n.reportNamespaces.addUsedNamespaces)
        i18n.reportNamespaces.addUsedNamespaces(namespaces);
      const ready = (i18n.isInitialized || i18n.initializedStoreOnce) && namespaces.every((n2) => hasLoadedNamespace(n2, i18n, i18nOptions));
      const memoGetT = useMemoizedT(i18n, props.lng || null, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix);
      const getT = () => memoGetT;
      const getNewT = () => alwaysNewT(i18n, props.lng || null, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix);
      const [t2, setT] = reactExports.useState(getT);
      let joinedNS = namespaces.join();
      if (props.lng)
        joinedNS = `${props.lng}${joinedNS}`;
      const previousJoinedNS = usePrevious(joinedNS);
      const isMounted = reactExports.useRef(true);
      reactExports.useEffect(() => {
        const {
          bindI18n,
          bindI18nStore
        } = i18nOptions;
        isMounted.current = true;
        if (!ready && !useSuspense) {
          if (props.lng) {
            loadLanguages(i18n, props.lng, namespaces, () => {
              if (isMounted.current)
                setT(getNewT);
            });
          } else {
            loadNamespaces(i18n, namespaces, () => {
              if (isMounted.current)
                setT(getNewT);
            });
          }
        }
        if (ready && previousJoinedNS && previousJoinedNS !== joinedNS && isMounted.current) {
          setT(getNewT);
        }
        function boundReset() {
          if (isMounted.current)
            setT(getNewT);
        }
        if (bindI18n && i18n)
          i18n.on(bindI18n, boundReset);
        if (bindI18nStore && i18n)
          i18n.store.on(bindI18nStore, boundReset);
        return () => {
          isMounted.current = false;
          if (bindI18n && i18n)
            bindI18n.split(" ").forEach((e2) => i18n.off(e2, boundReset));
          if (bindI18nStore && i18n)
            bindI18nStore.split(" ").forEach((e2) => i18n.store.off(e2, boundReset));
        };
      }, [i18n, joinedNS]);
      reactExports.useEffect(() => {
        if (isMounted.current && ready) {
          setT(getT);
        }
      }, [i18n, keyPrefix, ready]);
      const ret = [t2, i18n, ready];
      ret.t = t2;
      ret.i18n = i18n;
      ret.ready = ready;
      if (ready)
        return ret;
      if (!ready && !useSuspense)
        return ret;
      throw new Promise((resolve) => {
        if (props.lng) {
          loadLanguages(i18n, props.lng, namespaces, () => resolve());
        } else {
          loadNamespaces(i18n, namespaces, () => resolve());
        }
      });
    }
    var withSelector = { exports: {} };
    var useSyncExternalStoreWithSelector_production_min = {};
    /**
     * @license React
     * use-sync-external-store-with-selector.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var g = reactExports;
    function n(a2, b) {
      return a2 === b && (0 !== a2 || 1 / a2 === 1 / b) || a2 !== a2 && b !== b;
    }
    var p = "function" === typeof Object.is ? Object.is : n, q = g.useSyncExternalStore, r = g.useRef, t = g.useEffect, u = g.useMemo, v$2 = g.useDebugValue;
    useSyncExternalStoreWithSelector_production_min.useSyncExternalStoreWithSelector = function(a2, b, e2, l2, h2) {
      var c2 = r(null);
      if (null === c2.current) {
        var f2 = { hasValue: false, value: null };
        c2.current = f2;
      } else
        f2 = c2.current;
      c2 = u(function() {
        function a3(a4) {
          if (!c3) {
            c3 = true;
            d2 = a4;
            a4 = l2(a4);
            if (void 0 !== h2 && f2.hasValue) {
              var b2 = f2.value;
              if (h2(b2, a4))
                return k2 = b2;
            }
            return k2 = a4;
          }
          b2 = k2;
          if (p(d2, a4))
            return b2;
          var e3 = l2(a4);
          if (void 0 !== h2 && h2(b2, e3))
            return b2;
          d2 = a4;
          return k2 = e3;
        }
        var c3 = false, d2, k2, m2 = void 0 === e2 ? null : e2;
        return [function() {
          return a3(b());
        }, null === m2 ? void 0 : function() {
          return a3(m2());
        }];
      }, [b, e2, l2, h2]);
      var d = q(a2, c2[0], c2[1]);
      t(function() {
        f2.hasValue = true;
        f2.value = d;
      }, [d]);
      v$2(d);
      return d;
    };
    {
      withSelector.exports = useSyncExternalStoreWithSelector_production_min;
    }
    var withSelectorExports = withSelector.exports;
    var React = (
      // prettier-ignore
      // @ts-ignore
      "default" in React$2 ? React$1 : React$2
    );
    var ContextKey = Symbol.for(`react-redux-context`);
    var gT = typeof globalThis !== "undefined" ? globalThis : (
      /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */
      {}
    );
    function getContext() {
      if (!React.createContext)
        return {};
      const contextMap = gT[ContextKey] ?? (gT[ContextKey] = /* @__PURE__ */ new Map());
      let realContext = contextMap.get(React.createContext);
      if (!realContext) {
        realContext = React.createContext(
          null
        );
        contextMap.set(React.createContext, realContext);
      }
      return realContext;
    }
    var ReactReduxContext = /* @__PURE__ */ getContext();
    var notInitialized = () => {
      throw new Error("uSES not initialized!");
    };
    function createReduxContextHook(context = ReactReduxContext) {
      return function useReduxContext2() {
        const contextValue = React.useContext(context);
        return contextValue;
      };
    }
    var useReduxContext = /* @__PURE__ */ createReduxContextHook();
    var useSyncExternalStoreWithSelector = notInitialized;
    var initializeUseSelector = (fn) => {
      useSyncExternalStoreWithSelector = fn;
    };
    var refEquality = (a2, b) => a2 === b;
    function createSelectorHook(context = ReactReduxContext) {
      const useReduxContext2 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);
      const useSelector2 = (selector, equalityFnOrOptions = {}) => {
        const { equalityFn = refEquality, devModeChecks = {} } = typeof equalityFnOrOptions === "function" ? { equalityFn: equalityFnOrOptions } : equalityFnOrOptions;
        const {
          store: store2,
          subscription,
          getServerState,
          stabilityCheck,
          identityFunctionCheck
        } = useReduxContext2();
        React.useRef(true);
        const wrappedSelector = React.useCallback(
          {
            [selector.name](state) {
              const selected = selector(state);
              return selected;
            }
          }[selector.name],
          [selector, stabilityCheck, devModeChecks.stabilityCheck]
        );
        const selectedState = useSyncExternalStoreWithSelector(
          subscription.addNestedSub,
          store2.getState,
          getServerState || store2.getState,
          wrappedSelector,
          equalityFn
        );
        React.useDebugValue(selectedState);
        return selectedState;
      };
      Object.assign(useSelector2, {
        withTypes: () => useSelector2
      });
      return useSelector2;
    }
    var useSelector = /* @__PURE__ */ createSelectorHook();
    function defaultNoopBatch(callback) {
      callback();
    }
    function createListenerCollection() {
      let first = null;
      let last = null;
      return {
        clear() {
          first = null;
          last = null;
        },
        notify() {
          defaultNoopBatch(() => {
            let listener = first;
            while (listener) {
              listener.callback();
              listener = listener.next;
            }
          });
        },
        get() {
          const listeners = [];
          let listener = first;
          while (listener) {
            listeners.push(listener);
            listener = listener.next;
          }
          return listeners;
        },
        subscribe(callback) {
          let isSubscribed = true;
          const listener = last = {
            callback,
            next: null,
            prev: last
          };
          if (listener.prev) {
            listener.prev.next = listener;
          } else {
            first = listener;
          }
          return function unsubscribe() {
            if (!isSubscribed || first === null)
              return;
            isSubscribed = false;
            if (listener.next) {
              listener.next.prev = listener.prev;
            } else {
              last = listener.prev;
            }
            if (listener.prev) {
              listener.prev.next = listener.next;
            } else {
              first = listener.next;
            }
          };
        }
      };
    }
    var nullListeners = {
      notify() {
      },
      get: () => []
    };
    function createSubscription(store2, parentSub) {
      let unsubscribe;
      let listeners = nullListeners;
      let subscriptionsAmount = 0;
      let selfSubscribed = false;
      function addNestedSub(listener) {
        trySubscribe();
        const cleanupListener = listeners.subscribe(listener);
        let removed = false;
        return () => {
          if (!removed) {
            removed = true;
            cleanupListener();
            tryUnsubscribe();
          }
        };
      }
      function notifyNestedSubs() {
        listeners.notify();
      }
      function handleChangeWrapper() {
        if (subscription.onStateChange) {
          subscription.onStateChange();
        }
      }
      function isSubscribed() {
        return selfSubscribed;
      }
      function trySubscribe() {
        subscriptionsAmount++;
        if (!unsubscribe) {
          unsubscribe = store2.subscribe(handleChangeWrapper);
          listeners = createListenerCollection();
        }
      }
      function tryUnsubscribe() {
        subscriptionsAmount--;
        if (unsubscribe && subscriptionsAmount === 0) {
          unsubscribe();
          unsubscribe = void 0;
          listeners.clear();
          listeners = nullListeners;
        }
      }
      function trySubscribeSelf() {
        if (!selfSubscribed) {
          selfSubscribed = true;
          trySubscribe();
        }
      }
      function tryUnsubscribeSelf() {
        if (selfSubscribed) {
          selfSubscribed = false;
          tryUnsubscribe();
        }
      }
      const subscription = {
        addNestedSub,
        notifyNestedSubs,
        handleChangeWrapper,
        isSubscribed,
        trySubscribe: trySubscribeSelf,
        tryUnsubscribe: tryUnsubscribeSelf,
        getListeners: () => listeners
      };
      return subscription;
    }
    var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
    var isReactNative = typeof navigator !== "undefined" && navigator.product === "ReactNative";
    var useIsomorphicLayoutEffect$1 = canUseDOM || isReactNative ? React.useLayoutEffect : React.useEffect;
    function Provider$2({
      store: store2,
      context,
      children,
      serverState,
      stabilityCheck = "once",
      identityFunctionCheck = "once"
    }) {
      const contextValue = React.useMemo(() => {
        const subscription = createSubscription(store2);
        return {
          store: store2,
          subscription,
          getServerState: serverState ? () => serverState : void 0,
          stabilityCheck,
          identityFunctionCheck
        };
      }, [store2, serverState, stabilityCheck, identityFunctionCheck]);
      const previousState = React.useMemo(() => store2.getState(), [store2]);
      useIsomorphicLayoutEffect$1(() => {
        const { subscription } = contextValue;
        subscription.onStateChange = subscription.notifyNestedSubs;
        subscription.trySubscribe();
        if (previousState !== store2.getState()) {
          subscription.notifyNestedSubs();
        }
        return () => {
          subscription.tryUnsubscribe();
          subscription.onStateChange = void 0;
        };
      }, [contextValue, previousState]);
      const Context = context || ReactReduxContext;
      return /* @__PURE__ */ React.createElement(Context.Provider, { value: contextValue }, children);
    }
    var Provider_default = Provider$2;
    function createStoreHook(context = ReactReduxContext) {
      const useReduxContext2 = context === ReactReduxContext ? useReduxContext : (
        // @ts-ignore
        createReduxContextHook(context)
      );
      const useStore2 = () => {
        const { store: store2 } = useReduxContext2();
        return store2;
      };
      Object.assign(useStore2, {
        withTypes: () => useStore2
      });
      return useStore2;
    }
    var useStore = /* @__PURE__ */ createStoreHook();
    function createDispatchHook(context = ReactReduxContext) {
      const useStore2 = context === ReactReduxContext ? useStore : createStoreHook(context);
      const useDispatch2 = () => {
        const store2 = useStore2();
        return store2.dispatch;
      };
      Object.assign(useDispatch2, {
        withTypes: () => useDispatch2
      });
      return useDispatch2;
    }
    var useDispatch = /* @__PURE__ */ createDispatchHook();
    initializeUseSelector(withSelectorExports.useSyncExternalStoreWithSelector);
    function _classCallCheck(instance2, Constructor) {
      if (!(instance2 instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function toPrimitive$1(t2, r2) {
      if ("object" != _typeof(t2) || !t2)
        return t2;
      var e2 = t2[Symbol.toPrimitive];
      if (void 0 !== e2) {
        var i2 = e2.call(t2, r2);
        if ("object" != _typeof(i2))
          return i2;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return String(t2);
    }
    function toPropertyKey$1(t2) {
      var i2 = toPrimitive$1(t2, "string");
      return "symbol" == _typeof(i2) ? i2 : i2 + "";
    }
    function _defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, toPropertyKey$1(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    var arr = [];
    var each$1 = arr.forEach;
    var slice$1 = arr.slice;
    function defaults(obj) {
      each$1.call(slice$1.call(arguments, 1), function(source) {
        if (source) {
          for (var prop in source) {
            if (obj[prop] === void 0)
              obj[prop] = source[prop];
          }
        }
      });
      return obj;
    }
    var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    var serializeCookie = function serializeCookie2(name2, val2, options) {
      var opt = options || {};
      opt.path = opt.path || "/";
      var value2 = encodeURIComponent(val2);
      var str = "".concat(name2, "=").concat(value2);
      if (opt.maxAge > 0) {
        var maxAge = opt.maxAge - 0;
        if (Number.isNaN(maxAge))
          throw new Error("maxAge should be a Number");
        str += "; Max-Age=".concat(Math.floor(maxAge));
      }
      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain)) {
          throw new TypeError("option domain is invalid");
        }
        str += "; Domain=".concat(opt.domain);
      }
      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path)) {
          throw new TypeError("option path is invalid");
        }
        str += "; Path=".concat(opt.path);
      }
      if (opt.expires) {
        if (typeof opt.expires.toUTCString !== "function") {
          throw new TypeError("option expires is invalid");
        }
        str += "; Expires=".concat(opt.expires.toUTCString());
      }
      if (opt.httpOnly)
        str += "; HttpOnly";
      if (opt.secure)
        str += "; Secure";
      if (opt.sameSite) {
        var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case true:
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str;
    };
    var cookie = {
      create: function create(name2, value2, minutes, domain) {
        var cookieOptions = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
          path: "/",
          sameSite: "strict"
        };
        if (minutes) {
          cookieOptions.expires = /* @__PURE__ */ new Date();
          cookieOptions.expires.setTime(cookieOptions.expires.getTime() + minutes * 60 * 1e3);
        }
        if (domain)
          cookieOptions.domain = domain;
        document.cookie = serializeCookie(name2, encodeURIComponent(value2), cookieOptions);
      },
      read: function read(name2) {
        var nameEQ = "".concat(name2, "=");
        var ca2 = document.cookie.split(";");
        for (var i2 = 0; i2 < ca2.length; i2++) {
          var c2 = ca2[i2];
          while (c2.charAt(0) === " ")
            c2 = c2.substring(1, c2.length);
          if (c2.indexOf(nameEQ) === 0)
            return c2.substring(nameEQ.length, c2.length);
        }
        return null;
      },
      remove: function remove(name2) {
        this.create(name2, "", -1);
      }
    };
    var cookie$1 = {
      name: "cookie",
      lookup: function lookup2(options) {
        var found;
        if (options.lookupCookie && typeof document !== "undefined") {
          var c2 = cookie.read(options.lookupCookie);
          if (c2)
            found = c2;
        }
        return found;
      },
      cacheUserLanguage: function cacheUserLanguage(lng, options) {
        if (options.lookupCookie && typeof document !== "undefined") {
          cookie.create(options.lookupCookie, lng, options.cookieMinutes, options.cookieDomain, options.cookieOptions);
        }
      }
    };
    var querystring = {
      name: "querystring",
      lookup: function lookup2(options) {
        var found;
        if (typeof window !== "undefined") {
          var search2 = window.location.search;
          if (!window.location.search && window.location.hash && window.location.hash.indexOf("?") > -1) {
            search2 = window.location.hash.substring(window.location.hash.indexOf("?"));
          }
          var query = search2.substring(1);
          var params = query.split("&");
          for (var i2 = 0; i2 < params.length; i2++) {
            var pos = params[i2].indexOf("=");
            if (pos > 0) {
              var key2 = params[i2].substring(0, pos);
              if (key2 === options.lookupQuerystring) {
                found = params[i2].substring(pos + 1);
              }
            }
          }
        }
        return found;
      }
    };
    var hasLocalStorageSupport = null;
    var localStorageAvailable = function localStorageAvailable2() {
      if (hasLocalStorageSupport !== null)
        return hasLocalStorageSupport;
      try {
        hasLocalStorageSupport = window !== "undefined" && window.localStorage !== null;
        var testKey = "i18next.translate.boo";
        window.localStorage.setItem(testKey, "foo");
        window.localStorage.removeItem(testKey);
      } catch (e2) {
        hasLocalStorageSupport = false;
      }
      return hasLocalStorageSupport;
    };
    var localStorage = {
      name: "localStorage",
      lookup: function lookup2(options) {
        var found;
        if (options.lookupLocalStorage && localStorageAvailable()) {
          var lng = window.localStorage.getItem(options.lookupLocalStorage);
          if (lng)
            found = lng;
        }
        return found;
      },
      cacheUserLanguage: function cacheUserLanguage(lng, options) {
        if (options.lookupLocalStorage && localStorageAvailable()) {
          window.localStorage.setItem(options.lookupLocalStorage, lng);
        }
      }
    };
    var hasSessionStorageSupport = null;
    var sessionStorageAvailable = function sessionStorageAvailable2() {
      if (hasSessionStorageSupport !== null)
        return hasSessionStorageSupport;
      try {
        hasSessionStorageSupport = window !== "undefined" && window.sessionStorage !== null;
        var testKey = "i18next.translate.boo";
        window.sessionStorage.setItem(testKey, "foo");
        window.sessionStorage.removeItem(testKey);
      } catch (e2) {
        hasSessionStorageSupport = false;
      }
      return hasSessionStorageSupport;
    };
    var sessionStorage = {
      name: "sessionStorage",
      lookup: function lookup2(options) {
        var found;
        if (options.lookupSessionStorage && sessionStorageAvailable()) {
          var lng = window.sessionStorage.getItem(options.lookupSessionStorage);
          if (lng)
            found = lng;
        }
        return found;
      },
      cacheUserLanguage: function cacheUserLanguage(lng, options) {
        if (options.lookupSessionStorage && sessionStorageAvailable()) {
          window.sessionStorage.setItem(options.lookupSessionStorage, lng);
        }
      }
    };
    var navigator$1 = {
      name: "navigator",
      lookup: function lookup2(options) {
        var found = [];
        if (typeof navigator !== "undefined") {
          if (navigator.languages) {
            for (var i2 = 0; i2 < navigator.languages.length; i2++) {
              found.push(navigator.languages[i2]);
            }
          }
          if (navigator.userLanguage) {
            found.push(navigator.userLanguage);
          }
          if (navigator.language) {
            found.push(navigator.language);
          }
        }
        return found.length > 0 ? found : void 0;
      }
    };
    var htmlTag = {
      name: "htmlTag",
      lookup: function lookup2(options) {
        var found;
        var htmlTag2 = options.htmlTag || (typeof document !== "undefined" ? document.documentElement : null);
        if (htmlTag2 && typeof htmlTag2.getAttribute === "function") {
          found = htmlTag2.getAttribute("lang");
        }
        return found;
      }
    };
    var path$1 = {
      name: "path",
      lookup: function lookup2(options) {
        var found;
        if (typeof window !== "undefined") {
          var language = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
          if (language instanceof Array) {
            if (typeof options.lookupFromPathIndex === "number") {
              if (typeof language[options.lookupFromPathIndex] !== "string") {
                return void 0;
              }
              found = language[options.lookupFromPathIndex].replace("/", "");
            } else {
              found = language[0].replace("/", "");
            }
          }
        }
        return found;
      }
    };
    var subdomain = {
      name: "subdomain",
      lookup: function lookup2(options) {
        var lookupFromSubdomainIndex = typeof options.lookupFromSubdomainIndex === "number" ? options.lookupFromSubdomainIndex + 1 : 1;
        var language = typeof window !== "undefined" && window.location && window.location.hostname && window.location.hostname.match(/^(\w{2,5})\.(([a-z0-9-]{1,63}\.[a-z]{2,6})|localhost)/i);
        if (!language)
          return void 0;
        return language[lookupFromSubdomainIndex];
      }
    };
    function getDefaults() {
      return {
        order: ["querystring", "cookie", "localStorage", "sessionStorage", "navigator", "htmlTag"],
        lookupQuerystring: "lng",
        lookupCookie: "i18next",
        lookupLocalStorage: "i18nextLng",
        lookupSessionStorage: "i18nextLng",
        // cache user language
        caches: ["localStorage"],
        excludeCacheFor: ["cimode"],
        // cookieMinutes: 10,
        // cookieDomain: 'myDomain'
        convertDetectedLanguage: function convertDetectedLanguage(l2) {
          return l2;
        }
      };
    }
    var Browser = /* @__PURE__ */ function() {
      function Browser2(services) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _classCallCheck(this, Browser2);
        this.type = "languageDetector";
        this.detectors = {};
        this.init(services, options);
      }
      _createClass(Browser2, [{
        key: "init",
        value: function init2(services) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var i18nOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          this.services = services || {
            languageUtils: {}
          };
          this.options = defaults(options, this.options || {}, getDefaults());
          if (typeof this.options.convertDetectedLanguage === "string" && this.options.convertDetectedLanguage.indexOf("15897") > -1) {
            this.options.convertDetectedLanguage = function(l2) {
              return l2.replace("-", "_");
            };
          }
          if (this.options.lookupFromUrlIndex)
            this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex;
          this.i18nOptions = i18nOptions;
          this.addDetector(cookie$1);
          this.addDetector(querystring);
          this.addDetector(localStorage);
          this.addDetector(sessionStorage);
          this.addDetector(navigator$1);
          this.addDetector(htmlTag);
          this.addDetector(path$1);
          this.addDetector(subdomain);
        }
      }, {
        key: "addDetector",
        value: function addDetector(detector) {
          this.detectors[detector.name] = detector;
          return this;
        }
      }, {
        key: "detect",
        value: function detect(detectionOrder) {
          var _this = this;
          if (!detectionOrder)
            detectionOrder = this.options.order;
          var detected = [];
          detectionOrder.forEach(function(detectorName) {
            if (_this.detectors[detectorName]) {
              var lookup2 = _this.detectors[detectorName].lookup(_this.options);
              if (lookup2 && typeof lookup2 === "string")
                lookup2 = [lookup2];
              if (lookup2)
                detected = detected.concat(lookup2);
            }
          });
          detected = detected.map(function(d) {
            return _this.options.convertDetectedLanguage(d);
          });
          if (this.services.languageUtils.getBestMatchFromCodes)
            return detected;
          return detected.length > 0 ? detected[0] : null;
        }
      }, {
        key: "cacheUserLanguage",
        value: function cacheUserLanguage(lng, caches) {
          var _this2 = this;
          if (!caches)
            caches = this.options.caches;
          if (!caches)
            return;
          if (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(lng) > -1)
            return;
          caches.forEach(function(cacheName) {
            if (_this2.detectors[cacheName])
              _this2.detectors[cacheName].cacheUserLanguage(lng, _this2.options);
          });
        }
      }]);
      return Browser2;
    }();
    Browser.type = "languageDetector";
    /**
     * @remix-run/router v1.16.1
     *
     * Copyright (c) Remix Software Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     */
    function _extends$2() {
      _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key2 in source) {
            if (Object.prototype.hasOwnProperty.call(source, key2)) {
              target[key2] = source[key2];
            }
          }
        }
        return target;
      };
      return _extends$2.apply(this, arguments);
    }
    var Action;
    (function(Action2) {
      Action2["Pop"] = "POP";
      Action2["Push"] = "PUSH";
      Action2["Replace"] = "REPLACE";
    })(Action || (Action = {}));
    const PopStateEventType = "popstate";
    function createHashHistory(options) {
      if (options === void 0) {
        options = {};
      }
      function createHashLocation(window2, globalHistory) {
        let {
          pathname = "/",
          search: search2 = "",
          hash: hash2 = ""
        } = parsePath(window2.location.hash.substr(1));
        if (!pathname.startsWith("/") && !pathname.startsWith(".")) {
          pathname = "/" + pathname;
        }
        return createLocation(
          "",
          {
            pathname,
            search: search2,
            hash: hash2
          },
          // state defaults to `null` because `window.history.state` does
          globalHistory.state && globalHistory.state.usr || null,
          globalHistory.state && globalHistory.state.key || "default"
        );
      }
      function createHashHref(window2, to) {
        let base = window2.document.querySelector("base");
        let href = "";
        if (base && base.getAttribute("href")) {
          let url = window2.location.href;
          let hashIndex = url.indexOf("#");
          href = hashIndex === -1 ? url : url.slice(0, hashIndex);
        }
        return href + "#" + (typeof to === "string" ? to : createPath(to));
      }
      function validateHashLocation(location, to) {
        warning(location.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(to) + ")");
      }
      return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);
    }
    function invariant(value2, message2) {
      if (value2 === false || value2 === null || typeof value2 === "undefined") {
        throw new Error(message2);
      }
    }
    function warning(cond, message2) {
      if (!cond) {
        if (typeof console !== "undefined")
          console.warn(message2);
        try {
          throw new Error(message2);
        } catch (e2) {
        }
      }
    }
    function createKey() {
      return Math.random().toString(36).substr(2, 8);
    }
    function getHistoryState(location, index2) {
      return {
        usr: location.state,
        key: location.key,
        idx: index2
      };
    }
    function createLocation(current2, to, state, key2) {
      if (state === void 0) {
        state = null;
      }
      let location = _extends$2({
        pathname: typeof current2 === "string" ? current2 : current2.pathname,
        search: "",
        hash: ""
      }, typeof to === "string" ? parsePath(to) : to, {
        state,
        // TODO: This could be cleaned up.  push/replace should probably just take
        // full Locations now and avoid the need to run through this flow at all
        // But that's a pretty big refactor to the current test suite so going to
        // keep as is for the time being and just let any incoming keys take precedence
        key: to && to.key || key2 || createKey()
      });
      return location;
    }
    function createPath(_ref) {
      let {
        pathname = "/",
        search: search2 = "",
        hash: hash2 = ""
      } = _ref;
      if (search2 && search2 !== "?")
        pathname += search2.charAt(0) === "?" ? search2 : "?" + search2;
      if (hash2 && hash2 !== "#")
        pathname += hash2.charAt(0) === "#" ? hash2 : "#" + hash2;
      return pathname;
    }
    function parsePath(path2) {
      let parsedPath = {};
      if (path2) {
        let hashIndex = path2.indexOf("#");
        if (hashIndex >= 0) {
          parsedPath.hash = path2.substr(hashIndex);
          path2 = path2.substr(0, hashIndex);
        }
        let searchIndex = path2.indexOf("?");
        if (searchIndex >= 0) {
          parsedPath.search = path2.substr(searchIndex);
          path2 = path2.substr(0, searchIndex);
        }
        if (path2) {
          parsedPath.pathname = path2;
        }
      }
      return parsedPath;
    }
    function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
      if (options === void 0) {
        options = {};
      }
      let {
        window: window2 = document.defaultView,
        v5Compat = false
      } = options;
      let globalHistory = window2.history;
      let action = Action.Pop;
      let listener = null;
      let index2 = getIndex();
      if (index2 == null) {
        index2 = 0;
        globalHistory.replaceState(_extends$2({}, globalHistory.state, {
          idx: index2
        }), "");
      }
      function getIndex() {
        let state = globalHistory.state || {
          idx: null
        };
        return state.idx;
      }
      function handlePop() {
        action = Action.Pop;
        let nextIndex = getIndex();
        let delta = nextIndex == null ? null : nextIndex - index2;
        index2 = nextIndex;
        if (listener) {
          listener({
            action,
            location: history.location,
            delta
          });
        }
      }
      function push(to, state) {
        action = Action.Push;
        let location = createLocation(history.location, to, state);
        if (validateLocation)
          validateLocation(location, to);
        index2 = getIndex() + 1;
        let historyState = getHistoryState(location, index2);
        let url = history.createHref(location);
        try {
          globalHistory.pushState(historyState, "", url);
        } catch (error) {
          if (error instanceof DOMException && error.name === "DataCloneError") {
            throw error;
          }
          window2.location.assign(url);
        }
        if (v5Compat && listener) {
          listener({
            action,
            location: history.location,
            delta: 1
          });
        }
      }
      function replace(to, state) {
        action = Action.Replace;
        let location = createLocation(history.location, to, state);
        if (validateLocation)
          validateLocation(location, to);
        index2 = getIndex();
        let historyState = getHistoryState(location, index2);
        let url = history.createHref(location);
        globalHistory.replaceState(historyState, "", url);
        if (v5Compat && listener) {
          listener({
            action,
            location: history.location,
            delta: 0
          });
        }
      }
      function createURL(to) {
        let base = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
        let href = typeof to === "string" ? to : createPath(to);
        href = href.replace(/ $/, "%20");
        invariant(base, "No window.location.(origin|href) available to create URL for href: " + href);
        return new URL(href, base);
      }
      let history = {
        get action() {
          return action;
        },
        get location() {
          return getLocation(window2, globalHistory);
        },
        listen(fn) {
          if (listener) {
            throw new Error("A history only accepts one active listener");
          }
          window2.addEventListener(PopStateEventType, handlePop);
          listener = fn;
          return () => {
            window2.removeEventListener(PopStateEventType, handlePop);
            listener = null;
          };
        },
        createHref(to) {
          return createHref(window2, to);
        },
        createURL,
        encodeLocation(to) {
          let url = createURL(to);
          return {
            pathname: url.pathname,
            search: url.search,
            hash: url.hash
          };
        },
        push,
        replace,
        go(n2) {
          return globalHistory.go(n2);
        }
      };
      return history;
    }
    var ResultType;
    (function(ResultType2) {
      ResultType2["data"] = "data";
      ResultType2["deferred"] = "deferred";
      ResultType2["redirect"] = "redirect";
      ResultType2["error"] = "error";
    })(ResultType || (ResultType = {}));
    function matchRoutes(routes2, locationArg, basename) {
      if (basename === void 0) {
        basename = "/";
      }
      let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
      let pathname = stripBasename(location.pathname || "/", basename);
      if (pathname == null) {
        return null;
      }
      let branches = flattenRoutes(routes2);
      rankRouteBranches(branches);
      let matches = null;
      for (let i2 = 0; matches == null && i2 < branches.length; ++i2) {
        let decoded = decodePath(pathname);
        matches = matchRouteBranch(branches[i2], decoded);
      }
      return matches;
    }
    function flattenRoutes(routes2, branches, parentsMeta, parentPath) {
      if (branches === void 0) {
        branches = [];
      }
      if (parentsMeta === void 0) {
        parentsMeta = [];
      }
      if (parentPath === void 0) {
        parentPath = "";
      }
      let flattenRoute = (route2, index2, relativePath) => {
        let meta2 = {
          relativePath: relativePath === void 0 ? route2.path || "" : relativePath,
          caseSensitive: route2.caseSensitive === true,
          childrenIndex: index2,
          route: route2
        };
        if (meta2.relativePath.startsWith("/")) {
          invariant(meta2.relativePath.startsWith(parentPath), 'Absolute route path "' + meta2.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
          meta2.relativePath = meta2.relativePath.slice(parentPath.length);
        }
        let path2 = joinPaths([parentPath, meta2.relativePath]);
        let routesMeta = parentsMeta.concat(meta2);
        if (route2.children && route2.children.length > 0) {
          invariant(
            // Our types know better, but runtime JS may not!
            // @ts-expect-error
            route2.index !== true,
            "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path2 + '".')
          );
          flattenRoutes(route2.children, branches, routesMeta, path2);
        }
        if (route2.path == null && !route2.index) {
          return;
        }
        branches.push({
          path: path2,
          score: computeScore(path2, route2.index),
          routesMeta
        });
      };
      routes2.forEach((route2, index2) => {
        var _route$path;
        if (route2.path === "" || !((_route$path = route2.path) != null && _route$path.includes("?"))) {
          flattenRoute(route2, index2);
        } else {
          for (let exploded of explodeOptionalSegments(route2.path)) {
            flattenRoute(route2, index2, exploded);
          }
        }
      });
      return branches;
    }
    function explodeOptionalSegments(path2) {
      let segments = path2.split("/");
      if (segments.length === 0)
        return [];
      let [first, ...rest] = segments;
      let isOptional = first.endsWith("?");
      let required = first.replace(/\?$/, "");
      if (rest.length === 0) {
        return isOptional ? [required, ""] : [required];
      }
      let restExploded = explodeOptionalSegments(rest.join("/"));
      let result = [];
      result.push(...restExploded.map((subpath) => subpath === "" ? required : [required, subpath].join("/")));
      if (isOptional) {
        result.push(...restExploded);
      }
      return result.map((exploded) => path2.startsWith("/") && exploded === "" ? "/" : exploded);
    }
    function rankRouteBranches(branches) {
      branches.sort((a2, b) => a2.score !== b.score ? b.score - a2.score : compareIndexes(a2.routesMeta.map((meta2) => meta2.childrenIndex), b.routesMeta.map((meta2) => meta2.childrenIndex)));
    }
    const paramRe = /^:[\w-]+$/;
    const dynamicSegmentValue = 3;
    const indexRouteValue = 2;
    const emptySegmentValue = 1;
    const staticSegmentValue = 10;
    const splatPenalty = -2;
    const isSplat = (s2) => s2 === "*";
    function computeScore(path2, index2) {
      let segments = path2.split("/");
      let initialScore = segments.length;
      if (segments.some(isSplat)) {
        initialScore += splatPenalty;
      }
      if (index2) {
        initialScore += indexRouteValue;
      }
      return segments.filter((s2) => !isSplat(s2)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
    }
    function compareIndexes(a2, b) {
      let siblings = a2.length === b.length && a2.slice(0, -1).every((n2, i2) => n2 === b[i2]);
      return siblings ? (
        // If two routes are siblings, we should try to match the earlier sibling
        // first. This allows people to have fine-grained control over the matching
        // behavior by simply putting routes with identical paths in the order they
        // want them tried.
        a2[a2.length - 1] - b[b.length - 1]
      ) : (
        // Otherwise, it doesn't really make sense to rank non-siblings by index,
        // so they sort equally.
        0
      );
    }
    function matchRouteBranch(branch, pathname) {
      let {
        routesMeta
      } = branch;
      let matchedParams = {};
      let matchedPathname = "/";
      let matches = [];
      for (let i2 = 0; i2 < routesMeta.length; ++i2) {
        let meta2 = routesMeta[i2];
        let end = i2 === routesMeta.length - 1;
        let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
        let match2 = matchPath({
          path: meta2.relativePath,
          caseSensitive: meta2.caseSensitive,
          end
        }, remainingPathname);
        if (!match2)
          return null;
        Object.assign(matchedParams, match2.params);
        let route2 = meta2.route;
        matches.push({
          // TODO: Can this as be avoided?
          params: matchedParams,
          pathname: joinPaths([matchedPathname, match2.pathname]),
          pathnameBase: normalizePathname(joinPaths([matchedPathname, match2.pathnameBase])),
          route: route2
        });
        if (match2.pathnameBase !== "/") {
          matchedPathname = joinPaths([matchedPathname, match2.pathnameBase]);
        }
      }
      return matches;
    }
    function matchPath(pattern, pathname) {
      if (typeof pattern === "string") {
        pattern = {
          path: pattern,
          caseSensitive: false,
          end: true
        };
      }
      let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
      let match2 = pathname.match(matcher);
      if (!match2)
        return null;
      let matchedPathname = match2[0];
      let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
      let captureGroups = match2.slice(1);
      let params = compiledParams.reduce((memo, _ref, index2) => {
        let {
          paramName,
          isOptional
        } = _ref;
        if (paramName === "*") {
          let splatValue = captureGroups[index2] || "";
          pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
        }
        const value2 = captureGroups[index2];
        if (isOptional && !value2) {
          memo[paramName] = void 0;
        } else {
          memo[paramName] = (value2 || "").replace(/%2F/g, "/");
        }
        return memo;
      }, {});
      return {
        params,
        pathname: matchedPathname,
        pathnameBase,
        pattern
      };
    }
    function compilePath(path2, caseSensitive, end) {
      if (caseSensitive === void 0) {
        caseSensitive = false;
      }
      if (end === void 0) {
        end = true;
      }
      warning(path2 === "*" || !path2.endsWith("*") || path2.endsWith("/*"), 'Route path "' + path2 + '" will be treated as if it were ' + ('"' + path2.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path2.replace(/\*$/, "/*") + '".'));
      let params = [];
      let regexpSource = "^" + path2.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (_, paramName, isOptional) => {
        params.push({
          paramName,
          isOptional: isOptional != null
        });
        return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
      });
      if (path2.endsWith("*")) {
        params.push({
          paramName: "*"
        });
        regexpSource += path2 === "*" || path2 === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
      } else if (end) {
        regexpSource += "\\/*$";
      } else if (path2 !== "" && path2 !== "/") {
        regexpSource += "(?:(?=\\/|$))";
      } else
        ;
      let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
      return [matcher, params];
    }
    function decodePath(value2) {
      try {
        return value2.split("/").map((v2) => decodeURIComponent(v2).replace(/\//g, "%2F")).join("/");
      } catch (error) {
        warning(false, 'The URL path "' + value2 + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error + ")."));
        return value2;
      }
    }
    function stripBasename(pathname, basename) {
      if (basename === "/")
        return pathname;
      if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
        return null;
      }
      let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
      let nextChar = pathname.charAt(startIndex);
      if (nextChar && nextChar !== "/") {
        return null;
      }
      return pathname.slice(startIndex) || "/";
    }
    function resolvePath(to, fromPathname) {
      if (fromPathname === void 0) {
        fromPathname = "/";
      }
      let {
        pathname: toPathname,
        search: search2 = "",
        hash: hash2 = ""
      } = typeof to === "string" ? parsePath(to) : to;
      let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
      return {
        pathname,
        search: normalizeSearch(search2),
        hash: normalizeHash(hash2)
      };
    }
    function resolvePathname(relativePath, fromPathname) {
      let segments = fromPathname.replace(/\/+$/, "").split("/");
      let relativeSegments = relativePath.split("/");
      relativeSegments.forEach((segment) => {
        if (segment === "..") {
          if (segments.length > 1)
            segments.pop();
        } else if (segment !== ".") {
          segments.push(segment);
        }
      });
      return segments.length > 1 ? segments.join("/") : "/";
    }
    function getInvalidPathError(char, field, dest, path2) {
      return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path2) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
    }
    function getPathContributingMatches(matches) {
      return matches.filter((match2, index2) => index2 === 0 || match2.route.path && match2.route.path.length > 0);
    }
    function getResolveToMatches(matches, v7_relativeSplatPath) {
      let pathMatches = getPathContributingMatches(matches);
      if (v7_relativeSplatPath) {
        return pathMatches.map((match2, idx) => idx === matches.length - 1 ? match2.pathname : match2.pathnameBase);
      }
      return pathMatches.map((match2) => match2.pathnameBase);
    }
    function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
      if (isPathRelative === void 0) {
        isPathRelative = false;
      }
      let to;
      if (typeof toArg === "string") {
        to = parsePath(toArg);
      } else {
        to = _extends$2({}, toArg);
        invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
        invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
        invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
      }
      let isEmptyPath = toArg === "" || to.pathname === "";
      let toPathname = isEmptyPath ? "/" : to.pathname;
      let from;
      if (toPathname == null) {
        from = locationPathname;
      } else {
        let routePathnameIndex = routePathnames.length - 1;
        if (!isPathRelative && toPathname.startsWith("..")) {
          let toSegments = toPathname.split("/");
          while (toSegments[0] === "..") {
            toSegments.shift();
            routePathnameIndex -= 1;
          }
          to.pathname = toSegments.join("/");
        }
        from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
      }
      let path2 = resolvePath(to, from);
      let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
      let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
      if (!path2.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
        path2.pathname += "/";
      }
      return path2;
    }
    const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
    const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
    const normalizeSearch = (search2) => !search2 || search2 === "?" ? "" : search2.startsWith("?") ? search2 : "?" + search2;
    const normalizeHash = (hash2) => !hash2 || hash2 === "#" ? "" : hash2.startsWith("#") ? hash2 : "#" + hash2;
    function isRouteErrorResponse(error) {
      return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
    }
    const validMutationMethodsArr = ["post", "put", "patch", "delete"];
    new Set(validMutationMethodsArr);
    const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
    new Set(validRequestMethodsArr);
    /**
     * React Router v6.23.1
     *
     * Copyright (c) Remix Software Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     */
    function _extends$1() {
      _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key2 in source) {
            if (Object.prototype.hasOwnProperty.call(source, key2)) {
              target[key2] = source[key2];
            }
          }
        }
        return target;
      };
      return _extends$1.apply(this, arguments);
    }
    const DataRouterContext = /* @__PURE__ */ reactExports.createContext(null);
    const DataRouterStateContext = /* @__PURE__ */ reactExports.createContext(null);
    const NavigationContext = /* @__PURE__ */ reactExports.createContext(null);
    const LocationContext = /* @__PURE__ */ reactExports.createContext(null);
    const RouteContext = /* @__PURE__ */ reactExports.createContext({
      outlet: null,
      matches: [],
      isDataRoute: false
    });
    const RouteErrorContext = /* @__PURE__ */ reactExports.createContext(null);
    function useHref(to, _temp) {
      let {
        relative
      } = _temp === void 0 ? {} : _temp;
      !useInRouterContext() ? invariant(false) : void 0;
      let {
        basename,
        navigator: navigator2
      } = reactExports.useContext(NavigationContext);
      let {
        hash: hash2,
        pathname,
        search: search2
      } = useResolvedPath(to, {
        relative
      });
      let joinedPathname = pathname;
      if (basename !== "/") {
        joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
      }
      return navigator2.createHref({
        pathname: joinedPathname,
        search: search2,
        hash: hash2
      });
    }
    function useInRouterContext() {
      return reactExports.useContext(LocationContext) != null;
    }
    function useLocation() {
      !useInRouterContext() ? invariant(false) : void 0;
      return reactExports.useContext(LocationContext).location;
    }
    function useIsomorphicLayoutEffect(cb2) {
      let isStatic = reactExports.useContext(NavigationContext).static;
      if (!isStatic) {
        reactExports.useLayoutEffect(cb2);
      }
    }
    function useNavigate() {
      let {
        isDataRoute
      } = reactExports.useContext(RouteContext);
      return isDataRoute ? useNavigateStable() : useNavigateUnstable();
    }
    function useNavigateUnstable() {
      !useInRouterContext() ? invariant(false) : void 0;
      let dataRouterContext = reactExports.useContext(DataRouterContext);
      let {
        basename,
        future,
        navigator: navigator2
      } = reactExports.useContext(NavigationContext);
      let {
        matches
      } = reactExports.useContext(RouteContext);
      let {
        pathname: locationPathname
      } = useLocation();
      let routePathnamesJson = JSON.stringify(getResolveToMatches(matches, future.v7_relativeSplatPath));
      let activeRef = reactExports.useRef(false);
      useIsomorphicLayoutEffect(() => {
        activeRef.current = true;
      });
      let navigate = reactExports.useCallback(function(to, options) {
        if (options === void 0) {
          options = {};
        }
        if (!activeRef.current)
          return;
        if (typeof to === "number") {
          navigator2.go(to);
          return;
        }
        let path2 = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
        if (dataRouterContext == null && basename !== "/") {
          path2.pathname = path2.pathname === "/" ? basename : joinPaths([basename, path2.pathname]);
        }
        (!!options.replace ? navigator2.replace : navigator2.push)(path2, options.state, options);
      }, [basename, navigator2, routePathnamesJson, locationPathname, dataRouterContext]);
      return navigate;
    }
    const OutletContext = /* @__PURE__ */ reactExports.createContext(null);
    function useOutlet(context) {
      let outlet = reactExports.useContext(RouteContext).outlet;
      if (outlet) {
        return /* @__PURE__ */ reactExports.createElement(OutletContext.Provider, {
          value: context
        }, outlet);
      }
      return outlet;
    }
    function useParams() {
      let {
        matches
      } = reactExports.useContext(RouteContext);
      let routeMatch = matches[matches.length - 1];
      return routeMatch ? routeMatch.params : {};
    }
    function useResolvedPath(to, _temp2) {
      let {
        relative
      } = _temp2 === void 0 ? {} : _temp2;
      let {
        future
      } = reactExports.useContext(NavigationContext);
      let {
        matches
      } = reactExports.useContext(RouteContext);
      let {
        pathname: locationPathname
      } = useLocation();
      let routePathnamesJson = JSON.stringify(getResolveToMatches(matches, future.v7_relativeSplatPath));
      return reactExports.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
    }
    function useRoutes(routes2, locationArg) {
      return useRoutesImpl(routes2, locationArg);
    }
    function useRoutesImpl(routes2, locationArg, dataRouterState, future) {
      !useInRouterContext() ? invariant(false) : void 0;
      let {
        navigator: navigator2
      } = reactExports.useContext(NavigationContext);
      let {
        matches: parentMatches
      } = reactExports.useContext(RouteContext);
      let routeMatch = parentMatches[parentMatches.length - 1];
      let parentParams = routeMatch ? routeMatch.params : {};
      routeMatch ? routeMatch.pathname : "/";
      let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
      routeMatch && routeMatch.route;
      let locationFromContext = useLocation();
      let location;
      if (locationArg) {
        var _parsedLocationArg$pa;
        let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
        !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant(false) : void 0;
        location = parsedLocationArg;
      } else {
        location = locationFromContext;
      }
      let pathname = location.pathname || "/";
      let remainingPathname = pathname;
      if (parentPathnameBase !== "/") {
        let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
        let segments = pathname.replace(/^\//, "").split("/");
        remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
      }
      let matches = matchRoutes(routes2, {
        pathname: remainingPathname
      });
      let renderedMatches = _renderMatches(matches && matches.map((match2) => Object.assign({}, match2, {
        params: Object.assign({}, parentParams, match2.params),
        pathname: joinPaths([
          parentPathnameBase,
          // Re-encode pathnames that were decoded inside matchRoutes
          navigator2.encodeLocation ? navigator2.encodeLocation(match2.pathname).pathname : match2.pathname
        ]),
        pathnameBase: match2.pathnameBase === "/" ? parentPathnameBase : joinPaths([
          parentPathnameBase,
          // Re-encode pathnames that were decoded inside matchRoutes
          navigator2.encodeLocation ? navigator2.encodeLocation(match2.pathnameBase).pathname : match2.pathnameBase
        ])
      })), parentMatches, dataRouterState, future);
      if (locationArg && renderedMatches) {
        return /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
          value: {
            location: _extends$1({
              pathname: "/",
              search: "",
              hash: "",
              state: null,
              key: "default"
            }, location),
            navigationType: Action.Pop
          }
        }, renderedMatches);
      }
      return renderedMatches;
    }
    function DefaultErrorComponent() {
      let error = useRouteError();
      let message2 = isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
      let stack = error instanceof Error ? error.stack : null;
      let lightgrey = "rgba(200,200,200, 0.5)";
      let preStyles = {
        padding: "0.5rem",
        backgroundColor: lightgrey
      };
      let devInfo = null;
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ reactExports.createElement("h3", {
        style: {
          fontStyle: "italic"
        }
      }, message2), stack ? /* @__PURE__ */ reactExports.createElement("pre", {
        style: preStyles
      }, stack) : null, devInfo);
    }
    const defaultErrorElement = /* @__PURE__ */ reactExports.createElement(DefaultErrorComponent, null);
    class RenderErrorBoundary extends reactExports.Component {
      constructor(props) {
        super(props);
        this.state = {
          location: props.location,
          revalidation: props.revalidation,
          error: props.error
        };
      }
      static getDerivedStateFromError(error) {
        return {
          error
        };
      }
      static getDerivedStateFromProps(props, state) {
        if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
          return {
            error: props.error,
            location: props.location,
            revalidation: props.revalidation
          };
        }
        return {
          error: props.error !== void 0 ? props.error : state.error,
          location: state.location,
          revalidation: props.revalidation || state.revalidation
        };
      }
      componentDidCatch(error, errorInfo) {
        console.error("React Router caught the following error during render", error, errorInfo);
      }
      render() {
        return this.state.error !== void 0 ? /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
          value: this.props.routeContext
        }, /* @__PURE__ */ reactExports.createElement(RouteErrorContext.Provider, {
          value: this.state.error,
          children: this.props.component
        })) : this.props.children;
      }
    }
    function RenderedRoute(_ref) {
      let {
        routeContext,
        match: match2,
        children
      } = _ref;
      let dataRouterContext = reactExports.useContext(DataRouterContext);
      if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match2.route.errorElement || match2.route.ErrorBoundary)) {
        dataRouterContext.staticContext._deepestRenderedBoundaryId = match2.route.id;
      }
      return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
        value: routeContext
      }, children);
    }
    function _renderMatches(matches, parentMatches, dataRouterState, future) {
      var _dataRouterState2;
      if (parentMatches === void 0) {
        parentMatches = [];
      }
      if (dataRouterState === void 0) {
        dataRouterState = null;
      }
      if (future === void 0) {
        future = null;
      }
      if (matches == null) {
        var _dataRouterState;
        if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {
          matches = dataRouterState.matches;
        } else {
          return null;
        }
      }
      let renderedMatches = matches;
      let errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;
      if (errors != null) {
        let errorIndex = renderedMatches.findIndex((m2) => m2.route.id && (errors == null ? void 0 : errors[m2.route.id]) !== void 0);
        !(errorIndex >= 0) ? invariant(false) : void 0;
        renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
      }
      let renderFallback = false;
      let fallbackIndex = -1;
      if (dataRouterState && future && future.v7_partialHydration) {
        for (let i2 = 0; i2 < renderedMatches.length; i2++) {
          let match2 = renderedMatches[i2];
          if (match2.route.HydrateFallback || match2.route.hydrateFallbackElement) {
            fallbackIndex = i2;
          }
          if (match2.route.id) {
            let {
              loaderData,
              errors: errors2
            } = dataRouterState;
            let needsToRunLoader = match2.route.loader && loaderData[match2.route.id] === void 0 && (!errors2 || errors2[match2.route.id] === void 0);
            if (match2.route.lazy || needsToRunLoader) {
              renderFallback = true;
              if (fallbackIndex >= 0) {
                renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
              } else {
                renderedMatches = [renderedMatches[0]];
              }
              break;
            }
          }
        }
      }
      return renderedMatches.reduceRight((outlet, match2, index2) => {
        let error;
        let shouldRenderHydrateFallback = false;
        let errorElement = null;
        let hydrateFallbackElement = null;
        if (dataRouterState) {
          error = errors && match2.route.id ? errors[match2.route.id] : void 0;
          errorElement = match2.route.errorElement || defaultErrorElement;
          if (renderFallback) {
            if (fallbackIndex < 0 && index2 === 0) {
              shouldRenderHydrateFallback = true;
              hydrateFallbackElement = null;
            } else if (fallbackIndex === index2) {
              shouldRenderHydrateFallback = true;
              hydrateFallbackElement = match2.route.hydrateFallbackElement || null;
            }
          }
        }
        let matches2 = parentMatches.concat(renderedMatches.slice(0, index2 + 1));
        let getChildren2 = () => {
          let children;
          if (error) {
            children = errorElement;
          } else if (shouldRenderHydrateFallback) {
            children = hydrateFallbackElement;
          } else if (match2.route.Component) {
            children = /* @__PURE__ */ reactExports.createElement(match2.route.Component, null);
          } else if (match2.route.element) {
            children = match2.route.element;
          } else {
            children = outlet;
          }
          return /* @__PURE__ */ reactExports.createElement(RenderedRoute, {
            match: match2,
            routeContext: {
              outlet,
              matches: matches2,
              isDataRoute: dataRouterState != null
            },
            children
          });
        };
        return dataRouterState && (match2.route.ErrorBoundary || match2.route.errorElement || index2 === 0) ? /* @__PURE__ */ reactExports.createElement(RenderErrorBoundary, {
          location: dataRouterState.location,
          revalidation: dataRouterState.revalidation,
          component: errorElement,
          error,
          children: getChildren2(),
          routeContext: {
            outlet: null,
            matches: matches2,
            isDataRoute: true
          }
        }) : getChildren2();
      }, null);
    }
    var DataRouterHook$1 = /* @__PURE__ */ function(DataRouterHook2) {
      DataRouterHook2["UseBlocker"] = "useBlocker";
      DataRouterHook2["UseRevalidator"] = "useRevalidator";
      DataRouterHook2["UseNavigateStable"] = "useNavigate";
      return DataRouterHook2;
    }(DataRouterHook$1 || {});
    var DataRouterStateHook$1 = /* @__PURE__ */ function(DataRouterStateHook2) {
      DataRouterStateHook2["UseBlocker"] = "useBlocker";
      DataRouterStateHook2["UseLoaderData"] = "useLoaderData";
      DataRouterStateHook2["UseActionData"] = "useActionData";
      DataRouterStateHook2["UseRouteError"] = "useRouteError";
      DataRouterStateHook2["UseNavigation"] = "useNavigation";
      DataRouterStateHook2["UseRouteLoaderData"] = "useRouteLoaderData";
      DataRouterStateHook2["UseMatches"] = "useMatches";
      DataRouterStateHook2["UseRevalidator"] = "useRevalidator";
      DataRouterStateHook2["UseNavigateStable"] = "useNavigate";
      DataRouterStateHook2["UseRouteId"] = "useRouteId";
      return DataRouterStateHook2;
    }(DataRouterStateHook$1 || {});
    function useDataRouterContext(hookName) {
      let ctx = reactExports.useContext(DataRouterContext);
      !ctx ? invariant(false) : void 0;
      return ctx;
    }
    function useDataRouterState(hookName) {
      let state = reactExports.useContext(DataRouterStateContext);
      !state ? invariant(false) : void 0;
      return state;
    }
    function useRouteContext(hookName) {
      let route2 = reactExports.useContext(RouteContext);
      !route2 ? invariant(false) : void 0;
      return route2;
    }
    function useCurrentRouteId(hookName) {
      let route2 = useRouteContext();
      let thisRoute = route2.matches[route2.matches.length - 1];
      !thisRoute.route.id ? invariant(false) : void 0;
      return thisRoute.route.id;
    }
    function useRouteError() {
      var _state$errors;
      let error = reactExports.useContext(RouteErrorContext);
      let state = useDataRouterState(DataRouterStateHook$1.UseRouteError);
      let routeId = useCurrentRouteId(DataRouterStateHook$1.UseRouteError);
      if (error !== void 0) {
        return error;
      }
      return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];
    }
    function useNavigateStable() {
      let {
        router
      } = useDataRouterContext(DataRouterHook$1.UseNavigateStable);
      let id2 = useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable);
      let activeRef = reactExports.useRef(false);
      useIsomorphicLayoutEffect(() => {
        activeRef.current = true;
      });
      let navigate = reactExports.useCallback(function(to, options) {
        if (options === void 0) {
          options = {};
        }
        if (!activeRef.current)
          return;
        if (typeof to === "number") {
          router.navigate(to);
        } else {
          router.navigate(to, _extends$1({
            fromRouteId: id2
          }, options));
        }
      }, [router, id2]);
      return navigate;
    }
    function Outlet(props) {
      return useOutlet(props.context);
    }
    function Route(_props) {
      invariant(false);
    }
    function Router(_ref5) {
      let {
        basename: basenameProp = "/",
        children = null,
        location: locationProp,
        navigationType = Action.Pop,
        navigator: navigator2,
        static: staticProp = false,
        future
      } = _ref5;
      !!useInRouterContext() ? invariant(false) : void 0;
      let basename = basenameProp.replace(/^\/*/, "/");
      let navigationContext = reactExports.useMemo(() => ({
        basename,
        navigator: navigator2,
        static: staticProp,
        future: _extends$1({
          v7_relativeSplatPath: false
        }, future)
      }), [basename, future, navigator2, staticProp]);
      if (typeof locationProp === "string") {
        locationProp = parsePath(locationProp);
      }
      let {
        pathname = "/",
        search: search2 = "",
        hash: hash2 = "",
        state = null,
        key: key2 = "default"
      } = locationProp;
      let locationContext = reactExports.useMemo(() => {
        let trailingPathname = stripBasename(pathname, basename);
        if (trailingPathname == null) {
          return null;
        }
        return {
          location: {
            pathname: trailingPathname,
            search: search2,
            hash: hash2,
            state,
            key: key2
          },
          navigationType
        };
      }, [basename, pathname, search2, hash2, state, key2, navigationType]);
      if (locationContext == null) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, {
        value: navigationContext
      }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
        children,
        value: locationContext
      }));
    }
    function Routes(_ref6) {
      let {
        children,
        location
      } = _ref6;
      return useRoutes(createRoutesFromChildren(children), location);
    }
    new Promise(() => {
    });
    function createRoutesFromChildren(children, parentPath) {
      if (parentPath === void 0) {
        parentPath = [];
      }
      let routes2 = [];
      reactExports.Children.forEach(children, (element, index2) => {
        if (!/* @__PURE__ */ reactExports.isValidElement(element)) {
          return;
        }
        let treePath = [...parentPath, index2];
        if (element.type === reactExports.Fragment) {
          routes2.push.apply(routes2, createRoutesFromChildren(element.props.children, treePath));
          return;
        }
        !(element.type === Route) ? invariant(false) : void 0;
        !(!element.props.index || !element.props.children) ? invariant(false) : void 0;
        let route2 = {
          id: element.props.id || treePath.join("-"),
          caseSensitive: element.props.caseSensitive,
          element: element.props.element,
          Component: element.props.Component,
          index: element.props.index,
          path: element.props.path,
          loader: element.props.loader,
          action: element.props.action,
          errorElement: element.props.errorElement,
          ErrorBoundary: element.props.ErrorBoundary,
          hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,
          shouldRevalidate: element.props.shouldRevalidate,
          handle: element.props.handle,
          lazy: element.props.lazy
        };
        if (element.props.children) {
          route2.children = createRoutesFromChildren(element.props.children, treePath);
        }
        routes2.push(route2);
      });
      return routes2;
    }
    /**
     * React Router DOM v6.23.1
     *
     * Copyright (c) Remix Software Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     */
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key2 in source) {
            if (Object.prototype.hasOwnProperty.call(source, key2)) {
              target[key2] = source[key2];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _objectWithoutPropertiesLoose$1(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key2, i2;
      for (i2 = 0; i2 < sourceKeys.length; i2++) {
        key2 = sourceKeys[i2];
        if (excluded.indexOf(key2) >= 0)
          continue;
        target[key2] = source[key2];
      }
      return target;
    }
    function isModifiedEvent(event) {
      return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
    }
    function shouldProcessLinkClick(event, target) {
      return event.button === 0 && // Ignore everything but left clicks
      (!target || target === "_self") && // Let browser handle "target=_blank" etc.
      !isModifiedEvent(event);
    }
    function createSearchParams(init2) {
      if (init2 === void 0) {
        init2 = "";
      }
      return new URLSearchParams(typeof init2 === "string" || Array.isArray(init2) || init2 instanceof URLSearchParams ? init2 : Object.keys(init2).reduce((memo, key2) => {
        let value2 = init2[key2];
        return memo.concat(Array.isArray(value2) ? value2.map((v2) => [key2, v2]) : [[key2, value2]]);
      }, []));
    }
    function getSearchParamsForLocation(locationSearch, defaultSearchParams) {
      let searchParams = createSearchParams(locationSearch);
      if (defaultSearchParams) {
        defaultSearchParams.forEach((_, key2) => {
          if (!searchParams.has(key2)) {
            defaultSearchParams.getAll(key2).forEach((value2) => {
              searchParams.append(key2, value2);
            });
          }
        });
      }
      return searchParams;
    }
    const _excluded$2 = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "unstable_viewTransition"];
    const REACT_ROUTER_VERSION = "6";
    try {
      window.__reactRouterVersion = REACT_ROUTER_VERSION;
    } catch (e2) {
    }
    const START_TRANSITION = "startTransition";
    const startTransitionImpl = React$2[START_TRANSITION];
    function HashRouter(_ref5) {
      let {
        basename,
        children,
        future,
        window: window2
      } = _ref5;
      let historyRef = reactExports.useRef();
      if (historyRef.current == null) {
        historyRef.current = createHashHistory({
          window: window2,
          v5Compat: true
        });
      }
      let history = historyRef.current;
      let [state, setStateImpl] = reactExports.useState({
        action: history.action,
        location: history.location
      });
      let {
        v7_startTransition
      } = future || {};
      let setState = reactExports.useCallback((newState) => {
        v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
      }, [setStateImpl, v7_startTransition]);
      reactExports.useLayoutEffect(() => history.listen(setState), [history, setState]);
      return /* @__PURE__ */ reactExports.createElement(Router, {
        basename,
        children,
        location: state.location,
        navigationType: state.action,
        navigator: history,
        future
      });
    }
    const isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
    const Link$1 = /* @__PURE__ */ reactExports.forwardRef(function LinkWithRef(_ref7, ref) {
      let {
        onClick,
        relative,
        reloadDocument,
        replace,
        state,
        target,
        to,
        preventScrollReset,
        unstable_viewTransition
      } = _ref7, rest = _objectWithoutPropertiesLoose$1(_ref7, _excluded$2);
      let {
        basename
      } = reactExports.useContext(NavigationContext);
      let absoluteHref;
      let isExternal = false;
      if (typeof to === "string" && ABSOLUTE_URL_REGEX.test(to)) {
        absoluteHref = to;
        if (isBrowser) {
          try {
            let currentUrl = new URL(window.location.href);
            let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
            let path2 = stripBasename(targetUrl.pathname, basename);
            if (targetUrl.origin === currentUrl.origin && path2 != null) {
              to = path2 + targetUrl.search + targetUrl.hash;
            } else {
              isExternal = true;
            }
          } catch (e2) {
          }
        }
      }
      let href = useHref(to, {
        relative
      });
      let internalOnClick = useLinkClickHandler(to, {
        replace,
        state,
        target,
        preventScrollReset,
        relative,
        unstable_viewTransition
      });
      function handleClick(event) {
        if (onClick)
          onClick(event);
        if (!event.defaultPrevented) {
          internalOnClick(event);
        }
      }
      return (
        // eslint-disable-next-line jsx-a11y/anchor-has-content
        /* @__PURE__ */ reactExports.createElement("a", _extends({}, rest, {
          href: absoluteHref || href,
          onClick: isExternal || reloadDocument ? onClick : handleClick,
          ref,
          target
        }))
      );
    });
    var DataRouterHook;
    (function(DataRouterHook2) {
      DataRouterHook2["UseScrollRestoration"] = "useScrollRestoration";
      DataRouterHook2["UseSubmit"] = "useSubmit";
      DataRouterHook2["UseSubmitFetcher"] = "useSubmitFetcher";
      DataRouterHook2["UseFetcher"] = "useFetcher";
      DataRouterHook2["useViewTransitionState"] = "useViewTransitionState";
    })(DataRouterHook || (DataRouterHook = {}));
    var DataRouterStateHook;
    (function(DataRouterStateHook2) {
      DataRouterStateHook2["UseFetcher"] = "useFetcher";
      DataRouterStateHook2["UseFetchers"] = "useFetchers";
      DataRouterStateHook2["UseScrollRestoration"] = "useScrollRestoration";
    })(DataRouterStateHook || (DataRouterStateHook = {}));
    function useLinkClickHandler(to, _temp) {
      let {
        target,
        replace: replaceProp,
        state,
        preventScrollReset,
        relative,
        unstable_viewTransition
      } = _temp === void 0 ? {} : _temp;
      let navigate = useNavigate();
      let location = useLocation();
      let path2 = useResolvedPath(to, {
        relative
      });
      return reactExports.useCallback((event) => {
        if (shouldProcessLinkClick(event, target)) {
          event.preventDefault();
          let replace = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path2);
          navigate(to, {
            replace,
            state,
            preventScrollReset,
            relative,
            unstable_viewTransition
          });
        }
      }, [location, navigate, path2, replaceProp, state, target, to, preventScrollReset, relative, unstable_viewTransition]);
    }
    function useSearchParams(defaultInit) {
      let defaultSearchParamsRef = reactExports.useRef(createSearchParams(defaultInit));
      let hasSetSearchParamsRef = reactExports.useRef(false);
      let location = useLocation();
      let searchParams = reactExports.useMemo(() => (
        // Only merge in the defaults if we haven't yet called setSearchParams.
        // Once we call that we want those to take precedence, otherwise you can't
        // remove a param with setSearchParams({}) if it has an initial value
        getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current)
      ), [location.search]);
      let navigate = useNavigate();
      let setSearchParams = reactExports.useCallback((nextInit, navigateOptions) => {
        const newSearchParams = createSearchParams(typeof nextInit === "function" ? nextInit(searchParams) : nextInit);
        hasSetSearchParamsRef.current = true;
        navigate("?" + newSearchParams, navigateOptions);
      }, [navigate, searchParams]);
      return [searchParams, setSearchParams];
    }
    const objectToString$1 = Object.prototype.toString;
    function isError(wat) {
      switch (objectToString$1.call(wat)) {
        case "[object Error]":
        case "[object Exception]":
        case "[object DOMException]":
          return true;
        default:
          return isInstanceOf(wat, Error);
      }
    }
    function isBuiltin(wat, className) {
      return objectToString$1.call(wat) === `[object ${className}]`;
    }
    function isErrorEvent$1(wat) {
      return isBuiltin(wat, "ErrorEvent");
    }
    function isDOMError(wat) {
      return isBuiltin(wat, "DOMError");
    }
    function isDOMException(wat) {
      return isBuiltin(wat, "DOMException");
    }
    function isString(wat) {
      return isBuiltin(wat, "String");
    }
    function isParameterizedString(wat) {
      return typeof wat === "object" && wat !== null && "__sentry_template_string__" in wat && "__sentry_template_values__" in wat;
    }
    function isPrimitive(wat) {
      return wat === null || isParameterizedString(wat) || typeof wat !== "object" && typeof wat !== "function";
    }
    function isPlainObject$2(wat) {
      return isBuiltin(wat, "Object");
    }
    function isEvent(wat) {
      return typeof Event !== "undefined" && isInstanceOf(wat, Event);
    }
    function isElement(wat) {
      return typeof Element !== "undefined" && isInstanceOf(wat, Element);
    }
    function isRegExp(wat) {
      return isBuiltin(wat, "RegExp");
    }
    function isThenable(wat) {
      return Boolean(wat && wat.then && typeof wat.then === "function");
    }
    function isSyntheticEvent(wat) {
      return isPlainObject$2(wat) && "nativeEvent" in wat && "preventDefault" in wat && "stopPropagation" in wat;
    }
    function isInstanceOf(wat, base) {
      try {
        return wat instanceof base;
      } catch (_e) {
        return false;
      }
    }
    function isVueViewModel(wat) {
      return !!(typeof wat === "object" && wat !== null && (wat.__isVue || wat._isVue));
    }
    function truncate(str, max = 0) {
      if (typeof str !== "string" || max === 0) {
        return str;
      }
      return str.length <= max ? str : `${str.slice(0, max)}...`;
    }
    function safeJoin(input, delimiter) {
      if (!Array.isArray(input)) {
        return "";
      }
      const output = [];
      for (let i2 = 0; i2 < input.length; i2++) {
        const value2 = input[i2];
        try {
          if (isVueViewModel(value2)) {
            output.push("[VueViewModel]");
          } else {
            output.push(String(value2));
          }
        } catch (e2) {
          output.push("[value cannot be serialized]");
        }
      }
      return output.join(delimiter);
    }
    function isMatchingPattern(value2, pattern, requireExactStringMatch = false) {
      if (!isString(value2)) {
        return false;
      }
      if (isRegExp(pattern)) {
        return pattern.test(value2);
      }
      if (isString(pattern)) {
        return requireExactStringMatch ? value2 === pattern : value2.includes(pattern);
      }
      return false;
    }
    function stringMatchesSomePattern(testString, patterns = [], requireExactStringMatch = false) {
      return patterns.some((pattern) => isMatchingPattern(testString, pattern, requireExactStringMatch));
    }
    function applyAggregateErrorsToEvent(exceptionFromErrorImplementation, parser, maxValueLimit = 250, key2, limit, event, hint) {
      if (!event.exception || !event.exception.values || !hint || !isInstanceOf(hint.originalException, Error)) {
        return;
      }
      const originalException = event.exception.values.length > 0 ? event.exception.values[event.exception.values.length - 1] : void 0;
      if (originalException) {
        event.exception.values = truncateAggregateExceptions(
          aggregateExceptionsFromError(
            exceptionFromErrorImplementation,
            parser,
            limit,
            hint.originalException,
            key2,
            event.exception.values,
            originalException,
            0
          ),
          maxValueLimit
        );
      }
    }
    function aggregateExceptionsFromError(exceptionFromErrorImplementation, parser, limit, error, key2, prevExceptions, exception, exceptionId) {
      if (prevExceptions.length >= limit + 1) {
        return prevExceptions;
      }
      let newExceptions = [...prevExceptions];
      if (isInstanceOf(error[key2], Error)) {
        applyExceptionGroupFieldsForParentException(exception, exceptionId);
        const newException = exceptionFromErrorImplementation(parser, error[key2]);
        const newExceptionId = newExceptions.length;
        applyExceptionGroupFieldsForChildException(newException, key2, newExceptionId, exceptionId);
        newExceptions = aggregateExceptionsFromError(
          exceptionFromErrorImplementation,
          parser,
          limit,
          error[key2],
          key2,
          [newException, ...newExceptions],
          newException,
          newExceptionId
        );
      }
      if (Array.isArray(error.errors)) {
        error.errors.forEach((childError, i2) => {
          if (isInstanceOf(childError, Error)) {
            applyExceptionGroupFieldsForParentException(exception, exceptionId);
            const newException = exceptionFromErrorImplementation(parser, childError);
            const newExceptionId = newExceptions.length;
            applyExceptionGroupFieldsForChildException(newException, `errors[${i2}]`, newExceptionId, exceptionId);
            newExceptions = aggregateExceptionsFromError(
              exceptionFromErrorImplementation,
              parser,
              limit,
              childError,
              key2,
              [newException, ...newExceptions],
              newException,
              newExceptionId
            );
          }
        });
      }
      return newExceptions;
    }
    function applyExceptionGroupFieldsForParentException(exception, exceptionId) {
      exception.mechanism = exception.mechanism || { type: "generic", handled: true };
      exception.mechanism = {
        ...exception.mechanism,
        ...exception.type === "AggregateError" && { is_exception_group: true },
        exception_id: exceptionId
      };
    }
    function applyExceptionGroupFieldsForChildException(exception, source, exceptionId, parentId) {
      exception.mechanism = exception.mechanism || { type: "generic", handled: true };
      exception.mechanism = {
        ...exception.mechanism,
        type: "chained",
        source,
        exception_id: exceptionId,
        parent_id: parentId
      };
    }
    function truncateAggregateExceptions(exceptions, maxValueLength) {
      return exceptions.map((exception) => {
        if (exception.value) {
          exception.value = truncate(exception.value, maxValueLength);
        }
        return exception;
      });
    }
    const SDK_VERSION = "8.9.2";
    const GLOBAL_OBJ = globalThis;
    function getGlobalSingleton(name2, creator, obj) {
      const gbl = GLOBAL_OBJ;
      const __SENTRY__ = gbl.__SENTRY__ = gbl.__SENTRY__ || {};
      const versionedCarrier = __SENTRY__[SDK_VERSION] = __SENTRY__[SDK_VERSION] || {};
      return versionedCarrier[name2] || (versionedCarrier[name2] = creator());
    }
    const WINDOW$4 = GLOBAL_OBJ;
    const DEFAULT_MAX_STRING_LENGTH = 80;
    function htmlTreeAsString(elem2, options = {}) {
      if (!elem2) {
        return "<unknown>";
      }
      try {
        let currentElem = elem2;
        const MAX_TRAVERSE_HEIGHT = 5;
        const out = [];
        let height2 = 0;
        let len = 0;
        const separator2 = " > ";
        const sepLength = separator2.length;
        let nextStr;
        const keyAttrs = Array.isArray(options) ? options : options.keyAttrs;
        const maxStringLength = !Array.isArray(options) && options.maxStringLength || DEFAULT_MAX_STRING_LENGTH;
        while (currentElem && height2++ < MAX_TRAVERSE_HEIGHT) {
          nextStr = _htmlElementAsString(currentElem, keyAttrs);
          if (nextStr === "html" || height2 > 1 && len + out.length * sepLength + nextStr.length >= maxStringLength) {
            break;
          }
          out.push(nextStr);
          len += nextStr.length;
          currentElem = currentElem.parentNode;
        }
        return out.reverse().join(separator2);
      } catch (_oO) {
        return "<unknown>";
      }
    }
    function _htmlElementAsString(el2, keyAttrs) {
      const elem2 = el2;
      const out = [];
      let className;
      let classes;
      let key2;
      let attr;
      let i2;
      if (!elem2 || !elem2.tagName) {
        return "";
      }
      if (WINDOW$4.HTMLElement) {
        if (elem2 instanceof HTMLElement && elem2.dataset) {
          if (elem2.dataset["sentryComponent"]) {
            return elem2.dataset["sentryComponent"];
          }
          if (elem2.dataset["sentryElement"]) {
            return elem2.dataset["sentryElement"];
          }
        }
      }
      out.push(elem2.tagName.toLowerCase());
      const keyAttrPairs = keyAttrs && keyAttrs.length ? keyAttrs.filter((keyAttr) => elem2.getAttribute(keyAttr)).map((keyAttr) => [keyAttr, elem2.getAttribute(keyAttr)]) : null;
      if (keyAttrPairs && keyAttrPairs.length) {
        keyAttrPairs.forEach((keyAttrPair) => {
          out.push(`[${keyAttrPair[0]}="${keyAttrPair[1]}"]`);
        });
      } else {
        if (elem2.id) {
          out.push(`#${elem2.id}`);
        }
        className = elem2.className;
        if (className && isString(className)) {
          classes = className.split(/\s+/);
          for (i2 = 0; i2 < classes.length; i2++) {
            out.push(`.${classes[i2]}`);
          }
        }
      }
      const allowedAttrs = ["aria-label", "type", "name", "title", "alt"];
      for (i2 = 0; i2 < allowedAttrs.length; i2++) {
        key2 = allowedAttrs[i2];
        attr = elem2.getAttribute(key2);
        if (attr) {
          out.push(`[${key2}="${attr}"]`);
        }
      }
      return out.join("");
    }
    function getLocationHref() {
      try {
        return WINDOW$4.document.location.href;
      } catch (oO) {
        return "";
      }
    }
    function getComponentName(elem2) {
      if (!WINDOW$4.HTMLElement) {
        return null;
      }
      let currentElem = elem2;
      const MAX_TRAVERSE_HEIGHT = 5;
      for (let i2 = 0; i2 < MAX_TRAVERSE_HEIGHT; i2++) {
        if (!currentElem) {
          return null;
        }
        if (currentElem instanceof HTMLElement) {
          if (currentElem.dataset["sentryComponent"]) {
            return currentElem.dataset["sentryComponent"];
          }
          if (currentElem.dataset["sentryElement"]) {
            return currentElem.dataset["sentryElement"];
          }
        }
        currentElem = currentElem.parentNode;
      }
      return null;
    }
    const DEBUG_BUILD$3 = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;
    const PREFIX = "Sentry Logger ";
    const CONSOLE_LEVELS = [
      "debug",
      "info",
      "warn",
      "error",
      "log",
      "assert",
      "trace"
    ];
    const originalConsoleMethods = {};
    function consoleSandbox(callback) {
      if (!("console" in GLOBAL_OBJ)) {
        return callback();
      }
      const console2 = GLOBAL_OBJ.console;
      const wrappedFuncs = {};
      const wrappedLevels = Object.keys(originalConsoleMethods);
      wrappedLevels.forEach((level) => {
        const originalConsoleMethod = originalConsoleMethods[level];
        wrappedFuncs[level] = console2[level];
        console2[level] = originalConsoleMethod;
      });
      try {
        return callback();
      } finally {
        wrappedLevels.forEach((level) => {
          console2[level] = wrappedFuncs[level];
        });
      }
    }
    function makeLogger() {
      let enabled = false;
      const logger2 = {
        enable: () => {
          enabled = true;
        },
        disable: () => {
          enabled = false;
        },
        isEnabled: () => enabled
      };
      if (DEBUG_BUILD$3) {
        CONSOLE_LEVELS.forEach((name2) => {
          logger2[name2] = (...args) => {
            if (enabled) {
              consoleSandbox(() => {
                GLOBAL_OBJ.console[name2](`${PREFIX}[${name2}]:`, ...args);
              });
            }
          };
        });
      } else {
        CONSOLE_LEVELS.forEach((name2) => {
          logger2[name2] = () => void 0;
        });
      }
      return logger2;
    }
    const logger = makeLogger();
    const DSN_REGEX = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
    function isValidProtocol(protocol) {
      return protocol === "http" || protocol === "https";
    }
    function dsnToString(dsn, withPassword = false) {
      const { host, path: path2, pass, port, projectId, protocol, publicKey } = dsn;
      return `${protocol}://${publicKey}${withPassword && pass ? `:${pass}` : ""}@${host}${port ? `:${port}` : ""}/${path2 ? `${path2}/` : path2}${projectId}`;
    }
    function dsnFromString(str) {
      const match2 = DSN_REGEX.exec(str);
      if (!match2) {
        consoleSandbox(() => {
          console.error(`Invalid Sentry Dsn: ${str}`);
        });
        return void 0;
      }
      const [protocol, publicKey, pass = "", host, port = "", lastPath] = match2.slice(1);
      let path2 = "";
      let projectId = lastPath;
      const split = projectId.split("/");
      if (split.length > 1) {
        path2 = split.slice(0, -1).join("/");
        projectId = split.pop();
      }
      if (projectId) {
        const projectMatch = projectId.match(/^\d+/);
        if (projectMatch) {
          projectId = projectMatch[0];
        }
      }
      return dsnFromComponents({ host, pass, path: path2, projectId, port, protocol, publicKey });
    }
    function dsnFromComponents(components) {
      return {
        protocol: components.protocol,
        publicKey: components.publicKey || "",
        pass: components.pass || "",
        host: components.host,
        port: components.port || "",
        path: components.path || "",
        projectId: components.projectId
      };
    }
    function validateDsn(dsn) {
      if (!DEBUG_BUILD$3) {
        return true;
      }
      const { port, projectId, protocol } = dsn;
      const requiredComponents = ["protocol", "publicKey", "host", "projectId"];
      const hasMissingRequiredComponent = requiredComponents.find((component) => {
        if (!dsn[component]) {
          logger.error(`Invalid Sentry Dsn: ${component} missing`);
          return true;
        }
        return false;
      });
      if (hasMissingRequiredComponent) {
        return false;
      }
      if (!projectId.match(/^\d+$/)) {
        logger.error(`Invalid Sentry Dsn: Invalid projectId ${projectId}`);
        return false;
      }
      if (!isValidProtocol(protocol)) {
        logger.error(`Invalid Sentry Dsn: Invalid protocol ${protocol}`);
        return false;
      }
      if (port && isNaN(parseInt(port, 10))) {
        logger.error(`Invalid Sentry Dsn: Invalid port ${port}`);
        return false;
      }
      return true;
    }
    function makeDsn(from) {
      const components = typeof from === "string" ? dsnFromString(from) : dsnFromComponents(from);
      if (!components || !validateDsn(components)) {
        return void 0;
      }
      return components;
    }
    class SentryError extends Error {
      /** Display name of this error instance. */
      constructor(message2, logLevel = "warn") {
        super(message2);
        this.message = message2;
        this.name = new.target.prototype.constructor.name;
        Object.setPrototypeOf(this, new.target.prototype);
        this.logLevel = logLevel;
      }
    }
    function fill(source, name2, replacementFactory) {
      if (!(name2 in source)) {
        return;
      }
      const original = source[name2];
      const wrapped = replacementFactory(original);
      if (typeof wrapped === "function") {
        markFunctionWrapped(wrapped, original);
      }
      source[name2] = wrapped;
    }
    function addNonEnumerableProperty(obj, name2, value2) {
      try {
        Object.defineProperty(obj, name2, {
          // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it
          value: value2,
          writable: true,
          configurable: true
        });
      } catch (o_O) {
        DEBUG_BUILD$3 && logger.log(`Failed to add non-enumerable property "${name2}" to object`, obj);
      }
    }
    function markFunctionWrapped(wrapped, original) {
      try {
        const proto = original.prototype || {};
        wrapped.prototype = original.prototype = proto;
        addNonEnumerableProperty(wrapped, "__sentry_original__", original);
      } catch (o_O) {
      }
    }
    function getOriginalFunction(func) {
      return func.__sentry_original__;
    }
    function urlEncode(object) {
      return Object.keys(object).map((key2) => `${encodeURIComponent(key2)}=${encodeURIComponent(object[key2])}`).join("&");
    }
    function convertToPlainObject(value2) {
      if (isError(value2)) {
        return {
          message: value2.message,
          name: value2.name,
          stack: value2.stack,
          ...getOwnProperties(value2)
        };
      } else if (isEvent(value2)) {
        const newObj = {
          type: value2.type,
          target: serializeEventTarget(value2.target),
          currentTarget: serializeEventTarget(value2.currentTarget),
          ...getOwnProperties(value2)
        };
        if (typeof CustomEvent !== "undefined" && isInstanceOf(value2, CustomEvent)) {
          newObj.detail = value2.detail;
        }
        return newObj;
      } else {
        return value2;
      }
    }
    function serializeEventTarget(target) {
      try {
        return isElement(target) ? htmlTreeAsString(target) : Object.prototype.toString.call(target);
      } catch (_oO) {
        return "<unknown>";
      }
    }
    function getOwnProperties(obj) {
      if (typeof obj === "object" && obj !== null) {
        const extractedProps = {};
        for (const property2 in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, property2)) {
            extractedProps[property2] = obj[property2];
          }
        }
        return extractedProps;
      } else {
        return {};
      }
    }
    function extractExceptionKeysForMessage(exception, maxLength = 40) {
      const keys2 = Object.keys(convertToPlainObject(exception));
      keys2.sort();
      if (!keys2.length) {
        return "[object has no keys]";
      }
      if (keys2[0].length >= maxLength) {
        return truncate(keys2[0], maxLength);
      }
      for (let includedKeys = keys2.length; includedKeys > 0; includedKeys--) {
        const serialized = keys2.slice(0, includedKeys).join(", ");
        if (serialized.length > maxLength) {
          continue;
        }
        if (includedKeys === keys2.length) {
          return serialized;
        }
        return truncate(serialized, maxLength);
      }
      return "";
    }
    function dropUndefinedKeys(inputValue) {
      const memoizationMap = /* @__PURE__ */ new Map();
      return _dropUndefinedKeys(inputValue, memoizationMap);
    }
    function _dropUndefinedKeys(inputValue, memoizationMap) {
      if (isPojo(inputValue)) {
        const memoVal = memoizationMap.get(inputValue);
        if (memoVal !== void 0) {
          return memoVal;
        }
        const returnValue = {};
        memoizationMap.set(inputValue, returnValue);
        for (const key2 of Object.keys(inputValue)) {
          if (typeof inputValue[key2] !== "undefined") {
            returnValue[key2] = _dropUndefinedKeys(inputValue[key2], memoizationMap);
          }
        }
        return returnValue;
      }
      if (Array.isArray(inputValue)) {
        const memoVal = memoizationMap.get(inputValue);
        if (memoVal !== void 0) {
          return memoVal;
        }
        const returnValue = [];
        memoizationMap.set(inputValue, returnValue);
        inputValue.forEach((item) => {
          returnValue.push(_dropUndefinedKeys(item, memoizationMap));
        });
        return returnValue;
      }
      return inputValue;
    }
    function isPojo(input) {
      if (!isPlainObject$2(input)) {
        return false;
      }
      try {
        const name2 = Object.getPrototypeOf(input).constructor.name;
        return !name2 || name2 === "Object";
      } catch (e2) {
        return true;
      }
    }
    const STACKTRACE_FRAME_LIMIT$1 = 50;
    const UNKNOWN_FUNCTION = "?";
    const WEBPACK_ERROR_REGEXP = /\(error: (.*)\)/;
    const STRIP_FRAME_REGEXP = /captureMessage|captureException/;
    function createStackParser(...parsers) {
      const sortedParsers = parsers.sort((a2, b) => a2[0] - b[0]).map((p2) => p2[1]);
      return (stack, skipFirstLines = 0, framesToPop = 0) => {
        const frames2 = [];
        const lines = stack.split("\n");
        for (let i2 = skipFirstLines; i2 < lines.length; i2++) {
          const line = lines[i2];
          if (line.length > 1024) {
            continue;
          }
          const cleanedLine = WEBPACK_ERROR_REGEXP.test(line) ? line.replace(WEBPACK_ERROR_REGEXP, "$1") : line;
          if (cleanedLine.match(/\S*Error: /)) {
            continue;
          }
          for (const parser of sortedParsers) {
            const frame = parser(cleanedLine);
            if (frame) {
              frames2.push(frame);
              break;
            }
          }
          if (frames2.length >= STACKTRACE_FRAME_LIMIT$1 + framesToPop) {
            break;
          }
        }
        return stripSentryFramesAndReverse(frames2.slice(framesToPop));
      };
    }
    function stackParserFromStackParserOptions(stackParser) {
      if (Array.isArray(stackParser)) {
        return createStackParser(...stackParser);
      }
      return stackParser;
    }
    function stripSentryFramesAndReverse(stack) {
      if (!stack.length) {
        return [];
      }
      const localStack = Array.from(stack);
      if (/sentryWrapped/.test(localStack[localStack.length - 1].function || "")) {
        localStack.pop();
      }
      localStack.reverse();
      if (STRIP_FRAME_REGEXP.test(localStack[localStack.length - 1].function || "")) {
        localStack.pop();
        if (STRIP_FRAME_REGEXP.test(localStack[localStack.length - 1].function || "")) {
          localStack.pop();
        }
      }
      return localStack.slice(0, STACKTRACE_FRAME_LIMIT$1).map((frame) => ({
        ...frame,
        filename: frame.filename || localStack[localStack.length - 1].filename,
        function: frame.function || UNKNOWN_FUNCTION
      }));
    }
    const defaultFunctionName = "<anonymous>";
    function getFunctionName(fn) {
      try {
        if (!fn || typeof fn !== "function") {
          return defaultFunctionName;
        }
        return fn.name || defaultFunctionName;
      } catch (e2) {
        return defaultFunctionName;
      }
    }
    function getFramesFromEvent(event) {
      const exception = event.exception;
      if (exception) {
        const frames2 = [];
        try {
          exception.values.forEach((value2) => {
            if (value2.stacktrace.frames) {
              frames2.push(...value2.stacktrace.frames);
            }
          });
          return frames2;
        } catch (_oO) {
          return void 0;
        }
      }
      return void 0;
    }
    const handlers = {};
    const instrumented = {};
    function addHandler(type, handler) {
      handlers[type] = handlers[type] || [];
      handlers[type].push(handler);
    }
    function maybeInstrument(type, instrumentFn) {
      if (!instrumented[type]) {
        instrumentFn();
        instrumented[type] = true;
      }
    }
    function triggerHandlers(type, data2) {
      const typeHandlers = type && handlers[type];
      if (!typeHandlers) {
        return;
      }
      for (const handler of typeHandlers) {
        try {
          handler(data2);
        } catch (e2) {
          DEBUG_BUILD$3 && logger.error(
            `Error while triggering instrumentation handler.
Type: ${type}
Name: ${getFunctionName(handler)}
Error:`,
            e2
          );
        }
      }
    }
    function addConsoleInstrumentationHandler(handler) {
      const type = "console";
      addHandler(type, handler);
      maybeInstrument(type, instrumentConsole);
    }
    function instrumentConsole() {
      if (!("console" in GLOBAL_OBJ)) {
        return;
      }
      CONSOLE_LEVELS.forEach(function(level) {
        if (!(level in GLOBAL_OBJ.console)) {
          return;
        }
        fill(GLOBAL_OBJ.console, level, function(originalConsoleMethod) {
          originalConsoleMethods[level] = originalConsoleMethod;
          return function(...args) {
            const handlerData = { args, level };
            triggerHandlers("console", handlerData);
            const log = originalConsoleMethods[level];
            log && log.apply(GLOBAL_OBJ.console, args);
          };
        });
      });
    }
    const WINDOW$3 = GLOBAL_OBJ;
    function supportsFetch() {
      if (!("fetch" in WINDOW$3)) {
        return false;
      }
      try {
        new Headers();
        new Request("http://www.example.com");
        new Response();
        return true;
      } catch (e2) {
        return false;
      }
    }
    function isNativeFunction(func) {
      return func && /^function\s+\w+\(\)\s+\{\s+\[native code\]\s+\}$/.test(func.toString());
    }
    function supportsNativeFetch() {
      if (typeof EdgeRuntime === "string") {
        return true;
      }
      if (!supportsFetch()) {
        return false;
      }
      if (isNativeFunction(WINDOW$3.fetch)) {
        return true;
      }
      let result = false;
      const doc = WINDOW$3.document;
      if (doc && typeof doc.createElement === "function") {
        try {
          const sandbox = doc.createElement("iframe");
          sandbox.hidden = true;
          doc.head.appendChild(sandbox);
          if (sandbox.contentWindow && sandbox.contentWindow.fetch) {
            result = isNativeFunction(sandbox.contentWindow.fetch);
          }
          doc.head.removeChild(sandbox);
        } catch (err) {
          DEBUG_BUILD$3 && logger.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", err);
        }
      }
      return result;
    }
    const ONE_SECOND_IN_MS = 1e3;
    function dateTimestampInSeconds() {
      return Date.now() / ONE_SECOND_IN_MS;
    }
    function createUnixTimestampInSecondsFunc() {
      const { performance: performance2 } = GLOBAL_OBJ;
      if (!performance2 || !performance2.now) {
        return dateTimestampInSeconds;
      }
      const approxStartingTimeOrigin = Date.now() - performance2.now();
      const timeOrigin = performance2.timeOrigin == void 0 ? approxStartingTimeOrigin : performance2.timeOrigin;
      return () => {
        return (timeOrigin + performance2.now()) / ONE_SECOND_IN_MS;
      };
    }
    const timestampInSeconds = createUnixTimestampInSecondsFunc();
    (() => {
      const { performance: performance2 } = GLOBAL_OBJ;
      if (!performance2 || !performance2.now) {
        return void 0;
      }
      const threshold = 3600 * 1e3;
      const performanceNow = performance2.now();
      const dateNow = Date.now();
      const timeOriginDelta = performance2.timeOrigin ? Math.abs(performance2.timeOrigin + performanceNow - dateNow) : threshold;
      const timeOriginIsReliable = timeOriginDelta < threshold;
      const navigationStart = performance2.timing && performance2.timing.navigationStart;
      const hasNavigationStart = typeof navigationStart === "number";
      const navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;
      const navigationStartIsReliable = navigationStartDelta < threshold;
      if (timeOriginIsReliable || navigationStartIsReliable) {
        if (timeOriginDelta <= navigationStartDelta) {
          return performance2.timeOrigin;
        } else {
          return navigationStart;
        }
      }
      return dateNow;
    })();
    function addFetchInstrumentationHandler(handler) {
      const type = "fetch";
      addHandler(type, handler);
      maybeInstrument(type, instrumentFetch);
    }
    function instrumentFetch() {
      if (!supportsNativeFetch()) {
        return;
      }
      fill(GLOBAL_OBJ, "fetch", function(originalFetch) {
        return function(...args) {
          const { method, url } = parseFetchArgs(args);
          const handlerData = {
            args,
            fetchData: {
              method,
              url
            },
            startTimestamp: timestampInSeconds() * 1e3
          };
          triggerHandlers("fetch", {
            ...handlerData
          });
          const virtualStackTrace = new Error().stack;
          return originalFetch.apply(GLOBAL_OBJ, args).then(
            (response) => {
              const finishedHandlerData = {
                ...handlerData,
                endTimestamp: timestampInSeconds() * 1e3,
                response
              };
              triggerHandlers("fetch", finishedHandlerData);
              return response;
            },
            (error) => {
              const erroredHandlerData = {
                ...handlerData,
                endTimestamp: timestampInSeconds() * 1e3,
                error
              };
              triggerHandlers("fetch", erroredHandlerData);
              if (isError(error) && error.stack === void 0) {
                error.stack = virtualStackTrace;
                addNonEnumerableProperty(error, "framesToPop", 1);
              }
              throw error;
            }
          );
        };
      });
    }
    function hasProp(obj, prop) {
      return !!obj && typeof obj === "object" && !!obj[prop];
    }
    function getUrlFromResource(resource) {
      if (typeof resource === "string") {
        return resource;
      }
      if (!resource) {
        return "";
      }
      if (hasProp(resource, "url")) {
        return resource.url;
      }
      if (resource.toString) {
        return resource.toString();
      }
      return "";
    }
    function parseFetchArgs(fetchArgs) {
      if (fetchArgs.length === 0) {
        return { method: "GET", url: "" };
      }
      if (fetchArgs.length === 2) {
        const [url, options] = fetchArgs;
        return {
          url: getUrlFromResource(url),
          method: hasProp(options, "method") ? String(options.method).toUpperCase() : "GET"
        };
      }
      const arg = fetchArgs[0];
      return {
        url: getUrlFromResource(arg),
        method: hasProp(arg, "method") ? String(arg.method).toUpperCase() : "GET"
      };
    }
    let _oldOnErrorHandler = null;
    function addGlobalErrorInstrumentationHandler(handler) {
      const type = "error";
      addHandler(type, handler);
      maybeInstrument(type, instrumentError);
    }
    function instrumentError() {
      _oldOnErrorHandler = GLOBAL_OBJ.onerror;
      GLOBAL_OBJ.onerror = function(msg, url, line, column, error) {
        const handlerData = {
          column,
          error,
          line,
          msg,
          url
        };
        triggerHandlers("error", handlerData);
        if (_oldOnErrorHandler && !_oldOnErrorHandler.__SENTRY_LOADER__) {
          return _oldOnErrorHandler.apply(this, arguments);
        }
        return false;
      };
      GLOBAL_OBJ.onerror.__SENTRY_INSTRUMENTED__ = true;
    }
    let _oldOnUnhandledRejectionHandler = null;
    function addGlobalUnhandledRejectionInstrumentationHandler(handler) {
      const type = "unhandledrejection";
      addHandler(type, handler);
      maybeInstrument(type, instrumentUnhandledRejection);
    }
    function instrumentUnhandledRejection() {
      _oldOnUnhandledRejectionHandler = GLOBAL_OBJ.onunhandledrejection;
      GLOBAL_OBJ.onunhandledrejection = function(e2) {
        const handlerData = e2;
        triggerHandlers("unhandledrejection", handlerData);
        if (_oldOnUnhandledRejectionHandler && !_oldOnUnhandledRejectionHandler.__SENTRY_LOADER__) {
          return _oldOnUnhandledRejectionHandler.apply(this, arguments);
        }
        return true;
      };
      GLOBAL_OBJ.onunhandledrejection.__SENTRY_INSTRUMENTED__ = true;
    }
    function getSDKSource() {
      return "npm";
    }
    function memoBuilder() {
      const hasWeakSet = typeof WeakSet === "function";
      const inner = hasWeakSet ? /* @__PURE__ */ new WeakSet() : [];
      function memoize2(obj) {
        if (hasWeakSet) {
          if (inner.has(obj)) {
            return true;
          }
          inner.add(obj);
          return false;
        }
        for (let i2 = 0; i2 < inner.length; i2++) {
          const value2 = inner[i2];
          if (value2 === obj) {
            return true;
          }
        }
        inner.push(obj);
        return false;
      }
      function unmemoize(obj) {
        if (hasWeakSet) {
          inner.delete(obj);
        } else {
          for (let i2 = 0; i2 < inner.length; i2++) {
            if (inner[i2] === obj) {
              inner.splice(i2, 1);
              break;
            }
          }
        }
      }
      return [memoize2, unmemoize];
    }
    function uuid4() {
      const gbl = GLOBAL_OBJ;
      const crypto2 = gbl.crypto || gbl.msCrypto;
      let getRandomByte = () => Math.random() * 16;
      try {
        if (crypto2 && crypto2.randomUUID) {
          return crypto2.randomUUID().replace(/-/g, "");
        }
        if (crypto2 && crypto2.getRandomValues) {
          getRandomByte = () => {
            const typedArray = new Uint8Array(1);
            crypto2.getRandomValues(typedArray);
            return typedArray[0];
          };
        }
      } catch (_) {
      }
      return ("10000000100040008000" + 1e11).replace(
        /[018]/g,
        (c2) => (
          // eslint-disable-next-line no-bitwise
          (c2 ^ (getRandomByte() & 15) >> c2 / 4).toString(16)
        )
      );
    }
    function getFirstException(event) {
      return event.exception && event.exception.values ? event.exception.values[0] : void 0;
    }
    function getEventDescription(event) {
      const { message: message2, event_id: eventId } = event;
      if (message2) {
        return message2;
      }
      const firstException = getFirstException(event);
      if (firstException) {
        if (firstException.type && firstException.value) {
          return `${firstException.type}: ${firstException.value}`;
        }
        return firstException.type || firstException.value || eventId || "<unknown>";
      }
      return eventId || "<unknown>";
    }
    function addExceptionTypeValue(event, value2, type) {
      const exception = event.exception = event.exception || {};
      const values = exception.values = exception.values || [];
      const firstException = values[0] = values[0] || {};
      if (!firstException.value) {
        firstException.value = value2 || "";
      }
      if (!firstException.type) {
        firstException.type = "Error";
      }
    }
    function addExceptionMechanism(event, newMechanism) {
      const firstException = getFirstException(event);
      if (!firstException) {
        return;
      }
      const defaultMechanism = { type: "generic", handled: true };
      const currentMechanism = firstException.mechanism;
      firstException.mechanism = { ...defaultMechanism, ...currentMechanism, ...newMechanism };
      if (newMechanism && "data" in newMechanism) {
        const mergedData = { ...currentMechanism && currentMechanism.data, ...newMechanism.data };
        firstException.mechanism.data = mergedData;
      }
    }
    function checkOrSetAlreadyCaught(exception) {
      if (exception && exception.__sentry_captured__) {
        return true;
      }
      try {
        addNonEnumerableProperty(exception, "__sentry_captured__", true);
      } catch (err) {
      }
      return false;
    }
    function arrayify(maybeArray) {
      return Array.isArray(maybeArray) ? maybeArray : [maybeArray];
    }
    function normalize(input, depth = 100, maxProperties = Infinity) {
      try {
        return visit("", input, depth, maxProperties);
      } catch (err) {
        return { ERROR: `**non-serializable** (${err})` };
      }
    }
    function normalizeToSize(object, depth = 3, maxSize = 100 * 1024) {
      const normalized = normalize(object, depth);
      if (jsonSize(normalized) > maxSize) {
        return normalizeToSize(object, depth - 1, maxSize);
      }
      return normalized;
    }
    function visit(key2, value2, depth = Infinity, maxProperties = Infinity, memo = memoBuilder()) {
      const [memoize2, unmemoize] = memo;
      if (value2 == null || // this matches null and undefined -> eqeq not eqeqeq
      ["number", "boolean", "string"].includes(typeof value2) && !Number.isNaN(value2)) {
        return value2;
      }
      const stringified = stringifyValue(key2, value2);
      if (!stringified.startsWith("[object ")) {
        return stringified;
      }
      if (value2["__sentry_skip_normalization__"]) {
        return value2;
      }
      const remainingDepth = typeof value2["__sentry_override_normalization_depth__"] === "number" ? value2["__sentry_override_normalization_depth__"] : depth;
      if (remainingDepth === 0) {
        return stringified.replace("object ", "");
      }
      if (memoize2(value2)) {
        return "[Circular ~]";
      }
      const valueWithToJSON = value2;
      if (valueWithToJSON && typeof valueWithToJSON.toJSON === "function") {
        try {
          const jsonValue = valueWithToJSON.toJSON();
          return visit("", jsonValue, remainingDepth - 1, maxProperties, memo);
        } catch (err) {
        }
      }
      const normalized = Array.isArray(value2) ? [] : {};
      let numAdded = 0;
      const visitable = convertToPlainObject(value2);
      for (const visitKey in visitable) {
        if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {
          continue;
        }
        if (numAdded >= maxProperties) {
          normalized[visitKey] = "[MaxProperties ~]";
          break;
        }
        const visitValue = visitable[visitKey];
        normalized[visitKey] = visit(visitKey, visitValue, remainingDepth - 1, maxProperties, memo);
        numAdded++;
      }
      unmemoize(value2);
      return normalized;
    }
    function stringifyValue(key2, value2) {
      try {
        if (key2 === "domain" && value2 && typeof value2 === "object" && value2._events) {
          return "[Domain]";
        }
        if (key2 === "domainEmitter") {
          return "[DomainEmitter]";
        }
        if (typeof global !== "undefined" && value2 === global) {
          return "[Global]";
        }
        if (typeof window !== "undefined" && value2 === window) {
          return "[Window]";
        }
        if (typeof document !== "undefined" && value2 === document) {
          return "[Document]";
        }
        if (isVueViewModel(value2)) {
          return "[VueViewModel]";
        }
        if (isSyntheticEvent(value2)) {
          return "[SyntheticEvent]";
        }
        if (typeof value2 === "number" && value2 !== value2) {
          return "[NaN]";
        }
        if (typeof value2 === "function") {
          return `[Function: ${getFunctionName(value2)}]`;
        }
        if (typeof value2 === "symbol") {
          return `[${String(value2)}]`;
        }
        if (typeof value2 === "bigint") {
          return `[BigInt: ${String(value2)}]`;
        }
        const objName = getConstructorName(value2);
        if (/^HTML(\w*)Element$/.test(objName)) {
          return `[HTMLElement: ${objName}]`;
        }
        return `[object ${objName}]`;
      } catch (err) {
        return `**non-serializable** (${err})`;
      }
    }
    function getConstructorName(value2) {
      const prototype = Object.getPrototypeOf(value2);
      return prototype ? prototype.constructor.name : "null prototype";
    }
    function utf8Length(value2) {
      return ~-encodeURI(value2).split(/%..|./).length;
    }
    function jsonSize(value2) {
      return utf8Length(JSON.stringify(value2));
    }
    var States;
    (function(States2) {
      const PENDING = 0;
      States2[States2["PENDING"] = PENDING] = "PENDING";
      const RESOLVED = 1;
      States2[States2["RESOLVED"] = RESOLVED] = "RESOLVED";
      const REJECTED = 2;
      States2[States2["REJECTED"] = REJECTED] = "REJECTED";
    })(States || (States = {}));
    function resolvedSyncPromise(value2) {
      return new SyncPromise((resolve) => {
        resolve(value2);
      });
    }
    function rejectedSyncPromise(reason) {
      return new SyncPromise((_, reject) => {
        reject(reason);
      });
    }
    class SyncPromise {
      constructor(executor) {
        SyncPromise.prototype.__init.call(this);
        SyncPromise.prototype.__init2.call(this);
        SyncPromise.prototype.__init3.call(this);
        SyncPromise.prototype.__init4.call(this);
        this._state = States.PENDING;
        this._handlers = [];
        try {
          executor(this._resolve, this._reject);
        } catch (e2) {
          this._reject(e2);
        }
      }
      /** JSDoc */
      then(onfulfilled, onrejected) {
        return new SyncPromise((resolve, reject) => {
          this._handlers.push([
            false,
            (result) => {
              if (!onfulfilled) {
                resolve(result);
              } else {
                try {
                  resolve(onfulfilled(result));
                } catch (e2) {
                  reject(e2);
                }
              }
            },
            (reason) => {
              if (!onrejected) {
                reject(reason);
              } else {
                try {
                  resolve(onrejected(reason));
                } catch (e2) {
                  reject(e2);
                }
              }
            }
          ]);
          this._executeHandlers();
        });
      }
      /** JSDoc */
      catch(onrejected) {
        return this.then((val2) => val2, onrejected);
      }
      /** JSDoc */
      finally(onfinally) {
        return new SyncPromise((resolve, reject) => {
          let val2;
          let isRejected;
          return this.then(
            (value2) => {
              isRejected = false;
              val2 = value2;
              if (onfinally) {
                onfinally();
              }
            },
            (reason) => {
              isRejected = true;
              val2 = reason;
              if (onfinally) {
                onfinally();
              }
            }
          ).then(() => {
            if (isRejected) {
              reject(val2);
              return;
            }
            resolve(val2);
          });
        });
      }
      /** JSDoc */
      __init() {
        this._resolve = (value2) => {
          this._setResult(States.RESOLVED, value2);
        };
      }
      /** JSDoc */
      __init2() {
        this._reject = (reason) => {
          this._setResult(States.REJECTED, reason);
        };
      }
      /** JSDoc */
      __init3() {
        this._setResult = (state, value2) => {
          if (this._state !== States.PENDING) {
            return;
          }
          if (isThenable(value2)) {
            void value2.then(this._resolve, this._reject);
            return;
          }
          this._state = state;
          this._value = value2;
          this._executeHandlers();
        };
      }
      /** JSDoc */
      __init4() {
        this._executeHandlers = () => {
          if (this._state === States.PENDING) {
            return;
          }
          const cachedHandlers = this._handlers.slice();
          this._handlers = [];
          cachedHandlers.forEach((handler) => {
            if (handler[0]) {
              return;
            }
            if (this._state === States.RESOLVED) {
              handler[1](this._value);
            }
            if (this._state === States.REJECTED) {
              handler[2](this._value);
            }
            handler[0] = true;
          });
        };
      }
    }
    function makePromiseBuffer(limit) {
      const buffer = [];
      function isReady() {
        return limit === void 0 || buffer.length < limit;
      }
      function remove(task) {
        return buffer.splice(buffer.indexOf(task), 1)[0];
      }
      function add2(taskProducer) {
        if (!isReady()) {
          return rejectedSyncPromise(new SentryError("Not adding Promise because buffer limit was reached."));
        }
        const task = taskProducer();
        if (buffer.indexOf(task) === -1) {
          buffer.push(task);
        }
        void task.then(() => remove(task)).then(
          null,
          () => remove(task).then(null, () => {
          })
        );
        return task;
      }
      function drain(timeout) {
        return new SyncPromise((resolve, reject) => {
          let counter = buffer.length;
          if (!counter) {
            return resolve(true);
          }
          const capturedSetTimeout = setTimeout(() => {
            if (timeout && timeout > 0) {
              resolve(false);
            }
          }, timeout);
          buffer.forEach((item) => {
            void resolvedSyncPromise(item).then(() => {
              if (!--counter) {
                clearTimeout(capturedSetTimeout);
                resolve(true);
              }
            }, reject);
          });
        });
      }
      return {
        $: buffer,
        add: add2,
        drain
      };
    }
    function parseUrl$1(url) {
      if (!url) {
        return {};
      }
      const match2 = url.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
      if (!match2) {
        return {};
      }
      const query = match2[6] || "";
      const fragment = match2[8] || "";
      return {
        host: match2[4],
        path: match2[5],
        protocol: match2[2],
        search: query,
        hash: fragment,
        relative: match2[5] + query + fragment
        // everything minus origin
      };
    }
    const validSeverityLevels = ["fatal", "error", "warning", "log", "info", "debug"];
    function severityLevelFromString(level) {
      return level === "warn" ? "warning" : validSeverityLevels.includes(level) ? level : "log";
    }
    function filenameIsInApp(filename, isNative = false) {
      const isInternal = isNative || filename && // It's not internal if it's an absolute linux path
      !filename.startsWith("/") && // It's not internal if it's an absolute windows path
      !filename.match(/^[A-Z]:/) && // It's not internal if the path is starting with a dot
      !filename.startsWith(".") && // It's not internal if the frame has a protocol. In node, this is usually the case if the file got pre-processed with a bundler like webpack
      !filename.match(/^[a-zA-Z]([a-zA-Z0-9.\-+])*:\/\//);
      return !isInternal && filename !== void 0 && !filename.includes("node_modules/");
    }
    function node$1(getModule) {
      const FILENAME_MATCH = /^\s*[-]{4,}$/;
      const FULL_MATCH = /at (?:async )?(?:(.+?)\s+\()?(?:(.+):(\d+):(\d+)?|([^)]+))\)?/;
      return (line) => {
        const lineMatch = line.match(FULL_MATCH);
        if (lineMatch) {
          let object;
          let method;
          let functionName;
          let typeName;
          let methodName;
          if (lineMatch[1]) {
            functionName = lineMatch[1];
            let methodStart = functionName.lastIndexOf(".");
            if (functionName[methodStart - 1] === ".") {
              methodStart--;
            }
            if (methodStart > 0) {
              object = functionName.slice(0, methodStart);
              method = functionName.slice(methodStart + 1);
              const objectEnd = object.indexOf(".Module");
              if (objectEnd > 0) {
                functionName = functionName.slice(objectEnd + 1);
                object = object.slice(0, objectEnd);
              }
            }
            typeName = void 0;
          }
          if (method) {
            typeName = object;
            methodName = method;
          }
          if (method === "<anonymous>") {
            methodName = void 0;
            functionName = void 0;
          }
          if (functionName === void 0) {
            methodName = methodName || UNKNOWN_FUNCTION;
            functionName = typeName ? `${typeName}.${methodName}` : methodName;
          }
          let filename = lineMatch[2] && lineMatch[2].startsWith("file://") ? lineMatch[2].slice(7) : lineMatch[2];
          const isNative = lineMatch[5] === "native";
          if (filename && filename.match(/\/[A-Z]:/)) {
            filename = filename.slice(1);
          }
          if (!filename && lineMatch[5] && !isNative) {
            filename = lineMatch[5];
          }
          return {
            filename,
            module: void 0,
            function: functionName,
            lineno: parseInt(lineMatch[3], 10) || void 0,
            colno: parseInt(lineMatch[4], 10) || void 0,
            in_app: filenameIsInApp(filename, isNative)
          };
        }
        if (line.match(FILENAME_MATCH)) {
          return {
            filename: line
          };
        }
        return void 0;
      };
    }
    function nodeStackLineParser(getModule) {
      return [90, node$1()];
    }
    function createEnvelope(headers, items = []) {
      return [headers, items];
    }
    function addItemToEnvelope(envelope, newItem) {
      const [headers, items] = envelope;
      return [headers, [...items, newItem]];
    }
    function forEachEnvelopeItem(envelope, callback) {
      const envelopeItems = envelope[1];
      for (const envelopeItem of envelopeItems) {
        const envelopeItemType = envelopeItem[0].type;
        const result = callback(envelopeItem, envelopeItemType);
        if (result) {
          return true;
        }
      }
      return false;
    }
    function encodeUTF8(input) {
      return GLOBAL_OBJ.__SENTRY__ && GLOBAL_OBJ.__SENTRY__.encodePolyfill ? GLOBAL_OBJ.__SENTRY__.encodePolyfill(input) : new TextEncoder().encode(input);
    }
    function serializeEnvelope(envelope) {
      const [envHeaders, items] = envelope;
      let parts = JSON.stringify(envHeaders);
      function append(next) {
        if (typeof parts === "string") {
          parts = typeof next === "string" ? parts + next : [encodeUTF8(parts), next];
        } else {
          parts.push(typeof next === "string" ? encodeUTF8(next) : next);
        }
      }
      for (const item of items) {
        const [itemHeaders, payload] = item;
        append(`
${JSON.stringify(itemHeaders)}
`);
        if (typeof payload === "string" || payload instanceof Uint8Array) {
          append(payload);
        } else {
          let stringifiedPayload;
          try {
            stringifiedPayload = JSON.stringify(payload);
          } catch (e2) {
            stringifiedPayload = JSON.stringify(normalize(payload));
          }
          append(stringifiedPayload);
        }
      }
      return typeof parts === "string" ? parts : concatBuffers(parts);
    }
    function concatBuffers(buffers) {
      const totalLength = buffers.reduce((acc, buf) => acc + buf.length, 0);
      const merged = new Uint8Array(totalLength);
      let offset = 0;
      for (const buffer of buffers) {
        merged.set(buffer, offset);
        offset += buffer.length;
      }
      return merged;
    }
    function createAttachmentEnvelopeItem(attachment) {
      const buffer = typeof attachment.data === "string" ? encodeUTF8(attachment.data) : attachment.data;
      return [
        dropUndefinedKeys({
          type: "attachment",
          length: buffer.length,
          filename: attachment.filename,
          content_type: attachment.contentType,
          attachment_type: attachment.attachmentType
        }),
        buffer
      ];
    }
    const ITEM_TYPE_TO_DATA_CATEGORY_MAP = {
      session: "session",
      sessions: "session",
      attachment: "attachment",
      transaction: "transaction",
      event: "error",
      client_report: "internal",
      user_report: "default",
      profile: "profile",
      profile_chunk: "profile",
      replay_event: "replay",
      replay_recording: "replay",
      check_in: "monitor",
      feedback: "feedback",
      span: "span",
      statsd: "metric_bucket"
    };
    function envelopeItemTypeToDataCategory(type) {
      return ITEM_TYPE_TO_DATA_CATEGORY_MAP[type];
    }
    function getSdkMetadataForEnvelopeHeader(metadataOrEvent) {
      if (!metadataOrEvent || !metadataOrEvent.sdk) {
        return;
      }
      const { name: name2, version } = metadataOrEvent.sdk;
      return { name: name2, version };
    }
    function createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn) {
      const dynamicSamplingContext = event.sdkProcessingMetadata && event.sdkProcessingMetadata.dynamicSamplingContext;
      return {
        event_id: event.event_id,
        sent_at: (/* @__PURE__ */ new Date()).toISOString(),
        ...sdkInfo && { sdk: sdkInfo },
        ...!!tunnel && dsn && { dsn: dsnToString(dsn) },
        ...dynamicSamplingContext && {
          trace: dropUndefinedKeys({ ...dynamicSamplingContext })
        }
      };
    }
    function createClientReportEnvelope(discarded_events, dsn, timestamp) {
      const clientReportItem = [
        { type: "client_report" },
        {
          timestamp: dateTimestampInSeconds(),
          discarded_events
        }
      ];
      return createEnvelope(dsn ? { dsn } : {}, [clientReportItem]);
    }
    const DEFAULT_RETRY_AFTER = 60 * 1e3;
    function parseRetryAfterHeader(header2, now = Date.now()) {
      const headerDelay = parseInt(`${header2}`, 10);
      if (!isNaN(headerDelay)) {
        return headerDelay * 1e3;
      }
      const headerDate = Date.parse(`${header2}`);
      if (!isNaN(headerDate)) {
        return headerDate - now;
      }
      return DEFAULT_RETRY_AFTER;
    }
    function disabledUntil(limits, dataCategory) {
      return limits[dataCategory] || limits.all || 0;
    }
    function isRateLimited(limits, dataCategory, now = Date.now()) {
      return disabledUntil(limits, dataCategory) > now;
    }
    function updateRateLimits(limits, { statusCode, headers }, now = Date.now()) {
      const updatedRateLimits = {
        ...limits
      };
      const rateLimitHeader = headers && headers["x-sentry-rate-limits"];
      const retryAfterHeader = headers && headers["retry-after"];
      if (rateLimitHeader) {
        for (const limit of rateLimitHeader.trim().split(",")) {
          const [retryAfter, categories, , , namespaces] = limit.split(":", 5);
          const headerDelay = parseInt(retryAfter, 10);
          const delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1e3;
          if (!categories) {
            updatedRateLimits.all = now + delay;
          } else {
            for (const category of categories.split(";")) {
              if (category === "metric_bucket") {
                if (!namespaces || namespaces.split(";").includes("custom")) {
                  updatedRateLimits[category] = now + delay;
                }
              } else {
                updatedRateLimits[category] = now + delay;
              }
            }
          }
        }
      } else if (retryAfterHeader) {
        updatedRateLimits.all = now + parseRetryAfterHeader(retryAfterHeader, now);
      } else if (statusCode === 429) {
        updatedRateLimits.all = now + 60 * 1e3;
      }
      return updatedRateLimits;
    }
    function generatePropagationContext() {
      return {
        traceId: uuid4(),
        spanId: uuid4().substring(16)
      };
    }
    const WINDOW$2 = GLOBAL_OBJ;
    function supportsHistory() {
      const chromeVar = WINDOW$2.chrome;
      const isChromePackagedApp = chromeVar && chromeVar.app && chromeVar.app.runtime;
      const hasHistoryApi = "history" in WINDOW$2 && !!WINDOW$2.history.pushState && !!WINDOW$2.history.replaceState;
      return !isChromePackagedApp && hasHistoryApi;
    }
    const DEBUG_BUILD$2 = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;
    function getMainCarrier() {
      getSentryCarrier(GLOBAL_OBJ);
      return GLOBAL_OBJ;
    }
    function getSentryCarrier(carrier) {
      const __SENTRY__ = carrier.__SENTRY__ = carrier.__SENTRY__ || {};
      __SENTRY__.version = __SENTRY__.version || SDK_VERSION;
      return __SENTRY__[SDK_VERSION] = __SENTRY__[SDK_VERSION] || {};
    }
    function makeSession(context) {
      const startingTime = timestampInSeconds();
      const session = {
        sid: uuid4(),
        init: true,
        timestamp: startingTime,
        started: startingTime,
        duration: 0,
        status: "ok",
        errors: 0,
        ignoreDuration: false,
        toJSON: () => sessionToJSON(session)
      };
      if (context) {
        updateSession(session, context);
      }
      return session;
    }
    function updateSession(session, context = {}) {
      if (context.user) {
        if (!session.ipAddress && context.user.ip_address) {
          session.ipAddress = context.user.ip_address;
        }
        if (!session.did && !context.did) {
          session.did = context.user.id || context.user.email || context.user.username;
        }
      }
      session.timestamp = context.timestamp || timestampInSeconds();
      if (context.abnormal_mechanism) {
        session.abnormal_mechanism = context.abnormal_mechanism;
      }
      if (context.ignoreDuration) {
        session.ignoreDuration = context.ignoreDuration;
      }
      if (context.sid) {
        session.sid = context.sid.length === 32 ? context.sid : uuid4();
      }
      if (context.init !== void 0) {
        session.init = context.init;
      }
      if (!session.did && context.did) {
        session.did = `${context.did}`;
      }
      if (typeof context.started === "number") {
        session.started = context.started;
      }
      if (session.ignoreDuration) {
        session.duration = void 0;
      } else if (typeof context.duration === "number") {
        session.duration = context.duration;
      } else {
        const duration = session.timestamp - session.started;
        session.duration = duration >= 0 ? duration : 0;
      }
      if (context.release) {
        session.release = context.release;
      }
      if (context.environment) {
        session.environment = context.environment;
      }
      if (!session.ipAddress && context.ipAddress) {
        session.ipAddress = context.ipAddress;
      }
      if (!session.userAgent && context.userAgent) {
        session.userAgent = context.userAgent;
      }
      if (typeof context.errors === "number") {
        session.errors = context.errors;
      }
      if (context.status) {
        session.status = context.status;
      }
    }
    function closeSession(session, status) {
      let context = {};
      if (session.status === "ok") {
        context = { status: "exited" };
      }
      updateSession(session, context);
    }
    function sessionToJSON(session) {
      return dropUndefinedKeys({
        sid: `${session.sid}`,
        init: session.init,
        // Make sure that sec is converted to ms for date constructor
        started: new Date(session.started * 1e3).toISOString(),
        timestamp: new Date(session.timestamp * 1e3).toISOString(),
        status: session.status,
        errors: session.errors,
        did: typeof session.did === "number" || typeof session.did === "string" ? `${session.did}` : void 0,
        duration: session.duration,
        abnormal_mechanism: session.abnormal_mechanism,
        attrs: {
          release: session.release,
          environment: session.environment,
          ip_address: session.ipAddress,
          user_agent: session.userAgent
        }
      });
    }
    const SCOPE_SPAN_FIELD = "_sentrySpan";
    function _setSpanForScope(scope2, span) {
      if (span) {
        addNonEnumerableProperty(scope2, SCOPE_SPAN_FIELD, span);
      } else {
        delete scope2[SCOPE_SPAN_FIELD];
      }
    }
    function _getSpanForScope(scope2) {
      return scope2[SCOPE_SPAN_FIELD];
    }
    const DEFAULT_MAX_BREADCRUMBS = 100;
    class ScopeClass {
      /** Flag if notifying is happening. */
      /** Callback for client to receive scope changes. */
      /** Callback list that will be called during event processing. */
      /** Array of breadcrumbs. */
      /** User */
      /** Tags */
      /** Extra */
      /** Contexts */
      /** Attachments */
      /** Propagation Context for distributed tracing */
      /**
       * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get
       * sent to Sentry
       */
      /** Fingerprint */
      /** Severity */
      /**
       * Transaction Name
       *
       * IMPORTANT: The transaction name on the scope has nothing to do with root spans/transaction objects.
       * It's purpose is to assign a transaction to the scope that's added to non-transaction events.
       */
      /** Session */
      /** Request Mode Session Status */
      /** The client on this scope */
      /** Contains the last event id of a captured event.  */
      // NOTE: Any field which gets added here should get added not only to the constructor but also to the `clone` method.
      constructor() {
        this._notifyingListeners = false;
        this._scopeListeners = [];
        this._eventProcessors = [];
        this._breadcrumbs = [];
        this._attachments = [];
        this._user = {};
        this._tags = {};
        this._extra = {};
        this._contexts = {};
        this._sdkProcessingMetadata = {};
        this._propagationContext = generatePropagationContext();
      }
      /**
       * @inheritDoc
       */
      clone() {
        const newScope = new ScopeClass();
        newScope._breadcrumbs = [...this._breadcrumbs];
        newScope._tags = { ...this._tags };
        newScope._extra = { ...this._extra };
        newScope._contexts = { ...this._contexts };
        newScope._user = this._user;
        newScope._level = this._level;
        newScope._session = this._session;
        newScope._transactionName = this._transactionName;
        newScope._fingerprint = this._fingerprint;
        newScope._eventProcessors = [...this._eventProcessors];
        newScope._requestSession = this._requestSession;
        newScope._attachments = [...this._attachments];
        newScope._sdkProcessingMetadata = { ...this._sdkProcessingMetadata };
        newScope._propagationContext = { ...this._propagationContext };
        newScope._client = this._client;
        newScope._lastEventId = this._lastEventId;
        _setSpanForScope(newScope, _getSpanForScope(this));
        return newScope;
      }
      /**
       * @inheritDoc
       */
      setClient(client2) {
        this._client = client2;
      }
      /**
       * @inheritDoc
       */
      setLastEventId(lastEventId) {
        this._lastEventId = lastEventId;
      }
      /**
       * @inheritDoc
       */
      getClient() {
        return this._client;
      }
      /**
       * @inheritDoc
       */
      lastEventId() {
        return this._lastEventId;
      }
      /**
       * @inheritDoc
       */
      addScopeListener(callback) {
        this._scopeListeners.push(callback);
      }
      /**
       * @inheritDoc
       */
      addEventProcessor(callback) {
        this._eventProcessors.push(callback);
        return this;
      }
      /**
       * @inheritDoc
       */
      setUser(user) {
        this._user = user || {
          email: void 0,
          id: void 0,
          ip_address: void 0,
          username: void 0
        };
        if (this._session) {
          updateSession(this._session, { user });
        }
        this._notifyScopeListeners();
        return this;
      }
      /**
       * @inheritDoc
       */
      getUser() {
        return this._user;
      }
      /**
       * @inheritDoc
       */
      getRequestSession() {
        return this._requestSession;
      }
      /**
       * @inheritDoc
       */
      setRequestSession(requestSession) {
        this._requestSession = requestSession;
        return this;
      }
      /**
       * @inheritDoc
       */
      setTags(tags) {
        this._tags = {
          ...this._tags,
          ...tags
        };
        this._notifyScopeListeners();
        return this;
      }
      /**
       * @inheritDoc
       */
      setTag(key2, value2) {
        this._tags = { ...this._tags, [key2]: value2 };
        this._notifyScopeListeners();
        return this;
      }
      /**
       * @inheritDoc
       */
      setExtras(extras) {
        this._extra = {
          ...this._extra,
          ...extras
        };
        this._notifyScopeListeners();
        return this;
      }
      /**
       * @inheritDoc
       */
      setExtra(key2, extra) {
        this._extra = { ...this._extra, [key2]: extra };
        this._notifyScopeListeners();
        return this;
      }
      /**
       * @inheritDoc
       */
      setFingerprint(fingerprint) {
        this._fingerprint = fingerprint;
        this._notifyScopeListeners();
        return this;
      }
      /**
       * @inheritDoc
       */
      setLevel(level) {
        this._level = level;
        this._notifyScopeListeners();
        return this;
      }
      /**
       * @inheritDoc
       */
      setTransactionName(name2) {
        this._transactionName = name2;
        this._notifyScopeListeners();
        return this;
      }
      /**
       * @inheritDoc
       */
      setContext(key2, context) {
        if (context === null) {
          delete this._contexts[key2];
        } else {
          this._contexts[key2] = context;
        }
        this._notifyScopeListeners();
        return this;
      }
      /**
       * @inheritDoc
       */
      setSession(session) {
        if (!session) {
          delete this._session;
        } else {
          this._session = session;
        }
        this._notifyScopeListeners();
        return this;
      }
      /**
       * @inheritDoc
       */
      getSession() {
        return this._session;
      }
      /**
       * @inheritDoc
       */
      update(captureContext) {
        if (!captureContext) {
          return this;
        }
        const scopeToMerge = typeof captureContext === "function" ? captureContext(this) : captureContext;
        const [scopeInstance, requestSession] = scopeToMerge instanceof Scope ? [scopeToMerge.getScopeData(), scopeToMerge.getRequestSession()] : isPlainObject$2(scopeToMerge) ? [captureContext, captureContext.requestSession] : [];
        const { tags, extra, user, contexts, level, fingerprint = [], propagationContext } = scopeInstance || {};
        this._tags = { ...this._tags, ...tags };
        this._extra = { ...this._extra, ...extra };
        this._contexts = { ...this._contexts, ...contexts };
        if (user && Object.keys(user).length) {
          this._user = user;
        }
        if (level) {
          this._level = level;
        }
        if (fingerprint.length) {
          this._fingerprint = fingerprint;
        }
        if (propagationContext) {
          this._propagationContext = propagationContext;
        }
        if (requestSession) {
          this._requestSession = requestSession;
        }
        return this;
      }
      /**
       * @inheritDoc
       */
      clear() {
        this._breadcrumbs = [];
        this._tags = {};
        this._extra = {};
        this._user = {};
        this._contexts = {};
        this._level = void 0;
        this._transactionName = void 0;
        this._fingerprint = void 0;
        this._requestSession = void 0;
        this._session = void 0;
        _setSpanForScope(this, void 0);
        this._attachments = [];
        this._propagationContext = generatePropagationContext();
        this._notifyScopeListeners();
        return this;
      }
      /**
       * @inheritDoc
       */
      addBreadcrumb(breadcrumb, maxBreadcrumbs) {
        const maxCrumbs = typeof maxBreadcrumbs === "number" ? maxBreadcrumbs : DEFAULT_MAX_BREADCRUMBS;
        if (maxCrumbs <= 0) {
          return this;
        }
        const mergedBreadcrumb = {
          timestamp: dateTimestampInSeconds(),
          ...breadcrumb
        };
        const breadcrumbs = this._breadcrumbs;
        breadcrumbs.push(mergedBreadcrumb);
        this._breadcrumbs = breadcrumbs.length > maxCrumbs ? breadcrumbs.slice(-maxCrumbs) : breadcrumbs;
        this._notifyScopeListeners();
        return this;
      }
      /**
       * @inheritDoc
       */
      getLastBreadcrumb() {
        return this._breadcrumbs[this._breadcrumbs.length - 1];
      }
      /**
       * @inheritDoc
       */
      clearBreadcrumbs() {
        this._breadcrumbs = [];
        this._notifyScopeListeners();
        return this;
      }
      /**
       * @inheritDoc
       */
      addAttachment(attachment) {
        this._attachments.push(attachment);
        return this;
      }
      /**
       * @inheritDoc
       */
      clearAttachments() {
        this._attachments = [];
        return this;
      }
      /** @inheritDoc */
      getScopeData() {
        return {
          breadcrumbs: this._breadcrumbs,
          attachments: this._attachments,
          contexts: this._contexts,
          tags: this._tags,
          extra: this._extra,
          user: this._user,
          level: this._level,
          fingerprint: this._fingerprint || [],
          eventProcessors: this._eventProcessors,
          propagationContext: this._propagationContext,
          sdkProcessingMetadata: this._sdkProcessingMetadata,
          transactionName: this._transactionName,
          span: _getSpanForScope(this)
        };
      }
      /**
       * @inheritDoc
       */
      setSDKProcessingMetadata(newData) {
        this._sdkProcessingMetadata = { ...this._sdkProcessingMetadata, ...newData };
        return this;
      }
      /**
       * @inheritDoc
       */
      setPropagationContext(context) {
        this._propagationContext = context;
        return this;
      }
      /**
       * @inheritDoc
       */
      getPropagationContext() {
        return this._propagationContext;
      }
      /**
       * @inheritDoc
       */
      captureException(exception, hint) {
        const eventId = hint && hint.event_id ? hint.event_id : uuid4();
        if (!this._client) {
          logger.warn("No client configured on scope - will not capture exception!");
          return eventId;
        }
        const syntheticException = new Error("Sentry syntheticException");
        this._client.captureException(
          exception,
          {
            originalException: exception,
            syntheticException,
            ...hint,
            event_id: eventId
          },
          this
        );
        return eventId;
      }
      /**
       * @inheritDoc
       */
      captureMessage(message2, level, hint) {
        const eventId = hint && hint.event_id ? hint.event_id : uuid4();
        if (!this._client) {
          logger.warn("No client configured on scope - will not capture message!");
          return eventId;
        }
        const syntheticException = new Error(message2);
        this._client.captureMessage(
          message2,
          level,
          {
            originalException: message2,
            syntheticException,
            ...hint,
            event_id: eventId
          },
          this
        );
        return eventId;
      }
      /**
       * @inheritDoc
       */
      captureEvent(event, hint) {
        const eventId = hint && hint.event_id ? hint.event_id : uuid4();
        if (!this._client) {
          logger.warn("No client configured on scope - will not capture event!");
          return eventId;
        }
        this._client.captureEvent(event, { ...hint, event_id: eventId }, this);
        return eventId;
      }
      /**
       * This will be called on every set call.
       */
      _notifyScopeListeners() {
        if (!this._notifyingListeners) {
          this._notifyingListeners = true;
          this._scopeListeners.forEach((callback) => {
            callback(this);
          });
          this._notifyingListeners = false;
        }
      }
    }
    const Scope = ScopeClass;
    function getDefaultCurrentScope() {
      return getGlobalSingleton("defaultCurrentScope", () => new Scope());
    }
    function getDefaultIsolationScope() {
      return getGlobalSingleton("defaultIsolationScope", () => new Scope());
    }
    class AsyncContextStack {
      constructor(scope2, isolationScope) {
        let assignedScope;
        if (!scope2) {
          assignedScope = new Scope();
        } else {
          assignedScope = scope2;
        }
        let assignedIsolationScope;
        if (!isolationScope) {
          assignedIsolationScope = new Scope();
        } else {
          assignedIsolationScope = isolationScope;
        }
        this._stack = [{ scope: assignedScope }];
        this._isolationScope = assignedIsolationScope;
      }
      /**
       * Fork a scope for the stack.
       */
      withScope(callback) {
        const scope2 = this._pushScope();
        let maybePromiseResult;
        try {
          maybePromiseResult = callback(scope2);
        } catch (e2) {
          this._popScope();
          throw e2;
        }
        if (isThenable(maybePromiseResult)) {
          return maybePromiseResult.then(
            (res) => {
              this._popScope();
              return res;
            },
            (e2) => {
              this._popScope();
              throw e2;
            }
          );
        }
        this._popScope();
        return maybePromiseResult;
      }
      /**
       * Get the client of the stack.
       */
      getClient() {
        return this.getStackTop().client;
      }
      /**
       * Returns the scope of the top stack.
       */
      getScope() {
        return this.getStackTop().scope;
      }
      /**
       * Get the isolation scope for the stack.
       */
      getIsolationScope() {
        return this._isolationScope;
      }
      /**
       * Returns the scope stack for domains or the process.
       */
      getStack() {
        return this._stack;
      }
      /**
       * Returns the topmost scope layer in the order domain > local > process.
       */
      getStackTop() {
        return this._stack[this._stack.length - 1];
      }
      /**
       * Push a scope to the stack.
       */
      _pushScope() {
        const scope2 = this.getScope().clone();
        this.getStack().push({
          client: this.getClient(),
          scope: scope2
        });
        return scope2;
      }
      /**
       * Pop a scope from the stack.
       */
      _popScope() {
        if (this.getStack().length <= 1)
          return false;
        return !!this.getStack().pop();
      }
    }
    function getAsyncContextStack() {
      const registry = getMainCarrier();
      const sentry = getSentryCarrier(registry);
      return sentry.stack = sentry.stack || new AsyncContextStack(getDefaultCurrentScope(), getDefaultIsolationScope());
    }
    function withScope$1(callback) {
      return getAsyncContextStack().withScope(callback);
    }
    function withSetScope(scope2, callback) {
      const stack = getAsyncContextStack();
      return stack.withScope(() => {
        stack.getStackTop().scope = scope2;
        return callback(scope2);
      });
    }
    function withIsolationScope(callback) {
      return getAsyncContextStack().withScope(() => {
        return callback(getAsyncContextStack().getIsolationScope());
      });
    }
    function getStackAsyncContextStrategy() {
      return {
        withIsolationScope,
        withScope: withScope$1,
        withSetScope,
        withSetIsolationScope: (_isolationScope, callback) => {
          return withIsolationScope(callback);
        },
        getCurrentScope: () => getAsyncContextStack().getScope(),
        getIsolationScope: () => getAsyncContextStack().getIsolationScope()
      };
    }
    function getAsyncContextStrategy(carrier) {
      const sentry = getSentryCarrier(carrier);
      if (sentry.acs) {
        return sentry.acs;
      }
      return getStackAsyncContextStrategy();
    }
    function getCurrentScope$1() {
      const carrier = getMainCarrier();
      const acs = getAsyncContextStrategy(carrier);
      return acs.getCurrentScope();
    }
    function getIsolationScope() {
      const carrier = getMainCarrier();
      const acs = getAsyncContextStrategy(carrier);
      return acs.getIsolationScope();
    }
    function getGlobalScope() {
      return getGlobalSingleton("globalScope", () => new Scope());
    }
    function withScope(...rest) {
      const carrier = getMainCarrier();
      const acs = getAsyncContextStrategy(carrier);
      if (rest.length === 2) {
        const [scope2, callback] = rest;
        if (!scope2) {
          return acs.withScope(callback);
        }
        return acs.withSetScope(scope2, callback);
      }
      return acs.withScope(rest[0]);
    }
    function getClient() {
      return getCurrentScope$1().getClient();
    }
    const METRICS_SPAN_FIELD = "_sentryMetrics";
    function getMetricSummaryJsonForSpan(span) {
      const storage = span[METRICS_SPAN_FIELD];
      if (!storage) {
        return void 0;
      }
      const output = {};
      for (const [, [exportKey, summary]] of storage) {
        if (!output[exportKey]) {
          output[exportKey] = [];
        }
        output[exportKey].push(dropUndefinedKeys(summary));
      }
      return output;
    }
    const SEMANTIC_ATTRIBUTE_SENTRY_SOURCE = "sentry.source";
    const SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE = "sentry.sample_rate";
    const SEMANTIC_ATTRIBUTE_SENTRY_OP = "sentry.op";
    const SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN = "sentry.origin";
    const SPAN_STATUS_UNSET = 0;
    const SPAN_STATUS_OK = 1;
    const TRACE_FLAG_SAMPLED = 1;
    function spanToTraceContext(span) {
      const { spanId: span_id, traceId: trace_id } = span.spanContext();
      const { parent_span_id } = spanToJSON(span);
      return dropUndefinedKeys({ parent_span_id, span_id, trace_id });
    }
    function spanTimeInputToSeconds(input) {
      if (typeof input === "number") {
        return ensureTimestampInSeconds(input);
      }
      if (Array.isArray(input)) {
        return input[0] + input[1] / 1e9;
      }
      if (input instanceof Date) {
        return ensureTimestampInSeconds(input.getTime());
      }
      return timestampInSeconds();
    }
    function ensureTimestampInSeconds(timestamp) {
      const isMs = timestamp > 9999999999;
      return isMs ? timestamp / 1e3 : timestamp;
    }
    function spanToJSON(span) {
      if (spanIsSentrySpan(span)) {
        return span.getSpanJSON();
      }
      try {
        const { spanId: span_id, traceId: trace_id } = span.spanContext();
        if (spanIsOpenTelemetrySdkTraceBaseSpan(span)) {
          const { attributes, startTime, name: name2, endTime, parentSpanId, status } = span;
          return dropUndefinedKeys({
            span_id,
            trace_id,
            data: attributes,
            description: name2,
            parent_span_id: parentSpanId,
            start_timestamp: spanTimeInputToSeconds(startTime),
            // This is [0,0] by default in OTEL, in which case we want to interpret this as no end time
            timestamp: spanTimeInputToSeconds(endTime) || void 0,
            status: getStatusMessage(status),
            op: attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP],
            origin: attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN],
            _metrics_summary: getMetricSummaryJsonForSpan(span)
          });
        }
        return {
          span_id,
          trace_id
        };
      } catch (e2) {
        return {};
      }
    }
    function spanIsOpenTelemetrySdkTraceBaseSpan(span) {
      const castSpan = span;
      return !!castSpan.attributes && !!castSpan.startTime && !!castSpan.name && !!castSpan.endTime && !!castSpan.status;
    }
    function spanIsSentrySpan(span) {
      return typeof span.getSpanJSON === "function";
    }
    function spanIsSampled(span) {
      const { traceFlags } = span.spanContext();
      return traceFlags === TRACE_FLAG_SAMPLED;
    }
    function getStatusMessage(status) {
      if (!status || status.code === SPAN_STATUS_UNSET) {
        return void 0;
      }
      if (status.code === SPAN_STATUS_OK) {
        return "ok";
      }
      return status.message || "unknown_error";
    }
    const ROOT_SPAN_FIELD = "_sentryRootSpan";
    function getRootSpan(span) {
      return span[ROOT_SPAN_FIELD] || span;
    }
    const DEFAULT_ENVIRONMENT = "production";
    const FROZEN_DSC_FIELD = "_frozenDsc";
    function getDynamicSamplingContextFromClient(trace_id, client2) {
      const options = client2.getOptions();
      const { publicKey: public_key } = client2.getDsn() || {};
      const dsc = dropUndefinedKeys({
        environment: options.environment || DEFAULT_ENVIRONMENT,
        release: options.release,
        public_key,
        trace_id
      });
      client2.emit("createDsc", dsc);
      return dsc;
    }
    function getDynamicSamplingContextFromSpan(span) {
      const client2 = getClient();
      if (!client2) {
        return {};
      }
      const dsc = getDynamicSamplingContextFromClient(spanToJSON(span).trace_id || "", client2);
      const rootSpan = getRootSpan(span);
      if (!rootSpan) {
        return dsc;
      }
      const frozenDsc = rootSpan[FROZEN_DSC_FIELD];
      if (frozenDsc) {
        return frozenDsc;
      }
      const jsonSpan = spanToJSON(rootSpan);
      const attributes = jsonSpan.data || {};
      const maybeSampleRate = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE];
      if (maybeSampleRate != null) {
        dsc.sample_rate = `${maybeSampleRate}`;
      }
      const source = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];
      if (source && source !== "url") {
        dsc.transaction = jsonSpan.description;
      }
      dsc.sampled = String(spanIsSampled(rootSpan));
      client2.emit("createDsc", dsc);
      return dsc;
    }
    function parseSampleRate(sampleRate) {
      if (typeof sampleRate === "boolean") {
        return Number(sampleRate);
      }
      const rate = typeof sampleRate === "string" ? parseFloat(sampleRate) : sampleRate;
      if (typeof rate !== "number" || isNaN(rate) || rate < 0 || rate > 1) {
        DEBUG_BUILD$2 && logger.warn(
          `[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(
            sampleRate
          )} of type ${JSON.stringify(typeof sampleRate)}.`
        );
        return void 0;
      }
      return rate;
    }
    function enhanceEventWithSdkInfo(event, sdkInfo) {
      if (!sdkInfo) {
        return event;
      }
      event.sdk = event.sdk || {};
      event.sdk.name = event.sdk.name || sdkInfo.name;
      event.sdk.version = event.sdk.version || sdkInfo.version;
      event.sdk.integrations = [...event.sdk.integrations || [], ...sdkInfo.integrations || []];
      event.sdk.packages = [...event.sdk.packages || [], ...sdkInfo.packages || []];
      return event;
    }
    function createSessionEnvelope(session, dsn, metadata, tunnel) {
      const sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);
      const envelopeHeaders = {
        sent_at: (/* @__PURE__ */ new Date()).toISOString(),
        ...sdkInfo && { sdk: sdkInfo },
        ...!!tunnel && dsn && { dsn: dsnToString(dsn) }
      };
      const envelopeItem = "aggregates" in session ? [{ type: "sessions" }, session] : [{ type: "session" }, session.toJSON()];
      return createEnvelope(envelopeHeaders, [envelopeItem]);
    }
    function createEventEnvelope(event, dsn, metadata, tunnel) {
      const sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);
      const eventType = event.type && event.type !== "replay_event" ? event.type : "event";
      enhanceEventWithSdkInfo(event, metadata && metadata.sdk);
      const envelopeHeaders = createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn);
      delete event.sdkProcessingMetadata;
      const eventItem = [{ type: eventType }, event];
      return createEnvelope(envelopeHeaders, [eventItem]);
    }
    function notifyEventProcessors(processors, event, hint, index2 = 0) {
      return new SyncPromise((resolve, reject) => {
        const processor = processors[index2];
        if (event === null || typeof processor !== "function") {
          resolve(event);
        } else {
          const result = processor({ ...event }, hint);
          DEBUG_BUILD$2 && processor.id && result === null && logger.log(`Event processor "${processor.id}" dropped event`);
          if (isThenable(result)) {
            void result.then((final) => notifyEventProcessors(processors, final, hint, index2 + 1).then(resolve)).then(null, reject);
          } else {
            void notifyEventProcessors(processors, result, hint, index2 + 1).then(resolve).then(null, reject);
          }
        }
      });
    }
    function applyScopeDataToEvent(event, data2) {
      const { fingerprint, span, breadcrumbs, sdkProcessingMetadata } = data2;
      applyDataToEvent(event, data2);
      if (span) {
        applySpanToEvent(event, span);
      }
      applyFingerprintToEvent(event, fingerprint);
      applyBreadcrumbsToEvent(event, breadcrumbs);
      applySdkMetadataToEvent(event, sdkProcessingMetadata);
    }
    function mergeScopeData(data2, mergeData) {
      const {
        extra,
        tags,
        user,
        contexts,
        level,
        sdkProcessingMetadata,
        breadcrumbs,
        fingerprint,
        eventProcessors,
        attachments,
        propagationContext,
        transactionName,
        span
      } = mergeData;
      mergeAndOverwriteScopeData(data2, "extra", extra);
      mergeAndOverwriteScopeData(data2, "tags", tags);
      mergeAndOverwriteScopeData(data2, "user", user);
      mergeAndOverwriteScopeData(data2, "contexts", contexts);
      mergeAndOverwriteScopeData(data2, "sdkProcessingMetadata", sdkProcessingMetadata);
      if (level) {
        data2.level = level;
      }
      if (transactionName) {
        data2.transactionName = transactionName;
      }
      if (span) {
        data2.span = span;
      }
      if (breadcrumbs.length) {
        data2.breadcrumbs = [...data2.breadcrumbs, ...breadcrumbs];
      }
      if (fingerprint.length) {
        data2.fingerprint = [...data2.fingerprint, ...fingerprint];
      }
      if (eventProcessors.length) {
        data2.eventProcessors = [...data2.eventProcessors, ...eventProcessors];
      }
      if (attachments.length) {
        data2.attachments = [...data2.attachments, ...attachments];
      }
      data2.propagationContext = { ...data2.propagationContext, ...propagationContext };
    }
    function mergeAndOverwriteScopeData(data2, prop, mergeVal) {
      if (mergeVal && Object.keys(mergeVal).length) {
        data2[prop] = { ...data2[prop] };
        for (const key2 in mergeVal) {
          if (Object.prototype.hasOwnProperty.call(mergeVal, key2)) {
            data2[prop][key2] = mergeVal[key2];
          }
        }
      }
    }
    function applyDataToEvent(event, data2) {
      const { extra, tags, user, contexts, level, transactionName } = data2;
      const cleanedExtra = dropUndefinedKeys(extra);
      if (cleanedExtra && Object.keys(cleanedExtra).length) {
        event.extra = { ...cleanedExtra, ...event.extra };
      }
      const cleanedTags = dropUndefinedKeys(tags);
      if (cleanedTags && Object.keys(cleanedTags).length) {
        event.tags = { ...cleanedTags, ...event.tags };
      }
      const cleanedUser = dropUndefinedKeys(user);
      if (cleanedUser && Object.keys(cleanedUser).length) {
        event.user = { ...cleanedUser, ...event.user };
      }
      const cleanedContexts = dropUndefinedKeys(contexts);
      if (cleanedContexts && Object.keys(cleanedContexts).length) {
        event.contexts = { ...cleanedContexts, ...event.contexts };
      }
      if (level) {
        event.level = level;
      }
      if (transactionName && event.type !== "transaction") {
        event.transaction = transactionName;
      }
    }
    function applyBreadcrumbsToEvent(event, breadcrumbs) {
      const mergedBreadcrumbs = [...event.breadcrumbs || [], ...breadcrumbs];
      event.breadcrumbs = mergedBreadcrumbs.length ? mergedBreadcrumbs : void 0;
    }
    function applySdkMetadataToEvent(event, sdkProcessingMetadata) {
      event.sdkProcessingMetadata = {
        ...event.sdkProcessingMetadata,
        ...sdkProcessingMetadata
      };
    }
    function applySpanToEvent(event, span) {
      event.contexts = {
        trace: spanToTraceContext(span),
        ...event.contexts
      };
      event.sdkProcessingMetadata = {
        dynamicSamplingContext: getDynamicSamplingContextFromSpan(span),
        ...event.sdkProcessingMetadata
      };
      const rootSpan = getRootSpan(span);
      const transactionName = spanToJSON(rootSpan).description;
      if (transactionName && !event.transaction && event.type === "transaction") {
        event.transaction = transactionName;
      }
    }
    function applyFingerprintToEvent(event, fingerprint) {
      event.fingerprint = event.fingerprint ? arrayify(event.fingerprint) : [];
      if (fingerprint) {
        event.fingerprint = event.fingerprint.concat(fingerprint);
      }
      if (event.fingerprint && !event.fingerprint.length) {
        delete event.fingerprint;
      }
    }
    function prepareEvent(options, event, hint, scope2, client2, isolationScope) {
      const { normalizeDepth = 3, normalizeMaxBreadth = 1e3 } = options;
      const prepared = {
        ...event,
        event_id: event.event_id || hint.event_id || uuid4(),
        timestamp: event.timestamp || dateTimestampInSeconds()
      };
      const integrations = hint.integrations || options.integrations.map((i2) => i2.name);
      applyClientOptions(prepared, options);
      applyIntegrationsMetadata(prepared, integrations);
      if (event.type === void 0) {
        applyDebugIds(prepared, options.stackParser);
      }
      const finalScope = getFinalScope(scope2, hint.captureContext);
      if (hint.mechanism) {
        addExceptionMechanism(prepared, hint.mechanism);
      }
      const clientEventProcessors = client2 ? client2.getEventProcessors() : [];
      const data2 = getGlobalScope().getScopeData();
      if (isolationScope) {
        const isolationData = isolationScope.getScopeData();
        mergeScopeData(data2, isolationData);
      }
      if (finalScope) {
        const finalScopeData = finalScope.getScopeData();
        mergeScopeData(data2, finalScopeData);
      }
      const attachments = [...hint.attachments || [], ...data2.attachments];
      if (attachments.length) {
        hint.attachments = attachments;
      }
      applyScopeDataToEvent(prepared, data2);
      const eventProcessors = [
        ...clientEventProcessors,
        // Run scope event processors _after_ all other processors
        ...data2.eventProcessors
      ];
      const result = notifyEventProcessors(eventProcessors, prepared, hint);
      return result.then((evt) => {
        if (evt) {
          applyDebugMeta(evt);
        }
        if (typeof normalizeDepth === "number" && normalizeDepth > 0) {
          return normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);
        }
        return evt;
      });
    }
    function applyClientOptions(event, options) {
      const { environment, release, dist, maxValueLength = 250 } = options;
      if (!("environment" in event)) {
        event.environment = "environment" in options ? environment : DEFAULT_ENVIRONMENT;
      }
      if (event.release === void 0 && release !== void 0) {
        event.release = release;
      }
      if (event.dist === void 0 && dist !== void 0) {
        event.dist = dist;
      }
      if (event.message) {
        event.message = truncate(event.message, maxValueLength);
      }
      const exception = event.exception && event.exception.values && event.exception.values[0];
      if (exception && exception.value) {
        exception.value = truncate(exception.value, maxValueLength);
      }
      const request = event.request;
      if (request && request.url) {
        request.url = truncate(request.url, maxValueLength);
      }
    }
    const debugIdStackParserCache = /* @__PURE__ */ new WeakMap();
    function applyDebugIds(event, stackParser) {
      const debugIdMap = GLOBAL_OBJ._sentryDebugIds;
      if (!debugIdMap) {
        return;
      }
      let debugIdStackFramesCache;
      const cachedDebugIdStackFrameCache = debugIdStackParserCache.get(stackParser);
      if (cachedDebugIdStackFrameCache) {
        debugIdStackFramesCache = cachedDebugIdStackFrameCache;
      } else {
        debugIdStackFramesCache = /* @__PURE__ */ new Map();
        debugIdStackParserCache.set(stackParser, debugIdStackFramesCache);
      }
      const filenameDebugIdMap = Object.keys(debugIdMap).reduce((acc, debugIdStackTrace) => {
        let parsedStack;
        const cachedParsedStack = debugIdStackFramesCache.get(debugIdStackTrace);
        if (cachedParsedStack) {
          parsedStack = cachedParsedStack;
        } else {
          parsedStack = stackParser(debugIdStackTrace);
          debugIdStackFramesCache.set(debugIdStackTrace, parsedStack);
        }
        for (let i2 = parsedStack.length - 1; i2 >= 0; i2--) {
          const stackFrame = parsedStack[i2];
          if (stackFrame.filename) {
            acc[stackFrame.filename] = debugIdMap[debugIdStackTrace];
            break;
          }
        }
        return acc;
      }, {});
      try {
        event.exception.values.forEach((exception) => {
          exception.stacktrace.frames.forEach((frame) => {
            if (frame.filename) {
              frame.debug_id = filenameDebugIdMap[frame.filename];
            }
          });
        });
      } catch (e2) {
      }
    }
    function applyDebugMeta(event) {
      const filenameDebugIdMap = {};
      try {
        event.exception.values.forEach((exception) => {
          exception.stacktrace.frames.forEach((frame) => {
            if (frame.debug_id) {
              if (frame.abs_path) {
                filenameDebugIdMap[frame.abs_path] = frame.debug_id;
              } else if (frame.filename) {
                filenameDebugIdMap[frame.filename] = frame.debug_id;
              }
              delete frame.debug_id;
            }
          });
        });
      } catch (e2) {
      }
      if (Object.keys(filenameDebugIdMap).length === 0) {
        return;
      }
      event.debug_meta = event.debug_meta || {};
      event.debug_meta.images = event.debug_meta.images || [];
      const images = event.debug_meta.images;
      Object.keys(filenameDebugIdMap).forEach((filename) => {
        images.push({
          type: "sourcemap",
          code_file: filename,
          debug_id: filenameDebugIdMap[filename]
        });
      });
    }
    function applyIntegrationsMetadata(event, integrationNames) {
      if (integrationNames.length > 0) {
        event.sdk = event.sdk || {};
        event.sdk.integrations = [...event.sdk.integrations || [], ...integrationNames];
      }
    }
    function normalizeEvent(event, depth, maxBreadth) {
      if (!event) {
        return null;
      }
      const normalized = {
        ...event,
        ...event.breadcrumbs && {
          breadcrumbs: event.breadcrumbs.map((b) => ({
            ...b,
            ...b.data && {
              data: normalize(b.data, depth, maxBreadth)
            }
          }))
        },
        ...event.user && {
          user: normalize(event.user, depth, maxBreadth)
        },
        ...event.contexts && {
          contexts: normalize(event.contexts, depth, maxBreadth)
        },
        ...event.extra && {
          extra: normalize(event.extra, depth, maxBreadth)
        }
      };
      if (event.contexts && event.contexts.trace && normalized.contexts) {
        normalized.contexts.trace = event.contexts.trace;
        if (event.contexts.trace.data) {
          normalized.contexts.trace.data = normalize(event.contexts.trace.data, depth, maxBreadth);
        }
      }
      if (event.spans) {
        normalized.spans = event.spans.map((span) => {
          return {
            ...span,
            ...span.data && {
              data: normalize(span.data, depth, maxBreadth)
            }
          };
        });
      }
      return normalized;
    }
    function getFinalScope(scope2, captureContext) {
      if (!captureContext) {
        return scope2;
      }
      const finalScope = scope2 ? scope2.clone() : new Scope();
      finalScope.update(captureContext);
      return finalScope;
    }
    function parseEventHintOrCaptureContext(hint) {
      {
        return void 0;
      }
    }
    function captureException(exception, hint) {
      return getCurrentScope$1().captureException(exception, parseEventHintOrCaptureContext());
    }
    function captureEvent(event, hint) {
      return getCurrentScope$1().captureEvent(event, hint);
    }
    function startSession(context) {
      const client2 = getClient();
      const isolationScope = getIsolationScope();
      const currentScope2 = getCurrentScope$1();
      const { release, environment = DEFAULT_ENVIRONMENT } = client2 && client2.getOptions() || {};
      const { userAgent } = GLOBAL_OBJ.navigator || {};
      const session = makeSession({
        release,
        environment,
        user: currentScope2.getUser() || isolationScope.getUser(),
        ...userAgent && { userAgent },
        ...context
      });
      const currentSession = isolationScope.getSession();
      if (currentSession && currentSession.status === "ok") {
        updateSession(currentSession, { status: "exited" });
      }
      endSession();
      isolationScope.setSession(session);
      currentScope2.setSession(session);
      return session;
    }
    function endSession() {
      const isolationScope = getIsolationScope();
      const currentScope2 = getCurrentScope$1();
      const session = currentScope2.getSession() || isolationScope.getSession();
      if (session) {
        closeSession(session);
      }
      _sendSessionUpdate();
      isolationScope.setSession();
      currentScope2.setSession();
    }
    function _sendSessionUpdate() {
      const isolationScope = getIsolationScope();
      const currentScope2 = getCurrentScope$1();
      const client2 = getClient();
      const session = currentScope2.getSession() || isolationScope.getSession();
      if (session && client2) {
        client2.captureSession(session);
      }
    }
    function captureSession(end = false) {
      if (end) {
        endSession();
        return;
      }
      _sendSessionUpdate();
    }
    const SENTRY_API_VERSION = "7";
    function getBaseApiEndpoint(dsn) {
      const protocol = dsn.protocol ? `${dsn.protocol}:` : "";
      const port = dsn.port ? `:${dsn.port}` : "";
      return `${protocol}//${dsn.host}${port}${dsn.path ? `/${dsn.path}` : ""}/api/`;
    }
    function _getIngestEndpoint(dsn) {
      return `${getBaseApiEndpoint(dsn)}${dsn.projectId}/envelope/`;
    }
    function _encodedAuth(dsn, sdkInfo) {
      return urlEncode({
        // We send only the minimum set of required information. See
        // https://github.com/getsentry/sentry-javascript/issues/2572.
        sentry_key: dsn.publicKey,
        sentry_version: SENTRY_API_VERSION,
        ...sdkInfo && { sentry_client: `${sdkInfo.name}/${sdkInfo.version}` }
      });
    }
    function getEnvelopeEndpointWithUrlEncodedAuth(dsn, tunnel, sdkInfo) {
      return tunnel ? tunnel : `${_getIngestEndpoint(dsn)}?${_encodedAuth(dsn, sdkInfo)}`;
    }
    const installedIntegrations = [];
    function filterDuplicates(integrations) {
      const integrationsByName = {};
      integrations.forEach((currentInstance) => {
        const { name: name2 } = currentInstance;
        const existingInstance = integrationsByName[name2];
        if (existingInstance && !existingInstance.isDefaultInstance && currentInstance.isDefaultInstance) {
          return;
        }
        integrationsByName[name2] = currentInstance;
      });
      return Object.keys(integrationsByName).map((k2) => integrationsByName[k2]);
    }
    function getIntegrationsToSetup(options) {
      const defaultIntegrations = options.defaultIntegrations || [];
      const userIntegrations = options.integrations;
      defaultIntegrations.forEach((integration) => {
        integration.isDefaultInstance = true;
      });
      let integrations;
      if (Array.isArray(userIntegrations)) {
        integrations = [...defaultIntegrations, ...userIntegrations];
      } else if (typeof userIntegrations === "function") {
        integrations = arrayify(userIntegrations(defaultIntegrations));
      } else {
        integrations = defaultIntegrations;
      }
      const finalIntegrations = filterDuplicates(integrations);
      const debugIndex = findIndex$1(finalIntegrations, (integration) => integration.name === "Debug");
      if (debugIndex !== -1) {
        const [debugInstance] = finalIntegrations.splice(debugIndex, 1);
        finalIntegrations.push(debugInstance);
      }
      return finalIntegrations;
    }
    function setupIntegrations(client2, integrations) {
      const integrationIndex = {};
      integrations.forEach((integration) => {
        if (integration) {
          setupIntegration(client2, integration, integrationIndex);
        }
      });
      return integrationIndex;
    }
    function afterSetupIntegrations(client2, integrations) {
      for (const integration of integrations) {
        if (integration && integration.afterAllSetup) {
          integration.afterAllSetup(client2);
        }
      }
    }
    function setupIntegration(client2, integration, integrationIndex) {
      if (integrationIndex[integration.name]) {
        DEBUG_BUILD$2 && logger.log(`Integration skipped because it was already installed: ${integration.name}`);
        return;
      }
      integrationIndex[integration.name] = integration;
      if (installedIntegrations.indexOf(integration.name) === -1 && typeof integration.setupOnce === "function") {
        integration.setupOnce();
        installedIntegrations.push(integration.name);
      }
      if (integration.setup && typeof integration.setup === "function") {
        integration.setup(client2);
      }
      if (typeof integration.preprocessEvent === "function") {
        const callback = integration.preprocessEvent.bind(integration);
        client2.on("preprocessEvent", (event, hint) => callback(event, hint, client2));
      }
      if (typeof integration.processEvent === "function") {
        const callback = integration.processEvent.bind(integration);
        const processor = Object.assign((event, hint) => callback(event, hint, client2), {
          id: integration.name
        });
        client2.addEventProcessor(processor);
      }
      DEBUG_BUILD$2 && logger.log(`Integration installed: ${integration.name}`);
    }
    function findIndex$1(arr2, callback) {
      for (let i2 = 0; i2 < arr2.length; i2++) {
        if (callback(arr2[i2]) === true) {
          return i2;
        }
      }
      return -1;
    }
    function defineIntegration(fn) {
      return fn;
    }
    const ALREADY_SEEN_ERROR = "Not capturing exception because it's already been captured.";
    class BaseClient {
      /** Options passed to the SDK. */
      /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */
      /** Array of set up integrations. */
      /** Number of calls being processed */
      /** Holds flushable  */
      // eslint-disable-next-line @typescript-eslint/ban-types
      /**
       * Initializes this client instance.
       *
       * @param options Options for the client.
       */
      constructor(options) {
        this._options = options;
        this._integrations = {};
        this._numProcessing = 0;
        this._outcomes = {};
        this._hooks = {};
        this._eventProcessors = [];
        if (options.dsn) {
          this._dsn = makeDsn(options.dsn);
        } else {
          DEBUG_BUILD$2 && logger.warn("No DSN provided, client will not send events.");
        }
        if (this._dsn) {
          const url = getEnvelopeEndpointWithUrlEncodedAuth(
            this._dsn,
            options.tunnel,
            options._metadata ? options._metadata.sdk : void 0
          );
          this._transport = options.transport({
            tunnel: this._options.tunnel,
            recordDroppedEvent: this.recordDroppedEvent.bind(this),
            ...options.transportOptions,
            url
          });
        }
      }
      /**
       * @inheritDoc
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      captureException(exception, hint, scope2) {
        const eventId = uuid4();
        if (checkOrSetAlreadyCaught(exception)) {
          DEBUG_BUILD$2 && logger.log(ALREADY_SEEN_ERROR);
          return eventId;
        }
        const hintWithEventId = {
          event_id: eventId,
          ...hint
        };
        this._process(
          this.eventFromException(exception, hintWithEventId).then(
            (event) => this._captureEvent(event, hintWithEventId, scope2)
          )
        );
        return hintWithEventId.event_id;
      }
      /**
       * @inheritDoc
       */
      captureMessage(message2, level, hint, currentScope2) {
        const hintWithEventId = {
          event_id: uuid4(),
          ...hint
        };
        const eventMessage = isParameterizedString(message2) ? message2 : String(message2);
        const promisedEvent = isPrimitive(message2) ? this.eventFromMessage(eventMessage, level, hintWithEventId) : this.eventFromException(message2, hintWithEventId);
        this._process(promisedEvent.then((event) => this._captureEvent(event, hintWithEventId, currentScope2)));
        return hintWithEventId.event_id;
      }
      /**
       * @inheritDoc
       */
      captureEvent(event, hint, currentScope2) {
        const eventId = uuid4();
        if (hint && hint.originalException && checkOrSetAlreadyCaught(hint.originalException)) {
          DEBUG_BUILD$2 && logger.log(ALREADY_SEEN_ERROR);
          return eventId;
        }
        const hintWithEventId = {
          event_id: eventId,
          ...hint
        };
        const sdkProcessingMetadata = event.sdkProcessingMetadata || {};
        const capturedSpanScope = sdkProcessingMetadata.capturedSpanScope;
        this._process(this._captureEvent(event, hintWithEventId, capturedSpanScope || currentScope2));
        return hintWithEventId.event_id;
      }
      /**
       * @inheritDoc
       */
      captureSession(session) {
        if (!(typeof session.release === "string")) {
          DEBUG_BUILD$2 && logger.warn("Discarded session because of missing or non-string release");
        } else {
          this.sendSession(session);
          updateSession(session, { init: false });
        }
      }
      /**
       * @inheritDoc
       */
      getDsn() {
        return this._dsn;
      }
      /**
       * @inheritDoc
       */
      getOptions() {
        return this._options;
      }
      /**
       * @see SdkMetadata in @sentry/types
       *
       * @return The metadata of the SDK
       */
      getSdkMetadata() {
        return this._options._metadata;
      }
      /**
       * @inheritDoc
       */
      getTransport() {
        return this._transport;
      }
      /**
       * @inheritDoc
       */
      flush(timeout) {
        const transport = this._transport;
        if (transport) {
          this.emit("flush");
          return this._isClientDoneProcessing(timeout).then((clientFinished) => {
            return transport.flush(timeout).then((transportFlushed) => clientFinished && transportFlushed);
          });
        } else {
          return resolvedSyncPromise(true);
        }
      }
      /**
       * @inheritDoc
       */
      close(timeout) {
        return this.flush(timeout).then((result) => {
          this.getOptions().enabled = false;
          this.emit("close");
          return result;
        });
      }
      /** Get all installed event processors. */
      getEventProcessors() {
        return this._eventProcessors;
      }
      /** @inheritDoc */
      addEventProcessor(eventProcessor) {
        this._eventProcessors.push(eventProcessor);
      }
      /** @inheritdoc */
      init() {
        if (this._isEnabled()) {
          this._setupIntegrations();
        }
      }
      /**
       * Gets an installed integration by its name.
       *
       * @returns The installed integration or `undefined` if no integration with that `name` was installed.
       */
      getIntegrationByName(integrationName) {
        return this._integrations[integrationName];
      }
      /**
       * @inheritDoc
       */
      addIntegration(integration) {
        const isAlreadyInstalled = this._integrations[integration.name];
        setupIntegration(this, integration, this._integrations);
        if (!isAlreadyInstalled) {
          afterSetupIntegrations(this, [integration]);
        }
      }
      /**
       * @inheritDoc
       */
      sendEvent(event, hint = {}) {
        this.emit("beforeSendEvent", event, hint);
        let env = createEventEnvelope(event, this._dsn, this._options._metadata, this._options.tunnel);
        for (const attachment of hint.attachments || []) {
          env = addItemToEnvelope(env, createAttachmentEnvelopeItem(attachment));
        }
        const promise2 = this.sendEnvelope(env);
        if (promise2) {
          promise2.then((sendResponse) => this.emit("afterSendEvent", event, sendResponse), null);
        }
      }
      /**
       * @inheritDoc
       */
      sendSession(session) {
        const env = createSessionEnvelope(session, this._dsn, this._options._metadata, this._options.tunnel);
        this.sendEnvelope(env);
      }
      /**
       * @inheritDoc
       */
      recordDroppedEvent(reason, category, _event) {
        if (this._options.sendClientReports) {
          const key2 = `${reason}:${category}`;
          DEBUG_BUILD$2 && logger.log(`Adding outcome: "${key2}"`);
          this._outcomes[key2] = this._outcomes[key2] + 1 || 1;
        }
      }
      // Keep on() & emit() signatures in sync with types' client.ts interface
      /* eslint-disable @typescript-eslint/unified-signatures */
      /** @inheritdoc */
      /** @inheritdoc */
      on(hook, callback) {
        if (!this._hooks[hook]) {
          this._hooks[hook] = [];
        }
        this._hooks[hook].push(callback);
      }
      /** @inheritdoc */
      /** @inheritdoc */
      emit(hook, ...rest) {
        if (this._hooks[hook]) {
          this._hooks[hook].forEach((callback) => callback(...rest));
        }
      }
      /**
       * @inheritdoc
       */
      sendEnvelope(envelope) {
        this.emit("beforeEnvelope", envelope);
        if (this._isEnabled() && this._transport) {
          return this._transport.send(envelope).then(null, (reason) => {
            DEBUG_BUILD$2 && logger.error("Error while sending event:", reason);
            return reason;
          });
        }
        DEBUG_BUILD$2 && logger.error("Transport disabled");
        return resolvedSyncPromise({});
      }
      /* eslint-enable @typescript-eslint/unified-signatures */
      /** Setup integrations for this client. */
      _setupIntegrations() {
        const { integrations } = this._options;
        this._integrations = setupIntegrations(this, integrations);
        afterSetupIntegrations(this, integrations);
      }
      /** Updates existing session based on the provided event */
      _updateSessionFromEvent(session, event) {
        let crashed = false;
        let errored = false;
        const exceptions = event.exception && event.exception.values;
        if (exceptions) {
          errored = true;
          for (const ex of exceptions) {
            const mechanism = ex.mechanism;
            if (mechanism && mechanism.handled === false) {
              crashed = true;
              break;
            }
          }
        }
        const sessionNonTerminal = session.status === "ok";
        const shouldUpdateAndSend = sessionNonTerminal && session.errors === 0 || sessionNonTerminal && crashed;
        if (shouldUpdateAndSend) {
          updateSession(session, {
            ...crashed && { status: "crashed" },
            errors: session.errors || Number(errored || crashed)
          });
          this.captureSession(session);
        }
      }
      /**
       * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying
       * "no" (resolving to `false`) in order to give the client a chance to potentially finish first.
       *
       * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not
       * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to
       * `true`.
       * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and
       * `false` otherwise
       */
      _isClientDoneProcessing(timeout) {
        return new SyncPromise((resolve) => {
          let ticked = 0;
          const tick = 1;
          const interval = setInterval(() => {
            if (this._numProcessing == 0) {
              clearInterval(interval);
              resolve(true);
            } else {
              ticked += tick;
              if (timeout && ticked >= timeout) {
                clearInterval(interval);
                resolve(false);
              }
            }
          }, tick);
        });
      }
      /** Determines whether this SDK is enabled and a transport is present. */
      _isEnabled() {
        return this.getOptions().enabled !== false && this._transport !== void 0;
      }
      /**
       * Adds common information to events.
       *
       * The information includes release and environment from `options`,
       * breadcrumbs and context (extra, tags and user) from the scope.
       *
       * Information that is already present in the event is never overwritten. For
       * nested objects, such as the context, keys are merged.
       *
       * @param event The original event.
       * @param hint May contain additional information about the original exception.
       * @param currentScope A scope containing event metadata.
       * @returns A new event with more information.
       */
      _prepareEvent(event, hint, currentScope2, isolationScope = getIsolationScope()) {
        const options = this.getOptions();
        const integrations = Object.keys(this._integrations);
        if (!hint.integrations && integrations.length > 0) {
          hint.integrations = integrations;
        }
        this.emit("preprocessEvent", event, hint);
        if (!event.type) {
          isolationScope.setLastEventId(event.event_id || hint.event_id);
        }
        return prepareEvent(options, event, hint, currentScope2, this, isolationScope).then((evt) => {
          if (evt === null) {
            return evt;
          }
          const propagationContext = {
            ...isolationScope.getPropagationContext(),
            ...currentScope2 ? currentScope2.getPropagationContext() : void 0
          };
          const trace = evt.contexts && evt.contexts.trace;
          if (!trace && propagationContext) {
            const { traceId: trace_id, spanId, parentSpanId, dsc } = propagationContext;
            evt.contexts = {
              trace: dropUndefinedKeys({
                trace_id,
                span_id: spanId,
                parent_span_id: parentSpanId
              }),
              ...evt.contexts
            };
            const dynamicSamplingContext = dsc ? dsc : getDynamicSamplingContextFromClient(trace_id, this);
            evt.sdkProcessingMetadata = {
              dynamicSamplingContext,
              ...evt.sdkProcessingMetadata
            };
          }
          return evt;
        });
      }
      /**
       * Processes the event and logs an error in case of rejection
       * @param event
       * @param hint
       * @param scope
       */
      _captureEvent(event, hint = {}, scope2) {
        return this._processEvent(event, hint, scope2).then(
          (finalEvent) => {
            return finalEvent.event_id;
          },
          (reason) => {
            if (DEBUG_BUILD$2) {
              const sentryError = reason;
              if (sentryError.logLevel === "log") {
                logger.log(sentryError.message);
              } else {
                logger.warn(sentryError);
              }
            }
            return void 0;
          }
        );
      }
      /**
       * Processes an event (either error or message) and sends it to Sentry.
       *
       * This also adds breadcrumbs and context information to the event. However,
       * platform specific meta data (such as the User's IP address) must be added
       * by the SDK implementor.
       *
       *
       * @param event The event to send to Sentry.
       * @param hint May contain additional information about the original exception.
       * @param currentScope A scope containing event metadata.
       * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.
       */
      _processEvent(event, hint, currentScope2) {
        const options = this.getOptions();
        const { sampleRate } = options;
        const isTransaction = isTransactionEvent(event);
        const isError2 = isErrorEvent(event);
        const eventType = event.type || "error";
        const beforeSendLabel = `before send for type \`${eventType}\``;
        const parsedSampleRate = typeof sampleRate === "undefined" ? void 0 : parseSampleRate(sampleRate);
        if (isError2 && typeof parsedSampleRate === "number" && Math.random() > parsedSampleRate) {
          this.recordDroppedEvent("sample_rate", "error", event);
          return rejectedSyncPromise(
            new SentryError(
              `Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`,
              "log"
            )
          );
        }
        const dataCategory = eventType === "replay_event" ? "replay" : eventType;
        const sdkProcessingMetadata = event.sdkProcessingMetadata || {};
        const capturedSpanIsolationScope = sdkProcessingMetadata.capturedSpanIsolationScope;
        return this._prepareEvent(event, hint, currentScope2, capturedSpanIsolationScope).then((prepared) => {
          if (prepared === null) {
            this.recordDroppedEvent("event_processor", dataCategory, event);
            throw new SentryError("An event processor returned `null`, will not send event.", "log");
          }
          const isInternalException = hint.data && hint.data.__sentry__ === true;
          if (isInternalException) {
            return prepared;
          }
          const result = processBeforeSend(options, prepared, hint);
          return _validateBeforeSendResult(result, beforeSendLabel);
        }).then((processedEvent) => {
          if (processedEvent === null) {
            this.recordDroppedEvent("before_send", dataCategory, event);
            throw new SentryError(`${beforeSendLabel} returned \`null\`, will not send event.`, "log");
          }
          const session = currentScope2 && currentScope2.getSession();
          if (!isTransaction && session) {
            this._updateSessionFromEvent(session, processedEvent);
          }
          const transactionInfo = processedEvent.transaction_info;
          if (isTransaction && transactionInfo && processedEvent.transaction !== event.transaction) {
            const source = "custom";
            processedEvent.transaction_info = {
              ...transactionInfo,
              source
            };
          }
          this.sendEvent(processedEvent, hint);
          return processedEvent;
        }).then(null, (reason) => {
          if (reason instanceof SentryError) {
            throw reason;
          }
          this.captureException(reason, {
            data: {
              __sentry__: true
            },
            originalException: reason
          });
          throw new SentryError(
            `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${reason}`
          );
        });
      }
      /**
       * Occupies the client with processing and event
       */
      _process(promise2) {
        this._numProcessing++;
        void promise2.then(
          (value2) => {
            this._numProcessing--;
            return value2;
          },
          (reason) => {
            this._numProcessing--;
            return reason;
          }
        );
      }
      /**
       * Clears outcomes on this client and returns them.
       */
      _clearOutcomes() {
        const outcomes = this._outcomes;
        this._outcomes = {};
        return Object.keys(outcomes).map((key2) => {
          const [reason, category] = key2.split(":");
          return {
            reason,
            category,
            quantity: outcomes[key2]
          };
        });
      }
      /**
       * @inheritDoc
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    }
    function _validateBeforeSendResult(beforeSendResult, beforeSendLabel) {
      const invalidValueError = `${beforeSendLabel} must return \`null\` or a valid event.`;
      if (isThenable(beforeSendResult)) {
        return beforeSendResult.then(
          (event) => {
            if (!isPlainObject$2(event) && event !== null) {
              throw new SentryError(invalidValueError);
            }
            return event;
          },
          (e2) => {
            throw new SentryError(`${beforeSendLabel} rejected with ${e2}`);
          }
        );
      } else if (!isPlainObject$2(beforeSendResult) && beforeSendResult !== null) {
        throw new SentryError(invalidValueError);
      }
      return beforeSendResult;
    }
    function processBeforeSend(options, event, hint) {
      const { beforeSend, beforeSendTransaction, beforeSendSpan } = options;
      if (isErrorEvent(event) && beforeSend) {
        return beforeSend(event, hint);
      }
      if (isTransactionEvent(event)) {
        if (event.spans && beforeSendSpan) {
          const processedSpans = [];
          for (const span of event.spans) {
            const processedSpan = beforeSendSpan(span);
            if (processedSpan) {
              processedSpans.push(processedSpan);
            }
          }
          event.spans = processedSpans;
        }
        if (beforeSendTransaction) {
          return beforeSendTransaction(event, hint);
        }
      }
      return event;
    }
    function isErrorEvent(event) {
      return event.type === void 0;
    }
    function isTransactionEvent(event) {
      return event.type === "transaction";
    }
    function initAndBind(clientClass, options) {
      if (options.debug === true) {
        if (DEBUG_BUILD$2) {
          logger.enable();
        } else {
          consoleSandbox(() => {
            console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.");
          });
        }
      }
      const scope2 = getCurrentScope$1();
      scope2.update(options.initialScope);
      const client2 = new clientClass(options);
      setCurrentClient(client2);
      client2.init();
    }
    function setCurrentClient(client2) {
      getCurrentScope$1().setClient(client2);
    }
    const DEFAULT_TRANSPORT_BUFFER_SIZE = 64;
    function createTransport(options, makeRequest, buffer = makePromiseBuffer(
      options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE
    )) {
      let rateLimits = {};
      const flush = (timeout) => buffer.drain(timeout);
      function send(envelope) {
        const filteredEnvelopeItems = [];
        forEachEnvelopeItem(envelope, (item, type) => {
          const dataCategory = envelopeItemTypeToDataCategory(type);
          if (isRateLimited(rateLimits, dataCategory)) {
            const event = getEventForEnvelopeItem(item, type);
            options.recordDroppedEvent("ratelimit_backoff", dataCategory, event);
          } else {
            filteredEnvelopeItems.push(item);
          }
        });
        if (filteredEnvelopeItems.length === 0) {
          return resolvedSyncPromise({});
        }
        const filteredEnvelope = createEnvelope(envelope[0], filteredEnvelopeItems);
        const recordEnvelopeLoss = (reason) => {
          forEachEnvelopeItem(filteredEnvelope, (item, type) => {
            const event = getEventForEnvelopeItem(item, type);
            options.recordDroppedEvent(reason, envelopeItemTypeToDataCategory(type), event);
          });
        };
        const requestTask = () => makeRequest({ body: serializeEnvelope(filteredEnvelope) }).then(
          (response) => {
            if (response.statusCode !== void 0 && (response.statusCode < 200 || response.statusCode >= 300)) {
              DEBUG_BUILD$2 && logger.warn(`Sentry responded with status code ${response.statusCode} to sent event.`);
            }
            rateLimits = updateRateLimits(rateLimits, response);
            return response;
          },
          (error) => {
            recordEnvelopeLoss("network_error");
            throw error;
          }
        );
        return buffer.add(requestTask).then(
          (result) => result,
          (error) => {
            if (error instanceof SentryError) {
              DEBUG_BUILD$2 && logger.error("Skipped sending event because buffer is full.");
              recordEnvelopeLoss("queue_overflow");
              return resolvedSyncPromise({});
            } else {
              throw error;
            }
          }
        );
      }
      return {
        send,
        flush
      };
    }
    function getEventForEnvelopeItem(item, type) {
      if (type !== "event" && type !== "transaction") {
        return void 0;
      }
      return Array.isArray(item) ? item[1] : void 0;
    }
    function applySdkMetadata(options, name2, names = [name2], source = "npm") {
      const metadata = options._metadata || {};
      if (!metadata.sdk) {
        metadata.sdk = {
          name: `sentry.javascript.${name2}`,
          packages: names.map((name3) => ({
            name: `${source}:@sentry/${name3}`,
            version: SDK_VERSION
          })),
          version: SDK_VERSION
        };
      }
      options._metadata = metadata;
    }
    const DEFAULT_BREADCRUMBS = 100;
    function addBreadcrumb(breadcrumb, hint) {
      const client2 = getClient();
      const isolationScope = getIsolationScope();
      if (!client2)
        return;
      const { beforeBreadcrumb = null, maxBreadcrumbs = DEFAULT_BREADCRUMBS } = client2.getOptions();
      if (maxBreadcrumbs <= 0)
        return;
      const timestamp = dateTimestampInSeconds();
      const mergedBreadcrumb = { timestamp, ...breadcrumb };
      const finalBreadcrumb = beforeBreadcrumb ? consoleSandbox(() => beforeBreadcrumb(mergedBreadcrumb, hint)) : mergedBreadcrumb;
      if (finalBreadcrumb === null)
        return;
      if (client2.emit) {
        client2.emit("beforeAddBreadcrumb", finalBreadcrumb, hint);
      }
      isolationScope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);
    }
    let originalFunctionToString;
    const INTEGRATION_NAME$6 = "FunctionToString";
    const SETUP_CLIENTS = /* @__PURE__ */ new WeakMap();
    const _functionToStringIntegration = () => {
      return {
        name: INTEGRATION_NAME$6,
        setupOnce() {
          originalFunctionToString = Function.prototype.toString;
          try {
            Function.prototype.toString = function(...args) {
              const originalFunction = getOriginalFunction(this);
              const context = SETUP_CLIENTS.has(getClient()) && originalFunction !== void 0 ? originalFunction : this;
              return originalFunctionToString.apply(context, args);
            };
          } catch (e2) {
          }
        },
        setup(client2) {
          SETUP_CLIENTS.set(client2, true);
        }
      };
    };
    const functionToStringIntegration = defineIntegration(_functionToStringIntegration);
    const DEFAULT_IGNORE_ERRORS = [
      /^Script error\.?$/,
      /^Javascript error: Script error\.? on line 0$/,
      /^ResizeObserver loop completed with undelivered notifications.$/,
      // The browser logs this when a ResizeObserver handler takes a bit longer. Usually this is not an actual issue though. It indicates slowness.
      /^Cannot redefine property: googletag$/,
      // This is thrown when google tag manager is used in combination with an ad blocker
      "undefined is not an object (evaluating 'a.L')",
      // Random error that happens but not actionable or noticeable to end-users.
      `can't redefine non-configurable property "solana"`,
      // Probably a browser extension or custom browser (Brave) throwing this error
      "vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)",
      // Error thrown by GTM, seemingly not affecting end-users
      "Can't find variable: _AutofillCallbackHandler"
      // Unactionable error in instagram webview https://developers.facebook.com/community/threads/320013549791141/
    ];
    const INTEGRATION_NAME$5 = "InboundFilters";
    const _inboundFiltersIntegration = (options = {}) => {
      return {
        name: INTEGRATION_NAME$5,
        processEvent(event, _hint, client2) {
          const clientOptions = client2.getOptions();
          const mergedOptions = _mergeOptions(options, clientOptions);
          return _shouldDropEvent$1(event, mergedOptions) ? null : event;
        }
      };
    };
    const inboundFiltersIntegration = defineIntegration(_inboundFiltersIntegration);
    function _mergeOptions(internalOptions = {}, clientOptions = {}) {
      return {
        allowUrls: [...internalOptions.allowUrls || [], ...clientOptions.allowUrls || []],
        denyUrls: [...internalOptions.denyUrls || [], ...clientOptions.denyUrls || []],
        ignoreErrors: [
          ...internalOptions.ignoreErrors || [],
          ...clientOptions.ignoreErrors || [],
          ...internalOptions.disableErrorDefaults ? [] : DEFAULT_IGNORE_ERRORS
        ],
        ignoreTransactions: [...internalOptions.ignoreTransactions || [], ...clientOptions.ignoreTransactions || []],
        ignoreInternal: internalOptions.ignoreInternal !== void 0 ? internalOptions.ignoreInternal : true
      };
    }
    function _shouldDropEvent$1(event, options) {
      if (options.ignoreInternal && _isSentryError(event)) {
        DEBUG_BUILD$2 && logger.warn(`Event dropped due to being internal Sentry Error.
Event: ${getEventDescription(event)}`);
        return true;
      }
      if (_isIgnoredError(event, options.ignoreErrors)) {
        DEBUG_BUILD$2 && logger.warn(
          `Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${getEventDescription(event)}`
        );
        return true;
      }
      if (_isUselessError(event)) {
        DEBUG_BUILD$2 && logger.warn(
          `Event dropped due to not having an error message, error type or stacktrace.
Event: ${getEventDescription(
            event
          )}`
        );
        return true;
      }
      if (_isIgnoredTransaction(event, options.ignoreTransactions)) {
        DEBUG_BUILD$2 && logger.warn(
          `Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${getEventDescription(event)}`
        );
        return true;
      }
      if (_isDeniedUrl(event, options.denyUrls)) {
        DEBUG_BUILD$2 && logger.warn(
          `Event dropped due to being matched by \`denyUrls\` option.
Event: ${getEventDescription(
            event
          )}.
Url: ${_getEventFilterUrl(event)}`
        );
        return true;
      }
      if (!_isAllowedUrl(event, options.allowUrls)) {
        DEBUG_BUILD$2 && logger.warn(
          `Event dropped due to not being matched by \`allowUrls\` option.
Event: ${getEventDescription(
            event
          )}.
Url: ${_getEventFilterUrl(event)}`
        );
        return true;
      }
      return false;
    }
    function _isIgnoredError(event, ignoreErrors) {
      if (event.type || !ignoreErrors || !ignoreErrors.length) {
        return false;
      }
      return _getPossibleEventMessages(event).some((message2) => stringMatchesSomePattern(message2, ignoreErrors));
    }
    function _isIgnoredTransaction(event, ignoreTransactions) {
      if (event.type !== "transaction" || !ignoreTransactions || !ignoreTransactions.length) {
        return false;
      }
      const name2 = event.transaction;
      return name2 ? stringMatchesSomePattern(name2, ignoreTransactions) : false;
    }
    function _isDeniedUrl(event, denyUrls) {
      if (!denyUrls || !denyUrls.length) {
        return false;
      }
      const url = _getEventFilterUrl(event);
      return !url ? false : stringMatchesSomePattern(url, denyUrls);
    }
    function _isAllowedUrl(event, allowUrls) {
      if (!allowUrls || !allowUrls.length) {
        return true;
      }
      const url = _getEventFilterUrl(event);
      return !url ? true : stringMatchesSomePattern(url, allowUrls);
    }
    function _getPossibleEventMessages(event) {
      const possibleMessages = [];
      if (event.message) {
        possibleMessages.push(event.message);
      }
      let lastException;
      try {
        lastException = event.exception.values[event.exception.values.length - 1];
      } catch (e2) {
      }
      if (lastException) {
        if (lastException.value) {
          possibleMessages.push(lastException.value);
          if (lastException.type) {
            possibleMessages.push(`${lastException.type}: ${lastException.value}`);
          }
        }
      }
      return possibleMessages;
    }
    function _isSentryError(event) {
      try {
        return event.exception.values[0].type === "SentryError";
      } catch (e2) {
      }
      return false;
    }
    function _getLastValidUrl(frames2 = []) {
      for (let i2 = frames2.length - 1; i2 >= 0; i2--) {
        const frame = frames2[i2];
        if (frame && frame.filename !== "<anonymous>" && frame.filename !== "[native code]") {
          return frame.filename || null;
        }
      }
      return null;
    }
    function _getEventFilterUrl(event) {
      try {
        let frames2;
        try {
          frames2 = event.exception.values[0].stacktrace.frames;
        } catch (e2) {
        }
        return frames2 ? _getLastValidUrl(frames2) : null;
      } catch (oO) {
        DEBUG_BUILD$2 && logger.error(`Cannot extract url for event ${getEventDescription(event)}`);
        return null;
      }
    }
    function _isUselessError(event) {
      if (event.type) {
        return false;
      }
      if (!event.exception || !event.exception.values || event.exception.values.length === 0) {
        return false;
      }
      return (
        // No top-level message
        !event.message && // There are no exception values that have a stacktrace, a non-generic-Error type or value
        !event.exception.values.some((value2) => value2.stacktrace || value2.type && value2.type !== "Error" || value2.value)
      );
    }
    const INTEGRATION_NAME$4 = "Dedupe";
    const _dedupeIntegration = () => {
      let previousEvent;
      return {
        name: INTEGRATION_NAME$4,
        processEvent(currentEvent) {
          if (currentEvent.type) {
            return currentEvent;
          }
          try {
            if (_shouldDropEvent(currentEvent, previousEvent)) {
              DEBUG_BUILD$2 && logger.warn("Event dropped due to being a duplicate of previously captured event.");
              return null;
            }
          } catch (_oO) {
          }
          return previousEvent = currentEvent;
        }
      };
    };
    const dedupeIntegration = defineIntegration(_dedupeIntegration);
    function _shouldDropEvent(currentEvent, previousEvent) {
      if (!previousEvent) {
        return false;
      }
      if (_isSameMessageEvent(currentEvent, previousEvent)) {
        return true;
      }
      if (_isSameExceptionEvent(currentEvent, previousEvent)) {
        return true;
      }
      return false;
    }
    function _isSameMessageEvent(currentEvent, previousEvent) {
      const currentMessage = currentEvent.message;
      const previousMessage = previousEvent.message;
      if (!currentMessage && !previousMessage) {
        return false;
      }
      if (currentMessage && !previousMessage || !currentMessage && previousMessage) {
        return false;
      }
      if (currentMessage !== previousMessage) {
        return false;
      }
      if (!_isSameFingerprint(currentEvent, previousEvent)) {
        return false;
      }
      if (!_isSameStacktrace(currentEvent, previousEvent)) {
        return false;
      }
      return true;
    }
    function _isSameExceptionEvent(currentEvent, previousEvent) {
      const previousException = _getExceptionFromEvent(previousEvent);
      const currentException = _getExceptionFromEvent(currentEvent);
      if (!previousException || !currentException) {
        return false;
      }
      if (previousException.type !== currentException.type || previousException.value !== currentException.value) {
        return false;
      }
      if (!_isSameFingerprint(currentEvent, previousEvent)) {
        return false;
      }
      if (!_isSameStacktrace(currentEvent, previousEvent)) {
        return false;
      }
      return true;
    }
    function _isSameStacktrace(currentEvent, previousEvent) {
      let currentFrames = getFramesFromEvent(currentEvent);
      let previousFrames = getFramesFromEvent(previousEvent);
      if (!currentFrames && !previousFrames) {
        return true;
      }
      if (currentFrames && !previousFrames || !currentFrames && previousFrames) {
        return false;
      }
      currentFrames = currentFrames;
      previousFrames = previousFrames;
      if (previousFrames.length !== currentFrames.length) {
        return false;
      }
      for (let i2 = 0; i2 < previousFrames.length; i2++) {
        const frameA = previousFrames[i2];
        const frameB = currentFrames[i2];
        if (frameA.filename !== frameB.filename || frameA.lineno !== frameB.lineno || frameA.colno !== frameB.colno || frameA.function !== frameB.function) {
          return false;
        }
      }
      return true;
    }
    function _isSameFingerprint(currentEvent, previousEvent) {
      let currentFingerprint = currentEvent.fingerprint;
      let previousFingerprint = previousEvent.fingerprint;
      if (!currentFingerprint && !previousFingerprint) {
        return true;
      }
      if (currentFingerprint && !previousFingerprint || !currentFingerprint && previousFingerprint) {
        return false;
      }
      currentFingerprint = currentFingerprint;
      previousFingerprint = previousFingerprint;
      try {
        return !!(currentFingerprint.join("") === previousFingerprint.join(""));
      } catch (_oO) {
        return false;
      }
    }
    function _getExceptionFromEvent(event) {
      return event.exception && event.exception.values && event.exception.values[0];
    }
    const WINDOW$1 = GLOBAL_OBJ;
    let ignoreOnError = 0;
    function shouldIgnoreOnError() {
      return ignoreOnError > 0;
    }
    function ignoreNextOnError() {
      ignoreOnError++;
      setTimeout(() => {
        ignoreOnError--;
      });
    }
    function wrap(fn, options = {}, before) {
      if (typeof fn !== "function") {
        return fn;
      }
      try {
        const wrapper2 = fn.__sentry_wrapped__;
        if (wrapper2) {
          return wrapper2;
        }
        if (getOriginalFunction(fn)) {
          return fn;
        }
      } catch (e2) {
        return fn;
      }
      const sentryWrapped = function() {
        const args = Array.prototype.slice.call(arguments);
        try {
          if (before && typeof before === "function")
            ;
          const wrappedArguments = args.map((arg) => wrap(arg, options));
          return fn.apply(this, wrappedArguments);
        } catch (ex) {
          ignoreNextOnError();
          withScope((scope2) => {
            scope2.addEventProcessor((event) => {
              if (options.mechanism) {
                addExceptionTypeValue(event, void 0);
                addExceptionMechanism(event, options.mechanism);
              }
              event.extra = {
                ...event.extra,
                arguments: args
              };
              return event;
            });
            captureException(ex);
          });
          throw ex;
        }
      };
      try {
        for (const property2 in fn) {
          if (Object.prototype.hasOwnProperty.call(fn, property2)) {
            sentryWrapped[property2] = fn[property2];
          }
        }
      } catch (_oO) {
      }
      markFunctionWrapped(sentryWrapped, fn);
      addNonEnumerableProperty(fn, "__sentry_wrapped__", sentryWrapped);
      try {
        const descriptor = Object.getOwnPropertyDescriptor(sentryWrapped, "name");
        if (descriptor.configurable) {
          Object.defineProperty(sentryWrapped, "name", {
            get() {
              return fn.name;
            }
          });
        }
      } catch (_oO) {
      }
      return sentryWrapped;
    }
    const DEBUG_BUILD$1 = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;
    function exceptionFromError(stackParser, ex) {
      const frames2 = parseStackFrames(stackParser, ex);
      const exception = {
        type: ex && ex.name,
        value: extractMessage(ex)
      };
      if (frames2.length) {
        exception.stacktrace = { frames: frames2 };
      }
      if (exception.type === void 0 && exception.value === "") {
        exception.value = "Unrecoverable error caught";
      }
      return exception;
    }
    function eventFromPlainObject(stackParser, exception, syntheticException, isUnhandledRejection) {
      const client2 = getClient();
      const normalizeDepth = client2 && client2.getOptions().normalizeDepth;
      const errorFromProp = getErrorPropertyFromObject(exception);
      const extra = {
        __serialized__: normalizeToSize(exception, normalizeDepth)
      };
      if (errorFromProp) {
        return {
          exception: {
            values: [exceptionFromError(stackParser, errorFromProp)]
          },
          extra
        };
      }
      const event = {
        exception: {
          values: [
            {
              type: isEvent(exception) ? exception.constructor.name : isUnhandledRejection ? "UnhandledRejection" : "Error",
              value: getNonErrorObjectExceptionValue(exception, { isUnhandledRejection })
            }
          ]
        },
        extra
      };
      if (syntheticException) {
        const frames2 = parseStackFrames(stackParser, syntheticException);
        if (frames2.length) {
          event.exception.values[0].stacktrace = { frames: frames2 };
        }
      }
      return event;
    }
    function eventFromError(stackParser, ex) {
      return {
        exception: {
          values: [exceptionFromError(stackParser, ex)]
        }
      };
    }
    function parseStackFrames(stackParser, ex) {
      const stacktrace = ex.stacktrace || ex.stack || "";
      const skipLines = getSkipFirstStackStringLines(ex);
      const framesToPop = getPopFirstTopFrames(ex);
      try {
        return stackParser(stacktrace, skipLines, framesToPop);
      } catch (e2) {
      }
      return [];
    }
    const reactMinifiedRegexp = /Minified React error #\d+;/i;
    function getSkipFirstStackStringLines(ex) {
      if (ex && reactMinifiedRegexp.test(ex.message)) {
        return 1;
      }
      return 0;
    }
    function getPopFirstTopFrames(ex) {
      if (typeof ex.framesToPop === "number") {
        return ex.framesToPop;
      }
      return 0;
    }
    function extractMessage(ex) {
      const message2 = ex && ex.message;
      if (!message2) {
        return "No error message";
      }
      if (message2.error && typeof message2.error.message === "string") {
        return message2.error.message;
      }
      return message2;
    }
    function eventFromException(stackParser, exception, hint, attachStacktrace) {
      const syntheticException = hint && hint.syntheticException || void 0;
      const event = eventFromUnknownInput(stackParser, exception, syntheticException, attachStacktrace);
      addExceptionMechanism(event);
      event.level = "error";
      if (hint && hint.event_id) {
        event.event_id = hint.event_id;
      }
      return resolvedSyncPromise(event);
    }
    function eventFromMessage(stackParser, message2, level = "info", hint, attachStacktrace) {
      const syntheticException = hint && hint.syntheticException || void 0;
      const event = eventFromString(stackParser, message2, syntheticException, attachStacktrace);
      event.level = level;
      if (hint && hint.event_id) {
        event.event_id = hint.event_id;
      }
      return resolvedSyncPromise(event);
    }
    function eventFromUnknownInput(stackParser, exception, syntheticException, attachStacktrace, isUnhandledRejection) {
      let event;
      if (isErrorEvent$1(exception) && exception.error) {
        const errorEvent = exception;
        return eventFromError(stackParser, errorEvent.error);
      }
      if (isDOMError(exception) || isDOMException(exception)) {
        const domException = exception;
        if ("stack" in exception) {
          event = eventFromError(stackParser, exception);
        } else {
          const name2 = domException.name || (isDOMError(domException) ? "DOMError" : "DOMException");
          const message2 = domException.message ? `${name2}: ${domException.message}` : name2;
          event = eventFromString(stackParser, message2, syntheticException, attachStacktrace);
          addExceptionTypeValue(event, message2);
        }
        if ("code" in domException) {
          event.tags = { ...event.tags, "DOMException.code": `${domException.code}` };
        }
        return event;
      }
      if (isError(exception)) {
        return eventFromError(stackParser, exception);
      }
      if (isPlainObject$2(exception) || isEvent(exception)) {
        const objectException = exception;
        event = eventFromPlainObject(stackParser, objectException, syntheticException, isUnhandledRejection);
        addExceptionMechanism(event, {
          synthetic: true
        });
        return event;
      }
      event = eventFromString(stackParser, exception, syntheticException, attachStacktrace);
      addExceptionTypeValue(event, `${exception}`);
      addExceptionMechanism(event, {
        synthetic: true
      });
      return event;
    }
    function eventFromString(stackParser, message2, syntheticException, attachStacktrace) {
      const event = {};
      if (attachStacktrace && syntheticException) {
        const frames2 = parseStackFrames(stackParser, syntheticException);
        if (frames2.length) {
          event.exception = {
            values: [{ value: message2, stacktrace: { frames: frames2 } }]
          };
        }
      }
      if (isParameterizedString(message2)) {
        const { __sentry_template_string__, __sentry_template_values__ } = message2;
        event.logentry = {
          message: __sentry_template_string__,
          params: __sentry_template_values__
        };
        return event;
      }
      event.message = message2;
      return event;
    }
    function getNonErrorObjectExceptionValue(exception, { isUnhandledRejection }) {
      const keys2 = extractExceptionKeysForMessage(exception);
      const captureType = isUnhandledRejection ? "promise rejection" : "exception";
      if (isErrorEvent$1(exception)) {
        return `Event \`ErrorEvent\` captured as ${captureType} with message \`${exception.message}\``;
      }
      if (isEvent(exception)) {
        const className = getObjectClassName(exception);
        return `Event \`${className}\` (type=${exception.type}) captured as ${captureType}`;
      }
      return `Object captured as ${captureType} with keys: ${keys2}`;
    }
    function getObjectClassName(obj) {
      try {
        const prototype = Object.getPrototypeOf(obj);
        return prototype ? prototype.constructor.name : void 0;
      } catch (e2) {
      }
    }
    function getErrorPropertyFromObject(obj) {
      for (const prop in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, prop)) {
          const value2 = obj[prop];
          if (value2 instanceof Error) {
            return value2;
          }
        }
      }
      return void 0;
    }
    function createUserFeedbackEnvelope(feedback, {
      metadata,
      tunnel,
      dsn
    }) {
      const headers = {
        event_id: feedback.event_id,
        sent_at: (/* @__PURE__ */ new Date()).toISOString(),
        ...metadata && metadata.sdk && {
          sdk: {
            name: metadata.sdk.name,
            version: metadata.sdk.version
          }
        },
        ...!!tunnel && !!dsn && { dsn: dsnToString(dsn) }
      };
      const item = createUserFeedbackEnvelopeItem(feedback);
      return createEnvelope(headers, [item]);
    }
    function createUserFeedbackEnvelopeItem(feedback) {
      const feedbackHeaders = {
        type: "user_report"
      };
      return [feedbackHeaders, feedback];
    }
    class BrowserClient extends BaseClient {
      /**
       * Creates a new Browser SDK instance.
       *
       * @param options Configuration options for this SDK.
       */
      constructor(options) {
        const opts = {
          // We default this to true, as it is the safer scenario
          parentSpanIsAlwaysRootSpan: true,
          ...options
        };
        const sdkSource = WINDOW$1.SENTRY_SDK_SOURCE || getSDKSource();
        applySdkMetadata(opts, "browser", ["browser"], sdkSource);
        super(opts);
        if (opts.sendClientReports && WINDOW$1.document) {
          WINDOW$1.document.addEventListener("visibilitychange", () => {
            if (WINDOW$1.document.visibilityState === "hidden") {
              this._flushOutcomes();
            }
          });
        }
      }
      /**
       * @inheritDoc
       */
      eventFromException(exception, hint) {
        return eventFromException(this._options.stackParser, exception, hint, this._options.attachStacktrace);
      }
      /**
       * @inheritDoc
       */
      eventFromMessage(message2, level = "info", hint) {
        return eventFromMessage(this._options.stackParser, message2, level, hint, this._options.attachStacktrace);
      }
      /**
       * Sends user feedback to Sentry.
       *
       * @deprecated Use `captureFeedback` instead.
       */
      captureUserFeedback(feedback) {
        if (!this._isEnabled()) {
          DEBUG_BUILD$1 && logger.warn("SDK not enabled, will not capture user feedback.");
          return;
        }
        const envelope = createUserFeedbackEnvelope(feedback, {
          metadata: this.getSdkMetadata(),
          dsn: this.getDsn(),
          tunnel: this.getOptions().tunnel
        });
        this.sendEnvelope(envelope);
      }
      /**
       * @inheritDoc
       */
      _prepareEvent(event, hint, scope2) {
        event.platform = event.platform || "javascript";
        return super._prepareEvent(event, hint, scope2);
      }
      /**
       * Sends client reports as an envelope.
       */
      _flushOutcomes() {
        const outcomes = this._clearOutcomes();
        if (outcomes.length === 0) {
          DEBUG_BUILD$1 && logger.log("No outcomes to send");
          return;
        }
        if (!this._dsn) {
          DEBUG_BUILD$1 && logger.log("No dsn provided, will not send outcomes");
          return;
        }
        DEBUG_BUILD$1 && logger.log("Sending outcomes:", outcomes);
        const envelope = createClientReportEnvelope(outcomes, this._options.tunnel && dsnToString(this._dsn));
        this.sendEnvelope(envelope);
      }
    }
    const DEBUG_BUILD = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;
    const WINDOW = GLOBAL_OBJ;
    const DEBOUNCE_DURATION = 1e3;
    let debounceTimerID;
    let lastCapturedEventType;
    let lastCapturedEventTargetId;
    function addClickKeypressInstrumentationHandler(handler) {
      const type = "dom";
      addHandler(type, handler);
      maybeInstrument(type, instrumentDOM);
    }
    function instrumentDOM() {
      if (!WINDOW.document) {
        return;
      }
      const triggerDOMHandler = triggerHandlers.bind(null, "dom");
      const globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);
      WINDOW.document.addEventListener("click", globalDOMEventHandler, false);
      WINDOW.document.addEventListener("keypress", globalDOMEventHandler, false);
      ["EventTarget", "Node"].forEach((target) => {
        const proto = WINDOW[target] && WINDOW[target].prototype;
        if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty("addEventListener")) {
          return;
        }
        fill(proto, "addEventListener", function(originalAddEventListener) {
          return function(type, listener, options) {
            if (type === "click" || type == "keypress") {
              try {
                const el2 = this;
                const handlers2 = el2.__sentry_instrumentation_handlers__ = el2.__sentry_instrumentation_handlers__ || {};
                const handlerForType = handlers2[type] = handlers2[type] || { refCount: 0 };
                if (!handlerForType.handler) {
                  const handler = makeDOMEventHandler(triggerDOMHandler);
                  handlerForType.handler = handler;
                  originalAddEventListener.call(this, type, handler, options);
                }
                handlerForType.refCount++;
              } catch (e2) {
              }
            }
            return originalAddEventListener.call(this, type, listener, options);
          };
        });
        fill(
          proto,
          "removeEventListener",
          function(originalRemoveEventListener) {
            return function(type, listener, options) {
              if (type === "click" || type == "keypress") {
                try {
                  const el2 = this;
                  const handlers2 = el2.__sentry_instrumentation_handlers__ || {};
                  const handlerForType = handlers2[type];
                  if (handlerForType) {
                    handlerForType.refCount--;
                    if (handlerForType.refCount <= 0) {
                      originalRemoveEventListener.call(this, type, handlerForType.handler, options);
                      handlerForType.handler = void 0;
                      delete handlers2[type];
                    }
                    if (Object.keys(handlers2).length === 0) {
                      delete el2.__sentry_instrumentation_handlers__;
                    }
                  }
                } catch (e2) {
                }
              }
              return originalRemoveEventListener.call(this, type, listener, options);
            };
          }
        );
      });
    }
    function isSimilarToLastCapturedEvent(event) {
      if (event.type !== lastCapturedEventType) {
        return false;
      }
      try {
        if (!event.target || event.target._sentryId !== lastCapturedEventTargetId) {
          return false;
        }
      } catch (e2) {
      }
      return true;
    }
    function shouldSkipDOMEvent(eventType, target) {
      if (eventType !== "keypress") {
        return false;
      }
      if (!target || !target.tagName) {
        return true;
      }
      if (target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.isContentEditable) {
        return false;
      }
      return true;
    }
    function makeDOMEventHandler(handler, globalListener = false) {
      return (event) => {
        if (!event || event["_sentryCaptured"]) {
          return;
        }
        const target = getEventTarget(event);
        if (shouldSkipDOMEvent(event.type, target)) {
          return;
        }
        addNonEnumerableProperty(event, "_sentryCaptured", true);
        if (target && !target._sentryId) {
          addNonEnumerableProperty(target, "_sentryId", uuid4());
        }
        const name2 = event.type === "keypress" ? "input" : event.type;
        if (!isSimilarToLastCapturedEvent(event)) {
          const handlerData = { event, name: name2, global: globalListener };
          handler(handlerData);
          lastCapturedEventType = event.type;
          lastCapturedEventTargetId = target ? target._sentryId : void 0;
        }
        clearTimeout(debounceTimerID);
        debounceTimerID = WINDOW.setTimeout(() => {
          lastCapturedEventTargetId = void 0;
          lastCapturedEventType = void 0;
        }, DEBOUNCE_DURATION);
      };
    }
    function getEventTarget(event) {
      try {
        return event.target;
      } catch (e2) {
        return null;
      }
    }
    let lastHref;
    function addHistoryInstrumentationHandler(handler) {
      const type = "history";
      addHandler(type, handler);
      maybeInstrument(type, instrumentHistory);
    }
    function instrumentHistory() {
      if (!supportsHistory()) {
        return;
      }
      const oldOnPopState = WINDOW.onpopstate;
      WINDOW.onpopstate = function(...args) {
        const to = WINDOW.location.href;
        const from = lastHref;
        lastHref = to;
        const handlerData = { from, to };
        triggerHandlers("history", handlerData);
        if (oldOnPopState) {
          try {
            return oldOnPopState.apply(this, args);
          } catch (_oO) {
          }
        }
      };
      function historyReplacementFunction(originalHistoryFunction) {
        return function(...args) {
          const url = args.length > 2 ? args[2] : void 0;
          if (url) {
            const from = lastHref;
            const to = String(url);
            lastHref = to;
            const handlerData = { from, to };
            triggerHandlers("history", handlerData);
          }
          return originalHistoryFunction.apply(this, args);
        };
      }
      fill(WINDOW.history, "pushState", historyReplacementFunction);
      fill(WINDOW.history, "replaceState", historyReplacementFunction);
    }
    const cachedImplementations = {};
    function getNativeImplementation(name2) {
      const cached = cachedImplementations[name2];
      if (cached) {
        return cached;
      }
      let impl = WINDOW[name2];
      if (isNativeFunction(impl)) {
        return cachedImplementations[name2] = impl.bind(WINDOW);
      }
      const document2 = WINDOW.document;
      if (document2 && typeof document2.createElement === "function") {
        try {
          const sandbox = document2.createElement("iframe");
          sandbox.hidden = true;
          document2.head.appendChild(sandbox);
          const contentWindow = sandbox.contentWindow;
          if (contentWindow && contentWindow[name2]) {
            impl = contentWindow[name2];
          }
          document2.head.removeChild(sandbox);
        } catch (e2) {
          DEBUG_BUILD && logger.warn(`Could not create sandbox iframe for ${name2} check, bailing to window.${name2}: `, e2);
        }
      }
      if (!impl) {
        return impl;
      }
      return cachedImplementations[name2] = impl.bind(WINDOW);
    }
    function clearCachedImplementation(name2) {
      cachedImplementations[name2] = void 0;
    }
    const SENTRY_XHR_DATA_KEY = "__sentry_xhr_v3__";
    function addXhrInstrumentationHandler(handler) {
      const type = "xhr";
      addHandler(type, handler);
      maybeInstrument(type, instrumentXHR);
    }
    function instrumentXHR() {
      if (!WINDOW.XMLHttpRequest) {
        return;
      }
      const xhrproto = XMLHttpRequest.prototype;
      fill(xhrproto, "open", function(originalOpen) {
        return function(...args) {
          const startTimestamp = timestampInSeconds() * 1e3;
          const method = isString(args[0]) ? args[0].toUpperCase() : void 0;
          const url = parseUrl(args[1]);
          if (!method || !url) {
            return originalOpen.apply(this, args);
          }
          this[SENTRY_XHR_DATA_KEY] = {
            method,
            url,
            request_headers: {}
          };
          if (method === "POST" && url.match(/sentry_key/)) {
            this.__sentry_own_request__ = true;
          }
          const onreadystatechangeHandler = () => {
            const xhrInfo = this[SENTRY_XHR_DATA_KEY];
            if (!xhrInfo) {
              return;
            }
            if (this.readyState === 4) {
              try {
                xhrInfo.status_code = this.status;
              } catch (e2) {
              }
              const handlerData = {
                endTimestamp: timestampInSeconds() * 1e3,
                startTimestamp,
                xhr: this
              };
              triggerHandlers("xhr", handlerData);
            }
          };
          if ("onreadystatechange" in this && typeof this.onreadystatechange === "function") {
            fill(this, "onreadystatechange", function(original) {
              return function(...readyStateArgs) {
                onreadystatechangeHandler();
                return original.apply(this, readyStateArgs);
              };
            });
          } else {
            this.addEventListener("readystatechange", onreadystatechangeHandler);
          }
          fill(this, "setRequestHeader", function(original) {
            return function(...setRequestHeaderArgs) {
              const [header2, value2] = setRequestHeaderArgs;
              const xhrInfo = this[SENTRY_XHR_DATA_KEY];
              if (xhrInfo && isString(header2) && isString(value2)) {
                xhrInfo.request_headers[header2.toLowerCase()] = value2;
              }
              return original.apply(this, setRequestHeaderArgs);
            };
          });
          return originalOpen.apply(this, args);
        };
      });
      fill(xhrproto, "send", function(originalSend) {
        return function(...args) {
          const sentryXhrData = this[SENTRY_XHR_DATA_KEY];
          if (!sentryXhrData) {
            return originalSend.apply(this, args);
          }
          if (args[0] !== void 0) {
            sentryXhrData.body = args[0];
          }
          const handlerData = {
            startTimestamp: timestampInSeconds() * 1e3,
            xhr: this
          };
          triggerHandlers("xhr", handlerData);
          return originalSend.apply(this, args);
        };
      });
    }
    function parseUrl(url) {
      if (isString(url)) {
        return url;
      }
      try {
        return url.toString();
      } catch (e2) {
      }
      return void 0;
    }
    function makeFetchTransport(options, nativeFetch = getNativeImplementation("fetch")) {
      let pendingBodySize = 0;
      let pendingCount = 0;
      function makeRequest(request) {
        const requestSize = request.body.length;
        pendingBodySize += requestSize;
        pendingCount++;
        const requestOptions = {
          body: request.body,
          method: "POST",
          referrerPolicy: "origin",
          headers: options.headers,
          // Outgoing requests are usually cancelled when navigating to a different page, causing a "TypeError: Failed to
          // fetch" error and sending a "network_error" client-outcome - in Chrome, the request status shows "(cancelled)".
          // The `keepalive` flag keeps outgoing requests alive, even when switching pages. We want this since we're
          // frequently sending events right before the user is switching pages (eg. whenfinishing navigation transactions).
          // Gotchas:
          // - `keepalive` isn't supported by Firefox
          // - As per spec (https://fetch.spec.whatwg.org/#http-network-or-cache-fetch):
          //   If the sum of contentLength and inflightKeepaliveBytes is greater than 64 kibibytes, then return a network error.
          //   We will therefore only activate the flag when we're below that limit.
          // There is also a limit of requests that can be open at the same time, so we also limit this to 15
          // See https://github.com/getsentry/sentry-javascript/pull/7553 for details
          keepalive: pendingBodySize <= 6e4 && pendingCount < 15,
          ...options.fetchOptions
        };
        if (!nativeFetch) {
          clearCachedImplementation("fetch");
          return rejectedSyncPromise("No fetch implementation available");
        }
        try {
          return nativeFetch(options.url, requestOptions).then((response) => {
            pendingBodySize -= requestSize;
            pendingCount--;
            return {
              statusCode: response.status,
              headers: {
                "x-sentry-rate-limits": response.headers.get("X-Sentry-Rate-Limits"),
                "retry-after": response.headers.get("Retry-After")
              }
            };
          });
        } catch (e2) {
          clearCachedImplementation("fetch");
          pendingBodySize -= requestSize;
          pendingCount--;
          return rejectedSyncPromise(e2);
        }
      }
      return createTransport(options, makeRequest);
    }
    const CHROME_PRIORITY = 30;
    const GECKO_PRIORITY = 50;
    function createFrame(filename, func, lineno, colno) {
      const frame = {
        filename,
        function: func === "<anonymous>" ? UNKNOWN_FUNCTION : func,
        in_app: true
        // All browser frames are considered in_app
      };
      if (lineno !== void 0) {
        frame.lineno = lineno;
      }
      if (colno !== void 0) {
        frame.colno = colno;
      }
      return frame;
    }
    const chromeRegexNoFnName = /^\s*at (\S+?)(?::(\d+))(?::(\d+))\s*$/i;
    const chromeRegex = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
    const chromeEvalRegex = /\((\S*)(?::(\d+))(?::(\d+))\)/;
    const chromeStackParserFn = (line) => {
      const noFnParts = chromeRegexNoFnName.exec(line);
      if (noFnParts) {
        const [, filename, line2, col] = noFnParts;
        return createFrame(filename, UNKNOWN_FUNCTION, +line2, +col);
      }
      const parts = chromeRegex.exec(line);
      if (parts) {
        const isEval = parts[2] && parts[2].indexOf("eval") === 0;
        if (isEval) {
          const subMatch = chromeEvalRegex.exec(parts[2]);
          if (subMatch) {
            parts[2] = subMatch[1];
            parts[3] = subMatch[2];
            parts[4] = subMatch[3];
          }
        }
        const [func, filename] = extractSafariExtensionDetails(parts[1] || UNKNOWN_FUNCTION, parts[2]);
        return createFrame(filename, func, parts[3] ? +parts[3] : void 0, parts[4] ? +parts[4] : void 0);
      }
      return;
    };
    const chromeStackLineParser = [CHROME_PRIORITY, chromeStackParserFn];
    const geckoREgex = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i;
    const geckoEvalRegex = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
    const gecko = (line) => {
      const parts = geckoREgex.exec(line);
      if (parts) {
        const isEval = parts[3] && parts[3].indexOf(" > eval") > -1;
        if (isEval) {
          const subMatch = geckoEvalRegex.exec(parts[3]);
          if (subMatch) {
            parts[1] = parts[1] || "eval";
            parts[3] = subMatch[1];
            parts[4] = subMatch[2];
            parts[5] = "";
          }
        }
        let filename = parts[3];
        let func = parts[1] || UNKNOWN_FUNCTION;
        [func, filename] = extractSafariExtensionDetails(func, filename);
        return createFrame(filename, func, parts[4] ? +parts[4] : void 0, parts[5] ? +parts[5] : void 0);
      }
      return;
    };
    const geckoStackLineParser = [GECKO_PRIORITY, gecko];
    const defaultStackLineParsers = [chromeStackLineParser, geckoStackLineParser];
    const defaultStackParser = createStackParser(...defaultStackLineParsers);
    const extractSafariExtensionDetails = (func, filename) => {
      const isSafariExtension = func.indexOf("safari-extension") !== -1;
      const isSafariWebExtension = func.indexOf("safari-web-extension") !== -1;
      return isSafariExtension || isSafariWebExtension ? [
        func.indexOf("@") !== -1 ? func.split("@")[0] : UNKNOWN_FUNCTION,
        isSafariExtension ? `safari-extension:${filename}` : `safari-web-extension:${filename}`
      ] : [func, filename];
    };
    const MAX_ALLOWED_STRING_LENGTH = 1024;
    const INTEGRATION_NAME$3 = "Breadcrumbs";
    const _breadcrumbsIntegration = (options = {}) => {
      const _options = {
        console: true,
        dom: true,
        fetch: true,
        history: true,
        sentry: true,
        xhr: true,
        ...options
      };
      return {
        name: INTEGRATION_NAME$3,
        setup(client2) {
          if (_options.console) {
            addConsoleInstrumentationHandler(_getConsoleBreadcrumbHandler(client2));
          }
          if (_options.dom) {
            addClickKeypressInstrumentationHandler(_getDomBreadcrumbHandler(client2, _options.dom));
          }
          if (_options.xhr) {
            addXhrInstrumentationHandler(_getXhrBreadcrumbHandler(client2));
          }
          if (_options.fetch) {
            addFetchInstrumentationHandler(_getFetchBreadcrumbHandler(client2));
          }
          if (_options.history) {
            addHistoryInstrumentationHandler(_getHistoryBreadcrumbHandler(client2));
          }
          if (_options.sentry) {
            client2.on("beforeSendEvent", _getSentryBreadcrumbHandler(client2));
          }
        }
      };
    };
    const breadcrumbsIntegration = defineIntegration(_breadcrumbsIntegration);
    function _getSentryBreadcrumbHandler(client2) {
      return function addSentryBreadcrumb(event) {
        if (getClient() !== client2) {
          return;
        }
        addBreadcrumb(
          {
            category: `sentry.${event.type === "transaction" ? "transaction" : "event"}`,
            event_id: event.event_id,
            level: event.level,
            message: getEventDescription(event)
          },
          {
            event
          }
        );
      };
    }
    function _getDomBreadcrumbHandler(client2, dom) {
      return function _innerDomBreadcrumb(handlerData) {
        if (getClient() !== client2) {
          return;
        }
        let target;
        let componentName;
        let keyAttrs = typeof dom === "object" ? dom.serializeAttribute : void 0;
        let maxStringLength = typeof dom === "object" && typeof dom.maxStringLength === "number" ? dom.maxStringLength : void 0;
        if (maxStringLength && maxStringLength > MAX_ALLOWED_STRING_LENGTH) {
          DEBUG_BUILD$1 && logger.warn(
            `\`dom.maxStringLength\` cannot exceed ${MAX_ALLOWED_STRING_LENGTH}, but a value of ${maxStringLength} was configured. Sentry will use ${MAX_ALLOWED_STRING_LENGTH} instead.`
          );
          maxStringLength = MAX_ALLOWED_STRING_LENGTH;
        }
        if (typeof keyAttrs === "string") {
          keyAttrs = [keyAttrs];
        }
        try {
          const event = handlerData.event;
          const element = _isEvent(event) ? event.target : event;
          target = htmlTreeAsString(element, { keyAttrs, maxStringLength });
          componentName = getComponentName(element);
        } catch (e2) {
          target = "<unknown>";
        }
        if (target.length === 0) {
          return;
        }
        const breadcrumb = {
          category: `ui.${handlerData.name}`,
          message: target
        };
        if (componentName) {
          breadcrumb.data = { "ui.component_name": componentName };
        }
        addBreadcrumb(breadcrumb, {
          event: handlerData.event,
          name: handlerData.name,
          global: handlerData.global
        });
      };
    }
    function _getConsoleBreadcrumbHandler(client2) {
      return function _consoleBreadcrumb(handlerData) {
        if (getClient() !== client2) {
          return;
        }
        const breadcrumb = {
          category: "console",
          data: {
            arguments: handlerData.args,
            logger: "console"
          },
          level: severityLevelFromString(handlerData.level),
          message: safeJoin(handlerData.args, " ")
        };
        if (handlerData.level === "assert") {
          if (handlerData.args[0] === false) {
            breadcrumb.message = `Assertion failed: ${safeJoin(handlerData.args.slice(1), " ") || "console.assert"}`;
            breadcrumb.data.arguments = handlerData.args.slice(1);
          } else {
            return;
          }
        }
        addBreadcrumb(breadcrumb, {
          input: handlerData.args,
          level: handlerData.level
        });
      };
    }
    function _getXhrBreadcrumbHandler(client2) {
      return function _xhrBreadcrumb(handlerData) {
        if (getClient() !== client2) {
          return;
        }
        const { startTimestamp, endTimestamp } = handlerData;
        const sentryXhrData = handlerData.xhr[SENTRY_XHR_DATA_KEY];
        if (!startTimestamp || !endTimestamp || !sentryXhrData) {
          return;
        }
        const { method, url, status_code, body } = sentryXhrData;
        const data2 = {
          method,
          url,
          status_code
        };
        const hint = {
          xhr: handlerData.xhr,
          input: body,
          startTimestamp,
          endTimestamp
        };
        addBreadcrumb(
          {
            category: "xhr",
            data: data2,
            type: "http"
          },
          hint
        );
      };
    }
    function _getFetchBreadcrumbHandler(client2) {
      return function _fetchBreadcrumb(handlerData) {
        if (getClient() !== client2) {
          return;
        }
        const { startTimestamp, endTimestamp } = handlerData;
        if (!endTimestamp) {
          return;
        }
        if (handlerData.fetchData.url.match(/sentry_key/) && handlerData.fetchData.method === "POST") {
          return;
        }
        if (handlerData.error) {
          const data2 = handlerData.fetchData;
          const hint = {
            data: handlerData.error,
            input: handlerData.args,
            startTimestamp,
            endTimestamp
          };
          addBreadcrumb(
            {
              category: "fetch",
              data: data2,
              level: "error",
              type: "http"
            },
            hint
          );
        } else {
          const response = handlerData.response;
          const data2 = {
            ...handlerData.fetchData,
            status_code: response && response.status
          };
          const hint = {
            input: handlerData.args,
            response,
            startTimestamp,
            endTimestamp
          };
          addBreadcrumb(
            {
              category: "fetch",
              data: data2,
              type: "http"
            },
            hint
          );
        }
      };
    }
    function _getHistoryBreadcrumbHandler(client2) {
      return function _historyBreadcrumb(handlerData) {
        if (getClient() !== client2) {
          return;
        }
        let from = handlerData.from;
        let to = handlerData.to;
        const parsedLoc = parseUrl$1(WINDOW$1.location.href);
        let parsedFrom = from ? parseUrl$1(from) : void 0;
        const parsedTo = parseUrl$1(to);
        if (!parsedFrom || !parsedFrom.path) {
          parsedFrom = parsedLoc;
        }
        if (parsedLoc.protocol === parsedTo.protocol && parsedLoc.host === parsedTo.host) {
          to = parsedTo.relative;
        }
        if (parsedLoc.protocol === parsedFrom.protocol && parsedLoc.host === parsedFrom.host) {
          from = parsedFrom.relative;
        }
        addBreadcrumb({
          category: "navigation",
          data: {
            from,
            to
          }
        });
      };
    }
    function _isEvent(event) {
      return !!event && !!event.target;
    }
    const DEFAULT_EVENT_TARGET = [
      "EventTarget",
      "Window",
      "Node",
      "ApplicationCache",
      "AudioTrackList",
      "BroadcastChannel",
      "ChannelMergerNode",
      "CryptoOperation",
      "EventSource",
      "FileReader",
      "HTMLUnknownElement",
      "IDBDatabase",
      "IDBRequest",
      "IDBTransaction",
      "KeyOperation",
      "MediaController",
      "MessagePort",
      "ModalWindow",
      "Notification",
      "SVGElementInstance",
      "Screen",
      "SharedWorker",
      "TextTrack",
      "TextTrackCue",
      "TextTrackList",
      "WebSocket",
      "WebSocketWorker",
      "Worker",
      "XMLHttpRequest",
      "XMLHttpRequestEventTarget",
      "XMLHttpRequestUpload"
    ];
    const INTEGRATION_NAME$2 = "BrowserApiErrors";
    const _browserApiErrorsIntegration = (options = {}) => {
      const _options = {
        XMLHttpRequest: true,
        eventTarget: true,
        requestAnimationFrame: true,
        setInterval: true,
        setTimeout: true,
        ...options
      };
      return {
        name: INTEGRATION_NAME$2,
        // TODO: This currently only works for the first client this is setup
        // We may want to adjust this to check for client etc.
        setupOnce() {
          if (_options.setTimeout) {
            fill(WINDOW$1, "setTimeout", _wrapTimeFunction);
          }
          if (_options.setInterval) {
            fill(WINDOW$1, "setInterval", _wrapTimeFunction);
          }
          if (_options.requestAnimationFrame) {
            fill(WINDOW$1, "requestAnimationFrame", _wrapRAF);
          }
          if (_options.XMLHttpRequest && "XMLHttpRequest" in WINDOW$1) {
            fill(XMLHttpRequest.prototype, "send", _wrapXHR);
          }
          const eventTargetOption = _options.eventTarget;
          if (eventTargetOption) {
            const eventTarget = Array.isArray(eventTargetOption) ? eventTargetOption : DEFAULT_EVENT_TARGET;
            eventTarget.forEach(_wrapEventTarget);
          }
        }
      };
    };
    const browserApiErrorsIntegration = defineIntegration(_browserApiErrorsIntegration);
    function _wrapTimeFunction(original) {
      return function(...args) {
        const originalCallback = args[0];
        args[0] = wrap(originalCallback, {
          mechanism: {
            data: { function: getFunctionName(original) },
            handled: false,
            type: "instrument"
          }
        });
        return original.apply(this, args);
      };
    }
    function _wrapRAF(original) {
      return function(callback) {
        return original.apply(this, [
          wrap(callback, {
            mechanism: {
              data: {
                function: "requestAnimationFrame",
                handler: getFunctionName(original)
              },
              handled: false,
              type: "instrument"
            }
          })
        ]);
      };
    }
    function _wrapXHR(originalSend) {
      return function(...args) {
        const xhr = this;
        const xmlHttpRequestProps = ["onload", "onerror", "onprogress", "onreadystatechange"];
        xmlHttpRequestProps.forEach((prop) => {
          if (prop in xhr && typeof xhr[prop] === "function") {
            fill(xhr, prop, function(original) {
              const wrapOptions = {
                mechanism: {
                  data: {
                    function: prop,
                    handler: getFunctionName(original)
                  },
                  handled: false,
                  type: "instrument"
                }
              };
              const originalFunction = getOriginalFunction(original);
              if (originalFunction) {
                wrapOptions.mechanism.data.handler = getFunctionName(originalFunction);
              }
              return wrap(original, wrapOptions);
            });
          }
        });
        return originalSend.apply(this, args);
      };
    }
    function _wrapEventTarget(target) {
      const globalObject = WINDOW$1;
      const proto = globalObject[target] && globalObject[target].prototype;
      if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty("addEventListener")) {
        return;
      }
      fill(proto, "addEventListener", function(original) {
        return function(eventName, fn, options) {
          try {
            if (typeof fn.handleEvent === "function") {
              fn.handleEvent = wrap(fn.handleEvent, {
                mechanism: {
                  data: {
                    function: "handleEvent",
                    handler: getFunctionName(fn),
                    target
                  },
                  handled: false,
                  type: "instrument"
                }
              });
            }
          } catch (err) {
          }
          return original.apply(this, [
            eventName,
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            wrap(fn, {
              mechanism: {
                data: {
                  function: "addEventListener",
                  handler: getFunctionName(fn),
                  target
                },
                handled: false,
                type: "instrument"
              }
            }),
            options
          ]);
        };
      });
      fill(
        proto,
        "removeEventListener",
        function(originalRemoveEventListener) {
          return function(eventName, fn, options) {
            const wrappedEventHandler = fn;
            try {
              const originalEventHandler = wrappedEventHandler && wrappedEventHandler.__sentry_wrapped__;
              if (originalEventHandler) {
                originalRemoveEventListener.call(this, eventName, originalEventHandler, options);
              }
            } catch (e2) {
            }
            return originalRemoveEventListener.call(this, eventName, wrappedEventHandler, options);
          };
        }
      );
    }
    const INTEGRATION_NAME$1 = "GlobalHandlers";
    const _globalHandlersIntegration = (options = {}) => {
      const _options = {
        onerror: true,
        onunhandledrejection: true,
        ...options
      };
      return {
        name: INTEGRATION_NAME$1,
        setupOnce() {
          Error.stackTraceLimit = 50;
        },
        setup(client2) {
          if (_options.onerror) {
            _installGlobalOnErrorHandler(client2);
            globalHandlerLog("onerror");
          }
          if (_options.onunhandledrejection) {
            _installGlobalOnUnhandledRejectionHandler(client2);
            globalHandlerLog("onunhandledrejection");
          }
        }
      };
    };
    const globalHandlersIntegration = defineIntegration(_globalHandlersIntegration);
    function _installGlobalOnErrorHandler(client2) {
      addGlobalErrorInstrumentationHandler((data2) => {
        const { stackParser, attachStacktrace } = getOptions();
        if (getClient() !== client2 || shouldIgnoreOnError()) {
          return;
        }
        const { msg, url, line, column, error } = data2;
        const event = _enhanceEventWithInitialFrame(
          eventFromUnknownInput(stackParser, error || msg, void 0, attachStacktrace, false),
          url,
          line,
          column
        );
        event.level = "error";
        captureEvent(event, {
          originalException: error,
          mechanism: {
            handled: false,
            type: "onerror"
          }
        });
      });
    }
    function _installGlobalOnUnhandledRejectionHandler(client2) {
      addGlobalUnhandledRejectionInstrumentationHandler((e2) => {
        const { stackParser, attachStacktrace } = getOptions();
        if (getClient() !== client2 || shouldIgnoreOnError()) {
          return;
        }
        const error = _getUnhandledRejectionError(e2);
        const event = isPrimitive(error) ? _eventFromRejectionWithPrimitive(error) : eventFromUnknownInput(stackParser, error, void 0, attachStacktrace, true);
        event.level = "error";
        captureEvent(event, {
          originalException: error,
          mechanism: {
            handled: false,
            type: "onunhandledrejection"
          }
        });
      });
    }
    function _getUnhandledRejectionError(error) {
      if (isPrimitive(error)) {
        return error;
      }
      try {
        if ("reason" in error) {
          return error.reason;
        }
        if ("detail" in error && "reason" in error.detail) {
          return error.detail.reason;
        }
      } catch (e2) {
      }
      return error;
    }
    function _eventFromRejectionWithPrimitive(reason) {
      return {
        exception: {
          values: [
            {
              type: "UnhandledRejection",
              // String() is needed because the Primitive type includes symbols (which can't be automatically stringified)
              value: `Non-Error promise rejection captured with value: ${String(reason)}`
            }
          ]
        }
      };
    }
    function _enhanceEventWithInitialFrame(event, url, line, column) {
      const e2 = event.exception = event.exception || {};
      const ev = e2.values = e2.values || [];
      const ev0 = ev[0] = ev[0] || {};
      const ev0s = ev0.stacktrace = ev0.stacktrace || {};
      const ev0sf = ev0s.frames = ev0s.frames || [];
      const colno = isNaN(parseInt(column, 10)) ? void 0 : column;
      const lineno = isNaN(parseInt(line, 10)) ? void 0 : line;
      const filename = isString(url) && url.length > 0 ? url : getLocationHref();
      if (ev0sf.length === 0) {
        ev0sf.push({
          colno,
          filename,
          function: UNKNOWN_FUNCTION,
          in_app: true,
          lineno
        });
      }
      return event;
    }
    function globalHandlerLog(type) {
      DEBUG_BUILD$1 && logger.log(`Global Handler attached: ${type}`);
    }
    function getOptions() {
      const client2 = getClient();
      const options = client2 && client2.getOptions() || {
        stackParser: () => [],
        attachStacktrace: false
      };
      return options;
    }
    const httpContextIntegration = defineIntegration(() => {
      return {
        name: "HttpContext",
        preprocessEvent(event) {
          if (!WINDOW$1.navigator && !WINDOW$1.location && !WINDOW$1.document) {
            return;
          }
          const url = event.request && event.request.url || WINDOW$1.location && WINDOW$1.location.href;
          const { referrer } = WINDOW$1.document || {};
          const { userAgent } = WINDOW$1.navigator || {};
          const headers = {
            ...event.request && event.request.headers,
            ...referrer && { Referer: referrer },
            ...userAgent && { "User-Agent": userAgent }
          };
          const request = { ...event.request, ...url && { url }, headers };
          event.request = request;
        }
      };
    });
    const DEFAULT_KEY = "cause";
    const DEFAULT_LIMIT = 5;
    const INTEGRATION_NAME = "LinkedErrors";
    const _linkedErrorsIntegration = (options = {}) => {
      const limit = options.limit || DEFAULT_LIMIT;
      const key2 = options.key || DEFAULT_KEY;
      return {
        name: INTEGRATION_NAME,
        preprocessEvent(event, hint, client2) {
          const options2 = client2.getOptions();
          applyAggregateErrorsToEvent(
            // This differs from the LinkedErrors integration in core by using a different exceptionFromError function
            exceptionFromError,
            options2.stackParser,
            options2.maxValueLength,
            key2,
            limit,
            event,
            hint
          );
        }
      };
    };
    const linkedErrorsIntegration = defineIntegration(_linkedErrorsIntegration);
    function getDefaultIntegrations$1(_options) {
      return [
        inboundFiltersIntegration(),
        functionToStringIntegration(),
        browserApiErrorsIntegration(),
        breadcrumbsIntegration(),
        globalHandlersIntegration(),
        linkedErrorsIntegration(),
        dedupeIntegration(),
        httpContextIntegration()
      ];
    }
    function applyDefaultOptions(optionsArg = {}) {
      const defaultOptions2 = {
        defaultIntegrations: getDefaultIntegrations$1(),
        release: typeof __SENTRY_RELEASE__ === "string" ? __SENTRY_RELEASE__ : WINDOW$1.SENTRY_RELEASE && WINDOW$1.SENTRY_RELEASE.id ? WINDOW$1.SENTRY_RELEASE.id : void 0,
        autoSessionTracking: true,
        sendClientReports: true
      };
      return { ...defaultOptions2, ...optionsArg };
    }
    function shouldShowBrowserExtensionError() {
      const windowWithMaybeExtension = WINDOW$1;
      const extensionKey = windowWithMaybeExtension.chrome ? "chrome" : "browser";
      const extensionObject = windowWithMaybeExtension[extensionKey];
      const runtimeId = extensionObject && extensionObject.runtime && extensionObject.runtime.id;
      const href = WINDOW$1.location && WINDOW$1.location.href || "";
      const extensionProtocols = ["chrome-extension:", "moz-extension:", "ms-browser-extension:"];
      const isDedicatedExtensionPage = !!runtimeId && WINDOW$1 === WINDOW$1.top && extensionProtocols.some((protocol) => href.startsWith(`${protocol}//`));
      return !!runtimeId && !isDedicatedExtensionPage;
    }
    function init$1(browserOptions = {}) {
      const options = applyDefaultOptions(browserOptions);
      if (shouldShowBrowserExtensionError()) {
        consoleSandbox(() => {
          console.error(
            "[Sentry] You cannot run Sentry this way in a browser extension, check: https://docs.sentry.io/platforms/javascript/best-practices/browser-extensions/"
          );
        });
        return;
      }
      if (DEBUG_BUILD$1) {
        if (!supportsFetch()) {
          logger.warn(
            "No Fetch API detected. The Sentry SDK requires a Fetch API compatible environment to send events. Please add a Fetch API polyfill."
          );
        }
      }
      const clientOptions = {
        ...options,
        stackParser: stackParserFromStackParserOptions(options.stackParser || defaultStackParser),
        integrations: getIntegrationsToSetup(options),
        transport: options.transport || makeFetchTransport
      };
      initAndBind(BrowserClient, clientOptions);
      if (options.autoSessionTracking) {
        startSessionTracking();
      }
    }
    function startSessionTracking() {
      if (typeof WINDOW$1.document === "undefined") {
        DEBUG_BUILD$1 && logger.warn("Session tracking in non-browser environment with @sentry/browser is not supported.");
        return;
      }
      startSession({ ignoreDuration: true });
      captureSession();
      addHistoryInstrumentationHandler(({ from, to }) => {
        if (from !== void 0 && from !== to) {
          startSession({ ignoreDuration: true });
          captureSession();
        }
      });
    }
    function getScopeData() {
      const scope2 = getIsolationScope().getScopeData();
      mergeScopeData(scope2, getCurrentScope$1().getScopeData());
      scope2.eventProcessors = [];
      return scope2;
    }
    function addScopeListener(callback) {
      getIsolationScope().addScopeListener((isolation) => {
        const merged = getScopeData();
        callback(merged, isolation);
      });
      getCurrentScope$1().addScopeListener((current2) => {
        const merged = getScopeData();
        callback(merged, current2);
      });
    }
    var IPCMode;
    (function(IPCMode2) {
      IPCMode2[IPCMode2["Classic"] = 1] = "Classic";
      IPCMode2[IPCMode2["Protocol"] = 2] = "Protocol";
      IPCMode2[IPCMode2["Both"] = 3] = "Both";
    })(IPCMode || (IPCMode = {}));
    const PROTOCOL_SCHEME = "sentry-ipc";
    var IPCChannel;
    (function(IPCChannel2) {
      IPCChannel2["RENDERER_START"] = "sentry-electron.renderer-start";
      IPCChannel2["EVENT"] = "sentry-electron.event";
      IPCChannel2["SCOPE"] = "sentry-electron.scope";
      IPCChannel2["ENVELOPE"] = "sentry-electron.envelope";
      IPCChannel2["STATUS"] = "sentry-electron.status";
      IPCChannel2["ADD_METRIC"] = "sentry-electron.add-metric";
    })(IPCChannel || (IPCChannel = {}));
    const RENDERER_ID_HEADER = "sentry-electron-renderer-id";
    function buildUrl(channel) {
      return `${PROTOCOL_SCHEME}://${channel}/sentry_key`;
    }
    function getImplementation() {
      if (window.__SENTRY_IPC__) {
        return window.__SENTRY_IPC__;
      } else {
        logger.log("IPC was not configured in preload script, falling back to custom protocol and fetch");
        const id2 = window.__SENTRY_RENDERER_ID__ = uuid4();
        const headers = { [RENDERER_ID_HEADER]: id2 };
        return {
          sendRendererStart: () => {
            fetch(buildUrl(IPCChannel.RENDERER_START), { method: "POST", body: "", headers }).catch(() => {
              console.error(`Sentry SDK failed to establish connection with the Electron main process.
  - Ensure you have initialized the SDK in the main process
  - If your renderers use custom sessions, be sure to set 'getSessions' in the main process options
  - If you are bundling your main process code and using Electron < v5, you'll need to manually configure a preload script`);
            });
          },
          sendScope: (body) => {
            fetch(buildUrl(IPCChannel.SCOPE), { method: "POST", body, headers }).catch(() => {
            });
          },
          sendEvent: (body) => {
            fetch(buildUrl(IPCChannel.EVENT), { method: "POST", body, headers }).catch(() => {
            });
          },
          sendEnvelope: (body) => {
            fetch(buildUrl(IPCChannel.ENVELOPE), { method: "POST", body, headers }).catch(() => {
            });
          },
          sendStatus: (status) => {
            fetch(buildUrl(IPCChannel.STATUS), { method: "POST", body: JSON.stringify({ status }), headers }).catch(() => {
            });
          },
          sendAddMetric: (metric) => {
            fetch(buildUrl(IPCChannel.ADD_METRIC), { method: "POST", body: JSON.stringify(metric), headers }).catch(() => {
            });
          }
        };
      }
    }
    let cachedInterface;
    function getIPC() {
      if (!cachedInterface) {
        cachedInterface = getImplementation();
        cachedInterface.sendRendererStart();
      }
      return cachedInterface;
    }
    const scopeToMainIntegration = defineIntegration(() => {
      return {
        name: "ScopeToMain",
        setup() {
          const ipc = getIPC();
          addScopeListener((merged, changed) => {
            ipc.sendScope(JSON.stringify(normalize(merged, 20, 2e3)));
            changed.clearBreadcrumbs();
            changed.clearAttachments();
          });
        }
      };
    });
    function makeRendererTransport(options) {
      const ipc = getIPC();
      return createTransport(options, async (request) => {
        ipc.sendEnvelope(request.body);
        return { statusCode: 200 };
      });
    }
    function enableAnrRendererMessages(options) {
      const config = {
        pollInterval: 1e3,
        anrThreshold: 5e3,
        captureStackTrace: false,
        ...options
      };
      const ipc = getIPC();
      document.addEventListener("visibilitychange", () => {
        ipc.sendStatus({ status: document.visibilityState, config });
      });
      ipc.sendStatus({ status: document.visibilityState, config });
      setInterval(() => {
        ipc.sendStatus({ status: "alive", config });
      }, config.pollInterval);
    }
    const STACKTRACE_FRAME_LIMIT = 50;
    const [, chrome] = chromeStackLineParser;
    const [, node] = nodeStackLineParser();
    const electronRendererStackParser = (stack, skipFirst = 0) => {
      const frames2 = [];
      for (const line of stack.split("\n").slice(skipFirst)) {
        const chromeFrame = chrome(line);
        const nodeFrame = node(line);
        if (chromeFrame && nodeFrame?.in_app !== false) {
          frames2.push(chromeFrame);
        } else if (nodeFrame) {
          frames2.push(dropUndefinedKeys(nodeFrame));
        }
        if (frames2.length >= STACKTRACE_FRAME_LIMIT) {
          break;
        }
      }
      return stripSentryFramesAndReverse(frames2);
    };
    function getDefaultIntegrations(options) {
      return [...getDefaultIntegrations$1(), scopeToMainIntegration()];
    }
    function init(options = {}, originalInit = init$1) {
      if (window?.__SENTRY__RENDERER_INIT__) {
        logger.warn(`The browser SDK has already been initialized.
If init has been called in the preload and contextIsolation is disabled, is not required to call init in the renderer`);
        return;
      }
      window.__SENTRY__RENDERER_INIT__ = true;
      if (options.autoSessionTracking === void 0) {
        options.autoSessionTracking = false;
      }
      options.sendClientReports = false;
      if (options.defaultIntegrations === void 0) {
        options.defaultIntegrations = getDefaultIntegrations();
      }
      if (options.stackParser === void 0) {
        options.stackParser = electronRendererStackParser;
      }
      if (options.dsn === void 0) {
        options.dsn = "https://12345@dummy.dsn/12345";
      }
      if (options.transport === void 0) {
        options.transport = makeRendererTransport;
      }
      if (options.anrDetection) {
        enableAnrRendererMessages(options.anrDetection === true ? {} : options.anrDetection);
      }
      delete options.initialScope;
      originalInit(options);
    }
    function toDate(argument) {
      const argStr = Object.prototype.toString.call(argument);
      if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
        return new argument.constructor(+argument);
      } else if (typeof argument === "number" || argStr === "[object Number]" || typeof argument === "string" || argStr === "[object String]") {
        return new Date(argument);
      } else {
        return /* @__PURE__ */ new Date(NaN);
      }
    }
    function constructFrom(date, value2) {
      if (date instanceof Date) {
        return new date.constructor(value2);
      } else {
        return new Date(value2);
      }
    }
    function addMilliseconds(date, amount) {
      const timestamp = +toDate(date);
      return constructFrom(date, timestamp + amount);
    }
    const millisecondsInWeek = 6048e5;
    const millisecondsInDay = 864e5;
    const minutesInMonth = 43200;
    const minutesInDay = 1440;
    let defaultOptions = {};
    function getDefaultOptions() {
      return defaultOptions;
    }
    function startOfWeek(date, options) {
      const defaultOptions2 = getDefaultOptions();
      const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
      const _date = toDate(date);
      const day = _date.getDay();
      const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
      _date.setDate(_date.getDate() - diff);
      _date.setHours(0, 0, 0, 0);
      return _date;
    }
    function startOfISOWeek(date) {
      return startOfWeek(date, { weekStartsOn: 1 });
    }
    function getISOWeekYear(date) {
      const _date = toDate(date);
      const year = _date.getFullYear();
      const fourthOfJanuaryOfNextYear = constructFrom(date, 0);
      fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
      fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
      const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
      const fourthOfJanuaryOfThisYear = constructFrom(date, 0);
      fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
      fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
      const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
      if (_date.getTime() >= startOfNextYear.getTime()) {
        return year + 1;
      } else if (_date.getTime() >= startOfThisYear.getTime()) {
        return year;
      } else {
        return year - 1;
      }
    }
    function startOfDay(date) {
      const _date = toDate(date);
      _date.setHours(0, 0, 0, 0);
      return _date;
    }
    function getTimezoneOffsetInMilliseconds(date) {
      const _date = toDate(date);
      const utcDate = new Date(
        Date.UTC(
          _date.getFullYear(),
          _date.getMonth(),
          _date.getDate(),
          _date.getHours(),
          _date.getMinutes(),
          _date.getSeconds(),
          _date.getMilliseconds()
        )
      );
      utcDate.setUTCFullYear(_date.getFullYear());
      return +date - +utcDate;
    }
    function differenceInCalendarDays(dateLeft, dateRight) {
      const startOfDayLeft = startOfDay(dateLeft);
      const startOfDayRight = startOfDay(dateRight);
      const timestampLeft = +startOfDayLeft - getTimezoneOffsetInMilliseconds(startOfDayLeft);
      const timestampRight = +startOfDayRight - getTimezoneOffsetInMilliseconds(startOfDayRight);
      return Math.round((timestampLeft - timestampRight) / millisecondsInDay);
    }
    function startOfISOWeekYear(date) {
      const year = getISOWeekYear(date);
      const fourthOfJanuary = constructFrom(date, 0);
      fourthOfJanuary.setFullYear(year, 0, 4);
      fourthOfJanuary.setHours(0, 0, 0, 0);
      return startOfISOWeek(fourthOfJanuary);
    }
    function compareAsc(dateLeft, dateRight) {
      const _dateLeft = toDate(dateLeft);
      const _dateRight = toDate(dateRight);
      const diff = _dateLeft.getTime() - _dateRight.getTime();
      if (diff < 0) {
        return -1;
      } else if (diff > 0) {
        return 1;
      } else {
        return diff;
      }
    }
    function isDate(value2) {
      return value2 instanceof Date || typeof value2 === "object" && Object.prototype.toString.call(value2) === "[object Date]";
    }
    function isValid(date) {
      if (!isDate(date) && typeof date !== "number") {
        return false;
      }
      const _date = toDate(date);
      return !isNaN(Number(_date));
    }
    function differenceInCalendarMonths(dateLeft, dateRight) {
      const _dateLeft = toDate(dateLeft);
      const _dateRight = toDate(dateRight);
      const yearDiff = _dateLeft.getFullYear() - _dateRight.getFullYear();
      const monthDiff = _dateLeft.getMonth() - _dateRight.getMonth();
      return yearDiff * 12 + monthDiff;
    }
    function getRoundingMethod(method) {
      return (number) => {
        const round = method ? Math[method] : Math.trunc;
        const result = round(number);
        return result === 0 ? 0 : result;
      };
    }
    function differenceInMilliseconds(dateLeft, dateRight) {
      return +toDate(dateLeft) - +toDate(dateRight);
    }
    function endOfDay(date) {
      const _date = toDate(date);
      _date.setHours(23, 59, 59, 999);
      return _date;
    }
    function endOfMonth(date) {
      const _date = toDate(date);
      const month = _date.getMonth();
      _date.setFullYear(_date.getFullYear(), month + 1, 0);
      _date.setHours(23, 59, 59, 999);
      return _date;
    }
    function isLastDayOfMonth(date) {
      const _date = toDate(date);
      return +endOfDay(_date) === +endOfMonth(_date);
    }
    function differenceInMonths(dateLeft, dateRight) {
      const _dateLeft = toDate(dateLeft);
      const _dateRight = toDate(dateRight);
      const sign = compareAsc(_dateLeft, _dateRight);
      const difference = Math.abs(
        differenceInCalendarMonths(_dateLeft, _dateRight)
      );
      let result;
      if (difference < 1) {
        result = 0;
      } else {
        if (_dateLeft.getMonth() === 1 && _dateLeft.getDate() > 27) {
          _dateLeft.setDate(30);
        }
        _dateLeft.setMonth(_dateLeft.getMonth() - sign * difference);
        let isLastMonthNotFull = compareAsc(_dateLeft, _dateRight) === -sign;
        if (isLastDayOfMonth(toDate(dateLeft)) && difference === 1 && compareAsc(dateLeft, _dateRight) === 1) {
          isLastMonthNotFull = false;
        }
        result = sign * (difference - Number(isLastMonthNotFull));
      }
      return result === 0 ? 0 : result;
    }
    function differenceInSeconds(dateLeft, dateRight, options) {
      const diff = differenceInMilliseconds(dateLeft, dateRight) / 1e3;
      return getRoundingMethod(options?.roundingMethod)(diff);
    }
    function startOfYear(date) {
      const cleanDate = toDate(date);
      const _date = constructFrom(date, 0);
      _date.setFullYear(cleanDate.getFullYear(), 0, 1);
      _date.setHours(0, 0, 0, 0);
      return _date;
    }
    const formatDistanceLocale$a = {
      lessThanXSeconds: {
        one: "less than a second",
        other: "less than {{count}} seconds"
      },
      xSeconds: {
        one: "1 second",
        other: "{{count}} seconds"
      },
      halfAMinute: "half a minute",
      lessThanXMinutes: {
        one: "less than a minute",
        other: "less than {{count}} minutes"
      },
      xMinutes: {
        one: "1 minute",
        other: "{{count}} minutes"
      },
      aboutXHours: {
        one: "about 1 hour",
        other: "about {{count}} hours"
      },
      xHours: {
        one: "1 hour",
        other: "{{count}} hours"
      },
      xDays: {
        one: "1 day",
        other: "{{count}} days"
      },
      aboutXWeeks: {
        one: "about 1 week",
        other: "about {{count}} weeks"
      },
      xWeeks: {
        one: "1 week",
        other: "{{count}} weeks"
      },
      aboutXMonths: {
        one: "about 1 month",
        other: "about {{count}} months"
      },
      xMonths: {
        one: "1 month",
        other: "{{count}} months"
      },
      aboutXYears: {
        one: "about 1 year",
        other: "about {{count}} years"
      },
      xYears: {
        one: "1 year",
        other: "{{count}} years"
      },
      overXYears: {
        one: "over 1 year",
        other: "over {{count}} years"
      },
      almostXYears: {
        one: "almost 1 year",
        other: "almost {{count}} years"
      }
    };
    const formatDistance$c = (token, count, options) => {
      let result;
      const tokenValue = formatDistanceLocale$a[token];
      if (typeof tokenValue === "string") {
        result = tokenValue;
      } else if (count === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace("{{count}}", count.toString());
      }
      if (options?.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return "in " + result;
        } else {
          return result + " ago";
        }
      }
      return result;
    };
    function buildFormatLongFn(args) {
      return (options = {}) => {
        const width2 = options.width ? String(options.width) : args.defaultWidth;
        const format2 = args.formats[width2] || args.formats[args.defaultWidth];
        return format2;
      };
    }
    const dateFormats$b = {
      full: "EEEE, MMMM do, y",
      long: "MMMM do, y",
      medium: "MMM d, y",
      short: "MM/dd/yyyy"
    };
    const timeFormats$b = {
      full: "h:mm:ss a zzzz",
      long: "h:mm:ss a z",
      medium: "h:mm:ss a",
      short: "h:mm a"
    };
    const dateTimeFormats$b = {
      full: "{{date}} 'at' {{time}}",
      long: "{{date}} 'at' {{time}}",
      medium: "{{date}}, {{time}}",
      short: "{{date}}, {{time}}"
    };
    const formatLong$b = {
      date: buildFormatLongFn({
        formats: dateFormats$b,
        defaultWidth: "full"
      }),
      time: buildFormatLongFn({
        formats: timeFormats$b,
        defaultWidth: "full"
      }),
      dateTime: buildFormatLongFn({
        formats: dateTimeFormats$b,
        defaultWidth: "full"
      })
    };
    const formatRelativeLocale$b = {
      lastWeek: "'last' eeee 'at' p",
      yesterday: "'yesterday at' p",
      today: "'today at' p",
      tomorrow: "'tomorrow at' p",
      nextWeek: "eeee 'at' p",
      other: "P"
    };
    const formatRelative$b = (token, _date, _baseDate, _options) => formatRelativeLocale$b[token];
    function buildLocalizeFn(args) {
      return (value2, options) => {
        const context = options?.context ? String(options.context) : "standalone";
        let valuesArray;
        if (context === "formatting" && args.formattingValues) {
          const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
          const width2 = options?.width ? String(options.width) : defaultWidth;
          valuesArray = args.formattingValues[width2] || args.formattingValues[defaultWidth];
        } else {
          const defaultWidth = args.defaultWidth;
          const width2 = options?.width ? String(options.width) : args.defaultWidth;
          valuesArray = args.values[width2] || args.values[defaultWidth];
        }
        const index2 = args.argumentCallback ? args.argumentCallback(value2) : value2;
        return valuesArray[index2];
      };
    }
    const eraValues$b = {
      narrow: ["B", "A"],
      abbreviated: ["BC", "AD"],
      wide: ["Before Christ", "Anno Domini"]
    };
    const quarterValues$b = {
      narrow: ["1", "2", "3", "4"],
      abbreviated: ["Q1", "Q2", "Q3", "Q4"],
      wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
    };
    const monthValues$b = {
      narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
      abbreviated: [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ],
      wide: [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
      ]
    };
    const dayValues$b = {
      narrow: ["S", "M", "T", "W", "T", "F", "S"],
      short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
      abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      wide: [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday"
      ]
    };
    const dayPeriodValues$b = {
      narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
      },
      wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
      }
    };
    const formattingDayPeriodValues$8 = {
      narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
      },
      wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
      }
    };
    const ordinalNumber$b = (dirtyNumber, _options) => {
      const number = Number(dirtyNumber);
      const rem100 = number % 100;
      if (rem100 > 20 || rem100 < 10) {
        switch (rem100 % 10) {
          case 1:
            return number + "st";
          case 2:
            return number + "nd";
          case 3:
            return number + "rd";
        }
      }
      return number + "th";
    };
    const localize$b = {
      ordinalNumber: ordinalNumber$b,
      era: buildLocalizeFn({
        values: eraValues$b,
        defaultWidth: "wide"
      }),
      quarter: buildLocalizeFn({
        values: quarterValues$b,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
      }),
      month: buildLocalizeFn({
        values: monthValues$b,
        defaultWidth: "wide"
      }),
      day: buildLocalizeFn({
        values: dayValues$b,
        defaultWidth: "wide"
      }),
      dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$b,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$8,
        defaultFormattingWidth: "wide"
      })
    };
    function buildMatchFn(args) {
      return (string, options = {}) => {
        const width2 = options.width;
        const matchPattern = width2 && args.matchPatterns[width2] || args.matchPatterns[args.defaultMatchWidth];
        const matchResult = string.match(matchPattern);
        if (!matchResult) {
          return null;
        }
        const matchedString = matchResult[0];
        const parsePatterns = width2 && args.parsePatterns[width2] || args.parsePatterns[args.defaultParseWidth];
        const key2 = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString)) : (
          // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
          findKey(parsePatterns, (pattern) => pattern.test(matchedString))
        );
        let value2;
        value2 = args.valueCallback ? args.valueCallback(key2) : key2;
        value2 = options.valueCallback ? (
          // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
          options.valueCallback(value2)
        ) : value2;
        const rest = string.slice(matchedString.length);
        return { value: value2, rest };
      };
    }
    function findKey(object, predicate) {
      for (const key2 in object) {
        if (Object.prototype.hasOwnProperty.call(object, key2) && predicate(object[key2])) {
          return key2;
        }
      }
      return void 0;
    }
    function findIndex(array, predicate) {
      for (let key2 = 0; key2 < array.length; key2++) {
        if (predicate(array[key2])) {
          return key2;
        }
      }
      return void 0;
    }
    function buildMatchPatternFn(args) {
      return (string, options = {}) => {
        const matchResult = string.match(args.matchPattern);
        if (!matchResult)
          return null;
        const matchedString = matchResult[0];
        const parseResult = string.match(args.parsePattern);
        if (!parseResult)
          return null;
        let value2 = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
        value2 = options.valueCallback ? options.valueCallback(value2) : value2;
        const rest = string.slice(matchedString.length);
        return { value: value2, rest };
      };
    }
    const matchOrdinalNumberPattern$b = /^(\d+)(th|st|nd|rd)?/i;
    const parseOrdinalNumberPattern$b = /\d+/i;
    const matchEraPatterns$b = {
      narrow: /^(b|a)/i,
      abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
      wide: /^(before christ|before common era|anno domini|common era)/i
    };
    const parseEraPatterns$b = {
      any: [/^b/i, /^(a|c)/i]
    };
    const matchQuarterPatterns$b = {
      narrow: /^[1234]/i,
      abbreviated: /^q[1234]/i,
      wide: /^[1234](th|st|nd|rd)? quarter/i
    };
    const parseQuarterPatterns$b = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    const matchMonthPatterns$b = {
      narrow: /^[jfmasond]/i,
      abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
      wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
    };
    const parseMonthPatterns$b = {
      narrow: [
        /^j/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
      ],
      any: [
        /^ja/i,
        /^f/i,
        /^mar/i,
        /^ap/i,
        /^may/i,
        /^jun/i,
        /^jul/i,
        /^au/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
      ]
    };
    const matchDayPatterns$b = {
      narrow: /^[smtwf]/i,
      short: /^(su|mo|tu|we|th|fr|sa)/i,
      abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
      wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
    };
    const parseDayPatterns$b = {
      narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
      any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
    };
    const matchDayPeriodPatterns$b = {
      narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
      any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
    };
    const parseDayPeriodPatterns$b = {
      any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i
      }
    };
    const match$b = {
      ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$b,
        parsePattern: parseOrdinalNumberPattern$b,
        valueCallback: (value2) => parseInt(value2, 10)
      }),
      era: buildMatchFn({
        matchPatterns: matchEraPatterns$b,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$b,
        defaultParseWidth: "any"
      }),
      quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$b,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$b,
        defaultParseWidth: "any",
        valueCallback: (index2) => index2 + 1
      }),
      month: buildMatchFn({
        matchPatterns: matchMonthPatterns$b,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$b,
        defaultParseWidth: "any"
      }),
      day: buildMatchFn({
        matchPatterns: matchDayPatterns$b,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$b,
        defaultParseWidth: "any"
      }),
      dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$b,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$b,
        defaultParseWidth: "any"
      })
    };
    const enUS = {
      code: "en-US",
      formatDistance: formatDistance$c,
      formatLong: formatLong$b,
      formatRelative: formatRelative$b,
      localize: localize$b,
      match: match$b,
      options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
      }
    };
    function getDayOfYear(date) {
      const _date = toDate(date);
      const diff = differenceInCalendarDays(_date, startOfYear(_date));
      const dayOfYear = diff + 1;
      return dayOfYear;
    }
    function getISOWeek(date) {
      const _date = toDate(date);
      const diff = +startOfISOWeek(_date) - +startOfISOWeekYear(_date);
      return Math.round(diff / millisecondsInWeek) + 1;
    }
    function getWeekYear(date, options) {
      const _date = toDate(date);
      const year = _date.getFullYear();
      const defaultOptions2 = getDefaultOptions();
      const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
      const firstWeekOfNextYear = constructFrom(date, 0);
      firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
      firstWeekOfNextYear.setHours(0, 0, 0, 0);
      const startOfNextYear = startOfWeek(firstWeekOfNextYear, options);
      const firstWeekOfThisYear = constructFrom(date, 0);
      firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
      firstWeekOfThisYear.setHours(0, 0, 0, 0);
      const startOfThisYear = startOfWeek(firstWeekOfThisYear, options);
      if (_date.getTime() >= startOfNextYear.getTime()) {
        return year + 1;
      } else if (_date.getTime() >= startOfThisYear.getTime()) {
        return year;
      } else {
        return year - 1;
      }
    }
    function startOfWeekYear(date, options) {
      const defaultOptions2 = getDefaultOptions();
      const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
      const year = getWeekYear(date, options);
      const firstWeek = constructFrom(date, 0);
      firstWeek.setFullYear(year, 0, firstWeekContainsDate);
      firstWeek.setHours(0, 0, 0, 0);
      const _date = startOfWeek(firstWeek, options);
      return _date;
    }
    function getWeek(date, options) {
      const _date = toDate(date);
      const diff = +startOfWeek(_date, options) - +startOfWeekYear(_date, options);
      return Math.round(diff / millisecondsInWeek) + 1;
    }
    function addLeadingZeros(number, targetLength) {
      const sign = number < 0 ? "-" : "";
      const output = Math.abs(number).toString().padStart(targetLength, "0");
      return sign + output;
    }
    const lightFormatters = {
      // Year
      y(date, token) {
        const signedYear = date.getFullYear();
        const year = signedYear > 0 ? signedYear : 1 - signedYear;
        return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
      },
      // Month
      M(date, token) {
        const month = date.getMonth();
        return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
      },
      // Day of the month
      d(date, token) {
        return addLeadingZeros(date.getDate(), token.length);
      },
      // AM or PM
      a(date, token) {
        const dayPeriodEnumValue = date.getHours() / 12 >= 1 ? "pm" : "am";
        switch (token) {
          case "a":
          case "aa":
            return dayPeriodEnumValue.toUpperCase();
          case "aaa":
            return dayPeriodEnumValue;
          case "aaaaa":
            return dayPeriodEnumValue[0];
          case "aaaa":
          default:
            return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
        }
      },
      // Hour [1-12]
      h(date, token) {
        return addLeadingZeros(date.getHours() % 12 || 12, token.length);
      },
      // Hour [0-23]
      H(date, token) {
        return addLeadingZeros(date.getHours(), token.length);
      },
      // Minute
      m(date, token) {
        return addLeadingZeros(date.getMinutes(), token.length);
      },
      // Second
      s(date, token) {
        return addLeadingZeros(date.getSeconds(), token.length);
      },
      // Fraction of second
      S(date, token) {
        const numberOfDigits = token.length;
        const milliseconds = date.getMilliseconds();
        const fractionalSeconds = Math.trunc(
          milliseconds * Math.pow(10, numberOfDigits - 3)
        );
        return addLeadingZeros(fractionalSeconds, token.length);
      }
    };
    const dayPeriodEnum = {
      am: "am",
      pm: "pm",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    };
    const formatters = {
      // Era
      G: function(date, token, localize2) {
        const era = date.getFullYear() > 0 ? 1 : 0;
        switch (token) {
          case "G":
          case "GG":
          case "GGG":
            return localize2.era(era, { width: "abbreviated" });
          case "GGGGG":
            return localize2.era(era, { width: "narrow" });
          case "GGGG":
          default:
            return localize2.era(era, { width: "wide" });
        }
      },
      // Year
      y: function(date, token, localize2) {
        if (token === "yo") {
          const signedYear = date.getFullYear();
          const year = signedYear > 0 ? signedYear : 1 - signedYear;
          return localize2.ordinalNumber(year, { unit: "year" });
        }
        return lightFormatters.y(date, token);
      },
      // Local week-numbering year
      Y: function(date, token, localize2, options) {
        const signedWeekYear = getWeekYear(date, options);
        const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
        if (token === "YY") {
          const twoDigitYear = weekYear % 100;
          return addLeadingZeros(twoDigitYear, 2);
        }
        if (token === "Yo") {
          return localize2.ordinalNumber(weekYear, { unit: "year" });
        }
        return addLeadingZeros(weekYear, token.length);
      },
      // ISO week-numbering year
      R: function(date, token) {
        const isoWeekYear = getISOWeekYear(date);
        return addLeadingZeros(isoWeekYear, token.length);
      },
      // Extended year. This is a single number designating the year of this calendar system.
      // The main difference between `y` and `u` localizers are B.C. years:
      // | Year | `y` | `u` |
      // |------|-----|-----|
      // | AC 1 |   1 |   1 |
      // | BC 1 |   1 |   0 |
      // | BC 2 |   2 |  -1 |
      // Also `yy` always returns the last two digits of a year,
      // while `uu` pads single digit years to 2 characters and returns other years unchanged.
      u: function(date, token) {
        const year = date.getFullYear();
        return addLeadingZeros(year, token.length);
      },
      // Quarter
      Q: function(date, token, localize2) {
        const quarter = Math.ceil((date.getMonth() + 1) / 3);
        switch (token) {
          case "Q":
            return String(quarter);
          case "QQ":
            return addLeadingZeros(quarter, 2);
          case "Qo":
            return localize2.ordinalNumber(quarter, { unit: "quarter" });
          case "QQQ":
            return localize2.quarter(quarter, {
              width: "abbreviated",
              context: "formatting"
            });
          case "QQQQQ":
            return localize2.quarter(quarter, {
              width: "narrow",
              context: "formatting"
            });
          case "QQQQ":
          default:
            return localize2.quarter(quarter, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // Stand-alone quarter
      q: function(date, token, localize2) {
        const quarter = Math.ceil((date.getMonth() + 1) / 3);
        switch (token) {
          case "q":
            return String(quarter);
          case "qq":
            return addLeadingZeros(quarter, 2);
          case "qo":
            return localize2.ordinalNumber(quarter, { unit: "quarter" });
          case "qqq":
            return localize2.quarter(quarter, {
              width: "abbreviated",
              context: "standalone"
            });
          case "qqqqq":
            return localize2.quarter(quarter, {
              width: "narrow",
              context: "standalone"
            });
          case "qqqq":
          default:
            return localize2.quarter(quarter, {
              width: "wide",
              context: "standalone"
            });
        }
      },
      // Month
      M: function(date, token, localize2) {
        const month = date.getMonth();
        switch (token) {
          case "M":
          case "MM":
            return lightFormatters.M(date, token);
          case "Mo":
            return localize2.ordinalNumber(month + 1, { unit: "month" });
          case "MMM":
            return localize2.month(month, {
              width: "abbreviated",
              context: "formatting"
            });
          case "MMMMM":
            return localize2.month(month, {
              width: "narrow",
              context: "formatting"
            });
          case "MMMM":
          default:
            return localize2.month(month, { width: "wide", context: "formatting" });
        }
      },
      // Stand-alone month
      L: function(date, token, localize2) {
        const month = date.getMonth();
        switch (token) {
          case "L":
            return String(month + 1);
          case "LL":
            return addLeadingZeros(month + 1, 2);
          case "Lo":
            return localize2.ordinalNumber(month + 1, { unit: "month" });
          case "LLL":
            return localize2.month(month, {
              width: "abbreviated",
              context: "standalone"
            });
          case "LLLLL":
            return localize2.month(month, {
              width: "narrow",
              context: "standalone"
            });
          case "LLLL":
          default:
            return localize2.month(month, { width: "wide", context: "standalone" });
        }
      },
      // Local week of year
      w: function(date, token, localize2, options) {
        const week2 = getWeek(date, options);
        if (token === "wo") {
          return localize2.ordinalNumber(week2, { unit: "week" });
        }
        return addLeadingZeros(week2, token.length);
      },
      // ISO week of year
      I: function(date, token, localize2) {
        const isoWeek = getISOWeek(date);
        if (token === "Io") {
          return localize2.ordinalNumber(isoWeek, { unit: "week" });
        }
        return addLeadingZeros(isoWeek, token.length);
      },
      // Day of the month
      d: function(date, token, localize2) {
        if (token === "do") {
          return localize2.ordinalNumber(date.getDate(), { unit: "date" });
        }
        return lightFormatters.d(date, token);
      },
      // Day of year
      D: function(date, token, localize2) {
        const dayOfYear = getDayOfYear(date);
        if (token === "Do") {
          return localize2.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
        }
        return addLeadingZeros(dayOfYear, token.length);
      },
      // Day of week
      E: function(date, token, localize2) {
        const dayOfWeek = date.getDay();
        switch (token) {
          case "E":
          case "EE":
          case "EEE":
            return localize2.day(dayOfWeek, {
              width: "abbreviated",
              context: "formatting"
            });
          case "EEEEE":
            return localize2.day(dayOfWeek, {
              width: "narrow",
              context: "formatting"
            });
          case "EEEEEE":
            return localize2.day(dayOfWeek, {
              width: "short",
              context: "formatting"
            });
          case "EEEE":
          default:
            return localize2.day(dayOfWeek, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // Local day of week
      e: function(date, token, localize2, options) {
        const dayOfWeek = date.getDay();
        const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
        switch (token) {
          case "e":
            return String(localDayOfWeek);
          case "ee":
            return addLeadingZeros(localDayOfWeek, 2);
          case "eo":
            return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
          case "eee":
            return localize2.day(dayOfWeek, {
              width: "abbreviated",
              context: "formatting"
            });
          case "eeeee":
            return localize2.day(dayOfWeek, {
              width: "narrow",
              context: "formatting"
            });
          case "eeeeee":
            return localize2.day(dayOfWeek, {
              width: "short",
              context: "formatting"
            });
          case "eeee":
          default:
            return localize2.day(dayOfWeek, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // Stand-alone local day of week
      c: function(date, token, localize2, options) {
        const dayOfWeek = date.getDay();
        const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
        switch (token) {
          case "c":
            return String(localDayOfWeek);
          case "cc":
            return addLeadingZeros(localDayOfWeek, token.length);
          case "co":
            return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
          case "ccc":
            return localize2.day(dayOfWeek, {
              width: "abbreviated",
              context: "standalone"
            });
          case "ccccc":
            return localize2.day(dayOfWeek, {
              width: "narrow",
              context: "standalone"
            });
          case "cccccc":
            return localize2.day(dayOfWeek, {
              width: "short",
              context: "standalone"
            });
          case "cccc":
          default:
            return localize2.day(dayOfWeek, {
              width: "wide",
              context: "standalone"
            });
        }
      },
      // ISO day of week
      i: function(date, token, localize2) {
        const dayOfWeek = date.getDay();
        const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
        switch (token) {
          case "i":
            return String(isoDayOfWeek);
          case "ii":
            return addLeadingZeros(isoDayOfWeek, token.length);
          case "io":
            return localize2.ordinalNumber(isoDayOfWeek, { unit: "day" });
          case "iii":
            return localize2.day(dayOfWeek, {
              width: "abbreviated",
              context: "formatting"
            });
          case "iiiii":
            return localize2.day(dayOfWeek, {
              width: "narrow",
              context: "formatting"
            });
          case "iiiiii":
            return localize2.day(dayOfWeek, {
              width: "short",
              context: "formatting"
            });
          case "iiii":
          default:
            return localize2.day(dayOfWeek, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // AM or PM
      a: function(date, token, localize2) {
        const hours = date.getHours();
        const dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
        switch (token) {
          case "a":
          case "aa":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            });
          case "aaa":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            }).toLowerCase();
          case "aaaaa":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "narrow",
              context: "formatting"
            });
          case "aaaa":
          default:
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // AM, PM, midnight, noon
      b: function(date, token, localize2) {
        const hours = date.getHours();
        let dayPeriodEnumValue;
        if (hours === 12) {
          dayPeriodEnumValue = dayPeriodEnum.noon;
        } else if (hours === 0) {
          dayPeriodEnumValue = dayPeriodEnum.midnight;
        } else {
          dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
        }
        switch (token) {
          case "b":
          case "bb":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            });
          case "bbb":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            }).toLowerCase();
          case "bbbbb":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "narrow",
              context: "formatting"
            });
          case "bbbb":
          default:
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // in the morning, in the afternoon, in the evening, at night
      B: function(date, token, localize2) {
        const hours = date.getHours();
        let dayPeriodEnumValue;
        if (hours >= 17) {
          dayPeriodEnumValue = dayPeriodEnum.evening;
        } else if (hours >= 12) {
          dayPeriodEnumValue = dayPeriodEnum.afternoon;
        } else if (hours >= 4) {
          dayPeriodEnumValue = dayPeriodEnum.morning;
        } else {
          dayPeriodEnumValue = dayPeriodEnum.night;
        }
        switch (token) {
          case "B":
          case "BB":
          case "BBB":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            });
          case "BBBBB":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "narrow",
              context: "formatting"
            });
          case "BBBB":
          default:
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      // Hour [1-12]
      h: function(date, token, localize2) {
        if (token === "ho") {
          let hours = date.getHours() % 12;
          if (hours === 0)
            hours = 12;
          return localize2.ordinalNumber(hours, { unit: "hour" });
        }
        return lightFormatters.h(date, token);
      },
      // Hour [0-23]
      H: function(date, token, localize2) {
        if (token === "Ho") {
          return localize2.ordinalNumber(date.getHours(), { unit: "hour" });
        }
        return lightFormatters.H(date, token);
      },
      // Hour [0-11]
      K: function(date, token, localize2) {
        const hours = date.getHours() % 12;
        if (token === "Ko") {
          return localize2.ordinalNumber(hours, { unit: "hour" });
        }
        return addLeadingZeros(hours, token.length);
      },
      // Hour [1-24]
      k: function(date, token, localize2) {
        let hours = date.getHours();
        if (hours === 0)
          hours = 24;
        if (token === "ko") {
          return localize2.ordinalNumber(hours, { unit: "hour" });
        }
        return addLeadingZeros(hours, token.length);
      },
      // Minute
      m: function(date, token, localize2) {
        if (token === "mo") {
          return localize2.ordinalNumber(date.getMinutes(), { unit: "minute" });
        }
        return lightFormatters.m(date, token);
      },
      // Second
      s: function(date, token, localize2) {
        if (token === "so") {
          return localize2.ordinalNumber(date.getSeconds(), { unit: "second" });
        }
        return lightFormatters.s(date, token);
      },
      // Fraction of second
      S: function(date, token) {
        return lightFormatters.S(date, token);
      },
      // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
      X: function(date, token, _localize) {
        const timezoneOffset = date.getTimezoneOffset();
        if (timezoneOffset === 0) {
          return "Z";
        }
        switch (token) {
          case "X":
            return formatTimezoneWithOptionalMinutes(timezoneOffset);
          case "XXXX":
          case "XX":
            return formatTimezone(timezoneOffset);
          case "XXXXX":
          case "XXX":
          default:
            return formatTimezone(timezoneOffset, ":");
        }
      },
      // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
      x: function(date, token, _localize) {
        const timezoneOffset = date.getTimezoneOffset();
        switch (token) {
          case "x":
            return formatTimezoneWithOptionalMinutes(timezoneOffset);
          case "xxxx":
          case "xx":
            return formatTimezone(timezoneOffset);
          case "xxxxx":
          case "xxx":
          default:
            return formatTimezone(timezoneOffset, ":");
        }
      },
      // Timezone (GMT)
      O: function(date, token, _localize) {
        const timezoneOffset = date.getTimezoneOffset();
        switch (token) {
          case "O":
          case "OO":
          case "OOO":
            return "GMT" + formatTimezoneShort(timezoneOffset, ":");
          case "OOOO":
          default:
            return "GMT" + formatTimezone(timezoneOffset, ":");
        }
      },
      // Timezone (specific non-location)
      z: function(date, token, _localize) {
        const timezoneOffset = date.getTimezoneOffset();
        switch (token) {
          case "z":
          case "zz":
          case "zzz":
            return "GMT" + formatTimezoneShort(timezoneOffset, ":");
          case "zzzz":
          default:
            return "GMT" + formatTimezone(timezoneOffset, ":");
        }
      },
      // Seconds timestamp
      t: function(date, token, _localize) {
        const timestamp = Math.trunc(date.getTime() / 1e3);
        return addLeadingZeros(timestamp, token.length);
      },
      // Milliseconds timestamp
      T: function(date, token, _localize) {
        const timestamp = date.getTime();
        return addLeadingZeros(timestamp, token.length);
      }
    };
    function formatTimezoneShort(offset, delimiter = "") {
      const sign = offset > 0 ? "-" : "+";
      const absOffset = Math.abs(offset);
      const hours = Math.trunc(absOffset / 60);
      const minutes = absOffset % 60;
      if (minutes === 0) {
        return sign + String(hours);
      }
      return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
    }
    function formatTimezoneWithOptionalMinutes(offset, delimiter) {
      if (offset % 60 === 0) {
        const sign = offset > 0 ? "-" : "+";
        return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
      }
      return formatTimezone(offset, delimiter);
    }
    function formatTimezone(offset, delimiter = "") {
      const sign = offset > 0 ? "-" : "+";
      const absOffset = Math.abs(offset);
      const hours = addLeadingZeros(Math.trunc(absOffset / 60), 2);
      const minutes = addLeadingZeros(absOffset % 60, 2);
      return sign + hours + delimiter + minutes;
    }
    const dateLongFormatter = (pattern, formatLong2) => {
      switch (pattern) {
        case "P":
          return formatLong2.date({ width: "short" });
        case "PP":
          return formatLong2.date({ width: "medium" });
        case "PPP":
          return formatLong2.date({ width: "long" });
        case "PPPP":
        default:
          return formatLong2.date({ width: "full" });
      }
    };
    const timeLongFormatter = (pattern, formatLong2) => {
      switch (pattern) {
        case "p":
          return formatLong2.time({ width: "short" });
        case "pp":
          return formatLong2.time({ width: "medium" });
        case "ppp":
          return formatLong2.time({ width: "long" });
        case "pppp":
        default:
          return formatLong2.time({ width: "full" });
      }
    };
    const dateTimeLongFormatter = (pattern, formatLong2) => {
      const matchResult = pattern.match(/(P+)(p+)?/) || [];
      const datePattern = matchResult[1];
      const timePattern = matchResult[2];
      if (!timePattern) {
        return dateLongFormatter(pattern, formatLong2);
      }
      let dateTimeFormat;
      switch (datePattern) {
        case "P":
          dateTimeFormat = formatLong2.dateTime({ width: "short" });
          break;
        case "PP":
          dateTimeFormat = formatLong2.dateTime({ width: "medium" });
          break;
        case "PPP":
          dateTimeFormat = formatLong2.dateTime({ width: "long" });
          break;
        case "PPPP":
        default:
          dateTimeFormat = formatLong2.dateTime({ width: "full" });
          break;
      }
      return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
    };
    const longFormatters = {
      p: timeLongFormatter,
      P: dateTimeLongFormatter
    };
    const dayOfYearTokenRE = /^D+$/;
    const weekYearTokenRE = /^Y+$/;
    const throwTokens = ["D", "DD", "YY", "YYYY"];
    function isProtectedDayOfYearToken(token) {
      return dayOfYearTokenRE.test(token);
    }
    function isProtectedWeekYearToken(token) {
      return weekYearTokenRE.test(token);
    }
    function warnOrThrowProtectedError(token, format2, input) {
      const _message = message(token, format2, input);
      console.warn(_message);
      if (throwTokens.includes(token))
        throw new RangeError(_message);
    }
    function message(token, format2, input) {
      const subject = token[0] === "Y" ? "years" : "days of the month";
      return `Use \`${token.toLowerCase()}\` instead of \`${token}\` (in \`${format2}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
    }
    const formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
    const longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
    const escapedStringRegExp = /^'([^]*?)'?$/;
    const doubleQuoteRegExp = /''/g;
    const unescapedLatinCharacterRegExp = /[a-zA-Z]/;
    function format$1(date, formatStr, options) {
      const defaultOptions2 = getDefaultOptions();
      const locale = defaultOptions2.locale ?? enUS;
      const firstWeekContainsDate = defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
      const weekStartsOn = defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
      const originalDate = toDate(date);
      if (!isValid(originalDate)) {
        throw new RangeError("Invalid time value");
      }
      let parts = formatStr.match(longFormattingTokensRegExp).map((substring2) => {
        const firstCharacter = substring2[0];
        if (firstCharacter === "p" || firstCharacter === "P") {
          const longFormatter = longFormatters[firstCharacter];
          return longFormatter(substring2, locale.formatLong);
        }
        return substring2;
      }).join("").match(formattingTokensRegExp).map((substring2) => {
        if (substring2 === "''") {
          return { isToken: false, value: "'" };
        }
        const firstCharacter = substring2[0];
        if (firstCharacter === "'") {
          return { isToken: false, value: cleanEscapedString(substring2) };
        }
        if (formatters[firstCharacter]) {
          return { isToken: true, value: substring2 };
        }
        if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
          throw new RangeError(
            "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
          );
        }
        return { isToken: false, value: substring2 };
      });
      if (locale.localize.preprocessor) {
        parts = locale.localize.preprocessor(originalDate, parts);
      }
      const formatterOptions = {
        firstWeekContainsDate,
        weekStartsOn,
        locale
      };
      return parts.map((part) => {
        if (!part.isToken)
          return part.value;
        const token = part.value;
        if (isProtectedWeekYearToken(token) || isProtectedDayOfYearToken(token)) {
          warnOrThrowProtectedError(token, formatStr, String(date));
        }
        const formatter = formatters[token[0]];
        return formatter(originalDate, token, locale.localize, formatterOptions);
      }).join("");
    }
    function cleanEscapedString(input) {
      const matched = input.match(escapedStringRegExp);
      if (!matched) {
        return input;
      }
      return matched[1].replace(doubleQuoteRegExp, "'");
    }
    function formatDistance$b(date, baseDate, options) {
      const defaultOptions2 = getDefaultOptions();
      const locale = options?.locale ?? defaultOptions2.locale ?? enUS;
      const minutesInAlmostTwoDays = 2520;
      const comparison = compareAsc(date, baseDate);
      if (isNaN(comparison)) {
        throw new RangeError("Invalid time value");
      }
      const localizeOptions = Object.assign({}, options, {
        addSuffix: options?.addSuffix,
        comparison
      });
      let dateLeft;
      let dateRight;
      if (comparison > 0) {
        dateLeft = toDate(baseDate);
        dateRight = toDate(date);
      } else {
        dateLeft = toDate(date);
        dateRight = toDate(baseDate);
      }
      const seconds = differenceInSeconds(dateRight, dateLeft);
      const offsetInSeconds = (getTimezoneOffsetInMilliseconds(dateRight) - getTimezoneOffsetInMilliseconds(dateLeft)) / 1e3;
      const minutes = Math.round((seconds - offsetInSeconds) / 60);
      let months;
      if (minutes < 2) {
        if (options?.includeSeconds) {
          if (seconds < 5) {
            return locale.formatDistance("lessThanXSeconds", 5, localizeOptions);
          } else if (seconds < 10) {
            return locale.formatDistance("lessThanXSeconds", 10, localizeOptions);
          } else if (seconds < 20) {
            return locale.formatDistance("lessThanXSeconds", 20, localizeOptions);
          } else if (seconds < 40) {
            return locale.formatDistance("halfAMinute", 0, localizeOptions);
          } else if (seconds < 60) {
            return locale.formatDistance("lessThanXMinutes", 1, localizeOptions);
          } else {
            return locale.formatDistance("xMinutes", 1, localizeOptions);
          }
        } else {
          if (minutes === 0) {
            return locale.formatDistance("lessThanXMinutes", 1, localizeOptions);
          } else {
            return locale.formatDistance("xMinutes", minutes, localizeOptions);
          }
        }
      } else if (minutes < 45) {
        return locale.formatDistance("xMinutes", minutes, localizeOptions);
      } else if (minutes < 90) {
        return locale.formatDistance("aboutXHours", 1, localizeOptions);
      } else if (minutes < minutesInDay) {
        const hours = Math.round(minutes / 60);
        return locale.formatDistance("aboutXHours", hours, localizeOptions);
      } else if (minutes < minutesInAlmostTwoDays) {
        return locale.formatDistance("xDays", 1, localizeOptions);
      } else if (minutes < minutesInMonth) {
        const days = Math.round(minutes / minutesInDay);
        return locale.formatDistance("xDays", days, localizeOptions);
      } else if (minutes < minutesInMonth * 2) {
        months = Math.round(minutes / minutesInMonth);
        return locale.formatDistance("aboutXMonths", months, localizeOptions);
      }
      months = differenceInMonths(dateRight, dateLeft);
      if (months < 12) {
        const nearestMonth = Math.round(minutes / minutesInMonth);
        return locale.formatDistance("xMonths", nearestMonth, localizeOptions);
      } else {
        const monthsSinceStartOfYear = months % 12;
        const years = Math.trunc(months / 12);
        if (monthsSinceStartOfYear < 3) {
          return locale.formatDistance("aboutXYears", years, localizeOptions);
        } else if (monthsSinceStartOfYear < 9) {
          return locale.formatDistance("overXYears", years, localizeOptions);
        } else {
          return locale.formatDistance("almostXYears", years + 1, localizeOptions);
        }
      }
    }
    function isSameWeek(dateLeft, dateRight, options) {
      const dateLeftStartOfWeek = startOfWeek(dateLeft, options);
      const dateRightStartOfWeek = startOfWeek(dateRight, options);
      return +dateLeftStartOfWeek === +dateRightStartOfWeek;
    }
    function subMilliseconds(date, amount) {
      return addMilliseconds(date, -amount);
    }
    var colorString$1 = { exports: {} };
    var colorName = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
    var simpleSwizzle = { exports: {} };
    var isArrayish$1 = function isArrayish2(obj) {
      if (!obj || typeof obj === "string") {
        return false;
      }
      return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
    };
    var isArrayish = isArrayish$1;
    var concat$1 = Array.prototype.concat;
    var slice = Array.prototype.slice;
    var swizzle$1 = simpleSwizzle.exports = function swizzle2(args) {
      var results = [];
      for (var i2 = 0, len = args.length; i2 < len; i2++) {
        var arg = args[i2];
        if (isArrayish(arg)) {
          results = concat$1.call(results, slice.call(arg));
        } else {
          results.push(arg);
        }
      }
      return results;
    };
    swizzle$1.wrap = function(fn) {
      return function() {
        return fn(swizzle$1(arguments));
      };
    };
    var simpleSwizzleExports = simpleSwizzle.exports;
    var colorNames = colorName;
    var swizzle = simpleSwizzleExports;
    var hasOwnProperty$9 = Object.hasOwnProperty;
    var reverseNames = /* @__PURE__ */ Object.create(null);
    for (var name in colorNames) {
      if (hasOwnProperty$9.call(colorNames, name)) {
        reverseNames[colorNames[name]] = name;
      }
    }
    var cs = colorString$1.exports = {
      to: {},
      get: {}
    };
    cs.get = function(string) {
      var prefix = string.substring(0, 3).toLowerCase();
      var val2;
      var model;
      switch (prefix) {
        case "hsl":
          val2 = cs.get.hsl(string);
          model = "hsl";
          break;
        case "hwb":
          val2 = cs.get.hwb(string);
          model = "hwb";
          break;
        default:
          val2 = cs.get.rgb(string);
          model = "rgb";
          break;
      }
      if (!val2) {
        return null;
      }
      return { model, value: val2 };
    };
    cs.get.rgb = function(string) {
      if (!string) {
        return null;
      }
      var abbr = /^#([a-f0-9]{3,4})$/i;
      var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
      var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var keyword = /^(\w+)$/;
      var rgb = [0, 0, 0, 1];
      var match2;
      var i2;
      var hexAlpha;
      if (match2 = string.match(hex)) {
        hexAlpha = match2[2];
        match2 = match2[1];
        for (i2 = 0; i2 < 3; i2++) {
          var i22 = i2 * 2;
          rgb[i2] = parseInt(match2.slice(i22, i22 + 2), 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha, 16) / 255;
        }
      } else if (match2 = string.match(abbr)) {
        match2 = match2[1];
        hexAlpha = match2[3];
        for (i2 = 0; i2 < 3; i2++) {
          rgb[i2] = parseInt(match2[i2] + match2[i2], 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
        }
      } else if (match2 = string.match(rgba)) {
        for (i2 = 0; i2 < 3; i2++) {
          rgb[i2] = parseInt(match2[i2 + 1], 0);
        }
        if (match2[4]) {
          if (match2[5]) {
            rgb[3] = parseFloat(match2[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match2[4]);
          }
        }
      } else if (match2 = string.match(per)) {
        for (i2 = 0; i2 < 3; i2++) {
          rgb[i2] = Math.round(parseFloat(match2[i2 + 1]) * 2.55);
        }
        if (match2[4]) {
          if (match2[5]) {
            rgb[3] = parseFloat(match2[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match2[4]);
          }
        }
      } else if (match2 = string.match(keyword)) {
        if (match2[1] === "transparent") {
          return [0, 0, 0, 0];
        }
        if (!hasOwnProperty$9.call(colorNames, match2[1])) {
          return null;
        }
        rgb = colorNames[match2[1]];
        rgb[3] = 1;
        return rgb;
      } else {
        return null;
      }
      for (i2 = 0; i2 < 3; i2++) {
        rgb[i2] = clamp(rgb[i2], 0, 255);
      }
      rgb[3] = clamp(rgb[3], 0, 1);
      return rgb;
    };
    cs.get.hsl = function(string) {
      if (!string) {
        return null;
      }
      var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match2 = string.match(hsl);
      if (match2) {
        var alpha = parseFloat(match2[4]);
        var h2 = (parseFloat(match2[1]) % 360 + 360) % 360;
        var s2 = clamp(parseFloat(match2[2]), 0, 100);
        var l2 = clamp(parseFloat(match2[3]), 0, 100);
        var a2 = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h2, s2, l2, a2];
      }
      return null;
    };
    cs.get.hwb = function(string) {
      if (!string) {
        return null;
      }
      var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match2 = string.match(hwb);
      if (match2) {
        var alpha = parseFloat(match2[4]);
        var h2 = (parseFloat(match2[1]) % 360 + 360) % 360;
        var w2 = clamp(parseFloat(match2[2]), 0, 100);
        var b = clamp(parseFloat(match2[3]), 0, 100);
        var a2 = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h2, w2, b, a2];
      }
      return null;
    };
    cs.to.hex = function() {
      var rgba = swizzle(arguments);
      return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
    };
    cs.to.rgb = function() {
      var rgba = swizzle(arguments);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
    };
    cs.to.rgb.percent = function() {
      var rgba = swizzle(arguments);
      var r2 = Math.round(rgba[0] / 255 * 100);
      var g2 = Math.round(rgba[1] / 255 * 100);
      var b = Math.round(rgba[2] / 255 * 100);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r2 + "%, " + g2 + "%, " + b + "%)" : "rgba(" + r2 + "%, " + g2 + "%, " + b + "%, " + rgba[3] + ")";
    };
    cs.to.hsl = function() {
      var hsla = swizzle(arguments);
      return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
    };
    cs.to.hwb = function() {
      var hwba = swizzle(arguments);
      var a2 = "";
      if (hwba.length >= 4 && hwba[3] !== 1) {
        a2 = ", " + hwba[3];
      }
      return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a2 + ")";
    };
    cs.to.keyword = function(rgb) {
      return reverseNames[rgb.slice(0, 3)];
    };
    function clamp(num, min, max) {
      return Math.min(Math.max(min, num), max);
    }
    function hexDouble(num) {
      var str = Math.round(num).toString(16).toUpperCase();
      return str.length < 2 ? "0" + str : str;
    }
    var colorStringExports = colorString$1.exports;
    const cssKeywords = colorName;
    const reverseKeywords = {};
    for (const key2 of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key2]] = key2;
    }
    const convert$2 = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    var conversions$2 = convert$2;
    for (const model of Object.keys(convert$2)) {
      if (!("channels" in convert$2[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert$2[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert$2[model].labels.length !== convert$2[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert$2[model];
      delete convert$2[model].channels;
      delete convert$2[model].labels;
      Object.defineProperty(convert$2[model], "channels", { value: channels });
      Object.defineProperty(convert$2[model], "labels", { value: labels });
    }
    convert$2.rgb.hsl = function(rgb) {
      const r2 = rgb[0] / 255;
      const g2 = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r2, g2, b);
      const max = Math.max(r2, g2, b);
      const delta = max - min;
      let h2;
      let s2;
      if (max === min) {
        h2 = 0;
      } else if (r2 === max) {
        h2 = (g2 - b) / delta;
      } else if (g2 === max) {
        h2 = 2 + (b - r2) / delta;
      } else if (b === max) {
        h2 = 4 + (r2 - g2) / delta;
      }
      h2 = Math.min(h2 * 60, 360);
      if (h2 < 0) {
        h2 += 360;
      }
      const l2 = (min + max) / 2;
      if (max === min) {
        s2 = 0;
      } else if (l2 <= 0.5) {
        s2 = delta / (max + min);
      } else {
        s2 = delta / (2 - max - min);
      }
      return [h2, s2 * 100, l2 * 100];
    };
    convert$2.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h2;
      let s2;
      const r2 = rgb[0] / 255;
      const g2 = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v2 = Math.max(r2, g2, b);
      const diff = v2 - Math.min(r2, g2, b);
      const diffc = function(c2) {
        return (v2 - c2) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h2 = 0;
        s2 = 0;
      } else {
        s2 = diff / v2;
        rdif = diffc(r2);
        gdif = diffc(g2);
        bdif = diffc(b);
        if (r2 === v2) {
          h2 = bdif - gdif;
        } else if (g2 === v2) {
          h2 = 1 / 3 + rdif - bdif;
        } else if (b === v2) {
          h2 = 2 / 3 + gdif - rdif;
        }
        if (h2 < 0) {
          h2 += 1;
        } else if (h2 > 1) {
          h2 -= 1;
        }
      }
      return [
        h2 * 360,
        s2 * 100,
        v2 * 100
      ];
    };
    convert$2.rgb.hwb = function(rgb) {
      const r2 = rgb[0];
      const g2 = rgb[1];
      let b = rgb[2];
      const h2 = convert$2.rgb.hsl(rgb)[0];
      const w2 = 1 / 255 * Math.min(r2, Math.min(g2, b));
      b = 1 - 1 / 255 * Math.max(r2, Math.max(g2, b));
      return [h2, w2 * 100, b * 100];
    };
    convert$2.rgb.cmyk = function(rgb) {
      const r2 = rgb[0] / 255;
      const g2 = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k2 = Math.min(1 - r2, 1 - g2, 1 - b);
      const c2 = (1 - r2 - k2) / (1 - k2) || 0;
      const m2 = (1 - g2 - k2) / (1 - k2) || 0;
      const y2 = (1 - b - k2) / (1 - k2) || 0;
      return [c2 * 100, m2 * 100, y2 * 100, k2 * 100];
    };
    function comparativeDistance(x2, y2) {
      return (x2[0] - y2[0]) ** 2 + (x2[1] - y2[1]) ** 2 + (x2[2] - y2[2]) ** 2;
    }
    convert$2.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value2 = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value2);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert$2.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert$2.rgb.xyz = function(rgb) {
      let r2 = rgb[0] / 255;
      let g2 = rgb[1] / 255;
      let b = rgb[2] / 255;
      r2 = r2 > 0.04045 ? ((r2 + 0.055) / 1.055) ** 2.4 : r2 / 12.92;
      g2 = g2 > 0.04045 ? ((g2 + 0.055) / 1.055) ** 2.4 : g2 / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x2 = r2 * 0.4124 + g2 * 0.3576 + b * 0.1805;
      const y2 = r2 * 0.2126 + g2 * 0.7152 + b * 0.0722;
      const z2 = r2 * 0.0193 + g2 * 0.1192 + b * 0.9505;
      return [x2 * 100, y2 * 100, z2 * 100];
    };
    convert$2.rgb.lab = function(rgb) {
      const xyz = convert$2.rgb.xyz(rgb);
      let x2 = xyz[0];
      let y2 = xyz[1];
      let z2 = xyz[2];
      x2 /= 95.047;
      y2 /= 100;
      z2 /= 108.883;
      x2 = x2 > 8856e-6 ? x2 ** (1 / 3) : 7.787 * x2 + 16 / 116;
      y2 = y2 > 8856e-6 ? y2 ** (1 / 3) : 7.787 * y2 + 16 / 116;
      z2 = z2 > 8856e-6 ? z2 ** (1 / 3) : 7.787 * z2 + 16 / 116;
      const l2 = 116 * y2 - 16;
      const a2 = 500 * (x2 - y2);
      const b = 200 * (y2 - z2);
      return [l2, a2, b];
    };
    convert$2.hsl.rgb = function(hsl) {
      const h2 = hsl[0] / 360;
      const s2 = hsl[1] / 100;
      const l2 = hsl[2] / 100;
      let t2;
      let t3;
      let val2;
      if (s2 === 0) {
        val2 = l2 * 255;
        return [val2, val2, val2];
      }
      if (l2 < 0.5) {
        t2 = l2 * (1 + s2);
      } else {
        t2 = l2 + s2 - l2 * s2;
      }
      const t1 = 2 * l2 - t2;
      const rgb = [0, 0, 0];
      for (let i2 = 0; i2 < 3; i2++) {
        t3 = h2 + 1 / 3 * -(i2 - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val2 = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val2 = t2;
        } else if (3 * t3 < 2) {
          val2 = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val2 = t1;
        }
        rgb[i2] = val2 * 255;
      }
      return rgb;
    };
    convert$2.hsl.hsv = function(hsl) {
      const h2 = hsl[0];
      let s2 = hsl[1] / 100;
      let l2 = hsl[2] / 100;
      let smin = s2;
      const lmin = Math.max(l2, 0.01);
      l2 *= 2;
      s2 *= l2 <= 1 ? l2 : 2 - l2;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v2 = (l2 + s2) / 2;
      const sv = l2 === 0 ? 2 * smin / (lmin + smin) : 2 * s2 / (l2 + s2);
      return [h2, sv * 100, v2 * 100];
    };
    convert$2.hsv.rgb = function(hsv) {
      const h2 = hsv[0] / 60;
      const s2 = hsv[1] / 100;
      let v2 = hsv[2] / 100;
      const hi2 = Math.floor(h2) % 6;
      const f2 = h2 - Math.floor(h2);
      const p2 = 255 * v2 * (1 - s2);
      const q2 = 255 * v2 * (1 - s2 * f2);
      const t2 = 255 * v2 * (1 - s2 * (1 - f2));
      v2 *= 255;
      switch (hi2) {
        case 0:
          return [v2, t2, p2];
        case 1:
          return [q2, v2, p2];
        case 2:
          return [p2, v2, t2];
        case 3:
          return [p2, q2, v2];
        case 4:
          return [t2, p2, v2];
        case 5:
          return [v2, p2, q2];
      }
    };
    convert$2.hsv.hsl = function(hsv) {
      const h2 = hsv[0];
      const s2 = hsv[1] / 100;
      const v2 = hsv[2] / 100;
      const vmin = Math.max(v2, 0.01);
      let sl2;
      let l2;
      l2 = (2 - s2) * v2;
      const lmin = (2 - s2) * vmin;
      sl2 = s2 * vmin;
      sl2 /= lmin <= 1 ? lmin : 2 - lmin;
      sl2 = sl2 || 0;
      l2 /= 2;
      return [h2, sl2 * 100, l2 * 100];
    };
    convert$2.hwb.rgb = function(hwb) {
      const h2 = hwb[0] / 360;
      let wh2 = hwb[1] / 100;
      let bl2 = hwb[2] / 100;
      const ratio = wh2 + bl2;
      let f2;
      if (ratio > 1) {
        wh2 /= ratio;
        bl2 /= ratio;
      }
      const i2 = Math.floor(6 * h2);
      const v2 = 1 - bl2;
      f2 = 6 * h2 - i2;
      if ((i2 & 1) !== 0) {
        f2 = 1 - f2;
      }
      const n2 = wh2 + f2 * (v2 - wh2);
      let r2;
      let g2;
      let b;
      switch (i2) {
        default:
        case 6:
        case 0:
          r2 = v2;
          g2 = n2;
          b = wh2;
          break;
        case 1:
          r2 = n2;
          g2 = v2;
          b = wh2;
          break;
        case 2:
          r2 = wh2;
          g2 = v2;
          b = n2;
          break;
        case 3:
          r2 = wh2;
          g2 = n2;
          b = v2;
          break;
        case 4:
          r2 = n2;
          g2 = wh2;
          b = v2;
          break;
        case 5:
          r2 = v2;
          g2 = wh2;
          b = n2;
          break;
      }
      return [r2 * 255, g2 * 255, b * 255];
    };
    convert$2.cmyk.rgb = function(cmyk) {
      const c2 = cmyk[0] / 100;
      const m2 = cmyk[1] / 100;
      const y2 = cmyk[2] / 100;
      const k2 = cmyk[3] / 100;
      const r2 = 1 - Math.min(1, c2 * (1 - k2) + k2);
      const g2 = 1 - Math.min(1, m2 * (1 - k2) + k2);
      const b = 1 - Math.min(1, y2 * (1 - k2) + k2);
      return [r2 * 255, g2 * 255, b * 255];
    };
    convert$2.xyz.rgb = function(xyz) {
      const x2 = xyz[0] / 100;
      const y2 = xyz[1] / 100;
      const z2 = xyz[2] / 100;
      let r2;
      let g2;
      let b;
      r2 = x2 * 3.2406 + y2 * -1.5372 + z2 * -0.4986;
      g2 = x2 * -0.9689 + y2 * 1.8758 + z2 * 0.0415;
      b = x2 * 0.0557 + y2 * -0.204 + z2 * 1.057;
      r2 = r2 > 31308e-7 ? 1.055 * r2 ** (1 / 2.4) - 0.055 : r2 * 12.92;
      g2 = g2 > 31308e-7 ? 1.055 * g2 ** (1 / 2.4) - 0.055 : g2 * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r2 = Math.min(Math.max(0, r2), 1);
      g2 = Math.min(Math.max(0, g2), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r2 * 255, g2 * 255, b * 255];
    };
    convert$2.xyz.lab = function(xyz) {
      let x2 = xyz[0];
      let y2 = xyz[1];
      let z2 = xyz[2];
      x2 /= 95.047;
      y2 /= 100;
      z2 /= 108.883;
      x2 = x2 > 8856e-6 ? x2 ** (1 / 3) : 7.787 * x2 + 16 / 116;
      y2 = y2 > 8856e-6 ? y2 ** (1 / 3) : 7.787 * y2 + 16 / 116;
      z2 = z2 > 8856e-6 ? z2 ** (1 / 3) : 7.787 * z2 + 16 / 116;
      const l2 = 116 * y2 - 16;
      const a2 = 500 * (x2 - y2);
      const b = 200 * (y2 - z2);
      return [l2, a2, b];
    };
    convert$2.lab.xyz = function(lab) {
      const l2 = lab[0];
      const a2 = lab[1];
      const b = lab[2];
      let x2;
      let y2;
      let z2;
      y2 = (l2 + 16) / 116;
      x2 = a2 / 500 + y2;
      z2 = y2 - b / 200;
      const y22 = y2 ** 3;
      const x22 = x2 ** 3;
      const z22 = z2 ** 3;
      y2 = y22 > 8856e-6 ? y22 : (y2 - 16 / 116) / 7.787;
      x2 = x22 > 8856e-6 ? x22 : (x2 - 16 / 116) / 7.787;
      z2 = z22 > 8856e-6 ? z22 : (z2 - 16 / 116) / 7.787;
      x2 *= 95.047;
      y2 *= 100;
      z2 *= 108.883;
      return [x2, y2, z2];
    };
    convert$2.lab.lch = function(lab) {
      const l2 = lab[0];
      const a2 = lab[1];
      const b = lab[2];
      let h2;
      const hr = Math.atan2(b, a2);
      h2 = hr * 360 / 2 / Math.PI;
      if (h2 < 0) {
        h2 += 360;
      }
      const c2 = Math.sqrt(a2 * a2 + b * b);
      return [l2, c2, h2];
    };
    convert$2.lch.lab = function(lch) {
      const l2 = lch[0];
      const c2 = lch[1];
      const h2 = lch[2];
      const hr = h2 / 360 * 2 * Math.PI;
      const a2 = c2 * Math.cos(hr);
      const b = c2 * Math.sin(hr);
      return [l2, a2, b];
    };
    convert$2.rgb.ansi16 = function(args, saturation = null) {
      const [r2, g2, b] = args;
      let value2 = saturation === null ? convert$2.rgb.hsv(args)[2] : saturation;
      value2 = Math.round(value2 / 50);
      if (value2 === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g2 / 255) << 1 | Math.round(r2 / 255));
      if (value2 === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert$2.hsv.ansi16 = function(args) {
      return convert$2.rgb.ansi16(convert$2.hsv.rgb(args), args[2]);
    };
    convert$2.rgb.ansi256 = function(args) {
      const r2 = args[0];
      const g2 = args[1];
      const b = args[2];
      if (r2 === g2 && g2 === b) {
        if (r2 < 8) {
          return 16;
        }
        if (r2 > 248) {
          return 231;
        }
        return Math.round((r2 - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r2 / 255 * 5) + 6 * Math.round(g2 / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert$2.ansi16.rgb = function(args) {
      let color2 = args % 10;
      if (color2 === 0 || color2 === 7) {
        if (args > 50) {
          color2 += 3.5;
        }
        color2 = color2 / 10.5 * 255;
        return [color2, color2, color2];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r2 = (color2 & 1) * mult * 255;
      const g2 = (color2 >> 1 & 1) * mult * 255;
      const b = (color2 >> 2 & 1) * mult * 255;
      return [r2, g2, b];
    };
    convert$2.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c2 = (args - 232) * 10 + 8;
        return [c2, c2, c2];
      }
      args -= 16;
      let rem;
      const r2 = Math.floor(args / 36) / 5 * 255;
      const g2 = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r2, g2, b];
    };
    convert$2.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert$2.hex.rgb = function(args) {
      const match2 = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match2) {
        return [0, 0, 0];
      }
      let colorString2 = match2[0];
      if (match2[0].length === 3) {
        colorString2 = colorString2.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString2, 16);
      const r2 = integer >> 16 & 255;
      const g2 = integer >> 8 & 255;
      const b = integer & 255;
      return [r2, g2, b];
    };
    convert$2.rgb.hcg = function(rgb) {
      const r2 = rgb[0] / 255;
      const g2 = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r2, g2), b);
      const min = Math.min(Math.min(r2, g2), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r2) {
        hue = (g2 - b) / chroma % 6;
      } else if (max === g2) {
        hue = 2 + (b - r2) / chroma;
      } else {
        hue = 4 + (r2 - g2) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert$2.hsl.hcg = function(hsl) {
      const s2 = hsl[1] / 100;
      const l2 = hsl[2] / 100;
      const c2 = l2 < 0.5 ? 2 * s2 * l2 : 2 * s2 * (1 - l2);
      let f2 = 0;
      if (c2 < 1) {
        f2 = (l2 - 0.5 * c2) / (1 - c2);
      }
      return [hsl[0], c2 * 100, f2 * 100];
    };
    convert$2.hsv.hcg = function(hsv) {
      const s2 = hsv[1] / 100;
      const v2 = hsv[2] / 100;
      const c2 = s2 * v2;
      let f2 = 0;
      if (c2 < 1) {
        f2 = (v2 - c2) / (1 - c2);
      }
      return [hsv[0], c2 * 100, f2 * 100];
    };
    convert$2.hcg.rgb = function(hcg) {
      const h2 = hcg[0] / 360;
      const c2 = hcg[1] / 100;
      const g2 = hcg[2] / 100;
      if (c2 === 0) {
        return [g2 * 255, g2 * 255, g2 * 255];
      }
      const pure = [0, 0, 0];
      const hi2 = h2 % 1 * 6;
      const v2 = hi2 % 1;
      const w2 = 1 - v2;
      let mg2 = 0;
      switch (Math.floor(hi2)) {
        case 0:
          pure[0] = 1;
          pure[1] = v2;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w2;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v2;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w2;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v2;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w2;
      }
      mg2 = (1 - c2) * g2;
      return [
        (c2 * pure[0] + mg2) * 255,
        (c2 * pure[1] + mg2) * 255,
        (c2 * pure[2] + mg2) * 255
      ];
    };
    convert$2.hcg.hsv = function(hcg) {
      const c2 = hcg[1] / 100;
      const g2 = hcg[2] / 100;
      const v2 = c2 + g2 * (1 - c2);
      let f2 = 0;
      if (v2 > 0) {
        f2 = c2 / v2;
      }
      return [hcg[0], f2 * 100, v2 * 100];
    };
    convert$2.hcg.hsl = function(hcg) {
      const c2 = hcg[1] / 100;
      const g2 = hcg[2] / 100;
      const l2 = g2 * (1 - c2) + 0.5 * c2;
      let s2 = 0;
      if (l2 > 0 && l2 < 0.5) {
        s2 = c2 / (2 * l2);
      } else if (l2 >= 0.5 && l2 < 1) {
        s2 = c2 / (2 * (1 - l2));
      }
      return [hcg[0], s2 * 100, l2 * 100];
    };
    convert$2.hcg.hwb = function(hcg) {
      const c2 = hcg[1] / 100;
      const g2 = hcg[2] / 100;
      const v2 = c2 + g2 * (1 - c2);
      return [hcg[0], (v2 - c2) * 100, (1 - v2) * 100];
    };
    convert$2.hwb.hcg = function(hwb) {
      const w2 = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v2 = 1 - b;
      const c2 = v2 - w2;
      let g2 = 0;
      if (c2 < 1) {
        g2 = (v2 - c2) / (1 - c2);
      }
      return [hwb[0], c2 * 100, g2 * 100];
    };
    convert$2.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert$2.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert$2.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert$2.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert$2.gray.hsv = convert$2.gray.hsl;
    convert$2.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert$2.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert$2.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert$2.gray.hex = function(gray) {
      const val2 = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val2 << 16) + (val2 << 8) + val2;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert$2.rgb.gray = function(rgb) {
      const val2 = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val2 / 255 * 100];
    };
    const conversions$1 = conversions$2;
    function buildGraph() {
      const graph = {};
      const models2 = Object.keys(conversions$1);
      for (let len = models2.length, i2 = 0; i2 < len; i2++) {
        graph[models2[i2]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current2 = queue.pop();
        const adjacents = Object.keys(conversions$1[current2]);
        for (let len = adjacents.length, i2 = 0; i2 < len; i2++) {
          const adjacent = adjacents[i2];
          const node2 = graph[adjacent];
          if (node2.distance === -1) {
            node2.distance = graph[current2].distance + 1;
            node2.parent = current2;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link$1(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path2 = [graph[toModel].parent, toModel];
      let fn = conversions$1[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path2.unshift(graph[cur].parent);
        fn = link$1(conversions$1[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path2;
      return fn;
    }
    var route$1 = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models2 = Object.keys(graph);
      for (let len = models2.length, i2 = 0; i2 < len; i2++) {
        const toModel = models2[i2];
        const node2 = graph[toModel];
        if (node2.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
    const conversions = conversions$2;
    const route = route$1;
    const convert$1 = {};
    const models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i2 = 0; i2 < len; i2++) {
            result[i2] = Math.round(result[i2]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert$1[fromModel] = {};
      Object.defineProperty(convert$1[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert$1[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes2 = route(fromModel);
      const routeModels = Object.keys(routes2);
      routeModels.forEach((toModel) => {
        const fn = routes2[toModel];
        convert$1[fromModel][toModel] = wrapRounded(fn);
        convert$1[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    var colorConvert = convert$1;
    const colorString = colorStringExports;
    const convert = colorConvert;
    const skippedModels = [
      // To be honest, I don't really feel like keyword belongs in color convert, but eh.
      "keyword",
      // Gray conflicts with some method names, and has its own method defined.
      "gray",
      // Shouldn't really be in color-convert either...
      "hex"
    ];
    const hashedModelKeys = {};
    for (const model of Object.keys(convert)) {
      hashedModelKeys[[...convert[model].labels].sort().join("")] = model;
    }
    const limiters = {};
    function Color(object, model) {
      if (!(this instanceof Color)) {
        return new Color(object, model);
      }
      if (model && model in skippedModels) {
        model = null;
      }
      if (model && !(model in convert)) {
        throw new Error("Unknown model: " + model);
      }
      let i2;
      let channels;
      if (object == null) {
        this.model = "rgb";
        this.color = [0, 0, 0];
        this.valpha = 1;
      } else if (object instanceof Color) {
        this.model = object.model;
        this.color = [...object.color];
        this.valpha = object.valpha;
      } else if (typeof object === "string") {
        const result = colorString.get(object);
        if (result === null) {
          throw new Error("Unable to parse color from string: " + object);
        }
        this.model = result.model;
        channels = convert[this.model].channels;
        this.color = result.value.slice(0, channels);
        this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
      } else if (object.length > 0) {
        this.model = model || "rgb";
        channels = convert[this.model].channels;
        const newArray = Array.prototype.slice.call(object, 0, channels);
        this.color = zeroArray(newArray, channels);
        this.valpha = typeof object[channels] === "number" ? object[channels] : 1;
      } else if (typeof object === "number") {
        this.model = "rgb";
        this.color = [
          object >> 16 & 255,
          object >> 8 & 255,
          object & 255
        ];
        this.valpha = 1;
      } else {
        this.valpha = 1;
        const keys2 = Object.keys(object);
        if ("alpha" in object) {
          keys2.splice(keys2.indexOf("alpha"), 1);
          this.valpha = typeof object.alpha === "number" ? object.alpha : 0;
        }
        const hashedKeys = keys2.sort().join("");
        if (!(hashedKeys in hashedModelKeys)) {
          throw new Error("Unable to parse color from object: " + JSON.stringify(object));
        }
        this.model = hashedModelKeys[hashedKeys];
        const { labels } = convert[this.model];
        const color2 = [];
        for (i2 = 0; i2 < labels.length; i2++) {
          color2.push(object[labels[i2]]);
        }
        this.color = zeroArray(color2);
      }
      if (limiters[this.model]) {
        channels = convert[this.model].channels;
        for (i2 = 0; i2 < channels; i2++) {
          const limit = limiters[this.model][i2];
          if (limit) {
            this.color[i2] = limit(this.color[i2]);
          }
        }
      }
      this.valpha = Math.max(0, Math.min(1, this.valpha));
      if (Object.freeze) {
        Object.freeze(this);
      }
    }
    Color.prototype = {
      toString() {
        return this.string();
      },
      toJSON() {
        return this[this.model]();
      },
      string(places) {
        let self2 = this.model in colorString.to ? this : this.rgb();
        self2 = self2.round(typeof places === "number" ? places : 1);
        const args = self2.valpha === 1 ? self2.color : [...self2.color, this.valpha];
        return colorString.to[self2.model](args);
      },
      percentString(places) {
        const self2 = this.rgb().round(typeof places === "number" ? places : 1);
        const args = self2.valpha === 1 ? self2.color : [...self2.color, this.valpha];
        return colorString.to.rgb.percent(args);
      },
      array() {
        return this.valpha === 1 ? [...this.color] : [...this.color, this.valpha];
      },
      object() {
        const result = {};
        const { channels } = convert[this.model];
        const { labels } = convert[this.model];
        for (let i2 = 0; i2 < channels; i2++) {
          result[labels[i2]] = this.color[i2];
        }
        if (this.valpha !== 1) {
          result.alpha = this.valpha;
        }
        return result;
      },
      unitArray() {
        const rgb = this.rgb().color;
        rgb[0] /= 255;
        rgb[1] /= 255;
        rgb[2] /= 255;
        if (this.valpha !== 1) {
          rgb.push(this.valpha);
        }
        return rgb;
      },
      unitObject() {
        const rgb = this.rgb().object();
        rgb.r /= 255;
        rgb.g /= 255;
        rgb.b /= 255;
        if (this.valpha !== 1) {
          rgb.alpha = this.valpha;
        }
        return rgb;
      },
      round(places) {
        places = Math.max(places || 0, 0);
        return new Color([...this.color.map(roundToPlace(places)), this.valpha], this.model);
      },
      alpha(value2) {
        if (value2 !== void 0) {
          return new Color([...this.color, Math.max(0, Math.min(1, value2))], this.model);
        }
        return this.valpha;
      },
      // Rgb
      red: getset("rgb", 0, maxfn(255)),
      green: getset("rgb", 1, maxfn(255)),
      blue: getset("rgb", 2, maxfn(255)),
      hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, (value2) => (value2 % 360 + 360) % 360),
      saturationl: getset("hsl", 1, maxfn(100)),
      lightness: getset("hsl", 2, maxfn(100)),
      saturationv: getset("hsv", 1, maxfn(100)),
      value: getset("hsv", 2, maxfn(100)),
      chroma: getset("hcg", 1, maxfn(100)),
      gray: getset("hcg", 2, maxfn(100)),
      white: getset("hwb", 1, maxfn(100)),
      wblack: getset("hwb", 2, maxfn(100)),
      cyan: getset("cmyk", 0, maxfn(100)),
      magenta: getset("cmyk", 1, maxfn(100)),
      yellow: getset("cmyk", 2, maxfn(100)),
      black: getset("cmyk", 3, maxfn(100)),
      x: getset("xyz", 0, maxfn(95.047)),
      y: getset("xyz", 1, maxfn(100)),
      z: getset("xyz", 2, maxfn(108.833)),
      l: getset("lab", 0, maxfn(100)),
      a: getset("lab", 1),
      b: getset("lab", 2),
      keyword(value2) {
        if (value2 !== void 0) {
          return new Color(value2);
        }
        return convert[this.model].keyword(this.color);
      },
      hex(value2) {
        if (value2 !== void 0) {
          return new Color(value2);
        }
        return colorString.to.hex(this.rgb().round().color);
      },
      hexa(value2) {
        if (value2 !== void 0) {
          return new Color(value2);
        }
        const rgbArray = this.rgb().round().color;
        let alphaHex = Math.round(this.valpha * 255).toString(16).toUpperCase();
        if (alphaHex.length === 1) {
          alphaHex = "0" + alphaHex;
        }
        return colorString.to.hex(rgbArray) + alphaHex;
      },
      rgbNumber() {
        const rgb = this.rgb().color;
        return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;
      },
      luminosity() {
        const rgb = this.rgb().color;
        const lum = [];
        for (const [i2, element] of rgb.entries()) {
          const chan = element / 255;
          lum[i2] = chan <= 0.04045 ? chan / 12.92 : ((chan + 0.055) / 1.055) ** 2.4;
        }
        return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
      },
      contrast(color2) {
        const lum1 = this.luminosity();
        const lum2 = color2.luminosity();
        if (lum1 > lum2) {
          return (lum1 + 0.05) / (lum2 + 0.05);
        }
        return (lum2 + 0.05) / (lum1 + 0.05);
      },
      level(color2) {
        const contrastRatio = this.contrast(color2);
        if (contrastRatio >= 7) {
          return "AAA";
        }
        return contrastRatio >= 4.5 ? "AA" : "";
      },
      isDark() {
        const rgb = this.rgb().color;
        const yiq = (rgb[0] * 2126 + rgb[1] * 7152 + rgb[2] * 722) / 1e4;
        return yiq < 128;
      },
      isLight() {
        return !this.isDark();
      },
      negate() {
        const rgb = this.rgb();
        for (let i2 = 0; i2 < 3; i2++) {
          rgb.color[i2] = 255 - rgb.color[i2];
        }
        return rgb;
      },
      lighten(ratio) {
        const hsl = this.hsl();
        hsl.color[2] += hsl.color[2] * ratio;
        return hsl;
      },
      darken(ratio) {
        const hsl = this.hsl();
        hsl.color[2] -= hsl.color[2] * ratio;
        return hsl;
      },
      saturate(ratio) {
        const hsl = this.hsl();
        hsl.color[1] += hsl.color[1] * ratio;
        return hsl;
      },
      desaturate(ratio) {
        const hsl = this.hsl();
        hsl.color[1] -= hsl.color[1] * ratio;
        return hsl;
      },
      whiten(ratio) {
        const hwb = this.hwb();
        hwb.color[1] += hwb.color[1] * ratio;
        return hwb;
      },
      blacken(ratio) {
        const hwb = this.hwb();
        hwb.color[2] += hwb.color[2] * ratio;
        return hwb;
      },
      grayscale() {
        const rgb = this.rgb().color;
        const value2 = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
        return Color.rgb(value2, value2, value2);
      },
      fade(ratio) {
        return this.alpha(this.valpha - this.valpha * ratio);
      },
      opaquer(ratio) {
        return this.alpha(this.valpha + this.valpha * ratio);
      },
      rotate(degrees) {
        const hsl = this.hsl();
        let hue = hsl.color[0];
        hue = (hue + degrees) % 360;
        hue = hue < 0 ? 360 + hue : hue;
        hsl.color[0] = hue;
        return hsl;
      },
      mix(mixinColor, weight) {
        if (!mixinColor || !mixinColor.rgb) {
          throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
        }
        const color1 = mixinColor.rgb();
        const color2 = this.rgb();
        const p2 = weight === void 0 ? 0.5 : weight;
        const w2 = 2 * p2 - 1;
        const a2 = color1.alpha() - color2.alpha();
        const w1 = ((w2 * a2 === -1 ? w2 : (w2 + a2) / (1 + w2 * a2)) + 1) / 2;
        const w22 = 1 - w1;
        return Color.rgb(
          w1 * color1.red() + w22 * color2.red(),
          w1 * color1.green() + w22 * color2.green(),
          w1 * color1.blue() + w22 * color2.blue(),
          color1.alpha() * p2 + color2.alpha() * (1 - p2)
        );
      }
    };
    for (const model of Object.keys(convert)) {
      if (skippedModels.includes(model)) {
        continue;
      }
      const { channels } = convert[model];
      Color.prototype[model] = function(...args) {
        if (this.model === model) {
          return new Color(this);
        }
        if (args.length > 0) {
          return new Color(args, model);
        }
        return new Color([...assertArray(convert[this.model][model].raw(this.color)), this.valpha], model);
      };
      Color[model] = function(...args) {
        let color2 = args[0];
        if (typeof color2 === "number") {
          color2 = zeroArray(args, channels);
        }
        return new Color(color2, model);
      };
    }
    function roundTo(number, places) {
      return Number(number.toFixed(places));
    }
    function roundToPlace(places) {
      return function(number) {
        return roundTo(number, places);
      };
    }
    function getset(model, channel, modifier) {
      model = Array.isArray(model) ? model : [model];
      for (const m2 of model) {
        (limiters[m2] || (limiters[m2] = []))[channel] = modifier;
      }
      model = model[0];
      return function(value2) {
        let result;
        if (value2 !== void 0) {
          if (modifier) {
            value2 = modifier(value2);
          }
          result = this[model]();
          result.color[channel] = value2;
          return result;
        }
        result = this[model]().color[channel];
        if (modifier) {
          result = modifier(result);
        }
        return result;
      };
    }
    function maxfn(max) {
      return function(v2) {
        return Math.max(0, Math.min(max, v2));
      };
    }
    function assertArray(value2) {
      return Array.isArray(value2) ? value2 : [value2];
    }
    function zeroArray(array, length2) {
      for (let i2 = 0; i2 < length2; i2++) {
        if (typeof array[i2] !== "number") {
          array[i2] = 0;
        }
      }
      return array;
    }
    var color = Color;
    const Color$1 = /* @__PURE__ */ getDefaultExportFromCjs(color);
    const steamUrlBuilder = {
      library: (objectID) => `https://steamcdn-a.akamaihd.net/steam/apps/${objectID}/header.jpg`,
      libraryHero: (objectID) => `https://steamcdn-a.akamaihd.net/steam/apps/${objectID}/library_hero.jpg`,
      logo: (objectID) => `https://cdn.cloudflare.steamstatic.com/steam/apps/${objectID}/logo.png`
    };
    const formatDownloadProgress = (progress2) => {
      if (!progress2)
        return "0%";
      const progressPercentage = progress2 * 100;
      if (Number(progressPercentage.toFixed(2)) % 1 === 0)
        return `${Math.floor(progressPercentage)}%`;
      return `${progressPercentage.toFixed(2)}%`;
    };
    const getSteamLanguage = (language) => {
      if (language.startsWith("pt"))
        return "brazilian";
      if (language.startsWith("es"))
        return "spanish";
      if (language.startsWith("fr"))
        return "french";
      if (language.startsWith("ru") || language.startsWith("be"))
        return "russian";
      if (language.startsWith("it"))
        return "italian";
      if (language.startsWith("hu"))
        return "hungarian";
      if (language.startsWith("pl"))
        return "polish";
      if (language.startsWith("zh"))
        return "schinese";
      if (language.startsWith("da"))
        return "danish";
      return "english";
    };
    const buildGameDetailsPath = (game, params = {}) => {
      const searchParams = new URLSearchParams({ title: game.title, ...params });
      return `/game/${game.shop}/${game.objectID}?${searchParams.toString()}`;
    };
    const darkenColor = (color2, amount, alpha = 1) => new Color$1(color2).darken(amount).alpha(alpha).toString();
    const useAppDispatch = useDispatch;
    const useAppSelector = useSelector;
    function formatProdErrorMessage$1(code) {
      return `Minified Redux error #${code}; visit https://redux.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;
    }
    var $$observable = /* @__PURE__ */ (() => typeof Symbol === "function" && Symbol.observable || "@@observable")();
    var symbol_observable_default = $$observable;
    var randomString = () => Math.random().toString(36).substring(7).split("").join(".");
    var ActionTypes = {
      INIT: `@@redux/INIT${/* @__PURE__ */ randomString()}`,
      REPLACE: `@@redux/REPLACE${/* @__PURE__ */ randomString()}`,
      PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`
    };
    var actionTypes_default = ActionTypes;
    function isPlainObject$1(obj) {
      if (typeof obj !== "object" || obj === null)
        return false;
      let proto = obj;
      while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
      }
      return Object.getPrototypeOf(obj) === proto || Object.getPrototypeOf(obj) === null;
    }
    function createStore(reducer, preloadedState, enhancer) {
      if (typeof reducer !== "function") {
        throw new Error(formatProdErrorMessage$1(2));
      }
      if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
        throw new Error(formatProdErrorMessage$1(0));
      }
      if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
        enhancer = preloadedState;
        preloadedState = void 0;
      }
      if (typeof enhancer !== "undefined") {
        if (typeof enhancer !== "function") {
          throw new Error(formatProdErrorMessage$1(1));
        }
        return enhancer(createStore)(reducer, preloadedState);
      }
      let currentReducer = reducer;
      let currentState = preloadedState;
      let currentListeners = /* @__PURE__ */ new Map();
      let nextListeners = currentListeners;
      let listenerIdCounter = 0;
      let isDispatching = false;
      function ensureCanMutateNextListeners() {
        if (nextListeners === currentListeners) {
          nextListeners = /* @__PURE__ */ new Map();
          currentListeners.forEach((listener, key2) => {
            nextListeners.set(key2, listener);
          });
        }
      }
      function getState() {
        if (isDispatching) {
          throw new Error(formatProdErrorMessage$1(3));
        }
        return currentState;
      }
      function subscribe(listener) {
        if (typeof listener !== "function") {
          throw new Error(formatProdErrorMessage$1(4));
        }
        if (isDispatching) {
          throw new Error(formatProdErrorMessage$1(5));
        }
        let isSubscribed = true;
        ensureCanMutateNextListeners();
        const listenerId = listenerIdCounter++;
        nextListeners.set(listenerId, listener);
        return function unsubscribe() {
          if (!isSubscribed) {
            return;
          }
          if (isDispatching) {
            throw new Error(formatProdErrorMessage$1(6));
          }
          isSubscribed = false;
          ensureCanMutateNextListeners();
          nextListeners.delete(listenerId);
          currentListeners = null;
        };
      }
      function dispatch(action) {
        if (!isPlainObject$1(action)) {
          throw new Error(formatProdErrorMessage$1(7));
        }
        if (typeof action.type === "undefined") {
          throw new Error(formatProdErrorMessage$1(8));
        }
        if (typeof action.type !== "string") {
          throw new Error(formatProdErrorMessage$1(17));
        }
        if (isDispatching) {
          throw new Error(formatProdErrorMessage$1(9));
        }
        try {
          isDispatching = true;
          currentState = currentReducer(currentState, action);
        } finally {
          isDispatching = false;
        }
        const listeners = currentListeners = nextListeners;
        listeners.forEach((listener) => {
          listener();
        });
        return action;
      }
      function replaceReducer(nextReducer) {
        if (typeof nextReducer !== "function") {
          throw new Error(formatProdErrorMessage$1(10));
        }
        currentReducer = nextReducer;
        dispatch({
          type: actionTypes_default.REPLACE
        });
      }
      function observable() {
        const outerSubscribe = subscribe;
        return {
          /**
           * The minimal observable subscription method.
           * @param observer Any object that can be used as an observer.
           * The observer object should have a `next` method.
           * @returns An object with an `unsubscribe` method that can
           * be used to unsubscribe the observable from the store, and prevent further
           * emission of values from the observable.
           */
          subscribe(observer) {
            if (typeof observer !== "object" || observer === null) {
              throw new Error(formatProdErrorMessage$1(11));
            }
            function observeState() {
              const observerAsObserver = observer;
              if (observerAsObserver.next) {
                observerAsObserver.next(getState());
              }
            }
            observeState();
            const unsubscribe = outerSubscribe(observeState);
            return {
              unsubscribe
            };
          },
          [symbol_observable_default]() {
            return this;
          }
        };
      }
      dispatch({
        type: actionTypes_default.INIT
      });
      const store2 = {
        dispatch,
        subscribe,
        getState,
        replaceReducer,
        [symbol_observable_default]: observable
      };
      return store2;
    }
    function assertReducerShape(reducers) {
      Object.keys(reducers).forEach((key2) => {
        const reducer = reducers[key2];
        const initialState2 = reducer(void 0, {
          type: actionTypes_default.INIT
        });
        if (typeof initialState2 === "undefined") {
          throw new Error(formatProdErrorMessage$1(12));
        }
        if (typeof reducer(void 0, {
          type: actionTypes_default.PROBE_UNKNOWN_ACTION()
        }) === "undefined") {
          throw new Error(formatProdErrorMessage$1(13));
        }
      });
    }
    function combineReducers(reducers) {
      const reducerKeys = Object.keys(reducers);
      const finalReducers = {};
      for (let i2 = 0; i2 < reducerKeys.length; i2++) {
        const key2 = reducerKeys[i2];
        if (typeof reducers[key2] === "function") {
          finalReducers[key2] = reducers[key2];
        }
      }
      const finalReducerKeys = Object.keys(finalReducers);
      let shapeAssertionError;
      try {
        assertReducerShape(finalReducers);
      } catch (e2) {
        shapeAssertionError = e2;
      }
      return function combination(state = {}, action) {
        if (shapeAssertionError) {
          throw shapeAssertionError;
        }
        let hasChanged = false;
        const nextState = {};
        for (let i2 = 0; i2 < finalReducerKeys.length; i2++) {
          const key2 = finalReducerKeys[i2];
          const reducer = finalReducers[key2];
          const previousStateForKey = state[key2];
          const nextStateForKey = reducer(previousStateForKey, action);
          if (typeof nextStateForKey === "undefined") {
            action && action.type;
            throw new Error(formatProdErrorMessage$1(14));
          }
          nextState[key2] = nextStateForKey;
          hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
        }
        hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
        return hasChanged ? nextState : state;
      };
    }
    function compose(...funcs) {
      if (funcs.length === 0) {
        return (arg) => arg;
      }
      if (funcs.length === 1) {
        return funcs[0];
      }
      return funcs.reduce((a2, b) => (...args) => a2(b(...args)));
    }
    function applyMiddleware(...middlewares) {
      return (createStore2) => (reducer, preloadedState) => {
        const store2 = createStore2(reducer, preloadedState);
        let dispatch = () => {
          throw new Error(formatProdErrorMessage$1(15));
        };
        const middlewareAPI = {
          getState: store2.getState,
          dispatch: (action, ...args) => dispatch(action, ...args)
        };
        const chain = middlewares.map((middleware) => middleware(middlewareAPI));
        dispatch = compose(...chain)(store2.dispatch);
        return {
          ...store2,
          dispatch
        };
      };
    }
    function isAction(action) {
      return isPlainObject$1(action) && "type" in action && typeof action.type === "string";
    }
    var NOTHING = Symbol.for("immer-nothing");
    var DRAFTABLE = Symbol.for("immer-draftable");
    var DRAFT_STATE = Symbol.for("immer-state");
    function die(error, ...args) {
      throw new Error(
        `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`
      );
    }
    var getPrototypeOf = Object.getPrototypeOf;
    function isDraft(value2) {
      return !!value2 && !!value2[DRAFT_STATE];
    }
    function isDraftable(value2) {
      if (!value2)
        return false;
      return isPlainObject(value2) || Array.isArray(value2) || !!value2[DRAFTABLE] || !!value2.constructor?.[DRAFTABLE] || isMap(value2) || isSet(value2);
    }
    var objectCtorString = Object.prototype.constructor.toString();
    function isPlainObject(value2) {
      if (!value2 || typeof value2 !== "object")
        return false;
      const proto = getPrototypeOf(value2);
      if (proto === null) {
        return true;
      }
      const Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
      if (Ctor === Object)
        return true;
      return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
    }
    function each(obj, iter) {
      if (getArchtype(obj) === 0) {
        Reflect.ownKeys(obj).forEach((key2) => {
          iter(key2, obj[key2], obj);
        });
      } else {
        obj.forEach((entry, index2) => iter(index2, entry, obj));
      }
    }
    function getArchtype(thing) {
      const state = thing[DRAFT_STATE];
      return state ? state.type_ : Array.isArray(thing) ? 1 : isMap(thing) ? 2 : isSet(thing) ? 3 : 0;
    }
    function has(thing, prop) {
      return getArchtype(thing) === 2 ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
    }
    function set(thing, propOrOldValue, value2) {
      const t2 = getArchtype(thing);
      if (t2 === 2)
        thing.set(propOrOldValue, value2);
      else if (t2 === 3) {
        thing.add(value2);
      } else
        thing[propOrOldValue] = value2;
    }
    function is(x2, y2) {
      if (x2 === y2) {
        return x2 !== 0 || 1 / x2 === 1 / y2;
      } else {
        return x2 !== x2 && y2 !== y2;
      }
    }
    function isMap(target) {
      return target instanceof Map;
    }
    function isSet(target) {
      return target instanceof Set;
    }
    function latest(state) {
      return state.copy_ || state.base_;
    }
    function shallowCopy(base, strict) {
      if (isMap(base)) {
        return new Map(base);
      }
      if (isSet(base)) {
        return new Set(base);
      }
      if (Array.isArray(base))
        return Array.prototype.slice.call(base);
      const isPlain = isPlainObject(base);
      if (strict === true || strict === "class_only" && !isPlain) {
        const descriptors = Object.getOwnPropertyDescriptors(base);
        delete descriptors[DRAFT_STATE];
        let keys2 = Reflect.ownKeys(descriptors);
        for (let i2 = 0; i2 < keys2.length; i2++) {
          const key2 = keys2[i2];
          const desc = descriptors[key2];
          if (desc.writable === false) {
            desc.writable = true;
            desc.configurable = true;
          }
          if (desc.get || desc.set)
            descriptors[key2] = {
              configurable: true,
              writable: true,
              // could live with !!desc.set as well here...
              enumerable: desc.enumerable,
              value: base[key2]
            };
        }
        return Object.create(getPrototypeOf(base), descriptors);
      } else {
        const proto = getPrototypeOf(base);
        if (proto !== null && isPlain) {
          return { ...base };
        }
        const obj = Object.create(proto);
        return Object.assign(obj, base);
      }
    }
    function freeze(obj, deep = false) {
      if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))
        return obj;
      if (getArchtype(obj) > 1) {
        obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
      }
      Object.freeze(obj);
      if (deep)
        Object.entries(obj).forEach(([key2, value2]) => freeze(value2, true));
      return obj;
    }
    function dontMutateFrozenCollections() {
      die(2);
    }
    function isFrozen(obj) {
      return Object.isFrozen(obj);
    }
    var plugins = {};
    function getPlugin(pluginKey) {
      const plugin = plugins[pluginKey];
      if (!plugin) {
        die(0, pluginKey);
      }
      return plugin;
    }
    var currentScope;
    function getCurrentScope() {
      return currentScope;
    }
    function createScope(parent_, immer_) {
      return {
        drafts_: [],
        parent_,
        immer_,
        // Whenever the modified draft contains a draft from another scope, we
        // need to prevent auto-freezing so the unowned draft can be finalized.
        canAutoFreeze_: true,
        unfinalizedDrafts_: 0
      };
    }
    function usePatchesInScope(scope2, patchListener) {
      if (patchListener) {
        getPlugin("Patches");
        scope2.patches_ = [];
        scope2.inversePatches_ = [];
        scope2.patchListener_ = patchListener;
      }
    }
    function revokeScope(scope2) {
      leaveScope(scope2);
      scope2.drafts_.forEach(revokeDraft);
      scope2.drafts_ = null;
    }
    function leaveScope(scope2) {
      if (scope2 === currentScope) {
        currentScope = scope2.parent_;
      }
    }
    function enterScope(immer2) {
      return currentScope = createScope(currentScope, immer2);
    }
    function revokeDraft(draft) {
      const state = draft[DRAFT_STATE];
      if (state.type_ === 0 || state.type_ === 1)
        state.revoke_();
      else
        state.revoked_ = true;
    }
    function processResult(result, scope2) {
      scope2.unfinalizedDrafts_ = scope2.drafts_.length;
      const baseDraft = scope2.drafts_[0];
      const isReplaced = result !== void 0 && result !== baseDraft;
      if (isReplaced) {
        if (baseDraft[DRAFT_STATE].modified_) {
          revokeScope(scope2);
          die(4);
        }
        if (isDraftable(result)) {
          result = finalize(scope2, result);
          if (!scope2.parent_)
            maybeFreeze(scope2, result);
        }
        if (scope2.patches_) {
          getPlugin("Patches").generateReplacementPatches_(
            baseDraft[DRAFT_STATE].base_,
            result,
            scope2.patches_,
            scope2.inversePatches_
          );
        }
      } else {
        result = finalize(scope2, baseDraft, []);
      }
      revokeScope(scope2);
      if (scope2.patches_) {
        scope2.patchListener_(scope2.patches_, scope2.inversePatches_);
      }
      return result !== NOTHING ? result : void 0;
    }
    function finalize(rootScope, value2, path2) {
      if (isFrozen(value2))
        return value2;
      const state = value2[DRAFT_STATE];
      if (!state) {
        each(
          value2,
          (key2, childValue) => finalizeProperty(rootScope, state, value2, key2, childValue, path2)
        );
        return value2;
      }
      if (state.scope_ !== rootScope)
        return value2;
      if (!state.modified_) {
        maybeFreeze(rootScope, state.base_, true);
        return state.base_;
      }
      if (!state.finalized_) {
        state.finalized_ = true;
        state.scope_.unfinalizedDrafts_--;
        const result = state.copy_;
        let resultEach = result;
        let isSet2 = false;
        if (state.type_ === 3) {
          resultEach = new Set(result);
          result.clear();
          isSet2 = true;
        }
        each(
          resultEach,
          (key2, childValue) => finalizeProperty(rootScope, state, result, key2, childValue, path2, isSet2)
        );
        maybeFreeze(rootScope, result, false);
        if (path2 && rootScope.patches_) {
          getPlugin("Patches").generatePatches_(
            state,
            path2,
            rootScope.patches_,
            rootScope.inversePatches_
          );
        }
      }
      return state.copy_;
    }
    function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
      if (isDraft(childValue)) {
        const path2 = rootPath && parentState && parentState.type_ !== 3 && // Set objects are atomic since they have no keys.
        !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
        const res = finalize(rootScope, childValue, path2);
        set(targetObject, prop, res);
        if (isDraft(res)) {
          rootScope.canAutoFreeze_ = false;
        } else
          return;
      } else if (targetIsSet) {
        targetObject.add(childValue);
      }
      if (isDraftable(childValue) && !isFrozen(childValue)) {
        if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
          return;
        }
        finalize(rootScope, childValue);
        if ((!parentState || !parentState.scope_.parent_) && typeof prop !== "symbol" && Object.prototype.propertyIsEnumerable.call(targetObject, prop))
          maybeFreeze(rootScope, childValue);
      }
    }
    function maybeFreeze(scope2, value2, deep = false) {
      if (!scope2.parent_ && scope2.immer_.autoFreeze_ && scope2.canAutoFreeze_) {
        freeze(value2, deep);
      }
    }
    function createProxyProxy(base, parent2) {
      const isArray2 = Array.isArray(base);
      const state = {
        type_: isArray2 ? 1 : 0,
        // Track which produce call this is associated with.
        scope_: parent2 ? parent2.scope_ : getCurrentScope(),
        // True for both shallow and deep changes.
        modified_: false,
        // Used during finalization.
        finalized_: false,
        // Track which properties have been assigned (true) or deleted (false).
        assigned_: {},
        // The parent draft state.
        parent_: parent2,
        // The base state.
        base_: base,
        // The base proxy.
        draft_: null,
        // set below
        // The base copy with any updated values.
        copy_: null,
        // Called by the `produce` function.
        revoke_: null,
        isManual_: false
      };
      let target = state;
      let traps = objectTraps;
      if (isArray2) {
        target = [state];
        traps = arrayTraps;
      }
      const { revoke, proxy } = Proxy.revocable(target, traps);
      state.draft_ = proxy;
      state.revoke_ = revoke;
      return proxy;
    }
    var objectTraps = {
      get(state, prop) {
        if (prop === DRAFT_STATE)
          return state;
        const source = latest(state);
        if (!has(source, prop)) {
          return readPropFromProto(state, source, prop);
        }
        const value2 = source[prop];
        if (state.finalized_ || !isDraftable(value2)) {
          return value2;
        }
        if (value2 === peek(state.base_, prop)) {
          prepareCopy(state);
          return state.copy_[prop] = createProxy(value2, state);
        }
        return value2;
      },
      has(state, prop) {
        return prop in latest(state);
      },
      ownKeys(state) {
        return Reflect.ownKeys(latest(state));
      },
      set(state, prop, value2) {
        const desc = getDescriptorFromProto(latest(state), prop);
        if (desc?.set) {
          desc.set.call(state.draft_, value2);
          return true;
        }
        if (!state.modified_) {
          const current2 = peek(latest(state), prop);
          const currentState = current2?.[DRAFT_STATE];
          if (currentState && currentState.base_ === value2) {
            state.copy_[prop] = value2;
            state.assigned_[prop] = false;
            return true;
          }
          if (is(value2, current2) && (value2 !== void 0 || has(state.base_, prop)))
            return true;
          prepareCopy(state);
          markChanged(state);
        }
        if (state.copy_[prop] === value2 && // special case: handle new props with value 'undefined'
        (value2 !== void 0 || prop in state.copy_) || // special case: NaN
        Number.isNaN(value2) && Number.isNaN(state.copy_[prop]))
          return true;
        state.copy_[prop] = value2;
        state.assigned_[prop] = true;
        return true;
      },
      deleteProperty(state, prop) {
        if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
          state.assigned_[prop] = false;
          prepareCopy(state);
          markChanged(state);
        } else {
          delete state.assigned_[prop];
        }
        if (state.copy_) {
          delete state.copy_[prop];
        }
        return true;
      },
      // Note: We never coerce `desc.value` into an Immer draft, because we can't make
      // the same guarantee in ES5 mode.
      getOwnPropertyDescriptor(state, prop) {
        const owner = latest(state);
        const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
        if (!desc)
          return desc;
        return {
          writable: true,
          configurable: state.type_ !== 1 || prop !== "length",
          enumerable: desc.enumerable,
          value: owner[prop]
        };
      },
      defineProperty() {
        die(11);
      },
      getPrototypeOf(state) {
        return getPrototypeOf(state.base_);
      },
      setPrototypeOf() {
        die(12);
      }
    };
    var arrayTraps = {};
    each(objectTraps, (key2, fn) => {
      arrayTraps[key2] = function() {
        arguments[0] = arguments[0][0];
        return fn.apply(this, arguments);
      };
    });
    arrayTraps.deleteProperty = function(state, prop) {
      return arrayTraps.set.call(this, state, prop, void 0);
    };
    arrayTraps.set = function(state, prop, value2) {
      return objectTraps.set.call(this, state[0], prop, value2, state[0]);
    };
    function peek(draft, prop) {
      const state = draft[DRAFT_STATE];
      const source = state ? latest(state) : draft;
      return source[prop];
    }
    function readPropFromProto(state, source, prop) {
      const desc = getDescriptorFromProto(source, prop);
      return desc ? `value` in desc ? desc.value : (
        // This is a very special case, if the prop is a getter defined by the
        // prototype, we should invoke it with the draft as context!
        desc.get?.call(state.draft_)
      ) : void 0;
    }
    function getDescriptorFromProto(source, prop) {
      if (!(prop in source))
        return void 0;
      let proto = getPrototypeOf(source);
      while (proto) {
        const desc = Object.getOwnPropertyDescriptor(proto, prop);
        if (desc)
          return desc;
        proto = getPrototypeOf(proto);
      }
      return void 0;
    }
    function markChanged(state) {
      if (!state.modified_) {
        state.modified_ = true;
        if (state.parent_) {
          markChanged(state.parent_);
        }
      }
    }
    function prepareCopy(state) {
      if (!state.copy_) {
        state.copy_ = shallowCopy(
          state.base_,
          state.scope_.immer_.useStrictShallowCopy_
        );
      }
    }
    var Immer2 = class {
      constructor(config) {
        this.autoFreeze_ = true;
        this.useStrictShallowCopy_ = false;
        this.produce = (base, recipe, patchListener) => {
          if (typeof base === "function" && typeof recipe !== "function") {
            const defaultBase = recipe;
            recipe = base;
            const self2 = this;
            return function curriedProduce(base2 = defaultBase, ...args) {
              return self2.produce(base2, (draft) => recipe.call(this, draft, ...args));
            };
          }
          if (typeof recipe !== "function")
            die(6);
          if (patchListener !== void 0 && typeof patchListener !== "function")
            die(7);
          let result;
          if (isDraftable(base)) {
            const scope2 = enterScope(this);
            const proxy = createProxy(base, void 0);
            let hasError = true;
            try {
              result = recipe(proxy);
              hasError = false;
            } finally {
              if (hasError)
                revokeScope(scope2);
              else
                leaveScope(scope2);
            }
            usePatchesInScope(scope2, patchListener);
            return processResult(result, scope2);
          } else if (!base || typeof base !== "object") {
            result = recipe(base);
            if (result === void 0)
              result = base;
            if (result === NOTHING)
              result = void 0;
            if (this.autoFreeze_)
              freeze(result, true);
            if (patchListener) {
              const p2 = [];
              const ip2 = [];
              getPlugin("Patches").generateReplacementPatches_(base, result, p2, ip2);
              patchListener(p2, ip2);
            }
            return result;
          } else
            die(1, base);
        };
        this.produceWithPatches = (base, recipe) => {
          if (typeof base === "function") {
            return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));
          }
          let patches, inversePatches;
          const result = this.produce(base, recipe, (p2, ip2) => {
            patches = p2;
            inversePatches = ip2;
          });
          return [result, patches, inversePatches];
        };
        if (typeof config?.autoFreeze === "boolean")
          this.setAutoFreeze(config.autoFreeze);
        if (typeof config?.useStrictShallowCopy === "boolean")
          this.setUseStrictShallowCopy(config.useStrictShallowCopy);
      }
      createDraft(base) {
        if (!isDraftable(base))
          die(8);
        if (isDraft(base))
          base = current(base);
        const scope2 = enterScope(this);
        const proxy = createProxy(base, void 0);
        proxy[DRAFT_STATE].isManual_ = true;
        leaveScope(scope2);
        return proxy;
      }
      finishDraft(draft, patchListener) {
        const state = draft && draft[DRAFT_STATE];
        if (!state || !state.isManual_)
          die(9);
        const { scope_: scope2 } = state;
        usePatchesInScope(scope2, patchListener);
        return processResult(void 0, scope2);
      }
      /**
       * Pass true to automatically freeze all copies created by Immer.
       *
       * By default, auto-freezing is enabled.
       */
      setAutoFreeze(value2) {
        this.autoFreeze_ = value2;
      }
      /**
       * Pass true to enable strict shallow copy.
       *
       * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
       */
      setUseStrictShallowCopy(value2) {
        this.useStrictShallowCopy_ = value2;
      }
      applyPatches(base, patches) {
        let i2;
        for (i2 = patches.length - 1; i2 >= 0; i2--) {
          const patch = patches[i2];
          if (patch.path.length === 0 && patch.op === "replace") {
            base = patch.value;
            break;
          }
        }
        if (i2 > -1) {
          patches = patches.slice(i2 + 1);
        }
        const applyPatchesImpl = getPlugin("Patches").applyPatches_;
        if (isDraft(base)) {
          return applyPatchesImpl(base, patches);
        }
        return this.produce(
          base,
          (draft) => applyPatchesImpl(draft, patches)
        );
      }
    };
    function createProxy(value2, parent2) {
      const draft = isMap(value2) ? getPlugin("MapSet").proxyMap_(value2, parent2) : isSet(value2) ? getPlugin("MapSet").proxySet_(value2, parent2) : createProxyProxy(value2, parent2);
      const scope2 = parent2 ? parent2.scope_ : getCurrentScope();
      scope2.drafts_.push(draft);
      return draft;
    }
    function current(value2) {
      if (!isDraft(value2))
        die(10, value2);
      return currentImpl(value2);
    }
    function currentImpl(value2) {
      if (!isDraftable(value2) || isFrozen(value2))
        return value2;
      const state = value2[DRAFT_STATE];
      let copy2;
      if (state) {
        if (!state.modified_)
          return state.base_;
        state.finalized_ = true;
        copy2 = shallowCopy(value2, state.scope_.immer_.useStrictShallowCopy_);
      } else {
        copy2 = shallowCopy(value2, true);
      }
      each(copy2, (key2, childValue) => {
        set(copy2, key2, currentImpl(childValue));
      });
      if (state) {
        state.finalized_ = false;
      }
      return copy2;
    }
    var immer = new Immer2();
    var produce = immer.produce;
    immer.produceWithPatches.bind(
      immer
    );
    immer.setAutoFreeze.bind(immer);
    immer.setUseStrictShallowCopy.bind(immer);
    immer.applyPatches.bind(immer);
    immer.createDraft.bind(immer);
    immer.finishDraft.bind(immer);
    function assertIsFunction(func, errorMessage = `expected a function, instead received ${typeof func}`) {
      if (typeof func !== "function") {
        throw new TypeError(errorMessage);
      }
    }
    function assertIsObject(object, errorMessage = `expected an object, instead received ${typeof object}`) {
      if (typeof object !== "object") {
        throw new TypeError(errorMessage);
      }
    }
    function assertIsArrayOfFunctions(array, errorMessage = `expected all items to be functions, instead received the following types: `) {
      if (!array.every((item) => typeof item === "function")) {
        const itemTypes = array.map(
          (item) => typeof item === "function" ? `function ${item.name || "unnamed"}()` : typeof item
        ).join(", ");
        throw new TypeError(`${errorMessage}[${itemTypes}]`);
      }
    }
    var ensureIsArray = (item) => {
      return Array.isArray(item) ? item : [item];
    };
    function getDependencies(createSelectorArgs) {
      const dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;
      assertIsArrayOfFunctions(
        dependencies,
        `createSelector expects all input-selectors to be functions, but received the following types: `
      );
      return dependencies;
    }
    function collectInputSelectorResults(dependencies, inputSelectorArgs) {
      const inputSelectorResults = [];
      const { length: length2 } = dependencies;
      for (let i2 = 0; i2 < length2; i2++) {
        inputSelectorResults.push(dependencies[i2].apply(null, inputSelectorArgs));
      }
      return inputSelectorResults;
    }
    var StrongRef = class {
      constructor(value2) {
        this.value = value2;
      }
      deref() {
        return this.value;
      }
    };
    var Ref = typeof WeakRef !== "undefined" ? WeakRef : StrongRef;
    var UNTERMINATED = 0;
    var TERMINATED = 1;
    function createCacheNode() {
      return {
        s: UNTERMINATED,
        v: void 0,
        o: null,
        p: null
      };
    }
    function weakMapMemoize(func, options = {}) {
      let fnNode = createCacheNode();
      const { resultEqualityCheck } = options;
      let lastResult;
      let resultsCount = 0;
      function memoized() {
        let cacheNode = fnNode;
        const { length: length2 } = arguments;
        for (let i2 = 0, l2 = length2; i2 < l2; i2++) {
          const arg = arguments[i2];
          if (typeof arg === "function" || typeof arg === "object" && arg !== null) {
            let objectCache = cacheNode.o;
            if (objectCache === null) {
              cacheNode.o = objectCache = /* @__PURE__ */ new WeakMap();
            }
            const objectNode = objectCache.get(arg);
            if (objectNode === void 0) {
              cacheNode = createCacheNode();
              objectCache.set(arg, cacheNode);
            } else {
              cacheNode = objectNode;
            }
          } else {
            let primitiveCache = cacheNode.p;
            if (primitiveCache === null) {
              cacheNode.p = primitiveCache = /* @__PURE__ */ new Map();
            }
            const primitiveNode = primitiveCache.get(arg);
            if (primitiveNode === void 0) {
              cacheNode = createCacheNode();
              primitiveCache.set(arg, cacheNode);
            } else {
              cacheNode = primitiveNode;
            }
          }
        }
        const terminatedNode = cacheNode;
        let result;
        if (cacheNode.s === TERMINATED) {
          result = cacheNode.v;
        } else {
          result = func.apply(null, arguments);
          resultsCount++;
        }
        terminatedNode.s = TERMINATED;
        if (resultEqualityCheck) {
          const lastResultValue = lastResult?.deref?.() ?? lastResult;
          if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {
            result = lastResultValue;
            resultsCount !== 0 && resultsCount--;
          }
          const needsWeakRef = typeof result === "object" && result !== null || typeof result === "function";
          lastResult = needsWeakRef ? new Ref(result) : result;
        }
        terminatedNode.v = result;
        return result;
      }
      memoized.clearCache = () => {
        fnNode = createCacheNode();
        memoized.resetResultsCount();
      };
      memoized.resultsCount = () => resultsCount;
      memoized.resetResultsCount = () => {
        resultsCount = 0;
      };
      return memoized;
    }
    function createSelectorCreator(memoizeOrOptions, ...memoizeOptionsFromArgs) {
      const createSelectorCreatorOptions = typeof memoizeOrOptions === "function" ? {
        memoize: memoizeOrOptions,
        memoizeOptions: memoizeOptionsFromArgs
      } : memoizeOrOptions;
      const createSelector2 = (...createSelectorArgs) => {
        let recomputations = 0;
        let dependencyRecomputations = 0;
        let lastResult;
        let directlyPassedOptions = {};
        let resultFunc = createSelectorArgs.pop();
        if (typeof resultFunc === "object") {
          directlyPassedOptions = resultFunc;
          resultFunc = createSelectorArgs.pop();
        }
        assertIsFunction(
          resultFunc,
          `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`
        );
        const combinedOptions = {
          ...createSelectorCreatorOptions,
          ...directlyPassedOptions
        };
        const {
          memoize: memoize2,
          memoizeOptions = [],
          argsMemoize = weakMapMemoize,
          argsMemoizeOptions = [],
          devModeChecks = {}
        } = combinedOptions;
        const finalMemoizeOptions = ensureIsArray(memoizeOptions);
        const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);
        const dependencies = getDependencies(createSelectorArgs);
        const memoizedResultFunc = memoize2(function recomputationWrapper() {
          recomputations++;
          return resultFunc.apply(
            null,
            arguments
          );
        }, ...finalMemoizeOptions);
        const selector = argsMemoize(function dependenciesChecker() {
          dependencyRecomputations++;
          const inputSelectorResults = collectInputSelectorResults(
            dependencies,
            arguments
          );
          lastResult = memoizedResultFunc.apply(null, inputSelectorResults);
          return lastResult;
        }, ...finalArgsMemoizeOptions);
        return Object.assign(selector, {
          resultFunc,
          memoizedResultFunc,
          dependencies,
          dependencyRecomputations: () => dependencyRecomputations,
          resetDependencyRecomputations: () => {
            dependencyRecomputations = 0;
          },
          lastResult: () => lastResult,
          recomputations: () => recomputations,
          resetRecomputations: () => {
            recomputations = 0;
          },
          memoize: memoize2,
          argsMemoize
        });
      };
      Object.assign(createSelector2, {
        withTypes: () => createSelector2
      });
      return createSelector2;
    }
    var createSelector = /* @__PURE__ */ createSelectorCreator(weakMapMemoize);
    var createStructuredSelector = Object.assign(
      (inputSelectorsObject, selectorCreator = createSelector) => {
        assertIsObject(
          inputSelectorsObject,
          `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof inputSelectorsObject}`
        );
        const inputSelectorKeys = Object.keys(inputSelectorsObject);
        const dependencies = inputSelectorKeys.map(
          (key2) => inputSelectorsObject[key2]
        );
        const structuredSelector = selectorCreator(
          dependencies,
          (...inputSelectorResults) => {
            return inputSelectorResults.reduce((composition, value2, index2) => {
              composition[inputSelectorKeys[index2]] = value2;
              return composition;
            }, {});
          }
        );
        return structuredSelector;
      },
      { withTypes: () => createStructuredSelector }
    );
    function createThunkMiddleware(extraArgument) {
      const middleware = ({ dispatch, getState }) => (next) => (action) => {
        if (typeof action === "function") {
          return action(dispatch, getState, extraArgument);
        }
        return next(action);
      };
      return middleware;
    }
    var thunk = createThunkMiddleware();
    var withExtraArgument = createThunkMiddleware;
    var createDraftSafeSelectorCreator = (...args) => {
      const createSelector2 = createSelectorCreator(...args);
      const createDraftSafeSelector2 = Object.assign((...args2) => {
        const selector = createSelector2(...args2);
        const wrappedSelector = (value2, ...rest) => selector(isDraft(value2) ? current(value2) : value2, ...rest);
        Object.assign(wrappedSelector, selector);
        return wrappedSelector;
      }, {
        withTypes: () => createDraftSafeSelector2
      });
      return createDraftSafeSelector2;
    };
    createDraftSafeSelectorCreator(weakMapMemoize);
    var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
      if (arguments.length === 0)
        return void 0;
      if (typeof arguments[0] === "object")
        return compose;
      return compose.apply(null, arguments);
    };
    function createAction(type, prepareAction) {
      function actionCreator(...args) {
        if (prepareAction) {
          let prepared = prepareAction(...args);
          if (!prepared) {
            throw new Error(formatProdErrorMessage(0));
          }
          return {
            type,
            payload: prepared.payload,
            ..."meta" in prepared && {
              meta: prepared.meta
            },
            ..."error" in prepared && {
              error: prepared.error
            }
          };
        }
        return {
          type,
          payload: args[0]
        };
      }
      actionCreator.toString = () => `${type}`;
      actionCreator.type = type;
      actionCreator.match = (action) => isAction(action) && action.type === type;
      return actionCreator;
    }
    var Tuple = class _Tuple extends Array {
      constructor(...items) {
        super(...items);
        Object.setPrototypeOf(this, _Tuple.prototype);
      }
      static get [Symbol.species]() {
        return _Tuple;
      }
      concat(...arr2) {
        return super.concat.apply(this, arr2);
      }
      prepend(...arr2) {
        if (arr2.length === 1 && Array.isArray(arr2[0])) {
          return new _Tuple(...arr2[0].concat(this));
        }
        return new _Tuple(...arr2.concat(this));
      }
    };
    function freezeDraftable(val2) {
      return isDraftable(val2) ? produce(val2, () => {
      }) : val2;
    }
    function emplace(map, key2, handler) {
      if (map.has(key2)) {
        let value2 = map.get(key2);
        if (handler.update) {
          value2 = handler.update(value2, key2, map);
          map.set(key2, value2);
        }
        return value2;
      }
      if (!handler.insert)
        throw new Error(formatProdErrorMessage(10));
      const inserted = handler.insert(key2, map);
      map.set(key2, inserted);
      return inserted;
    }
    function isBoolean(x2) {
      return typeof x2 === "boolean";
    }
    var buildGetDefaultMiddleware = () => function getDefaultMiddleware(options) {
      const {
        thunk: thunk$1 = true,
        immutableCheck = true,
        serializableCheck = true,
        actionCreatorCheck = true
      } = options ?? {};
      let middlewareArray = new Tuple();
      if (thunk$1) {
        if (isBoolean(thunk$1)) {
          middlewareArray.push(thunk);
        } else {
          middlewareArray.push(withExtraArgument(thunk$1.extraArgument));
        }
      }
      return middlewareArray;
    };
    var SHOULD_AUTOBATCH = "RTK_autoBatch";
    var createQueueWithTimer = (timeout) => {
      return (notify) => {
        setTimeout(notify, timeout);
      };
    };
    var rAF = typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame : createQueueWithTimer(10);
    var autoBatchEnhancer = (options = {
      type: "raf"
    }) => (next) => (...args) => {
      const store2 = next(...args);
      let notifying = true;
      let shouldNotifyAtEndOfTick = false;
      let notificationQueued = false;
      const listeners = /* @__PURE__ */ new Set();
      const queueCallback = options.type === "tick" ? queueMicrotask : options.type === "raf" ? rAF : options.type === "callback" ? options.queueNotification : createQueueWithTimer(options.timeout);
      const notifyListeners = () => {
        notificationQueued = false;
        if (shouldNotifyAtEndOfTick) {
          shouldNotifyAtEndOfTick = false;
          listeners.forEach((l2) => l2());
        }
      };
      return Object.assign({}, store2, {
        // Override the base `store.subscribe` method to keep original listeners
        // from running if we're delaying notifications
        subscribe(listener2) {
          const wrappedListener = () => notifying && listener2();
          const unsubscribe = store2.subscribe(wrappedListener);
          listeners.add(listener2);
          return () => {
            unsubscribe();
            listeners.delete(listener2);
          };
        },
        // Override the base `store.dispatch` method so that we can check actions
        // for the `shouldAutoBatch` flag and determine if batching is active
        dispatch(action) {
          try {
            notifying = !action?.meta?.[SHOULD_AUTOBATCH];
            shouldNotifyAtEndOfTick = !notifying;
            if (shouldNotifyAtEndOfTick) {
              if (!notificationQueued) {
                notificationQueued = true;
                queueCallback(notifyListeners);
              }
            }
            return store2.dispatch(action);
          } finally {
            notifying = true;
          }
        }
      });
    };
    var buildGetDefaultEnhancers = (middlewareEnhancer) => function getDefaultEnhancers(options) {
      const {
        autoBatch = true
      } = options ?? {};
      let enhancerArray = new Tuple(middlewareEnhancer);
      if (autoBatch) {
        enhancerArray.push(autoBatchEnhancer(typeof autoBatch === "object" ? autoBatch : void 0));
      }
      return enhancerArray;
    };
    var IS_PRODUCTION = true;
    function configureStore(options) {
      const getDefaultMiddleware = buildGetDefaultMiddleware();
      const {
        reducer = void 0,
        middleware,
        devTools = true,
        preloadedState = void 0,
        enhancers = void 0
      } = options || {};
      let rootReducer;
      if (typeof reducer === "function") {
        rootReducer = reducer;
      } else if (isPlainObject$1(reducer)) {
        rootReducer = combineReducers(reducer);
      } else {
        throw new Error(formatProdErrorMessage(1));
      }
      let finalMiddleware;
      if (typeof middleware === "function") {
        finalMiddleware = middleware(getDefaultMiddleware);
      } else {
        finalMiddleware = getDefaultMiddleware();
      }
      let finalCompose = compose;
      if (devTools) {
        finalCompose = composeWithDevTools({
          // Enable capture of stack traces for dispatched Redux actions
          trace: !IS_PRODUCTION,
          ...typeof devTools === "object" && devTools
        });
      }
      const middlewareEnhancer = applyMiddleware(...finalMiddleware);
      const getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);
      let storeEnhancers = typeof enhancers === "function" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();
      const composedEnhancer = finalCompose(...storeEnhancers);
      return createStore(rootReducer, preloadedState, composedEnhancer);
    }
    function executeReducerBuilderCallback(builderCallback) {
      const actionsMap = {};
      const actionMatchers = [];
      let defaultCaseReducer;
      const builder = {
        addCase(typeOrActionCreator, reducer) {
          const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
          if (!type) {
            throw new Error(formatProdErrorMessage(28));
          }
          if (type in actionsMap) {
            throw new Error(formatProdErrorMessage(29));
          }
          actionsMap[type] = reducer;
          return builder;
        },
        addMatcher(matcher, reducer) {
          actionMatchers.push({
            matcher,
            reducer
          });
          return builder;
        },
        addDefaultCase(reducer) {
          defaultCaseReducer = reducer;
          return builder;
        }
      };
      builderCallback(builder);
      return [actionsMap, actionMatchers, defaultCaseReducer];
    }
    function isStateFunction(x2) {
      return typeof x2 === "function";
    }
    function createReducer(initialState2, mapOrBuilderCallback) {
      let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = executeReducerBuilderCallback(mapOrBuilderCallback);
      let getInitialState;
      if (isStateFunction(initialState2)) {
        getInitialState = () => freezeDraftable(initialState2());
      } else {
        const frozenInitialState = freezeDraftable(initialState2);
        getInitialState = () => frozenInitialState;
      }
      function reducer(state = getInitialState(), action) {
        let caseReducers = [actionsMap[action.type], ...finalActionMatchers.filter(({
          matcher
        }) => matcher(action)).map(({
          reducer: reducer2
        }) => reducer2)];
        if (caseReducers.filter((cr) => !!cr).length === 0) {
          caseReducers = [finalDefaultCaseReducer];
        }
        return caseReducers.reduce((previousState, caseReducer) => {
          if (caseReducer) {
            if (isDraft(previousState)) {
              const draft = previousState;
              const result = caseReducer(draft, action);
              if (result === void 0) {
                return previousState;
              }
              return result;
            } else if (!isDraftable(previousState)) {
              const result = caseReducer(previousState, action);
              if (result === void 0) {
                if (previousState === null) {
                  return previousState;
                }
                throw new Error(formatProdErrorMessage(9));
              }
              return result;
            } else {
              return produce(previousState, (draft) => {
                return caseReducer(draft, action);
              });
            }
          }
          return previousState;
        }, state);
      }
      reducer.getInitialState = getInitialState;
      return reducer;
    }
    var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
    var nanoid = (size = 21) => {
      let id2 = "";
      let i2 = size;
      while (i2--) {
        id2 += urlAlphabet[Math.random() * 64 | 0];
      }
      return id2;
    };
    var asyncThunkSymbol = /* @__PURE__ */ Symbol.for("rtk-slice-createasyncthunk");
    function getType$1(slice2, actionKey) {
      return `${slice2}/${actionKey}`;
    }
    function buildCreateSlice({
      creators
    } = {}) {
      const cAT = creators?.asyncThunk?.[asyncThunkSymbol];
      return function createSlice2(options) {
        const {
          name: name2,
          reducerPath = name2
        } = options;
        if (!name2) {
          throw new Error(formatProdErrorMessage(11));
        }
        if (typeof process !== "undefined" && false) {
          if (options.initialState === void 0) {
            console.error("You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`");
          }
        }
        const reducers = (typeof options.reducers === "function" ? options.reducers(buildReducerCreators()) : options.reducers) || {};
        const reducerNames = Object.keys(reducers);
        const context = {
          sliceCaseReducersByName: {},
          sliceCaseReducersByType: {},
          actionCreators: {},
          sliceMatchers: []
        };
        const contextMethods = {
          addCase(typeOrActionCreator, reducer2) {
            const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
            if (!type) {
              throw new Error(formatProdErrorMessage(12));
            }
            if (type in context.sliceCaseReducersByType) {
              throw new Error(formatProdErrorMessage(13));
            }
            context.sliceCaseReducersByType[type] = reducer2;
            return contextMethods;
          },
          addMatcher(matcher, reducer2) {
            context.sliceMatchers.push({
              matcher,
              reducer: reducer2
            });
            return contextMethods;
          },
          exposeAction(name22, actionCreator) {
            context.actionCreators[name22] = actionCreator;
            return contextMethods;
          },
          exposeCaseReducer(name22, reducer2) {
            context.sliceCaseReducersByName[name22] = reducer2;
            return contextMethods;
          }
        };
        reducerNames.forEach((reducerName) => {
          const reducerDefinition = reducers[reducerName];
          const reducerDetails = {
            reducerName,
            type: getType$1(name2, reducerName),
            createNotation: typeof options.reducers === "function"
          };
          if (isAsyncThunkSliceReducerDefinition(reducerDefinition)) {
            handleThunkCaseReducerDefinition(reducerDetails, reducerDefinition, contextMethods, cAT);
          } else {
            handleNormalReducerDefinition(reducerDetails, reducerDefinition, contextMethods);
          }
        });
        function buildReducer() {
          const [extraReducers = {}, actionMatchers = [], defaultCaseReducer = void 0] = typeof options.extraReducers === "function" ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers];
          const finalCaseReducers = {
            ...extraReducers,
            ...context.sliceCaseReducersByType
          };
          return createReducer(options.initialState, (builder) => {
            for (let key2 in finalCaseReducers) {
              builder.addCase(key2, finalCaseReducers[key2]);
            }
            for (let sM of context.sliceMatchers) {
              builder.addMatcher(sM.matcher, sM.reducer);
            }
            for (let m2 of actionMatchers) {
              builder.addMatcher(m2.matcher, m2.reducer);
            }
            if (defaultCaseReducer) {
              builder.addDefaultCase(defaultCaseReducer);
            }
          });
        }
        const selectSelf = (state) => state;
        const injectedSelectorCache = /* @__PURE__ */ new Map();
        let _reducer;
        function reducer(state, action) {
          if (!_reducer)
            _reducer = buildReducer();
          return _reducer(state, action);
        }
        function getInitialState() {
          if (!_reducer)
            _reducer = buildReducer();
          return _reducer.getInitialState();
        }
        function makeSelectorProps(reducerPath2, injected = false) {
          function selectSlice(state) {
            let sliceState = state[reducerPath2];
            if (typeof sliceState === "undefined") {
              if (injected) {
                sliceState = getInitialState();
              }
            }
            return sliceState;
          }
          function getSelectors(selectState = selectSelf) {
            const selectorCache = emplace(injectedSelectorCache, injected, {
              insert: () => /* @__PURE__ */ new WeakMap()
            });
            return emplace(selectorCache, selectState, {
              insert: () => {
                const map = {};
                for (const [name22, selector] of Object.entries(options.selectors ?? {})) {
                  map[name22] = wrapSelector(selector, selectState, getInitialState, injected);
                }
                return map;
              }
            });
          }
          return {
            reducerPath: reducerPath2,
            getSelectors,
            get selectors() {
              return getSelectors(selectSlice);
            },
            selectSlice
          };
        }
        const slice2 = {
          name: name2,
          reducer,
          actions: context.actionCreators,
          caseReducers: context.sliceCaseReducersByName,
          getInitialState,
          ...makeSelectorProps(reducerPath),
          injectInto(injectable, {
            reducerPath: pathOpt,
            ...config
          } = {}) {
            const newReducerPath = pathOpt ?? reducerPath;
            injectable.inject({
              reducerPath: newReducerPath,
              reducer
            }, config);
            return {
              ...slice2,
              ...makeSelectorProps(newReducerPath, true)
            };
          }
        };
        return slice2;
      };
    }
    function wrapSelector(selector, selectState, getInitialState, injected) {
      function wrapper2(rootState, ...args) {
        let sliceState = selectState(rootState);
        if (typeof sliceState === "undefined") {
          if (injected) {
            sliceState = getInitialState();
          }
        }
        return selector(sliceState, ...args);
      }
      wrapper2.unwrapped = selector;
      return wrapper2;
    }
    var createSlice = /* @__PURE__ */ buildCreateSlice();
    function buildReducerCreators() {
      function asyncThunk(payloadCreator, config) {
        return {
          _reducerDefinitionType: "asyncThunk",
          payloadCreator,
          ...config
        };
      }
      asyncThunk.withTypes = () => asyncThunk;
      return {
        reducer(caseReducer) {
          return Object.assign({
            // hack so the wrapping function has the same name as the original
            // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original
            [caseReducer.name](...args) {
              return caseReducer(...args);
            }
          }[caseReducer.name], {
            _reducerDefinitionType: "reducer"
            /* reducer */
          });
        },
        preparedReducer(prepare, reducer) {
          return {
            _reducerDefinitionType: "reducerWithPrepare",
            prepare,
            reducer
          };
        },
        asyncThunk
      };
    }
    function handleNormalReducerDefinition({
      type,
      reducerName,
      createNotation
    }, maybeReducerWithPrepare, context) {
      let caseReducer;
      let prepareCallback;
      if ("reducer" in maybeReducerWithPrepare) {
        if (createNotation && !isCaseReducerWithPrepareDefinition(maybeReducerWithPrepare)) {
          throw new Error(formatProdErrorMessage(17));
        }
        caseReducer = maybeReducerWithPrepare.reducer;
        prepareCallback = maybeReducerWithPrepare.prepare;
      } else {
        caseReducer = maybeReducerWithPrepare;
      }
      context.addCase(type, caseReducer).exposeCaseReducer(reducerName, caseReducer).exposeAction(reducerName, prepareCallback ? createAction(type, prepareCallback) : createAction(type));
    }
    function isAsyncThunkSliceReducerDefinition(reducerDefinition) {
      return reducerDefinition._reducerDefinitionType === "asyncThunk";
    }
    function isCaseReducerWithPrepareDefinition(reducerDefinition) {
      return reducerDefinition._reducerDefinitionType === "reducerWithPrepare";
    }
    function handleThunkCaseReducerDefinition({
      type,
      reducerName
    }, reducerDefinition, context, cAT) {
      if (!cAT) {
        throw new Error(formatProdErrorMessage(18));
      }
      const {
        payloadCreator,
        fulfilled,
        pending,
        rejected,
        settled,
        options
      } = reducerDefinition;
      const thunk2 = cAT(type, payloadCreator, options);
      context.exposeAction(reducerName, thunk2);
      if (fulfilled) {
        context.addCase(thunk2.fulfilled, fulfilled);
      }
      if (pending) {
        context.addCase(thunk2.pending, pending);
      }
      if (rejected) {
        context.addCase(thunk2.rejected, rejected);
      }
      if (settled) {
        context.addMatcher(thunk2.settled, settled);
      }
      context.exposeCaseReducer(reducerName, {
        fulfilled: fulfilled || noop,
        pending: pending || noop,
        rejected: rejected || noop,
        settled: settled || noop
      });
    }
    function noop() {
    }
    var assertFunction = (func, expected) => {
      if (typeof func !== "function") {
        throw new Error(formatProdErrorMessage(32));
      }
    };
    var alm = "listenerMiddleware";
    var getListenerEntryPropsFrom = (options) => {
      let {
        type,
        actionCreator,
        matcher,
        predicate,
        effect: effect2
      } = options;
      if (type) {
        predicate = createAction(type).match;
      } else if (actionCreator) {
        type = actionCreator.type;
        predicate = actionCreator.match;
      } else if (matcher) {
        predicate = matcher;
      } else if (predicate)
        ;
      else {
        throw new Error(formatProdErrorMessage(21));
      }
      assertFunction(effect2);
      return {
        predicate,
        type,
        effect: effect2
      };
    };
    var createListenerEntry = Object.assign((options) => {
      const {
        type,
        predicate,
        effect: effect2
      } = getListenerEntryPropsFrom(options);
      const id2 = nanoid();
      const entry = {
        id: id2,
        effect: effect2,
        type,
        predicate,
        pending: /* @__PURE__ */ new Set(),
        unsubscribe: () => {
          throw new Error(formatProdErrorMessage(22));
        }
      };
      return entry;
    }, {
      withTypes: () => createListenerEntry
    });
    var addListener = Object.assign(createAction(`${alm}/add`), {
      withTypes: () => addListener
    });
    createAction(`${alm}/removeAll`);
    var removeListener = Object.assign(createAction(`${alm}/remove`), {
      withTypes: () => removeListener
    });
    function formatProdErrorMessage(code) {
      return `Minified Redux Toolkit error #${code}; visit https://redux-toolkit.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;
    }
    const initialState$7 = {
      value: ""
    };
    const searchSlice = createSlice({
      name: "search",
      initialState: initialState$7,
      reducers: {
        setSearch: (state, action) => {
          state.value = action.payload;
        },
        clearSearch: (state) => {
          state.value = "";
        }
      }
    });
    const { setSearch, clearSearch } = searchSlice.actions;
    const initialState$6 = {
      value: []
    };
    const librarySlice = createSlice({
      name: "library",
      initialState: initialState$6,
      reducers: {
        setLibrary: (state, action) => {
          state.value = action.payload;
        }
      }
    });
    const { setLibrary } = librarySlice.actions;
    const initialState$5 = {
      value: null
    };
    const userPreferencesSlice = createSlice({
      name: "userPreferences",
      initialState: initialState$5,
      reducers: {
        setUserPreferences: (state, action) => {
          state.value = action.payload;
        }
      }
    });
    const { setUserPreferences } = userPreferencesSlice.actions;
    const initialState$4 = {
      lastPacket: null,
      gameId: null,
      gamesWithDeletionInProgress: []
    };
    const downloadSlice = createSlice({
      name: "download",
      initialState: initialState$4,
      reducers: {
        setLastPacket: (state, action) => {
          state.lastPacket = action.payload;
          if (!state.gameId)
            state.gameId = action.payload.game.id;
        },
        clearDownload: (state) => {
          state.lastPacket = null;
          state.gameId = null;
        },
        setGameDeleting: (state, action) => {
          if (!state.gamesWithDeletionInProgress.includes(action.payload) && action.payload) {
            state.gamesWithDeletionInProgress.push(action.payload);
          }
        },
        removeGameFromDeleting: (state, action) => {
          const index2 = state.gamesWithDeletionInProgress.indexOf(action.payload);
          if (index2 >= 0)
            state.gamesWithDeletionInProgress.splice(index2, 1);
        }
      }
    });
    const {
      setLastPacket,
      clearDownload,
      setGameDeleting,
      removeGameFromDeleting
    } = downloadSlice.actions;
    const initialState$3 = {
      draggingDisabled: false,
      headerTitle: ""
    };
    const windowSlice = createSlice({
      name: "window",
      initialState: initialState$3,
      reducers: {
        toggleDraggingDisabled: (state, action) => {
          state.draggingDisabled = action.payload;
        },
        setHeaderTitle: (state, action) => {
          state.headerTitle = action.payload;
        }
      }
    });
    const { toggleDraggingDisabled, setHeaderTitle } = windowSlice.actions;
    const initialState$2 = {
      message: "",
      type: "success",
      visible: false
    };
    const toastSlice = createSlice({
      name: "toast",
      initialState: initialState$2,
      reducers: {
        showToast: (state, action) => {
          state.message = action.payload.message;
          state.type = action.payload.type;
          state.visible = true;
        },
        closeToast: (state) => {
          state.visible = false;
        }
      }
    });
    const { showToast, closeToast } = toastSlice.actions;
    const initialState$1 = {
      userDetails: null,
      profileBackground: null
    };
    const userDetailsSlice = createSlice({
      name: "user-details",
      initialState: initialState$1,
      reducers: {
        setUserDetails: (state, action) => {
          state.userDetails = action.payload;
        },
        setProfileBackground: (state, action) => {
          state.profileBackground = action.payload;
        }
      }
    });
    const { setUserDetails, setProfileBackground } = userDetailsSlice.actions;
    const initialState = {
      gameRunning: null
    };
    const gameRunningSlice = createSlice({
      name: "running-game",
      initialState,
      reducers: {
        setGameRunning: (state, action) => {
          state.gameRunning = action.payload;
        }
      }
    });
    const { setGameRunning } = gameRunningSlice.actions;
    function useLibrary() {
      const dispatch = useAppDispatch();
      const library = useAppSelector((state) => state.library.value);
      const updateLibrary = reactExports.useCallback(async () => {
        return window.electron.getLibrary().then((updatedLibrary) => dispatch(setLibrary(updatedLibrary)));
      }, [dispatch]);
      return { library, updateLibrary };
    }
    function declension$2(scheme, count) {
      if (scheme.one !== void 0 && count === 1) {
        return scheme.one;
      }
      const rem10 = count % 10;
      const rem100 = count % 100;
      if (rem10 === 1 && rem100 !== 11) {
        return scheme.singularNominative.replace("{{count}}", String(count));
      } else if (rem10 >= 2 && rem10 <= 4 && (rem100 < 10 || rem100 > 20)) {
        return scheme.singularGenitive.replace("{{count}}", String(count));
      } else {
        return scheme.pluralGenitive.replace("{{count}}", String(count));
      }
    }
    function buildLocalizeTokenFn$1(scheme) {
      return (count, options) => {
        if (options && options.addSuffix) {
          if (options.comparison && options.comparison > 0) {
            if (scheme.future) {
              return declension$2(scheme.future, count);
            } else {
              return "праз " + declension$2(scheme.regular, count);
            }
          } else {
            if (scheme.past) {
              return declension$2(scheme.past, count);
            } else {
              return declension$2(scheme.regular, count) + " таму";
            }
          }
        } else {
          return declension$2(scheme.regular, count);
        }
      };
    }
    const halfAMinute = (_, options) => {
      if (options && options.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return "праз паўхвіліны";
        } else {
          return "паўхвіліны таму";
        }
      }
      return "паўхвіліны";
    };
    const formatDistanceLocale$9 = {
      lessThanXSeconds: buildLocalizeTokenFn$1({
        regular: {
          one: "менш за секунду",
          singularNominative: "менш за {{count}} секунду",
          singularGenitive: "менш за {{count}} секунды",
          pluralGenitive: "менш за {{count}} секунд"
        },
        future: {
          one: "менш, чым праз секунду",
          singularNominative: "менш, чым праз {{count}} секунду",
          singularGenitive: "менш, чым праз {{count}} секунды",
          pluralGenitive: "менш, чым праз {{count}} секунд"
        }
      }),
      xSeconds: buildLocalizeTokenFn$1({
        regular: {
          singularNominative: "{{count}} секунда",
          singularGenitive: "{{count}} секунды",
          pluralGenitive: "{{count}} секунд"
        },
        past: {
          singularNominative: "{{count}} секунду таму",
          singularGenitive: "{{count}} секунды таму",
          pluralGenitive: "{{count}} секунд таму"
        },
        future: {
          singularNominative: "праз {{count}} секунду",
          singularGenitive: "праз {{count}} секунды",
          pluralGenitive: "праз {{count}} секунд"
        }
      }),
      halfAMinute,
      lessThanXMinutes: buildLocalizeTokenFn$1({
        regular: {
          one: "менш за хвіліну",
          singularNominative: "менш за {{count}} хвіліну",
          singularGenitive: "менш за {{count}} хвіліны",
          pluralGenitive: "менш за {{count}} хвілін"
        },
        future: {
          one: "менш, чым праз хвіліну",
          singularNominative: "менш, чым праз {{count}} хвіліну",
          singularGenitive: "менш, чым праз {{count}} хвіліны",
          pluralGenitive: "менш, чым праз {{count}} хвілін"
        }
      }),
      xMinutes: buildLocalizeTokenFn$1({
        regular: {
          singularNominative: "{{count}} хвіліна",
          singularGenitive: "{{count}} хвіліны",
          pluralGenitive: "{{count}} хвілін"
        },
        past: {
          singularNominative: "{{count}} хвіліну таму",
          singularGenitive: "{{count}} хвіліны таму",
          pluralGenitive: "{{count}} хвілін таму"
        },
        future: {
          singularNominative: "праз {{count}} хвіліну",
          singularGenitive: "праз {{count}} хвіліны",
          pluralGenitive: "праз {{count}} хвілін"
        }
      }),
      aboutXHours: buildLocalizeTokenFn$1({
        regular: {
          singularNominative: "каля {{count}} гадзіны",
          singularGenitive: "каля {{count}} гадзін",
          pluralGenitive: "каля {{count}} гадзін"
        },
        future: {
          singularNominative: "прыблізна праз {{count}} гадзіну",
          singularGenitive: "прыблізна праз {{count}} гадзіны",
          pluralGenitive: "прыблізна праз {{count}} гадзін"
        }
      }),
      xHours: buildLocalizeTokenFn$1({
        regular: {
          singularNominative: "{{count}} гадзіна",
          singularGenitive: "{{count}} гадзіны",
          pluralGenitive: "{{count}} гадзін"
        },
        past: {
          singularNominative: "{{count}} гадзіну таму",
          singularGenitive: "{{count}} гадзіны таму",
          pluralGenitive: "{{count}} гадзін таму"
        },
        future: {
          singularNominative: "праз {{count}} гадзіну",
          singularGenitive: "праз {{count}} гадзіны",
          pluralGenitive: "праз {{count}} гадзін"
        }
      }),
      xDays: buildLocalizeTokenFn$1({
        regular: {
          singularNominative: "{{count}} дзень",
          singularGenitive: "{{count}} дні",
          pluralGenitive: "{{count}} дзён"
        }
      }),
      aboutXWeeks: buildLocalizeTokenFn$1({
        regular: {
          singularNominative: "каля {{count}} тыдні",
          singularGenitive: "каля {{count}} тыдняў",
          pluralGenitive: "каля {{count}} тыдняў"
        },
        future: {
          singularNominative: "прыблізна праз {{count}} тыдзень",
          singularGenitive: "прыблізна праз {{count}} тыдні",
          pluralGenitive: "прыблізна праз {{count}} тыдняў"
        }
      }),
      xWeeks: buildLocalizeTokenFn$1({
        regular: {
          singularNominative: "{{count}} тыдзень",
          singularGenitive: "{{count}} тыдні",
          pluralGenitive: "{{count}} тыдняў"
        }
      }),
      aboutXMonths: buildLocalizeTokenFn$1({
        regular: {
          singularNominative: "каля {{count}} месяца",
          singularGenitive: "каля {{count}} месяцаў",
          pluralGenitive: "каля {{count}} месяцаў"
        },
        future: {
          singularNominative: "прыблізна праз {{count}} месяц",
          singularGenitive: "прыблізна праз {{count}} месяцы",
          pluralGenitive: "прыблізна праз {{count}} месяцаў"
        }
      }),
      xMonths: buildLocalizeTokenFn$1({
        regular: {
          singularNominative: "{{count}} месяц",
          singularGenitive: "{{count}} месяцы",
          pluralGenitive: "{{count}} месяцаў"
        }
      }),
      aboutXYears: buildLocalizeTokenFn$1({
        regular: {
          singularNominative: "каля {{count}} года",
          singularGenitive: "каля {{count}} гадоў",
          pluralGenitive: "каля {{count}} гадоў"
        },
        future: {
          singularNominative: "прыблізна праз {{count}} год",
          singularGenitive: "прыблізна праз {{count}} гады",
          pluralGenitive: "прыблізна праз {{count}} гадоў"
        }
      }),
      xYears: buildLocalizeTokenFn$1({
        regular: {
          singularNominative: "{{count}} год",
          singularGenitive: "{{count}} гады",
          pluralGenitive: "{{count}} гадоў"
        }
      }),
      overXYears: buildLocalizeTokenFn$1({
        regular: {
          singularNominative: "больш за {{count}} год",
          singularGenitive: "больш за {{count}} гады",
          pluralGenitive: "больш за {{count}} гадоў"
        },
        future: {
          singularNominative: "больш, чым праз {{count}} год",
          singularGenitive: "больш, чым праз {{count}} гады",
          pluralGenitive: "больш, чым праз {{count}} гадоў"
        }
      }),
      almostXYears: buildLocalizeTokenFn$1({
        regular: {
          singularNominative: "амаль {{count}} год",
          singularGenitive: "амаль {{count}} гады",
          pluralGenitive: "амаль {{count}} гадоў"
        },
        future: {
          singularNominative: "амаль праз {{count}} год",
          singularGenitive: "амаль праз {{count}} гады",
          pluralGenitive: "амаль праз {{count}} гадоў"
        }
      })
    };
    const formatDistance$a = (token, count, options) => {
      options = options || {};
      return formatDistanceLocale$9[token](count, options);
    };
    const dateFormats$a = {
      full: "EEEE, d MMMM y 'г.'",
      long: "d MMMM y 'г.'",
      medium: "d MMM y 'г.'",
      short: "dd.MM.y"
    };
    const timeFormats$a = {
      full: "H:mm:ss zzzz",
      long: "H:mm:ss z",
      medium: "H:mm:ss",
      short: "H:mm"
    };
    const dateTimeFormats$a = {
      any: "{{date}}, {{time}}"
    };
    const formatLong$a = {
      date: buildFormatLongFn({
        formats: dateFormats$a,
        defaultWidth: "full"
      }),
      time: buildFormatLongFn({
        formats: timeFormats$a,
        defaultWidth: "full"
      }),
      dateTime: buildFormatLongFn({
        formats: dateTimeFormats$a,
        defaultWidth: "any"
      })
    };
    const accusativeWeekdays$2 = [
      "нядзелю",
      "панядзелак",
      "аўторак",
      "сераду",
      "чацвер",
      "пятніцу",
      "суботу"
    ];
    function lastWeek$2(day) {
      const weekday = accusativeWeekdays$2[day];
      switch (day) {
        case 0:
        case 3:
        case 5:
        case 6:
          return "'у мінулую " + weekday + " а' p";
        case 1:
        case 2:
        case 4:
          return "'у мінулы " + weekday + " а' p";
      }
    }
    function thisWeek$2(day) {
      const weekday = accusativeWeekdays$2[day];
      return "'у " + weekday + " а' p";
    }
    function nextWeek$2(day) {
      const weekday = accusativeWeekdays$2[day];
      switch (day) {
        case 0:
        case 3:
        case 5:
        case 6:
          return "'у наступную " + weekday + " а' p";
        case 1:
        case 2:
        case 4:
          return "'у наступны " + weekday + " а' p";
      }
    }
    const lastWeekFormat = (dirtyDate, baseDate, options) => {
      const date = toDate(dirtyDate);
      const day = date.getDay();
      if (isSameWeek(date, baseDate, options)) {
        return thisWeek$2(day);
      } else {
        return lastWeek$2(day);
      }
    };
    const nextWeekFormat = (dirtyDate, baseDate, options) => {
      const date = toDate(dirtyDate);
      const day = date.getDay();
      if (isSameWeek(date, baseDate, options)) {
        return thisWeek$2(day);
      } else {
        return nextWeek$2(day);
      }
    };
    const formatRelativeLocale$a = {
      lastWeek: lastWeekFormat,
      yesterday: "'учора а' p",
      today: "'сёння а' p",
      tomorrow: "'заўтра а' p",
      nextWeek: nextWeekFormat,
      other: "P"
    };
    const formatRelative$a = (token, date, baseDate, options) => {
      const format2 = formatRelativeLocale$a[token];
      if (typeof format2 === "function") {
        return format2(date, baseDate, options);
      }
      return format2;
    };
    const eraValues$a = {
      narrow: ["да н.э.", "н.э."],
      abbreviated: ["да н. э.", "н. э."],
      wide: ["да нашай эры", "нашай эры"]
    };
    const quarterValues$a = {
      narrow: ["1", "2", "3", "4"],
      abbreviated: ["1-ы кв.", "2-і кв.", "3-і кв.", "4-ы кв."],
      wide: ["1-ы квартал", "2-і квартал", "3-і квартал", "4-ы квартал"]
    };
    const monthValues$a = {
      narrow: ["С", "Л", "С", "К", "М", "Ч", "Л", "Ж", "В", "К", "Л", "С"],
      abbreviated: [
        "студз.",
        "лют.",
        "сак.",
        "крас.",
        "май",
        "чэрв.",
        "ліп.",
        "жн.",
        "вер.",
        "кастр.",
        "ліст.",
        "снеж."
      ],
      wide: [
        "студзень",
        "люты",
        "сакавік",
        "красавік",
        "май",
        "чэрвень",
        "ліпень",
        "жнівень",
        "верасень",
        "кастрычнік",
        "лістапад",
        "снежань"
      ]
    };
    const formattingMonthValues$1 = {
      narrow: ["С", "Л", "С", "К", "М", "Ч", "Л", "Ж", "В", "К", "Л", "С"],
      abbreviated: [
        "студз.",
        "лют.",
        "сак.",
        "крас.",
        "мая",
        "чэрв.",
        "ліп.",
        "жн.",
        "вер.",
        "кастр.",
        "ліст.",
        "снеж."
      ],
      wide: [
        "студзеня",
        "лютага",
        "сакавіка",
        "красавіка",
        "мая",
        "чэрвеня",
        "ліпеня",
        "жніўня",
        "верасня",
        "кастрычніка",
        "лістапада",
        "снежня"
      ]
    };
    const dayValues$a = {
      narrow: ["Н", "П", "А", "С", "Ч", "П", "С"],
      short: ["нд", "пн", "аў", "ср", "чц", "пт", "сб"],
      abbreviated: ["нядз", "пан", "аўт", "сер", "чац", "пят", "суб"],
      wide: [
        "нядзеля",
        "панядзелак",
        "аўторак",
        "серада",
        "чацвер",
        "пятніца",
        "субота"
      ]
    };
    const dayPeriodValues$a = {
      narrow: {
        am: "ДП",
        pm: "ПП",
        midnight: "поўн.",
        noon: "поўд.",
        morning: "ран.",
        afternoon: "дзень",
        evening: "веч.",
        night: "ноч"
      },
      abbreviated: {
        am: "ДП",
        pm: "ПП",
        midnight: "поўн.",
        noon: "поўд.",
        morning: "ран.",
        afternoon: "дзень",
        evening: "веч.",
        night: "ноч"
      },
      wide: {
        am: "ДП",
        pm: "ПП",
        midnight: "поўнач",
        noon: "поўдзень",
        morning: "раніца",
        afternoon: "дзень",
        evening: "вечар",
        night: "ноч"
      }
    };
    const formattingDayPeriodValues$7 = {
      narrow: {
        am: "ДП",
        pm: "ПП",
        midnight: "поўн.",
        noon: "поўд.",
        morning: "ран.",
        afternoon: "дня",
        evening: "веч.",
        night: "ночы"
      },
      abbreviated: {
        am: "ДП",
        pm: "ПП",
        midnight: "поўн.",
        noon: "поўд.",
        morning: "ран.",
        afternoon: "дня",
        evening: "веч.",
        night: "ночы"
      },
      wide: {
        am: "ДП",
        pm: "ПП",
        midnight: "поўнач",
        noon: "поўдзень",
        morning: "раніцы",
        afternoon: "дня",
        evening: "вечара",
        night: "ночы"
      }
    };
    const ordinalNumber$a = (dirtyNumber, options) => {
      const unit = String(options?.unit);
      const number = Number(dirtyNumber);
      let suffix;
      if (unit === "date") {
        suffix = "-га";
      } else if (unit === "hour" || unit === "minute" || unit === "second") {
        suffix = "-я";
      } else {
        suffix = (number % 10 === 2 || number % 10 === 3) && number % 100 !== 12 && number % 100 !== 13 ? "-і" : "-ы";
      }
      return number + suffix;
    };
    const localize$a = {
      ordinalNumber: ordinalNumber$a,
      era: buildLocalizeFn({
        values: eraValues$a,
        defaultWidth: "wide"
      }),
      quarter: buildLocalizeFn({
        values: quarterValues$a,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
      }),
      month: buildLocalizeFn({
        values: monthValues$a,
        defaultWidth: "wide",
        formattingValues: formattingMonthValues$1,
        defaultFormattingWidth: "wide"
      }),
      day: buildLocalizeFn({
        values: dayValues$a,
        defaultWidth: "wide"
      }),
      dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$a,
        defaultWidth: "any",
        formattingValues: formattingDayPeriodValues$7,
        defaultFormattingWidth: "wide"
      })
    };
    const matchOrdinalNumberPattern$a = /^(\d+)(-?(е|я|га|і|ы|ае|ая|яя|шы|гі|ці|ты|мы))?/i;
    const parseOrdinalNumberPattern$a = /\d+/i;
    const matchEraPatterns$a = {
      narrow: /^((да )?н\.?\s?э\.?)/i,
      abbreviated: /^((да )?н\.?\s?э\.?)/i,
      wide: /^(да нашай эры|нашай эры|наша эра)/i
    };
    const parseEraPatterns$a = {
      any: [/^д/i, /^н/i]
    };
    const matchQuarterPatterns$a = {
      narrow: /^[1234]/i,
      abbreviated: /^[1234](-?[ыі]?)? кв.?/i,
      wide: /^[1234](-?[ыі]?)? квартал/i
    };
    const parseQuarterPatterns$a = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    const matchMonthPatterns$a = {
      narrow: /^[слкмчжв]/i,
      abbreviated: /^(студз|лют|сак|крас|ма[йя]|чэрв|ліп|жн|вер|кастр|ліст|снеж)\.?/i,
      wide: /^(студзен[ья]|лют(ы|ага)|сакавіка?|красавіка?|ма[йя]|чэрвен[ья]|ліпен[ья]|жні(вень|ўня)|верас(ень|ня)|кастрычніка?|лістапада?|снеж(ань|ня))/i
    };
    const parseMonthPatterns$a = {
      narrow: [
        /^с/i,
        /^л/i,
        /^с/i,
        /^к/i,
        /^м/i,
        /^ч/i,
        /^л/i,
        /^ж/i,
        /^в/i,
        /^к/i,
        /^л/i,
        /^с/i
      ],
      any: [
        /^ст/i,
        /^лю/i,
        /^са/i,
        /^кр/i,
        /^ма/i,
        /^ч/i,
        /^ліп/i,
        /^ж/i,
        /^в/i,
        /^ка/i,
        /^ліс/i,
        /^сн/i
      ]
    };
    const matchDayPatterns$a = {
      narrow: /^[нпасч]/i,
      short: /^(нд|ня|пн|па|аў|ат|ср|се|чц|ча|пт|пя|сб|су)\.?/i,
      abbreviated: /^(нядз?|ндз|пнд|пан|аўт|срд|сер|чцв|чац|птн|пят|суб).?/i,
      wide: /^(нядзел[яі]|панядзел(ак|ка)|аўтор(ак|ка)|серад[аы]|чацв(ер|ярга)|пятніц[аы]|субот[аы])/i
    };
    const parseDayPatterns$a = {
      narrow: [/^н/i, /^п/i, /^а/i, /^с/i, /^ч/i, /^п/i, /^с/i],
      any: [/^н/i, /^п[ан]/i, /^а/i, /^с[ер]/i, /^ч/i, /^п[ят]/i, /^с[уб]/i]
    };
    const matchDayPeriodPatterns$a = {
      narrow: /^([дп]п|поўн\.?|поўд\.?|ран\.?|дзень|дня|веч\.?|ночы?)/i,
      abbreviated: /^([дп]п|поўн\.?|поўд\.?|ран\.?|дзень|дня|веч\.?|ночы?)/i,
      wide: /^([дп]п|поўнач|поўдзень|раніц[аы]|дзень|дня|вечара?|ночы?)/i
    };
    const parseDayPeriodPatterns$a = {
      any: {
        am: /^дп/i,
        pm: /^пп/i,
        midnight: /^поўн/i,
        noon: /^поўд/i,
        morning: /^р/i,
        afternoon: /^д[зн]/i,
        evening: /^в/i,
        night: /^н/i
      }
    };
    const match$a = {
      ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$a,
        parsePattern: parseOrdinalNumberPattern$a,
        valueCallback: (value2) => parseInt(value2, 10)
      }),
      era: buildMatchFn({
        matchPatterns: matchEraPatterns$a,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$a,
        defaultParseWidth: "any"
      }),
      quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$a,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$a,
        defaultParseWidth: "any",
        valueCallback: (index2) => index2 + 1
      }),
      month: buildMatchFn({
        matchPatterns: matchMonthPatterns$a,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$a,
        defaultParseWidth: "any"
      }),
      day: buildMatchFn({
        matchPatterns: matchDayPatterns$a,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$a,
        defaultParseWidth: "any"
      }),
      dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$a,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPeriodPatterns$a,
        defaultParseWidth: "any"
      })
    };
    const be = {
      code: "be",
      formatDistance: formatDistance$a,
      formatLong: formatLong$a,
      formatRelative: formatRelative$a,
      localize: localize$a,
      match: match$a,
      options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 1
      }
    };
    const formatDistanceLocale$8 = {
      lessThanXSeconds: {
        one: "mindre end ét sekund",
        other: "mindre end {{count}} sekunder"
      },
      xSeconds: {
        one: "1 sekund",
        other: "{{count}} sekunder"
      },
      halfAMinute: "ét halvt minut",
      lessThanXMinutes: {
        one: "mindre end ét minut",
        other: "mindre end {{count}} minutter"
      },
      xMinutes: {
        one: "1 minut",
        other: "{{count}} minutter"
      },
      aboutXHours: {
        one: "cirka 1 time",
        other: "cirka {{count}} timer"
      },
      xHours: {
        one: "1 time",
        other: "{{count}} timer"
      },
      xDays: {
        one: "1 dag",
        other: "{{count}} dage"
      },
      aboutXWeeks: {
        one: "cirka 1 uge",
        other: "cirka {{count}} uger"
      },
      xWeeks: {
        one: "1 uge",
        other: "{{count}} uger"
      },
      aboutXMonths: {
        one: "cirka 1 måned",
        other: "cirka {{count}} måneder"
      },
      xMonths: {
        one: "1 måned",
        other: "{{count}} måneder"
      },
      aboutXYears: {
        one: "cirka 1 år",
        other: "cirka {{count}} år"
      },
      xYears: {
        one: "1 år",
        other: "{{count}} år"
      },
      overXYears: {
        one: "over 1 år",
        other: "over {{count}} år"
      },
      almostXYears: {
        one: "næsten 1 år",
        other: "næsten {{count}} år"
      }
    };
    const formatDistance$9 = (token, count, options) => {
      let result;
      const tokenValue = formatDistanceLocale$8[token];
      if (typeof tokenValue === "string") {
        result = tokenValue;
      } else if (count === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace("{{count}}", String(count));
      }
      if (options?.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return "om " + result;
        } else {
          return result + " siden";
        }
      }
      return result;
    };
    const dateFormats$9 = {
      full: "EEEE 'den' d. MMMM y",
      long: "d. MMMM y",
      medium: "d. MMM y",
      short: "dd/MM/y"
    };
    const timeFormats$9 = {
      full: "HH:mm:ss zzzz",
      long: "HH:mm:ss z",
      medium: "HH:mm:ss",
      short: "HH:mm"
    };
    const dateTimeFormats$9 = {
      full: "{{date}} 'kl'. {{time}}",
      long: "{{date}} 'kl'. {{time}}",
      medium: "{{date}} {{time}}",
      short: "{{date}} {{time}}"
    };
    const formatLong$9 = {
      date: buildFormatLongFn({
        formats: dateFormats$9,
        defaultWidth: "full"
      }),
      time: buildFormatLongFn({
        formats: timeFormats$9,
        defaultWidth: "full"
      }),
      dateTime: buildFormatLongFn({
        formats: dateTimeFormats$9,
        defaultWidth: "full"
      })
    };
    const formatRelativeLocale$9 = {
      lastWeek: "'sidste' eeee 'kl.' p",
      yesterday: "'i går kl.' p",
      today: "'i dag kl.' p",
      tomorrow: "'i morgen kl.' p",
      nextWeek: "'på' eeee 'kl.' p",
      other: "P"
    };
    const formatRelative$9 = (token, _date, _baseDate, _options) => formatRelativeLocale$9[token];
    const eraValues$9 = {
      narrow: ["fvt", "vt"],
      abbreviated: ["f.v.t.", "v.t."],
      wide: ["før vesterlandsk tidsregning", "vesterlandsk tidsregning"]
    };
    const quarterValues$9 = {
      narrow: ["1", "2", "3", "4"],
      abbreviated: ["1. kvt.", "2. kvt.", "3. kvt.", "4. kvt."],
      wide: ["1. kvartal", "2. kvartal", "3. kvartal", "4. kvartal"]
    };
    const monthValues$9 = {
      narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
      abbreviated: [
        "jan.",
        "feb.",
        "mar.",
        "apr.",
        "maj",
        "jun.",
        "jul.",
        "aug.",
        "sep.",
        "okt.",
        "nov.",
        "dec."
      ],
      wide: [
        "januar",
        "februar",
        "marts",
        "april",
        "maj",
        "juni",
        "juli",
        "august",
        "september",
        "oktober",
        "november",
        "december"
      ]
    };
    const dayValues$9 = {
      narrow: ["S", "M", "T", "O", "T", "F", "L"],
      short: ["sø", "ma", "ti", "on", "to", "fr", "lø"],
      abbreviated: ["søn.", "man.", "tir.", "ons.", "tor.", "fre.", "lør."],
      wide: [
        "søndag",
        "mandag",
        "tirsdag",
        "onsdag",
        "torsdag",
        "fredag",
        "lørdag"
      ]
    };
    const dayPeriodValues$9 = {
      narrow: {
        am: "a",
        pm: "p",
        midnight: "midnat",
        noon: "middag",
        morning: "morgen",
        afternoon: "eftermiddag",
        evening: "aften",
        night: "nat"
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnat",
        noon: "middag",
        morning: "morgen",
        afternoon: "eftermiddag",
        evening: "aften",
        night: "nat"
      },
      wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnat",
        noon: "middag",
        morning: "morgen",
        afternoon: "eftermiddag",
        evening: "aften",
        night: "nat"
      }
    };
    const formattingDayPeriodValues$6 = {
      narrow: {
        am: "a",
        pm: "p",
        midnight: "midnat",
        noon: "middag",
        morning: "om morgenen",
        afternoon: "om eftermiddagen",
        evening: "om aftenen",
        night: "om natten"
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnat",
        noon: "middag",
        morning: "om morgenen",
        afternoon: "om eftermiddagen",
        evening: "om aftenen",
        night: "om natten"
      },
      wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnat",
        noon: "middag",
        morning: "om morgenen",
        afternoon: "om eftermiddagen",
        evening: "om aftenen",
        night: "om natten"
      }
    };
    const ordinalNumber$9 = (dirtyNumber, _options) => {
      const number = Number(dirtyNumber);
      return number + ".";
    };
    const localize$9 = {
      ordinalNumber: ordinalNumber$9,
      era: buildLocalizeFn({
        values: eraValues$9,
        defaultWidth: "wide"
      }),
      quarter: buildLocalizeFn({
        values: quarterValues$9,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
      }),
      month: buildLocalizeFn({
        values: monthValues$9,
        defaultWidth: "wide"
      }),
      day: buildLocalizeFn({
        values: dayValues$9,
        defaultWidth: "wide"
      }),
      dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$9,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$6,
        defaultFormattingWidth: "wide"
      })
    };
    const matchOrdinalNumberPattern$9 = /^(\d+)(\.)?/i;
    const parseOrdinalNumberPattern$9 = /\d+/i;
    const matchEraPatterns$9 = {
      narrow: /^(fKr|fvt|eKr|vt)/i,
      abbreviated: /^(f\.Kr\.?|f\.v\.t\.?|e\.Kr\.?|v\.t\.)/i,
      wide: /^(f.Kr.|før vesterlandsk tidsregning|e.Kr.|vesterlandsk tidsregning)/i
    };
    const parseEraPatterns$9 = {
      any: [/^f/i, /^(v|e)/i]
    };
    const matchQuarterPatterns$9 = {
      narrow: /^[1234]/i,
      abbreviated: /^[1234]. kvt\./i,
      wide: /^[1234]\.? kvartal/i
    };
    const parseQuarterPatterns$9 = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    const matchMonthPatterns$9 = {
      narrow: /^[jfmasond]/i,
      abbreviated: /^(jan.|feb.|mar.|apr.|maj|jun.|jul.|aug.|sep.|okt.|nov.|dec.)/i,
      wide: /^(januar|februar|marts|april|maj|juni|juli|august|september|oktober|november|december)/i
    };
    const parseMonthPatterns$9 = {
      narrow: [
        /^j/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
      ],
      any: [
        /^ja/i,
        /^f/i,
        /^mar/i,
        /^ap/i,
        /^maj/i,
        /^jun/i,
        /^jul/i,
        /^au/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
      ]
    };
    const matchDayPatterns$9 = {
      narrow: /^[smtofl]/i,
      short: /^(søn.|man.|tir.|ons.|tor.|fre.|lør.)/i,
      abbreviated: /^(søn|man|tir|ons|tor|fre|lør)/i,
      wide: /^(søndag|mandag|tirsdag|onsdag|torsdag|fredag|lørdag)/i
    };
    const parseDayPatterns$9 = {
      narrow: [/^s/i, /^m/i, /^t/i, /^o/i, /^t/i, /^f/i, /^l/i],
      any: [/^s/i, /^m/i, /^ti/i, /^o/i, /^to/i, /^f/i, /^l/i]
    };
    const matchDayPeriodPatterns$9 = {
      narrow: /^(a|p|midnat|middag|(om) (morgenen|eftermiddagen|aftenen|natten))/i,
      any: /^([ap]\.?\s?m\.?|midnat|middag|(om) (morgenen|eftermiddagen|aftenen|natten))/i
    };
    const parseDayPeriodPatterns$9 = {
      any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /midnat/i,
        noon: /middag/i,
        morning: /morgen/i,
        afternoon: /eftermiddag/i,
        evening: /aften/i,
        night: /nat/i
      }
    };
    const match$9 = {
      ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$9,
        parsePattern: parseOrdinalNumberPattern$9,
        valueCallback: (value2) => parseInt(value2, 10)
      }),
      era: buildMatchFn({
        matchPatterns: matchEraPatterns$9,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$9,
        defaultParseWidth: "any"
      }),
      quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$9,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$9,
        defaultParseWidth: "any",
        valueCallback: (index2) => index2 + 1
      }),
      month: buildMatchFn({
        matchPatterns: matchMonthPatterns$9,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$9,
        defaultParseWidth: "any"
      }),
      day: buildMatchFn({
        matchPatterns: matchDayPatterns$9,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$9,
        defaultParseWidth: "any"
      }),
      dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$9,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$9,
        defaultParseWidth: "any"
      })
    };
    const da = {
      code: "da",
      formatDistance: formatDistance$9,
      formatLong: formatLong$9,
      formatRelative: formatRelative$9,
      localize: localize$9,
      match: match$9,
      options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
      }
    };
    const formatDistanceLocale$7 = {
      lessThanXSeconds: {
        one: "menos de un segundo",
        other: "menos de {{count}} segundos"
      },
      xSeconds: {
        one: "1 segundo",
        other: "{{count}} segundos"
      },
      halfAMinute: "medio minuto",
      lessThanXMinutes: {
        one: "menos de un minuto",
        other: "menos de {{count}} minutos"
      },
      xMinutes: {
        one: "1 minuto",
        other: "{{count}} minutos"
      },
      aboutXHours: {
        one: "alrededor de 1 hora",
        other: "alrededor de {{count}} horas"
      },
      xHours: {
        one: "1 hora",
        other: "{{count}} horas"
      },
      xDays: {
        one: "1 día",
        other: "{{count}} días"
      },
      aboutXWeeks: {
        one: "alrededor de 1 semana",
        other: "alrededor de {{count}} semanas"
      },
      xWeeks: {
        one: "1 semana",
        other: "{{count}} semanas"
      },
      aboutXMonths: {
        one: "alrededor de 1 mes",
        other: "alrededor de {{count}} meses"
      },
      xMonths: {
        one: "1 mes",
        other: "{{count}} meses"
      },
      aboutXYears: {
        one: "alrededor de 1 año",
        other: "alrededor de {{count}} años"
      },
      xYears: {
        one: "1 año",
        other: "{{count}} años"
      },
      overXYears: {
        one: "más de 1 año",
        other: "más de {{count}} años"
      },
      almostXYears: {
        one: "casi 1 año",
        other: "casi {{count}} años"
      }
    };
    const formatDistance$8 = (token, count, options) => {
      let result;
      const tokenValue = formatDistanceLocale$7[token];
      if (typeof tokenValue === "string") {
        result = tokenValue;
      } else if (count === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace("{{count}}", count.toString());
      }
      if (options?.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return "en " + result;
        } else {
          return "hace " + result;
        }
      }
      return result;
    };
    const dateFormats$8 = {
      full: "EEEE, d 'de' MMMM 'de' y",
      long: "d 'de' MMMM 'de' y",
      medium: "d MMM y",
      short: "dd/MM/y"
    };
    const timeFormats$8 = {
      full: "HH:mm:ss zzzz",
      long: "HH:mm:ss z",
      medium: "HH:mm:ss",
      short: "HH:mm"
    };
    const dateTimeFormats$8 = {
      full: "{{date}} 'a las' {{time}}",
      long: "{{date}} 'a las' {{time}}",
      medium: "{{date}}, {{time}}",
      short: "{{date}}, {{time}}"
    };
    const formatLong$8 = {
      date: buildFormatLongFn({
        formats: dateFormats$8,
        defaultWidth: "full"
      }),
      time: buildFormatLongFn({
        formats: timeFormats$8,
        defaultWidth: "full"
      }),
      dateTime: buildFormatLongFn({
        formats: dateTimeFormats$8,
        defaultWidth: "full"
      })
    };
    const formatRelativeLocale$8 = {
      lastWeek: "'el' eeee 'pasado a la' p",
      yesterday: "'ayer a la' p",
      today: "'hoy a la' p",
      tomorrow: "'mañana a la' p",
      nextWeek: "eeee 'a la' p",
      other: "P"
    };
    const formatRelativeLocalePlural = {
      lastWeek: "'el' eeee 'pasado a las' p",
      yesterday: "'ayer a las' p",
      today: "'hoy a las' p",
      tomorrow: "'mañana a las' p",
      nextWeek: "eeee 'a las' p",
      other: "P"
    };
    const formatRelative$8 = (token, date, _baseDate, _options) => {
      if (date.getHours() !== 1) {
        return formatRelativeLocalePlural[token];
      } else {
        return formatRelativeLocale$8[token];
      }
    };
    const eraValues$8 = {
      narrow: ["AC", "DC"],
      abbreviated: ["AC", "DC"],
      wide: ["antes de cristo", "después de cristo"]
    };
    const quarterValues$8 = {
      narrow: ["1", "2", "3", "4"],
      abbreviated: ["T1", "T2", "T3", "T4"],
      wide: ["1º trimestre", "2º trimestre", "3º trimestre", "4º trimestre"]
    };
    const monthValues$8 = {
      narrow: ["e", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
      abbreviated: [
        "ene",
        "feb",
        "mar",
        "abr",
        "may",
        "jun",
        "jul",
        "ago",
        "sep",
        "oct",
        "nov",
        "dic"
      ],
      wide: [
        "enero",
        "febrero",
        "marzo",
        "abril",
        "mayo",
        "junio",
        "julio",
        "agosto",
        "septiembre",
        "octubre",
        "noviembre",
        "diciembre"
      ]
    };
    const dayValues$8 = {
      narrow: ["d", "l", "m", "m", "j", "v", "s"],
      short: ["do", "lu", "ma", "mi", "ju", "vi", "sá"],
      abbreviated: ["dom", "lun", "mar", "mié", "jue", "vie", "sáb"],
      wide: [
        "domingo",
        "lunes",
        "martes",
        "miércoles",
        "jueves",
        "viernes",
        "sábado"
      ]
    };
    const dayPeriodValues$8 = {
      narrow: {
        am: "a",
        pm: "p",
        midnight: "mn",
        noon: "md",
        morning: "mañana",
        afternoon: "tarde",
        evening: "tarde",
        night: "noche"
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "medianoche",
        noon: "mediodia",
        morning: "mañana",
        afternoon: "tarde",
        evening: "tarde",
        night: "noche"
      },
      wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "medianoche",
        noon: "mediodia",
        morning: "mañana",
        afternoon: "tarde",
        evening: "tarde",
        night: "noche"
      }
    };
    const formattingDayPeriodValues$5 = {
      narrow: {
        am: "a",
        pm: "p",
        midnight: "mn",
        noon: "md",
        morning: "de la mañana",
        afternoon: "de la tarde",
        evening: "de la tarde",
        night: "de la noche"
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "medianoche",
        noon: "mediodia",
        morning: "de la mañana",
        afternoon: "de la tarde",
        evening: "de la tarde",
        night: "de la noche"
      },
      wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "medianoche",
        noon: "mediodia",
        morning: "de la mañana",
        afternoon: "de la tarde",
        evening: "de la tarde",
        night: "de la noche"
      }
    };
    const ordinalNumber$8 = (dirtyNumber, _options) => {
      const number = Number(dirtyNumber);
      return number + "º";
    };
    const localize$8 = {
      ordinalNumber: ordinalNumber$8,
      era: buildLocalizeFn({
        values: eraValues$8,
        defaultWidth: "wide"
      }),
      quarter: buildLocalizeFn({
        values: quarterValues$8,
        defaultWidth: "wide",
        argumentCallback: (quarter) => Number(quarter) - 1
      }),
      month: buildLocalizeFn({
        values: monthValues$8,
        defaultWidth: "wide"
      }),
      day: buildLocalizeFn({
        values: dayValues$8,
        defaultWidth: "wide"
      }),
      dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$8,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$5,
        defaultFormattingWidth: "wide"
      })
    };
    const matchOrdinalNumberPattern$8 = /^(\d+)(º)?/i;
    const parseOrdinalNumberPattern$8 = /\d+/i;
    const matchEraPatterns$8 = {
      narrow: /^(ac|dc|a|d)/i,
      abbreviated: /^(a\.?\s?c\.?|a\.?\s?e\.?\s?c\.?|d\.?\s?c\.?|e\.?\s?c\.?)/i,
      wide: /^(antes de cristo|antes de la era com[uú]n|despu[eé]s de cristo|era com[uú]n)/i
    };
    const parseEraPatterns$8 = {
      any: [/^ac/i, /^dc/i],
      wide: [
        /^(antes de cristo|antes de la era com[uú]n)/i,
        /^(despu[eé]s de cristo|era com[uú]n)/i
      ]
    };
    const matchQuarterPatterns$8 = {
      narrow: /^[1234]/i,
      abbreviated: /^T[1234]/i,
      wide: /^[1234](º)? trimestre/i
    };
    const parseQuarterPatterns$8 = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    const matchMonthPatterns$8 = {
      narrow: /^[efmajsond]/i,
      abbreviated: /^(ene|feb|mar|abr|may|jun|jul|ago|sep|oct|nov|dic)/i,
      wide: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i
    };
    const parseMonthPatterns$8 = {
      narrow: [
        /^e/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
      ],
      any: [
        /^en/i,
        /^feb/i,
        /^mar/i,
        /^abr/i,
        /^may/i,
        /^jun/i,
        /^jul/i,
        /^ago/i,
        /^sep/i,
        /^oct/i,
        /^nov/i,
        /^dic/i
      ]
    };
    const matchDayPatterns$8 = {
      narrow: /^[dlmjvs]/i,
      short: /^(do|lu|ma|mi|ju|vi|s[áa])/i,
      abbreviated: /^(dom|lun|mar|mi[ée]|jue|vie|s[áa]b)/i,
      wide: /^(domingo|lunes|martes|mi[ée]rcoles|jueves|viernes|s[áa]bado)/i
    };
    const parseDayPatterns$8 = {
      narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^j/i, /^v/i, /^s/i],
      any: [/^do/i, /^lu/i, /^ma/i, /^mi/i, /^ju/i, /^vi/i, /^sa/i]
    };
    const matchDayPeriodPatterns$8 = {
      narrow: /^(a|p|mn|md|(de la|a las) (mañana|tarde|noche))/i,
      any: /^([ap]\.?\s?m\.?|medianoche|mediodia|(de la|a las) (mañana|tarde|noche))/i
    };
    const parseDayPeriodPatterns$8 = {
      any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mn/i,
        noon: /^md/i,
        morning: /mañana/i,
        afternoon: /tarde/i,
        evening: /tarde/i,
        night: /noche/i
      }
    };
    const match$8 = {
      ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$8,
        parsePattern: parseOrdinalNumberPattern$8,
        valueCallback: function(value2) {
          return parseInt(value2, 10);
        }
      }),
      era: buildMatchFn({
        matchPatterns: matchEraPatterns$8,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$8,
        defaultParseWidth: "any"
      }),
      quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$8,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$8,
        defaultParseWidth: "any",
        valueCallback: (index2) => index2 + 1
      }),
      month: buildMatchFn({
        matchPatterns: matchMonthPatterns$8,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$8,
        defaultParseWidth: "any"
      }),
      day: buildMatchFn({
        matchPatterns: matchDayPatterns$8,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$8,
        defaultParseWidth: "any"
      }),
      dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$8,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$8,
        defaultParseWidth: "any"
      })
    };
    const es = {
      code: "es",
      formatDistance: formatDistance$8,
      formatLong: formatLong$8,
      formatRelative: formatRelative$8,
      localize: localize$8,
      match: match$8,
      options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 1
      }
    };
    const formatDistanceLocale$6 = {
      lessThanXSeconds: {
        one: "moins d’une seconde",
        other: "moins de {{count}} secondes"
      },
      xSeconds: {
        one: "1 seconde",
        other: "{{count}} secondes"
      },
      halfAMinute: "30 secondes",
      lessThanXMinutes: {
        one: "moins d’une minute",
        other: "moins de {{count}} minutes"
      },
      xMinutes: {
        one: "1 minute",
        other: "{{count}} minutes"
      },
      aboutXHours: {
        one: "environ 1 heure",
        other: "environ {{count}} heures"
      },
      xHours: {
        one: "1 heure",
        other: "{{count}} heures"
      },
      xDays: {
        one: "1 jour",
        other: "{{count}} jours"
      },
      aboutXWeeks: {
        one: "environ 1 semaine",
        other: "environ {{count}} semaines"
      },
      xWeeks: {
        one: "1 semaine",
        other: "{{count}} semaines"
      },
      aboutXMonths: {
        one: "environ 1 mois",
        other: "environ {{count}} mois"
      },
      xMonths: {
        one: "1 mois",
        other: "{{count}} mois"
      },
      aboutXYears: {
        one: "environ 1 an",
        other: "environ {{count}} ans"
      },
      xYears: {
        one: "1 an",
        other: "{{count}} ans"
      },
      overXYears: {
        one: "plus d’un an",
        other: "plus de {{count}} ans"
      },
      almostXYears: {
        one: "presqu’un an",
        other: "presque {{count}} ans"
      }
    };
    const formatDistance$7 = (token, count, options) => {
      let result;
      const form2 = formatDistanceLocale$6[token];
      if (typeof form2 === "string") {
        result = form2;
      } else if (count === 1) {
        result = form2.one;
      } else {
        result = form2.other.replace("{{count}}", String(count));
      }
      if (options?.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return "dans " + result;
        } else {
          return "il y a " + result;
        }
      }
      return result;
    };
    const dateFormats$7 = {
      full: "EEEE d MMMM y",
      long: "d MMMM y",
      medium: "d MMM y",
      short: "dd/MM/y"
    };
    const timeFormats$7 = {
      full: "HH:mm:ss zzzz",
      long: "HH:mm:ss z",
      medium: "HH:mm:ss",
      short: "HH:mm"
    };
    const dateTimeFormats$7 = {
      full: "{{date}} 'à' {{time}}",
      long: "{{date}} 'à' {{time}}",
      medium: "{{date}}, {{time}}",
      short: "{{date}}, {{time}}"
    };
    const formatLong$7 = {
      date: buildFormatLongFn({
        formats: dateFormats$7,
        defaultWidth: "full"
      }),
      time: buildFormatLongFn({
        formats: timeFormats$7,
        defaultWidth: "full"
      }),
      dateTime: buildFormatLongFn({
        formats: dateTimeFormats$7,
        defaultWidth: "full"
      })
    };
    const formatRelativeLocale$7 = {
      lastWeek: "eeee 'dernier à' p",
      yesterday: "'hier à' p",
      today: "'aujourd’hui à' p",
      tomorrow: "'demain à' p'",
      nextWeek: "eeee 'prochain à' p",
      other: "P"
    };
    const formatRelative$7 = (token, _date, _baseDate, _options) => formatRelativeLocale$7[token];
    const eraValues$7 = {
      narrow: ["av. J.-C", "ap. J.-C"],
      abbreviated: ["av. J.-C", "ap. J.-C"],
      wide: ["avant Jésus-Christ", "après Jésus-Christ"]
    };
    const quarterValues$7 = {
      narrow: ["T1", "T2", "T3", "T4"],
      abbreviated: ["1er trim.", "2ème trim.", "3ème trim.", "4ème trim."],
      wide: ["1er trimestre", "2ème trimestre", "3ème trimestre", "4ème trimestre"]
    };
    const monthValues$7 = {
      narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
      abbreviated: [
        "janv.",
        "févr.",
        "mars",
        "avr.",
        "mai",
        "juin",
        "juil.",
        "août",
        "sept.",
        "oct.",
        "nov.",
        "déc."
      ],
      wide: [
        "janvier",
        "février",
        "mars",
        "avril",
        "mai",
        "juin",
        "juillet",
        "août",
        "septembre",
        "octobre",
        "novembre",
        "décembre"
      ]
    };
    const dayValues$7 = {
      narrow: ["D", "L", "M", "M", "J", "V", "S"],
      short: ["di", "lu", "ma", "me", "je", "ve", "sa"],
      abbreviated: ["dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam."],
      wide: [
        "dimanche",
        "lundi",
        "mardi",
        "mercredi",
        "jeudi",
        "vendredi",
        "samedi"
      ]
    };
    const dayPeriodValues$7 = {
      narrow: {
        am: "AM",
        pm: "PM",
        midnight: "minuit",
        noon: "midi",
        morning: "mat.",
        afternoon: "ap.m.",
        evening: "soir",
        night: "mat."
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "minuit",
        noon: "midi",
        morning: "matin",
        afternoon: "après-midi",
        evening: "soir",
        night: "matin"
      },
      wide: {
        am: "AM",
        pm: "PM",
        midnight: "minuit",
        noon: "midi",
        morning: "du matin",
        afternoon: "de l’après-midi",
        evening: "du soir",
        night: "du matin"
      }
    };
    const ordinalNumber$7 = (dirtyNumber, options) => {
      const number = Number(dirtyNumber);
      const unit = options?.unit;
      if (number === 0)
        return "0";
      const feminineUnits = ["year", "week", "hour", "minute", "second"];
      let suffix;
      if (number === 1) {
        suffix = unit && feminineUnits.includes(unit) ? "ère" : "er";
      } else {
        suffix = "ème";
      }
      return number + suffix;
    };
    const LONG_MONTHS_TOKENS = ["MMM", "MMMM"];
    const localize$7 = {
      preprocessor: (date, parts) => {
        if (date.getDate() === 1)
          return parts;
        const hasLongMonthToken = parts.some(
          (part) => part.isToken && LONG_MONTHS_TOKENS.includes(part.value)
        );
        if (!hasLongMonthToken)
          return parts;
        return parts.map(
          (part) => part.isToken && part.value === "do" ? { isToken: true, value: "d" } : part
        );
      },
      ordinalNumber: ordinalNumber$7,
      era: buildLocalizeFn({
        values: eraValues$7,
        defaultWidth: "wide"
      }),
      quarter: buildLocalizeFn({
        values: quarterValues$7,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
      }),
      month: buildLocalizeFn({
        values: monthValues$7,
        defaultWidth: "wide"
      }),
      day: buildLocalizeFn({
        values: dayValues$7,
        defaultWidth: "wide"
      }),
      dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$7,
        defaultWidth: "wide"
      })
    };
    const matchOrdinalNumberPattern$7 = /^(\d+)(ième|ère|ème|er|e)?/i;
    const parseOrdinalNumberPattern$7 = /\d+/i;
    const matchEraPatterns$7 = {
      narrow: /^(av\.J\.C|ap\.J\.C|ap\.J\.-C)/i,
      abbreviated: /^(av\.J\.-C|av\.J-C|apr\.J\.-C|apr\.J-C|ap\.J-C)/i,
      wide: /^(avant Jésus-Christ|après Jésus-Christ)/i
    };
    const parseEraPatterns$7 = {
      any: [/^av/i, /^ap/i]
    };
    const matchQuarterPatterns$7 = {
      narrow: /^T?[1234]/i,
      abbreviated: /^[1234](er|ème|e)? trim\.?/i,
      wide: /^[1234](er|ème|e)? trimestre/i
    };
    const parseQuarterPatterns$7 = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    const matchMonthPatterns$7 = {
      narrow: /^[jfmasond]/i,
      abbreviated: /^(janv|févr|mars|avr|mai|juin|juill|juil|août|sept|oct|nov|déc)\.?/i,
      wide: /^(janvier|février|mars|avril|mai|juin|juillet|août|septembre|octobre|novembre|décembre)/i
    };
    const parseMonthPatterns$7 = {
      narrow: [
        /^j/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
      ],
      any: [
        /^ja/i,
        /^f/i,
        /^mar/i,
        /^av/i,
        /^ma/i,
        /^juin/i,
        /^juil/i,
        /^ao/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
      ]
    };
    const matchDayPatterns$7 = {
      narrow: /^[lmjvsd]/i,
      short: /^(di|lu|ma|me|je|ve|sa)/i,
      abbreviated: /^(dim|lun|mar|mer|jeu|ven|sam)\.?/i,
      wide: /^(dimanche|lundi|mardi|mercredi|jeudi|vendredi|samedi)/i
    };
    const parseDayPatterns$7 = {
      narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^j/i, /^v/i, /^s/i],
      any: [/^di/i, /^lu/i, /^ma/i, /^me/i, /^je/i, /^ve/i, /^sa/i]
    };
    const matchDayPeriodPatterns$7 = {
      narrow: /^(a|p|minuit|midi|mat\.?|ap\.?m\.?|soir|nuit)/i,
      any: /^([ap]\.?\s?m\.?|du matin|de l'après[-\s]midi|du soir|de la nuit)/i
    };
    const parseDayPeriodPatterns$7 = {
      any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^min/i,
        noon: /^mid/i,
        morning: /mat/i,
        afternoon: /ap/i,
        evening: /soir/i,
        night: /nuit/i
      }
    };
    const match$7 = {
      ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$7,
        parsePattern: parseOrdinalNumberPattern$7,
        valueCallback: (value2) => parseInt(value2)
      }),
      era: buildMatchFn({
        matchPatterns: matchEraPatterns$7,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$7,
        defaultParseWidth: "any"
      }),
      quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$7,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$7,
        defaultParseWidth: "any",
        valueCallback: (index2) => index2 + 1
      }),
      month: buildMatchFn({
        matchPatterns: matchMonthPatterns$7,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$7,
        defaultParseWidth: "any"
      }),
      day: buildMatchFn({
        matchPatterns: matchDayPatterns$7,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$7,
        defaultParseWidth: "any"
      }),
      dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$7,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$7,
        defaultParseWidth: "any"
      })
    };
    const fr$2 = {
      code: "fr",
      formatDistance: formatDistance$7,
      formatLong: formatLong$7,
      formatRelative: formatRelative$7,
      localize: localize$7,
      match: match$7,
      options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
      }
    };
    const translations = {
      about: "körülbelül",
      over: "több mint",
      almost: "majdnem",
      lessthan: "kevesebb mint"
    };
    const withoutSuffixes = {
      xseconds: " másodperc",
      halfaminute: "fél perc",
      xminutes: " perc",
      xhours: " óra",
      xdays: " nap",
      xweeks: " hét",
      xmonths: " hónap",
      xyears: " év"
    };
    const withSuffixes = {
      xseconds: {
        "-1": " másodperccel ezelőtt",
        1: " másodperc múlva",
        0: " másodperce"
      },
      halfaminute: {
        "-1": "fél perccel ezelőtt",
        1: "fél perc múlva",
        0: "fél perce"
      },
      xminutes: {
        "-1": " perccel ezelőtt",
        1: " perc múlva",
        0: " perce"
      },
      xhours: {
        "-1": " órával ezelőtt",
        1: " óra múlva",
        0: " órája"
      },
      xdays: {
        "-1": " nappal ezelőtt",
        1: " nap múlva",
        0: " napja"
      },
      xweeks: {
        "-1": " héttel ezelőtt",
        1: " hét múlva",
        0: " hete"
      },
      xmonths: {
        "-1": " hónappal ezelőtt",
        1: " hónap múlva",
        0: " hónapja"
      },
      xyears: {
        "-1": " évvel ezelőtt",
        1: " év múlva",
        0: " éve"
      }
    };
    const formatDistance$6 = (token, count, options) => {
      const adverb = token.match(/about|over|almost|lessthan/i);
      const unit = adverb ? token.replace(adverb[0], "") : token;
      const addSuffix = options?.addSuffix === true;
      const key2 = unit.toLowerCase();
      const comparison = options?.comparison || 0;
      const translated = addSuffix ? withSuffixes[key2][comparison] : withoutSuffixes[key2];
      let result = key2 === "halfaminute" ? translated : count + translated;
      if (adverb) {
        const adv = adverb[0].toLowerCase();
        result = translations[adv] + " " + result;
      }
      return result;
    };
    const dateFormats$6 = {
      full: "y. MMMM d., EEEE",
      long: "y. MMMM d.",
      medium: "y. MMM d.",
      short: "y. MM. dd."
    };
    const timeFormats$6 = {
      full: "H:mm:ss zzzz",
      long: "H:mm:ss z",
      medium: "H:mm:ss",
      short: "H:mm"
    };
    const dateTimeFormats$6 = {
      full: "{{date}} {{time}}",
      long: "{{date}} {{time}}",
      medium: "{{date}} {{time}}",
      short: "{{date}} {{time}}"
    };
    const formatLong$6 = {
      date: buildFormatLongFn({
        formats: dateFormats$6,
        defaultWidth: "full"
      }),
      time: buildFormatLongFn({
        formats: timeFormats$6,
        defaultWidth: "full"
      }),
      dateTime: buildFormatLongFn({
        formats: dateTimeFormats$6,
        defaultWidth: "full"
      })
    };
    const accusativeWeekdays$1 = [
      "vasárnap",
      "hétfőn",
      "kedden",
      "szerdán",
      "csütörtökön",
      "pénteken",
      "szombaton"
    ];
    function week(isFuture) {
      return (date) => {
        const weekday = accusativeWeekdays$1[date.getDay()];
        const prefix = isFuture ? "" : "'múlt' ";
        return `${prefix}'${weekday}' p'-kor'`;
      };
    }
    const formatRelativeLocale$6 = {
      lastWeek: week(false),
      yesterday: "'tegnap' p'-kor'",
      today: "'ma' p'-kor'",
      tomorrow: "'holnap' p'-kor'",
      nextWeek: week(true),
      other: "P"
    };
    const formatRelative$6 = (token, date) => {
      const format2 = formatRelativeLocale$6[token];
      if (typeof format2 === "function") {
        return format2(date);
      }
      return format2;
    };
    const eraValues$6 = {
      narrow: ["ie.", "isz."],
      abbreviated: ["i. e.", "i. sz."],
      wide: ["Krisztus előtt", "időszámításunk szerint"]
    };
    const quarterValues$6 = {
      narrow: ["1.", "2.", "3.", "4."],
      abbreviated: ["1. n.év", "2. n.év", "3. n.év", "4. n.év"],
      wide: ["1. negyedév", "2. negyedév", "3. negyedév", "4. negyedév"]
    };
    const formattingQuarterValues = {
      narrow: ["I.", "II.", "III.", "IV."],
      abbreviated: ["I. n.év", "II. n.év", "III. n.év", "IV. n.év"],
      wide: ["I. negyedév", "II. negyedév", "III. negyedév", "IV. negyedév"]
    };
    const monthValues$6 = {
      narrow: ["J", "F", "M", "Á", "M", "J", "J", "A", "Sz", "O", "N", "D"],
      abbreviated: [
        "jan.",
        "febr.",
        "márc.",
        "ápr.",
        "máj.",
        "jún.",
        "júl.",
        "aug.",
        "szept.",
        "okt.",
        "nov.",
        "dec."
      ],
      wide: [
        "január",
        "február",
        "március",
        "április",
        "május",
        "június",
        "július",
        "augusztus",
        "szeptember",
        "október",
        "november",
        "december"
      ]
    };
    const dayValues$6 = {
      narrow: ["V", "H", "K", "Sz", "Cs", "P", "Sz"],
      short: ["V", "H", "K", "Sze", "Cs", "P", "Szo"],
      abbreviated: ["V", "H", "K", "Sze", "Cs", "P", "Szo"],
      wide: [
        "vasárnap",
        "hétfő",
        "kedd",
        "szerda",
        "csütörtök",
        "péntek",
        "szombat"
      ]
    };
    const dayPeriodValues$6 = {
      narrow: {
        am: "de.",
        pm: "du.",
        midnight: "éjfél",
        noon: "dél",
        morning: "reggel",
        afternoon: "du.",
        evening: "este",
        night: "éjjel"
      },
      abbreviated: {
        am: "de.",
        pm: "du.",
        midnight: "éjfél",
        noon: "dél",
        morning: "reggel",
        afternoon: "du.",
        evening: "este",
        night: "éjjel"
      },
      wide: {
        am: "de.",
        pm: "du.",
        midnight: "éjfél",
        noon: "dél",
        morning: "reggel",
        afternoon: "délután",
        evening: "este",
        night: "éjjel"
      }
    };
    const ordinalNumber$6 = (dirtyNumber, _options) => {
      const number = Number(dirtyNumber);
      return number + ".";
    };
    const localize$6 = {
      ordinalNumber: ordinalNumber$6,
      era: buildLocalizeFn({
        values: eraValues$6,
        defaultWidth: "wide"
      }),
      quarter: buildLocalizeFn({
        values: quarterValues$6,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1,
        formattingValues: formattingQuarterValues,
        defaultFormattingWidth: "wide"
      }),
      month: buildLocalizeFn({
        values: monthValues$6,
        defaultWidth: "wide"
      }),
      day: buildLocalizeFn({
        values: dayValues$6,
        defaultWidth: "wide"
      }),
      dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$6,
        defaultWidth: "wide"
      })
    };
    const matchOrdinalNumberPattern$6 = /^(\d+)\.?/i;
    const parseOrdinalNumberPattern$6 = /\d+/i;
    const matchEraPatterns$6 = {
      narrow: /^(ie\.|isz\.)/i,
      abbreviated: /^(i\.\s?e\.?|b?\s?c\s?e|i\.\s?sz\.?)/i,
      wide: /^(Krisztus előtt|időszámításunk előtt|időszámításunk szerint|i\. sz\.)/i
    };
    const parseEraPatterns$6 = {
      narrow: [/ie/i, /isz/i],
      abbreviated: [/^(i\.?\s?e\.?|b\s?ce)/i, /^(i\.?\s?sz\.?|c\s?e)/i],
      any: [/előtt/i, /(szerint|i. sz.)/i]
    };
    const matchQuarterPatterns$6 = {
      narrow: /^[1234]\.?/i,
      abbreviated: /^[1234]?\.?\s?n\.év/i,
      wide: /^([1234]|I|II|III|IV)?\.?\s?negyedév/i
    };
    const parseQuarterPatterns$6 = {
      any: [/1|I$/i, /2|II$/i, /3|III/i, /4|IV/i]
    };
    const matchMonthPatterns$6 = {
      narrow: /^[jfmaásond]|sz/i,
      abbreviated: /^(jan\.?|febr\.?|márc\.?|ápr\.?|máj\.?|jún\.?|júl\.?|aug\.?|szept\.?|okt\.?|nov\.?|dec\.?)/i,
      wide: /^(január|február|március|április|május|június|július|augusztus|szeptember|október|november|december)/i
    };
    const parseMonthPatterns$6 = {
      narrow: [
        /^j/i,
        /^f/i,
        /^m/i,
        /^a|á/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^a/i,
        /^s|sz/i,
        /^o/i,
        /^n/i,
        /^d/i
      ],
      any: [
        /^ja/i,
        /^f/i,
        /^már/i,
        /^áp/i,
        /^máj/i,
        /^jún/i,
        /^júl/i,
        /^au/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
      ]
    };
    const matchDayPatterns$6 = {
      narrow: /^([vhkpc]|sz|cs|sz)/i,
      short: /^([vhkp]|sze|cs|szo)/i,
      abbreviated: /^([vhkp]|sze|cs|szo)/i,
      wide: /^(vasárnap|hétfő|kedd|szerda|csütörtök|péntek|szombat)/i
    };
    const parseDayPatterns$6 = {
      narrow: [/^v/i, /^h/i, /^k/i, /^sz/i, /^c/i, /^p/i, /^sz/i],
      any: [/^v/i, /^h/i, /^k/i, /^sze/i, /^c/i, /^p/i, /^szo/i]
    };
    const matchDayPeriodPatterns$6 = {
      any: /^((de|du)\.?|éjfél|délután|dél|reggel|este|éjjel)/i
    };
    const parseDayPeriodPatterns$6 = {
      any: {
        am: /^de\.?/i,
        pm: /^du\.?/i,
        midnight: /^éjf/i,
        noon: /^dé/i,
        morning: /reg/i,
        afternoon: /^délu\.?/i,
        evening: /es/i,
        night: /éjj/i
      }
    };
    const match$6 = {
      ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$6,
        parsePattern: parseOrdinalNumberPattern$6,
        valueCallback: (value2) => parseInt(value2, 10)
      }),
      era: buildMatchFn({
        matchPatterns: matchEraPatterns$6,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$6,
        defaultParseWidth: "any"
      }),
      quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$6,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$6,
        defaultParseWidth: "any",
        valueCallback: (index2) => index2 + 1
      }),
      month: buildMatchFn({
        matchPatterns: matchMonthPatterns$6,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$6,
        defaultParseWidth: "any"
      }),
      day: buildMatchFn({
        matchPatterns: matchDayPatterns$6,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$6,
        defaultParseWidth: "any"
      }),
      dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$6,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$6,
        defaultParseWidth: "any"
      })
    };
    const hu = {
      code: "hu",
      formatDistance: formatDistance$6,
      formatLong: formatLong$6,
      formatRelative: formatRelative$6,
      localize: localize$6,
      match: match$6,
      options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
      }
    };
    const formatDistanceLocale$5 = {
      lessThanXSeconds: {
        one: "meno di un secondo",
        other: "meno di {{count}} secondi"
      },
      xSeconds: {
        one: "un secondo",
        other: "{{count}} secondi"
      },
      halfAMinute: "alcuni secondi",
      lessThanXMinutes: {
        one: "meno di un minuto",
        other: "meno di {{count}} minuti"
      },
      xMinutes: {
        one: "un minuto",
        other: "{{count}} minuti"
      },
      aboutXHours: {
        one: "circa un'ora",
        other: "circa {{count}} ore"
      },
      xHours: {
        one: "un'ora",
        other: "{{count}} ore"
      },
      xDays: {
        one: "un giorno",
        other: "{{count}} giorni"
      },
      aboutXWeeks: {
        one: "circa una settimana",
        other: "circa {{count}} settimane"
      },
      xWeeks: {
        one: "una settimana",
        other: "{{count}} settimane"
      },
      aboutXMonths: {
        one: "circa un mese",
        other: "circa {{count}} mesi"
      },
      xMonths: {
        one: "un mese",
        other: "{{count}} mesi"
      },
      aboutXYears: {
        one: "circa un anno",
        other: "circa {{count}} anni"
      },
      xYears: {
        one: "un anno",
        other: "{{count}} anni"
      },
      overXYears: {
        one: "più di un anno",
        other: "più di {{count}} anni"
      },
      almostXYears: {
        one: "quasi un anno",
        other: "quasi {{count}} anni"
      }
    };
    const formatDistance$5 = (token, count, options) => {
      let result;
      const tokenValue = formatDistanceLocale$5[token];
      if (typeof tokenValue === "string") {
        result = tokenValue;
      } else if (count === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace("{{count}}", count.toString());
      }
      if (options?.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return "tra " + result;
        } else {
          return result + " fa";
        }
      }
      return result;
    };
    const dateFormats$5 = {
      full: "EEEE d MMMM y",
      long: "d MMMM y",
      medium: "d MMM y",
      short: "dd/MM/y"
    };
    const timeFormats$5 = {
      full: "HH:mm:ss zzzz",
      long: "HH:mm:ss z",
      medium: "HH:mm:ss",
      short: "HH:mm"
    };
    const dateTimeFormats$5 = {
      full: "{{date}} {{time}}",
      long: "{{date}} {{time}}",
      medium: "{{date}} {{time}}",
      short: "{{date}} {{time}}"
    };
    const formatLong$5 = {
      date: buildFormatLongFn({
        formats: dateFormats$5,
        defaultWidth: "full"
      }),
      time: buildFormatLongFn({
        formats: timeFormats$5,
        defaultWidth: "full"
      }),
      dateTime: buildFormatLongFn({
        formats: dateTimeFormats$5,
        defaultWidth: "full"
      })
    };
    const weekdays = [
      "domenica",
      "lunedì",
      "martedì",
      "mercoledì",
      "giovedì",
      "venerdì",
      "sabato"
    ];
    function lastWeek$1(day) {
      switch (day) {
        case 0:
          return "'domenica scorsa alle' p";
        default:
          return "'" + weekdays[day] + " scorso alle' p";
      }
    }
    function thisWeek$1(day) {
      return "'" + weekdays[day] + " alle' p";
    }
    function nextWeek$1(day) {
      switch (day) {
        case 0:
          return "'domenica prossima alle' p";
        default:
          return "'" + weekdays[day] + " prossimo alle' p";
      }
    }
    const formatRelativeLocale$5 = {
      lastWeek: (date, baseDate, options) => {
        const day = date.getDay();
        if (isSameWeek(date, baseDate, options)) {
          return thisWeek$1(day);
        } else {
          return lastWeek$1(day);
        }
      },
      yesterday: "'ieri alle' p",
      today: "'oggi alle' p",
      tomorrow: "'domani alle' p",
      nextWeek: (date, baseDate, options) => {
        const day = date.getDay();
        if (isSameWeek(date, baseDate, options)) {
          return thisWeek$1(day);
        } else {
          return nextWeek$1(day);
        }
      },
      other: "P"
    };
    const formatRelative$5 = (token, date, baseDate, options) => {
      const format2 = formatRelativeLocale$5[token];
      if (typeof format2 === "function") {
        return format2(date, baseDate, options);
      }
      return format2;
    };
    const eraValues$5 = {
      narrow: ["aC", "dC"],
      abbreviated: ["a.C.", "d.C."],
      wide: ["avanti Cristo", "dopo Cristo"]
    };
    const quarterValues$5 = {
      narrow: ["1", "2", "3", "4"],
      abbreviated: ["T1", "T2", "T3", "T4"],
      wide: ["1º trimestre", "2º trimestre", "3º trimestre", "4º trimestre"]
    };
    const monthValues$5 = {
      narrow: ["G", "F", "M", "A", "M", "G", "L", "A", "S", "O", "N", "D"],
      abbreviated: [
        "gen",
        "feb",
        "mar",
        "apr",
        "mag",
        "giu",
        "lug",
        "ago",
        "set",
        "ott",
        "nov",
        "dic"
      ],
      wide: [
        "gennaio",
        "febbraio",
        "marzo",
        "aprile",
        "maggio",
        "giugno",
        "luglio",
        "agosto",
        "settembre",
        "ottobre",
        "novembre",
        "dicembre"
      ]
    };
    const dayValues$5 = {
      narrow: ["D", "L", "M", "M", "G", "V", "S"],
      short: ["dom", "lun", "mar", "mer", "gio", "ven", "sab"],
      abbreviated: ["dom", "lun", "mar", "mer", "gio", "ven", "sab"],
      wide: [
        "domenica",
        "lunedì",
        "martedì",
        "mercoledì",
        "giovedì",
        "venerdì",
        "sabato"
      ]
    };
    const dayPeriodValues$5 = {
      narrow: {
        am: "m.",
        pm: "p.",
        midnight: "mezzanotte",
        noon: "mezzogiorno",
        morning: "mattina",
        afternoon: "pomeriggio",
        evening: "sera",
        night: "notte"
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "mezzanotte",
        noon: "mezzogiorno",
        morning: "mattina",
        afternoon: "pomeriggio",
        evening: "sera",
        night: "notte"
      },
      wide: {
        am: "AM",
        pm: "PM",
        midnight: "mezzanotte",
        noon: "mezzogiorno",
        morning: "mattina",
        afternoon: "pomeriggio",
        evening: "sera",
        night: "notte"
      }
    };
    const formattingDayPeriodValues$4 = {
      narrow: {
        am: "m.",
        pm: "p.",
        midnight: "mezzanotte",
        noon: "mezzogiorno",
        morning: "di mattina",
        afternoon: "del pomeriggio",
        evening: "di sera",
        night: "di notte"
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "mezzanotte",
        noon: "mezzogiorno",
        morning: "di mattina",
        afternoon: "del pomeriggio",
        evening: "di sera",
        night: "di notte"
      },
      wide: {
        am: "AM",
        pm: "PM",
        midnight: "mezzanotte",
        noon: "mezzogiorno",
        morning: "di mattina",
        afternoon: "del pomeriggio",
        evening: "di sera",
        night: "di notte"
      }
    };
    const ordinalNumber$5 = (dirtyNumber, _options) => {
      const number = Number(dirtyNumber);
      return String(number);
    };
    const localize$5 = {
      ordinalNumber: ordinalNumber$5,
      era: buildLocalizeFn({
        values: eraValues$5,
        defaultWidth: "wide"
      }),
      quarter: buildLocalizeFn({
        values: quarterValues$5,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
      }),
      month: buildLocalizeFn({
        values: monthValues$5,
        defaultWidth: "wide"
      }),
      day: buildLocalizeFn({
        values: dayValues$5,
        defaultWidth: "wide"
      }),
      dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$5,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$4,
        defaultFormattingWidth: "wide"
      })
    };
    const matchOrdinalNumberPattern$5 = /^(\d+)(º)?/i;
    const parseOrdinalNumberPattern$5 = /\d+/i;
    const matchEraPatterns$5 = {
      narrow: /^(aC|dC)/i,
      abbreviated: /^(a\.?\s?C\.?|a\.?\s?e\.?\s?v\.?|d\.?\s?C\.?|e\.?\s?v\.?)/i,
      wide: /^(avanti Cristo|avanti Era Volgare|dopo Cristo|Era Volgare)/i
    };
    const parseEraPatterns$5 = {
      any: [/^a/i, /^(d|e)/i]
    };
    const matchQuarterPatterns$5 = {
      narrow: /^[1234]/i,
      abbreviated: /^t[1234]/i,
      wide: /^[1234](º)? trimestre/i
    };
    const parseQuarterPatterns$5 = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    const matchMonthPatterns$5 = {
      narrow: /^[gfmalsond]/i,
      abbreviated: /^(gen|feb|mar|apr|mag|giu|lug|ago|set|ott|nov|dic)/i,
      wide: /^(gennaio|febbraio|marzo|aprile|maggio|giugno|luglio|agosto|settembre|ottobre|novembre|dicembre)/i
    };
    const parseMonthPatterns$5 = {
      narrow: [
        /^g/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^g/i,
        /^l/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
      ],
      any: [
        /^ge/i,
        /^f/i,
        /^mar/i,
        /^ap/i,
        /^mag/i,
        /^gi/i,
        /^l/i,
        /^ag/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
      ]
    };
    const matchDayPatterns$5 = {
      narrow: /^[dlmgvs]/i,
      short: /^(do|lu|ma|me|gi|ve|sa)/i,
      abbreviated: /^(dom|lun|mar|mer|gio|ven|sab)/i,
      wide: /^(domenica|luned[i|ì]|marted[i|ì]|mercoled[i|ì]|gioved[i|ì]|venerd[i|ì]|sabato)/i
    };
    const parseDayPatterns$5 = {
      narrow: [/^d/i, /^l/i, /^m/i, /^m/i, /^g/i, /^v/i, /^s/i],
      any: [/^d/i, /^l/i, /^ma/i, /^me/i, /^g/i, /^v/i, /^s/i]
    };
    const matchDayPeriodPatterns$5 = {
      narrow: /^(a|m\.|p|mezzanotte|mezzogiorno|(di|del) (mattina|pomeriggio|sera|notte))/i,
      any: /^([ap]\.?\s?m\.?|mezzanotte|mezzogiorno|(di|del) (mattina|pomeriggio|sera|notte))/i
    };
    const parseDayPeriodPatterns$5 = {
      any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mezza/i,
        noon: /^mezzo/i,
        morning: /mattina/i,
        afternoon: /pomeriggio/i,
        evening: /sera/i,
        night: /notte/i
      }
    };
    const match$5 = {
      ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$5,
        parsePattern: parseOrdinalNumberPattern$5,
        valueCallback: (value2) => parseInt(value2, 10)
      }),
      era: buildMatchFn({
        matchPatterns: matchEraPatterns$5,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$5,
        defaultParseWidth: "any"
      }),
      quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$5,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$5,
        defaultParseWidth: "any",
        valueCallback: (index2) => index2 + 1
      }),
      month: buildMatchFn({
        matchPatterns: matchMonthPatterns$5,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$5,
        defaultParseWidth: "any"
      }),
      day: buildMatchFn({
        matchPatterns: matchDayPatterns$5,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$5,
        defaultParseWidth: "any"
      }),
      dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$5,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$5,
        defaultParseWidth: "any"
      })
    };
    const it = {
      code: "it",
      formatDistance: formatDistance$5,
      formatLong: formatLong$5,
      formatRelative: formatRelative$5,
      localize: localize$5,
      match: match$5,
      options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
      }
    };
    const formatDistanceLocale$4 = {
      lessThanXSeconds: {
        one: {
          regular: "mniej niż sekunda",
          past: "mniej niż sekundę",
          future: "mniej niż sekundę"
        },
        twoFour: "mniej niż {{count}} sekundy",
        other: "mniej niż {{count}} sekund"
      },
      xSeconds: {
        one: {
          regular: "sekunda",
          past: "sekundę",
          future: "sekundę"
        },
        twoFour: "{{count}} sekundy",
        other: "{{count}} sekund"
      },
      halfAMinute: {
        one: "pół minuty",
        twoFour: "pół minuty",
        other: "pół minuty"
      },
      lessThanXMinutes: {
        one: {
          regular: "mniej niż minuta",
          past: "mniej niż minutę",
          future: "mniej niż minutę"
        },
        twoFour: "mniej niż {{count}} minuty",
        other: "mniej niż {{count}} minut"
      },
      xMinutes: {
        one: {
          regular: "minuta",
          past: "minutę",
          future: "minutę"
        },
        twoFour: "{{count}} minuty",
        other: "{{count}} minut"
      },
      aboutXHours: {
        one: {
          regular: "około godziny",
          past: "około godziny",
          future: "około godzinę"
        },
        twoFour: "około {{count}} godziny",
        other: "około {{count}} godzin"
      },
      xHours: {
        one: {
          regular: "godzina",
          past: "godzinę",
          future: "godzinę"
        },
        twoFour: "{{count}} godziny",
        other: "{{count}} godzin"
      },
      xDays: {
        one: {
          regular: "dzień",
          past: "dzień",
          future: "1 dzień"
        },
        twoFour: "{{count}} dni",
        other: "{{count}} dni"
      },
      aboutXWeeks: {
        one: "około tygodnia",
        twoFour: "około {{count}} tygodni",
        other: "około {{count}} tygodni"
      },
      xWeeks: {
        one: "tydzień",
        twoFour: "{{count}} tygodnie",
        other: "{{count}} tygodni"
      },
      aboutXMonths: {
        one: "około miesiąc",
        twoFour: "około {{count}} miesiące",
        other: "około {{count}} miesięcy"
      },
      xMonths: {
        one: "miesiąc",
        twoFour: "{{count}} miesiące",
        other: "{{count}} miesięcy"
      },
      aboutXYears: {
        one: "około rok",
        twoFour: "około {{count}} lata",
        other: "około {{count}} lat"
      },
      xYears: {
        one: "rok",
        twoFour: "{{count}} lata",
        other: "{{count}} lat"
      },
      overXYears: {
        one: "ponad rok",
        twoFour: "ponad {{count}} lata",
        other: "ponad {{count}} lat"
      },
      almostXYears: {
        one: "prawie rok",
        twoFour: "prawie {{count}} lata",
        other: "prawie {{count}} lat"
      }
    };
    function declensionGroup(scheme, count) {
      if (count === 1) {
        return scheme.one;
      }
      const rem100 = count % 100;
      if (rem100 <= 20 && rem100 > 10) {
        return scheme.other;
      }
      const rem10 = rem100 % 10;
      if (rem10 >= 2 && rem10 <= 4) {
        return scheme.twoFour;
      }
      return scheme.other;
    }
    function declension$1(scheme, count, time2) {
      const group = declensionGroup(scheme, count);
      const finalText = typeof group === "string" ? group : group[time2];
      return finalText.replace("{{count}}", String(count));
    }
    const formatDistance$4 = (token, count, options) => {
      const scheme = formatDistanceLocale$4[token];
      if (!options?.addSuffix) {
        return declension$1(scheme, count, "regular");
      }
      if (options.comparison && options.comparison > 0) {
        return "za " + declension$1(scheme, count, "future");
      } else {
        return declension$1(scheme, count, "past") + " temu";
      }
    };
    const dateFormats$4 = {
      full: "EEEE, do MMMM y",
      long: "do MMMM y",
      medium: "do MMM y",
      short: "dd.MM.y"
    };
    const timeFormats$4 = {
      full: "HH:mm:ss zzzz",
      long: "HH:mm:ss z",
      medium: "HH:mm:ss",
      short: "HH:mm"
    };
    const dateTimeFormats$4 = {
      full: "{{date}} {{time}}",
      long: "{{date}} {{time}}",
      medium: "{{date}}, {{time}}",
      short: "{{date}}, {{time}}"
    };
    const formatLong$4 = {
      date: buildFormatLongFn({
        formats: dateFormats$4,
        defaultWidth: "full"
      }),
      time: buildFormatLongFn({
        formats: timeFormats$4,
        defaultWidth: "full"
      }),
      dateTime: buildFormatLongFn({
        formats: dateTimeFormats$4,
        defaultWidth: "full"
      })
    };
    const adjectivesLastWeek = {
      masculine: "ostatni",
      feminine: "ostatnia"
    };
    const adjectivesThisWeek = {
      masculine: "ten",
      feminine: "ta"
    };
    const adjectivesNextWeek = {
      masculine: "następny",
      feminine: "następna"
    };
    const dayGrammaticalGender = {
      0: "feminine",
      1: "masculine",
      2: "masculine",
      3: "feminine",
      4: "masculine",
      5: "masculine",
      6: "feminine"
    };
    function dayAndTimeWithAdjective(token, date, baseDate, options) {
      let adjectives;
      if (isSameWeek(date, baseDate, options)) {
        adjectives = adjectivesThisWeek;
      } else if (token === "lastWeek") {
        adjectives = adjectivesLastWeek;
      } else if (token === "nextWeek") {
        adjectives = adjectivesNextWeek;
      } else {
        throw new Error(`Cannot determine adjectives for token ${token}`);
      }
      const day = date.getDay();
      const grammaticalGender = dayGrammaticalGender[day];
      const adjective = adjectives[grammaticalGender];
      return `'${adjective}' eeee 'o' p`;
    }
    const formatRelativeLocale$4 = {
      lastWeek: dayAndTimeWithAdjective,
      yesterday: "'wczoraj o' p",
      today: "'dzisiaj o' p",
      tomorrow: "'jutro o' p",
      nextWeek: dayAndTimeWithAdjective,
      other: "P"
    };
    const formatRelative$4 = (token, date, baseDate, options) => {
      const format2 = formatRelativeLocale$4[token];
      if (typeof format2 === "function") {
        return format2(token, date, baseDate, options);
      }
      return format2;
    };
    const eraValues$4 = {
      narrow: ["p.n.e.", "n.e."],
      abbreviated: ["p.n.e.", "n.e."],
      wide: ["przed naszą erą", "naszej ery"]
    };
    const quarterValues$4 = {
      narrow: ["1", "2", "3", "4"],
      abbreviated: ["I kw.", "II kw.", "III kw.", "IV kw."],
      wide: ["I kwartał", "II kwartał", "III kwartał", "IV kwartał"]
    };
    const monthValues$4 = {
      narrow: ["S", "L", "M", "K", "M", "C", "L", "S", "W", "P", "L", "G"],
      abbreviated: [
        "sty",
        "lut",
        "mar",
        "kwi",
        "maj",
        "cze",
        "lip",
        "sie",
        "wrz",
        "paź",
        "lis",
        "gru"
      ],
      wide: [
        "styczeń",
        "luty",
        "marzec",
        "kwiecień",
        "maj",
        "czerwiec",
        "lipiec",
        "sierpień",
        "wrzesień",
        "październik",
        "listopad",
        "grudzień"
      ]
    };
    const monthFormattingValues = {
      narrow: ["s", "l", "m", "k", "m", "c", "l", "s", "w", "p", "l", "g"],
      abbreviated: [
        "sty",
        "lut",
        "mar",
        "kwi",
        "maj",
        "cze",
        "lip",
        "sie",
        "wrz",
        "paź",
        "lis",
        "gru"
      ],
      wide: [
        "stycznia",
        "lutego",
        "marca",
        "kwietnia",
        "maja",
        "czerwca",
        "lipca",
        "sierpnia",
        "września",
        "października",
        "listopada",
        "grudnia"
      ]
    };
    const dayValues$4 = {
      narrow: ["N", "P", "W", "Ś", "C", "P", "S"],
      short: ["nie", "pon", "wto", "śro", "czw", "pią", "sob"],
      abbreviated: ["niedz.", "pon.", "wt.", "śr.", "czw.", "pt.", "sob."],
      wide: [
        "niedziela",
        "poniedziałek",
        "wtorek",
        "środa",
        "czwartek",
        "piątek",
        "sobota"
      ]
    };
    const dayFormattingValues = {
      narrow: ["n", "p", "w", "ś", "c", "p", "s"],
      short: ["nie", "pon", "wto", "śro", "czw", "pią", "sob"],
      abbreviated: ["niedz.", "pon.", "wt.", "śr.", "czw.", "pt.", "sob."],
      wide: [
        "niedziela",
        "poniedziałek",
        "wtorek",
        "środa",
        "czwartek",
        "piątek",
        "sobota"
      ]
    };
    const dayPeriodValues$4 = {
      narrow: {
        am: "a",
        pm: "p",
        midnight: "półn.",
        noon: "poł",
        morning: "rano",
        afternoon: "popoł.",
        evening: "wiecz.",
        night: "noc"
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "północ",
        noon: "południe",
        morning: "rano",
        afternoon: "popołudnie",
        evening: "wieczór",
        night: "noc"
      },
      wide: {
        am: "AM",
        pm: "PM",
        midnight: "północ",
        noon: "południe",
        morning: "rano",
        afternoon: "popołudnie",
        evening: "wieczór",
        night: "noc"
      }
    };
    const dayPeriodFormattingValues = {
      narrow: {
        am: "a",
        pm: "p",
        midnight: "o półn.",
        noon: "w poł.",
        morning: "rano",
        afternoon: "po poł.",
        evening: "wiecz.",
        night: "w nocy"
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "o północy",
        noon: "w południe",
        morning: "rano",
        afternoon: "po południu",
        evening: "wieczorem",
        night: "w nocy"
      },
      wide: {
        am: "AM",
        pm: "PM",
        midnight: "o północy",
        noon: "w południe",
        morning: "rano",
        afternoon: "po południu",
        evening: "wieczorem",
        night: "w nocy"
      }
    };
    const ordinalNumber$4 = (dirtyNumber, _options) => {
      return String(dirtyNumber);
    };
    const localize$4 = {
      ordinalNumber: ordinalNumber$4,
      era: buildLocalizeFn({
        values: eraValues$4,
        defaultWidth: "wide"
      }),
      quarter: buildLocalizeFn({
        values: quarterValues$4,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
      }),
      month: buildLocalizeFn({
        values: monthValues$4,
        defaultWidth: "wide",
        formattingValues: monthFormattingValues,
        defaultFormattingWidth: "wide"
      }),
      day: buildLocalizeFn({
        values: dayValues$4,
        defaultWidth: "wide",
        formattingValues: dayFormattingValues,
        defaultFormattingWidth: "wide"
      }),
      dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$4,
        defaultWidth: "wide",
        formattingValues: dayPeriodFormattingValues,
        defaultFormattingWidth: "wide"
      })
    };
    const matchOrdinalNumberPattern$4 = /^(\d+)?/i;
    const parseOrdinalNumberPattern$4 = /\d+/i;
    const matchEraPatterns$4 = {
      narrow: /^(p\.?\s*n\.?\s*e\.?\s*|n\.?\s*e\.?\s*)/i,
      abbreviated: /^(p\.?\s*n\.?\s*e\.?\s*|n\.?\s*e\.?\s*)/i,
      wide: /^(przed\s*nasz(ą|a)\s*er(ą|a)|naszej\s*ery)/i
    };
    const parseEraPatterns$4 = {
      any: [/^p/i, /^n/i]
    };
    const matchQuarterPatterns$4 = {
      narrow: /^[1234]/i,
      abbreviated: /^(I|II|III|IV)\s*kw\.?/i,
      wide: /^(I|II|III|IV)\s*kwarta(ł|l)/i
    };
    const parseQuarterPatterns$4 = {
      narrow: [/1/i, /2/i, /3/i, /4/i],
      any: [/^I kw/i, /^II kw/i, /^III kw/i, /^IV kw/i]
    };
    const matchMonthPatterns$4 = {
      narrow: /^[slmkcwpg]/i,
      abbreviated: /^(sty|lut|mar|kwi|maj|cze|lip|sie|wrz|pa(ź|z)|lis|gru)/i,
      wide: /^(stycznia|stycze(ń|n)|lutego|luty|marca|marzec|kwietnia|kwiecie(ń|n)|maja|maj|czerwca|czerwiec|lipca|lipiec|sierpnia|sierpie(ń|n)|wrze(ś|s)nia|wrzesie(ń|n)|pa(ź|z)dziernika|pa(ź|z)dziernik|listopada|listopad|grudnia|grudzie(ń|n))/i
    };
    const parseMonthPatterns$4 = {
      narrow: [
        /^s/i,
        /^l/i,
        /^m/i,
        /^k/i,
        /^m/i,
        /^c/i,
        /^l/i,
        /^s/i,
        /^w/i,
        /^p/i,
        /^l/i,
        /^g/i
      ],
      any: [
        /^st/i,
        /^lu/i,
        /^mar/i,
        /^k/i,
        /^maj/i,
        /^c/i,
        /^lip/i,
        /^si/i,
        /^w/i,
        /^p/i,
        /^lis/i,
        /^g/i
      ]
    };
    const matchDayPatterns$4 = {
      narrow: /^[npwścs]/i,
      short: /^(nie|pon|wto|(ś|s)ro|czw|pi(ą|a)|sob)/i,
      abbreviated: /^(niedz|pon|wt|(ś|s)r|czw|pt|sob)\.?/i,
      wide: /^(niedziela|poniedzia(ł|l)ek|wtorek|(ś|s)roda|czwartek|pi(ą|a)tek|sobota)/i
    };
    const parseDayPatterns$4 = {
      narrow: [/^n/i, /^p/i, /^w/i, /^ś/i, /^c/i, /^p/i, /^s/i],
      abbreviated: [/^n/i, /^po/i, /^w/i, /^(ś|s)r/i, /^c/i, /^pt/i, /^so/i],
      any: [/^n/i, /^po/i, /^w/i, /^(ś|s)r/i, /^c/i, /^pi/i, /^so/i]
    };
    const matchDayPeriodPatterns$4 = {
      narrow: /^(^a$|^p$|pó(ł|l)n\.?|o\s*pó(ł|l)n\.?|po(ł|l)\.?|w\s*po(ł|l)\.?|po\s*po(ł|l)\.?|rano|wiecz\.?|noc|w\s*nocy)/i,
      any: /^(am|pm|pó(ł|l)noc|o\s*pó(ł|l)nocy|po(ł|l)udnie|w\s*po(ł|l)udnie|popo(ł|l)udnie|po\s*po(ł|l)udniu|rano|wieczór|wieczorem|noc|w\s*nocy)/i
    };
    const parseDayPeriodPatterns$4 = {
      narrow: {
        am: /^a$/i,
        pm: /^p$/i,
        midnight: /pó(ł|l)n/i,
        noon: /po(ł|l)/i,
        morning: /rano/i,
        afternoon: /po\s*po(ł|l)/i,
        evening: /wiecz/i,
        night: /noc/i
      },
      any: {
        am: /^am/i,
        pm: /^pm/i,
        midnight: /pó(ł|l)n/i,
        noon: /po(ł|l)/i,
        morning: /rano/i,
        afternoon: /po\s*po(ł|l)/i,
        evening: /wiecz/i,
        night: /noc/i
      }
    };
    const match$4 = {
      ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$4,
        parsePattern: parseOrdinalNumberPattern$4,
        valueCallback: (value2) => parseInt(value2, 10)
      }),
      era: buildMatchFn({
        matchPatterns: matchEraPatterns$4,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$4,
        defaultParseWidth: "any"
      }),
      quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$4,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$4,
        defaultParseWidth: "any",
        valueCallback: (index2) => index2 + 1
      }),
      month: buildMatchFn({
        matchPatterns: matchMonthPatterns$4,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$4,
        defaultParseWidth: "any"
      }),
      day: buildMatchFn({
        matchPatterns: matchDayPatterns$4,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$4,
        defaultParseWidth: "any"
      }),
      dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$4,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$4,
        defaultParseWidth: "any"
      })
    };
    const pl = {
      code: "pl",
      formatDistance: formatDistance$4,
      formatLong: formatLong$4,
      formatRelative: formatRelative$4,
      localize: localize$4,
      match: match$4,
      options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
      }
    };
    const formatDistanceLocale$3 = {
      lessThanXSeconds: {
        one: "menos de um segundo",
        other: "menos de {{count}} segundos"
      },
      xSeconds: {
        one: "1 segundo",
        other: "{{count}} segundos"
      },
      halfAMinute: "meio minuto",
      lessThanXMinutes: {
        one: "menos de um minuto",
        other: "menos de {{count}} minutos"
      },
      xMinutes: {
        one: "1 minuto",
        other: "{{count}} minutos"
      },
      aboutXHours: {
        one: "cerca de 1 hora",
        other: "cerca de {{count}} horas"
      },
      xHours: {
        one: "1 hora",
        other: "{{count}} horas"
      },
      xDays: {
        one: "1 dia",
        other: "{{count}} dias"
      },
      aboutXWeeks: {
        one: "cerca de 1 semana",
        other: "cerca de {{count}} semanas"
      },
      xWeeks: {
        one: "1 semana",
        other: "{{count}} semanas"
      },
      aboutXMonths: {
        one: "cerca de 1 mês",
        other: "cerca de {{count}} meses"
      },
      xMonths: {
        one: "1 mês",
        other: "{{count}} meses"
      },
      aboutXYears: {
        one: "cerca de 1 ano",
        other: "cerca de {{count}} anos"
      },
      xYears: {
        one: "1 ano",
        other: "{{count}} anos"
      },
      overXYears: {
        one: "mais de 1 ano",
        other: "mais de {{count}} anos"
      },
      almostXYears: {
        one: "quase 1 ano",
        other: "quase {{count}} anos"
      }
    };
    const formatDistance$3 = (token, count, options) => {
      let result;
      const tokenValue = formatDistanceLocale$3[token];
      if (typeof tokenValue === "string") {
        result = tokenValue;
      } else if (count === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace("{{count}}", String(count));
      }
      if (options?.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return "em " + result;
        } else {
          return "há " + result;
        }
      }
      return result;
    };
    const dateFormats$3 = {
      full: "EEEE, d 'de' MMMM 'de' y",
      long: "d 'de' MMMM 'de' y",
      medium: "d MMM y",
      short: "dd/MM/yyyy"
    };
    const timeFormats$3 = {
      full: "HH:mm:ss zzzz",
      long: "HH:mm:ss z",
      medium: "HH:mm:ss",
      short: "HH:mm"
    };
    const dateTimeFormats$3 = {
      full: "{{date}} 'às' {{time}}",
      long: "{{date}} 'às' {{time}}",
      medium: "{{date}}, {{time}}",
      short: "{{date}}, {{time}}"
    };
    const formatLong$3 = {
      date: buildFormatLongFn({
        formats: dateFormats$3,
        defaultWidth: "full"
      }),
      time: buildFormatLongFn({
        formats: timeFormats$3,
        defaultWidth: "full"
      }),
      dateTime: buildFormatLongFn({
        formats: dateTimeFormats$3,
        defaultWidth: "full"
      })
    };
    const formatRelativeLocale$3 = {
      lastWeek: (date) => {
        const weekday = date.getDay();
        const last = weekday === 0 || weekday === 6 ? "último" : "última";
        return "'" + last + "' eeee 'às' p";
      },
      yesterday: "'ontem às' p",
      today: "'hoje às' p",
      tomorrow: "'amanhã às' p",
      nextWeek: "eeee 'às' p",
      other: "P"
    };
    const formatRelative$3 = (token, date, _baseDate, _options) => {
      const format2 = formatRelativeLocale$3[token];
      if (typeof format2 === "function") {
        return format2(date);
      }
      return format2;
    };
    const eraValues$3 = {
      narrow: ["AC", "DC"],
      abbreviated: ["AC", "DC"],
      wide: ["antes de cristo", "depois de cristo"]
    };
    const quarterValues$3 = {
      narrow: ["1", "2", "3", "4"],
      abbreviated: ["T1", "T2", "T3", "T4"],
      wide: ["1º trimestre", "2º trimestre", "3º trimestre", "4º trimestre"]
    };
    const monthValues$3 = {
      narrow: ["j", "f", "m", "a", "m", "j", "j", "a", "s", "o", "n", "d"],
      abbreviated: [
        "jan",
        "fev",
        "mar",
        "abr",
        "mai",
        "jun",
        "jul",
        "ago",
        "set",
        "out",
        "nov",
        "dez"
      ],
      wide: [
        "janeiro",
        "fevereiro",
        "março",
        "abril",
        "maio",
        "junho",
        "julho",
        "agosto",
        "setembro",
        "outubro",
        "novembro",
        "dezembro"
      ]
    };
    const dayValues$3 = {
      narrow: ["D", "S", "T", "Q", "Q", "S", "S"],
      short: ["dom", "seg", "ter", "qua", "qui", "sex", "sab"],
      abbreviated: [
        "domingo",
        "segunda",
        "terça",
        "quarta",
        "quinta",
        "sexta",
        "sábado"
      ],
      wide: [
        "domingo",
        "segunda-feira",
        "terça-feira",
        "quarta-feira",
        "quinta-feira",
        "sexta-feira",
        "sábado"
      ]
    };
    const dayPeriodValues$3 = {
      narrow: {
        am: "a",
        pm: "p",
        midnight: "mn",
        noon: "md",
        morning: "manhã",
        afternoon: "tarde",
        evening: "tarde",
        night: "noite"
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "meia-noite",
        noon: "meio-dia",
        morning: "manhã",
        afternoon: "tarde",
        evening: "tarde",
        night: "noite"
      },
      wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "meia-noite",
        noon: "meio-dia",
        morning: "manhã",
        afternoon: "tarde",
        evening: "tarde",
        night: "noite"
      }
    };
    const formattingDayPeriodValues$3 = {
      narrow: {
        am: "a",
        pm: "p",
        midnight: "mn",
        noon: "md",
        morning: "da manhã",
        afternoon: "da tarde",
        evening: "da tarde",
        night: "da noite"
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "meia-noite",
        noon: "meio-dia",
        morning: "da manhã",
        afternoon: "da tarde",
        evening: "da tarde",
        night: "da noite"
      },
      wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "meia-noite",
        noon: "meio-dia",
        morning: "da manhã",
        afternoon: "da tarde",
        evening: "da tarde",
        night: "da noite"
      }
    };
    const ordinalNumber$3 = (dirtyNumber, options) => {
      const number = Number(dirtyNumber);
      if (options?.unit === "week") {
        return number + "ª";
      }
      return number + "º";
    };
    const localize$3 = {
      ordinalNumber: ordinalNumber$3,
      era: buildLocalizeFn({
        values: eraValues$3,
        defaultWidth: "wide"
      }),
      quarter: buildLocalizeFn({
        values: quarterValues$3,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
      }),
      month: buildLocalizeFn({
        values: monthValues$3,
        defaultWidth: "wide"
      }),
      day: buildLocalizeFn({
        values: dayValues$3,
        defaultWidth: "wide"
      }),
      dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$3,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$3,
        defaultFormattingWidth: "wide"
      })
    };
    const matchOrdinalNumberPattern$3 = /^(\d+)[ºªo]?/i;
    const parseOrdinalNumberPattern$3 = /\d+/i;
    const matchEraPatterns$3 = {
      narrow: /^(ac|dc|a|d)/i,
      abbreviated: /^(a\.?\s?c\.?|d\.?\s?c\.?)/i,
      wide: /^(antes de cristo|depois de cristo)/i
    };
    const parseEraPatterns$3 = {
      any: [/^ac/i, /^dc/i],
      wide: [/^antes de cristo/i, /^depois de cristo/i]
    };
    const matchQuarterPatterns$3 = {
      narrow: /^[1234]/i,
      abbreviated: /^T[1234]/i,
      wide: /^[1234](º)? trimestre/i
    };
    const parseQuarterPatterns$3 = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    const matchMonthPatterns$3 = {
      narrow: /^[jfmajsond]/i,
      abbreviated: /^(jan|fev|mar|abr|mai|jun|jul|ago|set|out|nov|dez)/i,
      wide: /^(janeiro|fevereiro|março|abril|maio|junho|julho|agosto|setembro|outubro|novembro|dezembro)/i
    };
    const parseMonthPatterns$3 = {
      narrow: [
        /^j/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
      ],
      any: [
        /^ja/i,
        /^fev/i,
        /^mar/i,
        /^abr/i,
        /^mai/i,
        /^jun/i,
        /^jul/i,
        /^ago/i,
        /^set/i,
        /^out/i,
        /^nov/i,
        /^dez/i
      ]
    };
    const matchDayPatterns$3 = {
      narrow: /^(dom|[23456]ª?|s[aá]b)/i,
      short: /^(dom|[23456]ª?|s[aá]b)/i,
      abbreviated: /^(dom|seg|ter|qua|qui|sex|s[aá]b)/i,
      wide: /^(domingo|(segunda|ter[cç]a|quarta|quinta|sexta)([- ]feira)?|s[aá]bado)/i
    };
    const parseDayPatterns$3 = {
      short: [/^d/i, /^2/i, /^3/i, /^4/i, /^5/i, /^6/i, /^s[aá]/i],
      narrow: [/^d/i, /^2/i, /^3/i, /^4/i, /^5/i, /^6/i, /^s[aá]/i],
      any: [/^d/i, /^seg/i, /^t/i, /^qua/i, /^qui/i, /^sex/i, /^s[aá]b/i]
    };
    const matchDayPeriodPatterns$3 = {
      narrow: /^(a|p|mn|md|(da) (manhã|tarde|noite))/i,
      any: /^([ap]\.?\s?m\.?|meia[-\s]noite|meio[-\s]dia|(da) (manhã|tarde|noite))/i
    };
    const parseDayPeriodPatterns$3 = {
      any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mn|^meia[-\s]noite/i,
        noon: /^md|^meio[-\s]dia/i,
        morning: /manhã/i,
        afternoon: /tarde/i,
        evening: /tarde/i,
        night: /noite/i
      }
    };
    const match$3 = {
      ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$3,
        parsePattern: parseOrdinalNumberPattern$3,
        valueCallback: (value2) => parseInt(value2, 10)
      }),
      era: buildMatchFn({
        matchPatterns: matchEraPatterns$3,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$3,
        defaultParseWidth: "any"
      }),
      quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$3,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$3,
        defaultParseWidth: "any",
        valueCallback: (index2) => index2 + 1
      }),
      month: buildMatchFn({
        matchPatterns: matchMonthPatterns$3,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$3,
        defaultParseWidth: "any"
      }),
      day: buildMatchFn({
        matchPatterns: matchDayPatterns$3,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$3,
        defaultParseWidth: "any"
      }),
      dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$3,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$3,
        defaultParseWidth: "any"
      })
    };
    const ptBR = {
      code: "pt-BR",
      formatDistance: formatDistance$3,
      formatLong: formatLong$3,
      formatRelative: formatRelative$3,
      localize: localize$3,
      match: match$3,
      options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
      }
    };
    function declension(scheme, count) {
      if (scheme.one !== void 0 && count === 1) {
        return scheme.one;
      }
      const rem10 = count % 10;
      const rem100 = count % 100;
      if (rem10 === 1 && rem100 !== 11) {
        return scheme.singularNominative.replace("{{count}}", String(count));
      } else if (rem10 >= 2 && rem10 <= 4 && (rem100 < 10 || rem100 > 20)) {
        return scheme.singularGenitive.replace("{{count}}", String(count));
      } else {
        return scheme.pluralGenitive.replace("{{count}}", String(count));
      }
    }
    function buildLocalizeTokenFn(scheme) {
      return (count, options) => {
        if (options?.addSuffix) {
          if (options.comparison && options.comparison > 0) {
            if (scheme.future) {
              return declension(scheme.future, count);
            } else {
              return "через " + declension(scheme.regular, count);
            }
          } else {
            if (scheme.past) {
              return declension(scheme.past, count);
            } else {
              return declension(scheme.regular, count) + " назад";
            }
          }
        } else {
          return declension(scheme.regular, count);
        }
      };
    }
    const formatDistanceLocale$2 = {
      lessThanXSeconds: buildLocalizeTokenFn({
        regular: {
          one: "меньше секунды",
          singularNominative: "меньше {{count}} секунды",
          singularGenitive: "меньше {{count}} секунд",
          pluralGenitive: "меньше {{count}} секунд"
        },
        future: {
          one: "меньше, чем через секунду",
          singularNominative: "меньше, чем через {{count}} секунду",
          singularGenitive: "меньше, чем через {{count}} секунды",
          pluralGenitive: "меньше, чем через {{count}} секунд"
        }
      }),
      xSeconds: buildLocalizeTokenFn({
        regular: {
          singularNominative: "{{count}} секунда",
          singularGenitive: "{{count}} секунды",
          pluralGenitive: "{{count}} секунд"
        },
        past: {
          singularNominative: "{{count}} секунду назад",
          singularGenitive: "{{count}} секунды назад",
          pluralGenitive: "{{count}} секунд назад"
        },
        future: {
          singularNominative: "через {{count}} секунду",
          singularGenitive: "через {{count}} секунды",
          pluralGenitive: "через {{count}} секунд"
        }
      }),
      halfAMinute: (_count, options) => {
        if (options?.addSuffix) {
          if (options.comparison && options.comparison > 0) {
            return "через полминуты";
          } else {
            return "полминуты назад";
          }
        }
        return "полминуты";
      },
      lessThanXMinutes: buildLocalizeTokenFn({
        regular: {
          one: "меньше минуты",
          singularNominative: "меньше {{count}} минуты",
          singularGenitive: "меньше {{count}} минут",
          pluralGenitive: "меньше {{count}} минут"
        },
        future: {
          one: "меньше, чем через минуту",
          singularNominative: "меньше, чем через {{count}} минуту",
          singularGenitive: "меньше, чем через {{count}} минуты",
          pluralGenitive: "меньше, чем через {{count}} минут"
        }
      }),
      xMinutes: buildLocalizeTokenFn({
        regular: {
          singularNominative: "{{count}} минута",
          singularGenitive: "{{count}} минуты",
          pluralGenitive: "{{count}} минут"
        },
        past: {
          singularNominative: "{{count}} минуту назад",
          singularGenitive: "{{count}} минуты назад",
          pluralGenitive: "{{count}} минут назад"
        },
        future: {
          singularNominative: "через {{count}} минуту",
          singularGenitive: "через {{count}} минуты",
          pluralGenitive: "через {{count}} минут"
        }
      }),
      aboutXHours: buildLocalizeTokenFn({
        regular: {
          singularNominative: "около {{count}} часа",
          singularGenitive: "около {{count}} часов",
          pluralGenitive: "около {{count}} часов"
        },
        future: {
          singularNominative: "приблизительно через {{count}} час",
          singularGenitive: "приблизительно через {{count}} часа",
          pluralGenitive: "приблизительно через {{count}} часов"
        }
      }),
      xHours: buildLocalizeTokenFn({
        regular: {
          singularNominative: "{{count}} час",
          singularGenitive: "{{count}} часа",
          pluralGenitive: "{{count}} часов"
        }
      }),
      xDays: buildLocalizeTokenFn({
        regular: {
          singularNominative: "{{count}} день",
          singularGenitive: "{{count}} дня",
          pluralGenitive: "{{count}} дней"
        }
      }),
      aboutXWeeks: buildLocalizeTokenFn({
        regular: {
          singularNominative: "около {{count}} недели",
          singularGenitive: "около {{count}} недель",
          pluralGenitive: "около {{count}} недель"
        },
        future: {
          singularNominative: "приблизительно через {{count}} неделю",
          singularGenitive: "приблизительно через {{count}} недели",
          pluralGenitive: "приблизительно через {{count}} недель"
        }
      }),
      xWeeks: buildLocalizeTokenFn({
        regular: {
          singularNominative: "{{count}} неделя",
          singularGenitive: "{{count}} недели",
          pluralGenitive: "{{count}} недель"
        }
      }),
      aboutXMonths: buildLocalizeTokenFn({
        regular: {
          singularNominative: "около {{count}} месяца",
          singularGenitive: "около {{count}} месяцев",
          pluralGenitive: "около {{count}} месяцев"
        },
        future: {
          singularNominative: "приблизительно через {{count}} месяц",
          singularGenitive: "приблизительно через {{count}} месяца",
          pluralGenitive: "приблизительно через {{count}} месяцев"
        }
      }),
      xMonths: buildLocalizeTokenFn({
        regular: {
          singularNominative: "{{count}} месяц",
          singularGenitive: "{{count}} месяца",
          pluralGenitive: "{{count}} месяцев"
        }
      }),
      aboutXYears: buildLocalizeTokenFn({
        regular: {
          singularNominative: "около {{count}} года",
          singularGenitive: "около {{count}} лет",
          pluralGenitive: "около {{count}} лет"
        },
        future: {
          singularNominative: "приблизительно через {{count}} год",
          singularGenitive: "приблизительно через {{count}} года",
          pluralGenitive: "приблизительно через {{count}} лет"
        }
      }),
      xYears: buildLocalizeTokenFn({
        regular: {
          singularNominative: "{{count}} год",
          singularGenitive: "{{count}} года",
          pluralGenitive: "{{count}} лет"
        }
      }),
      overXYears: buildLocalizeTokenFn({
        regular: {
          singularNominative: "больше {{count}} года",
          singularGenitive: "больше {{count}} лет",
          pluralGenitive: "больше {{count}} лет"
        },
        future: {
          singularNominative: "больше, чем через {{count}} год",
          singularGenitive: "больше, чем через {{count}} года",
          pluralGenitive: "больше, чем через {{count}} лет"
        }
      }),
      almostXYears: buildLocalizeTokenFn({
        regular: {
          singularNominative: "почти {{count}} год",
          singularGenitive: "почти {{count}} года",
          pluralGenitive: "почти {{count}} лет"
        },
        future: {
          singularNominative: "почти через {{count}} год",
          singularGenitive: "почти через {{count}} года",
          pluralGenitive: "почти через {{count}} лет"
        }
      })
    };
    const formatDistance$2 = (token, count, options) => {
      return formatDistanceLocale$2[token](count, options);
    };
    const dateFormats$2 = {
      full: "EEEE, d MMMM y 'г.'",
      long: "d MMMM y 'г.'",
      medium: "d MMM y 'г.'",
      short: "dd.MM.y"
    };
    const timeFormats$2 = {
      full: "H:mm:ss zzzz",
      long: "H:mm:ss z",
      medium: "H:mm:ss",
      short: "H:mm"
    };
    const dateTimeFormats$2 = {
      any: "{{date}}, {{time}}"
    };
    const formatLong$2 = {
      date: buildFormatLongFn({
        formats: dateFormats$2,
        defaultWidth: "full"
      }),
      time: buildFormatLongFn({
        formats: timeFormats$2,
        defaultWidth: "full"
      }),
      dateTime: buildFormatLongFn({
        formats: dateTimeFormats$2,
        defaultWidth: "any"
      })
    };
    const accusativeWeekdays = [
      "воскресенье",
      "понедельник",
      "вторник",
      "среду",
      "четверг",
      "пятницу",
      "субботу"
    ];
    function lastWeek(day) {
      const weekday = accusativeWeekdays[day];
      switch (day) {
        case 0:
          return "'в прошлое " + weekday + " в' p";
        case 1:
        case 2:
        case 4:
          return "'в прошлый " + weekday + " в' p";
        case 3:
        case 5:
        case 6:
          return "'в прошлую " + weekday + " в' p";
      }
    }
    function thisWeek(day) {
      const weekday = accusativeWeekdays[day];
      if (day === 2) {
        return "'во " + weekday + " в' p";
      } else {
        return "'в " + weekday + " в' p";
      }
    }
    function nextWeek(day) {
      const weekday = accusativeWeekdays[day];
      switch (day) {
        case 0:
          return "'в следующее " + weekday + " в' p";
        case 1:
        case 2:
        case 4:
          return "'в следующий " + weekday + " в' p";
        case 3:
        case 5:
        case 6:
          return "'в следующую " + weekday + " в' p";
      }
    }
    const formatRelativeLocale$2 = {
      lastWeek: (date, baseDate, options) => {
        const day = date.getDay();
        if (isSameWeek(date, baseDate, options)) {
          return thisWeek(day);
        } else {
          return lastWeek(day);
        }
      },
      yesterday: "'вчера в' p",
      today: "'сегодня в' p",
      tomorrow: "'завтра в' p",
      nextWeek: (date, baseDate, options) => {
        const day = date.getDay();
        if (isSameWeek(date, baseDate, options)) {
          return thisWeek(day);
        } else {
          return nextWeek(day);
        }
      },
      other: "P"
    };
    const formatRelative$2 = (token, date, baseDate, options) => {
      const format2 = formatRelativeLocale$2[token];
      if (typeof format2 === "function") {
        return format2(date, baseDate, options);
      }
      return format2;
    };
    const eraValues$2 = {
      narrow: ["до н.э.", "н.э."],
      abbreviated: ["до н. э.", "н. э."],
      wide: ["до нашей эры", "нашей эры"]
    };
    const quarterValues$2 = {
      narrow: ["1", "2", "3", "4"],
      abbreviated: ["1-й кв.", "2-й кв.", "3-й кв.", "4-й кв."],
      wide: ["1-й квартал", "2-й квартал", "3-й квартал", "4-й квартал"]
    };
    const monthValues$2 = {
      narrow: ["Я", "Ф", "М", "А", "М", "И", "И", "А", "С", "О", "Н", "Д"],
      abbreviated: [
        "янв.",
        "фев.",
        "март",
        "апр.",
        "май",
        "июнь",
        "июль",
        "авг.",
        "сент.",
        "окт.",
        "нояб.",
        "дек."
      ],
      wide: [
        "январь",
        "февраль",
        "март",
        "апрель",
        "май",
        "июнь",
        "июль",
        "август",
        "сентябрь",
        "октябрь",
        "ноябрь",
        "декабрь"
      ]
    };
    const formattingMonthValues = {
      narrow: ["Я", "Ф", "М", "А", "М", "И", "И", "А", "С", "О", "Н", "Д"],
      abbreviated: [
        "янв.",
        "фев.",
        "мар.",
        "апр.",
        "мая",
        "июн.",
        "июл.",
        "авг.",
        "сент.",
        "окт.",
        "нояб.",
        "дек."
      ],
      wide: [
        "января",
        "февраля",
        "марта",
        "апреля",
        "мая",
        "июня",
        "июля",
        "августа",
        "сентября",
        "октября",
        "ноября",
        "декабря"
      ]
    };
    const dayValues$2 = {
      narrow: ["В", "П", "В", "С", "Ч", "П", "С"],
      short: ["вс", "пн", "вт", "ср", "чт", "пт", "сб"],
      abbreviated: ["вск", "пнд", "втр", "срд", "чтв", "птн", "суб"],
      wide: [
        "воскресенье",
        "понедельник",
        "вторник",
        "среда",
        "четверг",
        "пятница",
        "суббота"
      ]
    };
    const dayPeriodValues$2 = {
      narrow: {
        am: "ДП",
        pm: "ПП",
        midnight: "полн.",
        noon: "полд.",
        morning: "утро",
        afternoon: "день",
        evening: "веч.",
        night: "ночь"
      },
      abbreviated: {
        am: "ДП",
        pm: "ПП",
        midnight: "полн.",
        noon: "полд.",
        morning: "утро",
        afternoon: "день",
        evening: "веч.",
        night: "ночь"
      },
      wide: {
        am: "ДП",
        pm: "ПП",
        midnight: "полночь",
        noon: "полдень",
        morning: "утро",
        afternoon: "день",
        evening: "вечер",
        night: "ночь"
      }
    };
    const formattingDayPeriodValues$2 = {
      narrow: {
        am: "ДП",
        pm: "ПП",
        midnight: "полн.",
        noon: "полд.",
        morning: "утра",
        afternoon: "дня",
        evening: "веч.",
        night: "ночи"
      },
      abbreviated: {
        am: "ДП",
        pm: "ПП",
        midnight: "полн.",
        noon: "полд.",
        morning: "утра",
        afternoon: "дня",
        evening: "веч.",
        night: "ночи"
      },
      wide: {
        am: "ДП",
        pm: "ПП",
        midnight: "полночь",
        noon: "полдень",
        morning: "утра",
        afternoon: "дня",
        evening: "вечера",
        night: "ночи"
      }
    };
    const ordinalNumber$2 = (dirtyNumber, options) => {
      const number = Number(dirtyNumber);
      const unit = options?.unit;
      let suffix;
      if (unit === "date") {
        suffix = "-е";
      } else if (unit === "week" || unit === "minute" || unit === "second") {
        suffix = "-я";
      } else {
        suffix = "-й";
      }
      return number + suffix;
    };
    const localize$2 = {
      ordinalNumber: ordinalNumber$2,
      era: buildLocalizeFn({
        values: eraValues$2,
        defaultWidth: "wide"
      }),
      quarter: buildLocalizeFn({
        values: quarterValues$2,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
      }),
      month: buildLocalizeFn({
        values: monthValues$2,
        defaultWidth: "wide",
        formattingValues: formattingMonthValues,
        defaultFormattingWidth: "wide"
      }),
      day: buildLocalizeFn({
        values: dayValues$2,
        defaultWidth: "wide"
      }),
      dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$2,
        defaultWidth: "any",
        formattingValues: formattingDayPeriodValues$2,
        defaultFormattingWidth: "wide"
      })
    };
    const matchOrdinalNumberPattern$2 = /^(\d+)(-?(е|я|й|ое|ье|ая|ья|ый|ой|ий|ый))?/i;
    const parseOrdinalNumberPattern$2 = /\d+/i;
    const matchEraPatterns$2 = {
      narrow: /^((до )?н\.?\s?э\.?)/i,
      abbreviated: /^((до )?н\.?\s?э\.?)/i,
      wide: /^(до нашей эры|нашей эры|наша эра)/i
    };
    const parseEraPatterns$2 = {
      any: [/^д/i, /^н/i]
    };
    const matchQuarterPatterns$2 = {
      narrow: /^[1234]/i,
      abbreviated: /^[1234](-?[ыои]?й?)? кв.?/i,
      wide: /^[1234](-?[ыои]?й?)? квартал/i
    };
    const parseQuarterPatterns$2 = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    const matchMonthPatterns$2 = {
      narrow: /^[яфмаисонд]/i,
      abbreviated: /^(янв|фев|март?|апр|ма[йя]|июн[ья]?|июл[ья]?|авг|сент?|окт|нояб?|дек)\.?/i,
      wide: /^(январ[ья]|феврал[ья]|марта?|апрел[ья]|ма[йя]|июн[ья]|июл[ья]|августа?|сентябр[ья]|октябр[ья]|октябр[ья]|ноябр[ья]|декабр[ья])/i
    };
    const parseMonthPatterns$2 = {
      narrow: [
        /^я/i,
        /^ф/i,
        /^м/i,
        /^а/i,
        /^м/i,
        /^и/i,
        /^и/i,
        /^а/i,
        /^с/i,
        /^о/i,
        /^н/i,
        /^я/i
      ],
      any: [
        /^я/i,
        /^ф/i,
        /^мар/i,
        /^ап/i,
        /^ма[йя]/i,
        /^июн/i,
        /^июл/i,
        /^ав/i,
        /^с/i,
        /^о/i,
        /^н/i,
        /^д/i
      ]
    };
    const matchDayPatterns$2 = {
      narrow: /^[впсч]/i,
      short: /^(вс|во|пн|по|вт|ср|чт|че|пт|пя|сб|су)\.?/i,
      abbreviated: /^(вск|вос|пнд|пон|втр|вто|срд|сре|чтв|чет|птн|пят|суб).?/i,
      wide: /^(воскресень[ея]|понедельника?|вторника?|сред[аы]|четверга?|пятниц[аы]|суббот[аы])/i
    };
    const parseDayPatterns$2 = {
      narrow: [/^в/i, /^п/i, /^в/i, /^с/i, /^ч/i, /^п/i, /^с/i],
      any: [/^в[ос]/i, /^п[он]/i, /^в/i, /^ср/i, /^ч/i, /^п[ят]/i, /^с[уб]/i]
    };
    const matchDayPeriodPatterns$2 = {
      narrow: /^([дп]п|полн\.?|полд\.?|утр[оа]|день|дня|веч\.?|ноч[ьи])/i,
      abbreviated: /^([дп]п|полн\.?|полд\.?|утр[оа]|день|дня|веч\.?|ноч[ьи])/i,
      wide: /^([дп]п|полночь|полдень|утр[оа]|день|дня|вечера?|ноч[ьи])/i
    };
    const parseDayPeriodPatterns$2 = {
      any: {
        am: /^дп/i,
        pm: /^пп/i,
        midnight: /^полн/i,
        noon: /^полд/i,
        morning: /^у/i,
        afternoon: /^д[ен]/i,
        evening: /^в/i,
        night: /^н/i
      }
    };
    const match$2 = {
      ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$2,
        parsePattern: parseOrdinalNumberPattern$2,
        valueCallback: (value2) => parseInt(value2, 10)
      }),
      era: buildMatchFn({
        matchPatterns: matchEraPatterns$2,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$2,
        defaultParseWidth: "any"
      }),
      quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$2,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$2,
        defaultParseWidth: "any",
        valueCallback: (index2) => index2 + 1
      }),
      month: buildMatchFn({
        matchPatterns: matchMonthPatterns$2,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$2,
        defaultParseWidth: "any"
      }),
      day: buildMatchFn({
        matchPatterns: matchDayPatterns$2,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$2,
        defaultParseWidth: "any"
      }),
      dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$2,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPeriodPatterns$2,
        defaultParseWidth: "any"
      })
    };
    const ru = {
      code: "ru",
      formatDistance: formatDistance$2,
      formatLong: formatLong$2,
      formatRelative: formatRelative$2,
      localize: localize$2,
      match: match$2,
      options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 1
      }
    };
    const formatDistanceLocale$1 = {
      lessThanXSeconds: {
        one: "bir saniyeden az",
        other: "{{count}} saniyeden az"
      },
      xSeconds: {
        one: "1 saniye",
        other: "{{count}} saniye"
      },
      halfAMinute: "yarım dakika",
      lessThanXMinutes: {
        one: "bir dakikadan az",
        other: "{{count}} dakikadan az"
      },
      xMinutes: {
        one: "1 dakika",
        other: "{{count}} dakika"
      },
      aboutXHours: {
        one: "yaklaşık 1 saat",
        other: "yaklaşık {{count}} saat"
      },
      xHours: {
        one: "1 saat",
        other: "{{count}} saat"
      },
      xDays: {
        one: "1 gün",
        other: "{{count}} gün"
      },
      aboutXWeeks: {
        one: "yaklaşık 1 hafta",
        other: "yaklaşık {{count}} hafta"
      },
      xWeeks: {
        one: "1 hafta",
        other: "{{count}} hafta"
      },
      aboutXMonths: {
        one: "yaklaşık 1 ay",
        other: "yaklaşık {{count}} ay"
      },
      xMonths: {
        one: "1 ay",
        other: "{{count}} ay"
      },
      aboutXYears: {
        one: "yaklaşık 1 yıl",
        other: "yaklaşık {{count}} yıl"
      },
      xYears: {
        one: "1 yıl",
        other: "{{count}} yıl"
      },
      overXYears: {
        one: "1 yıldan fazla",
        other: "{{count}} yıldan fazla"
      },
      almostXYears: {
        one: "neredeyse 1 yıl",
        other: "neredeyse {{count}} yıl"
      }
    };
    const formatDistance$1 = (token, count, options) => {
      let result;
      const tokenValue = formatDistanceLocale$1[token];
      if (typeof tokenValue === "string") {
        result = tokenValue;
      } else if (count === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace("{{count}}", count.toString());
      }
      if (options?.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return result + " sonra";
        } else {
          return result + " önce";
        }
      }
      return result;
    };
    const dateFormats$1 = {
      full: "d MMMM y EEEE",
      long: "d MMMM y",
      medium: "d MMM y",
      short: "dd.MM.yyyy"
    };
    const timeFormats$1 = {
      full: "HH:mm:ss zzzz",
      long: "HH:mm:ss z",
      medium: "HH:mm:ss",
      short: "HH:mm"
    };
    const dateTimeFormats$1 = {
      full: "{{date}} 'saat' {{time}}",
      long: "{{date}} 'saat' {{time}}",
      medium: "{{date}}, {{time}}",
      short: "{{date}}, {{time}}"
    };
    const formatLong$1 = {
      date: buildFormatLongFn({
        formats: dateFormats$1,
        defaultWidth: "full"
      }),
      time: buildFormatLongFn({
        formats: timeFormats$1,
        defaultWidth: "full"
      }),
      dateTime: buildFormatLongFn({
        formats: dateTimeFormats$1,
        defaultWidth: "full"
      })
    };
    const formatRelativeLocale$1 = {
      lastWeek: "'geçen hafta' eeee 'saat' p",
      yesterday: "'dün saat' p",
      today: "'bugün saat' p",
      tomorrow: "'yarın saat' p",
      nextWeek: "eeee 'saat' p",
      other: "P"
    };
    const formatRelative$1 = (token, _date, _baseDate, _options) => formatRelativeLocale$1[token];
    const eraValues$1 = {
      narrow: ["MÖ", "MS"],
      abbreviated: ["MÖ", "MS"],
      wide: ["Milattan Önce", "Milattan Sonra"]
    };
    const quarterValues$1 = {
      narrow: ["1", "2", "3", "4"],
      abbreviated: ["1Ç", "2Ç", "3Ç", "4Ç"],
      wide: ["İlk çeyrek", "İkinci Çeyrek", "Üçüncü çeyrek", "Son çeyrek"]
    };
    const monthValues$1 = {
      narrow: ["O", "Ş", "M", "N", "M", "H", "T", "A", "E", "E", "K", "A"],
      abbreviated: [
        "Oca",
        "Şub",
        "Mar",
        "Nis",
        "May",
        "Haz",
        "Tem",
        "Ağu",
        "Eyl",
        "Eki",
        "Kas",
        "Ara"
      ],
      wide: [
        "Ocak",
        "Şubat",
        "Mart",
        "Nisan",
        "Mayıs",
        "Haziran",
        "Temmuz",
        "Ağustos",
        "Eylül",
        "Ekim",
        "Kasım",
        "Aralık"
      ]
    };
    const dayValues$1 = {
      narrow: ["P", "P", "S", "Ç", "P", "C", "C"],
      short: ["Pz", "Pt", "Sa", "Ça", "Pe", "Cu", "Ct"],
      abbreviated: ["Paz", "Pzt", "Sal", "Çar", "Per", "Cum", "Cts"],
      wide: [
        "Pazar",
        "Pazartesi",
        "Salı",
        "Çarşamba",
        "Perşembe",
        "Cuma",
        "Cumartesi"
      ]
    };
    const dayPeriodValues$1 = {
      narrow: {
        am: "öö",
        pm: "ös",
        midnight: "gy",
        noon: "ö",
        morning: "sa",
        afternoon: "ös",
        evening: "ak",
        night: "ge"
      },
      abbreviated: {
        am: "ÖÖ",
        pm: "ÖS",
        midnight: "gece yarısı",
        noon: "öğle",
        morning: "sabah",
        afternoon: "öğleden sonra",
        evening: "akşam",
        night: "gece"
      },
      wide: {
        am: "Ö.Ö.",
        pm: "Ö.S.",
        midnight: "gece yarısı",
        noon: "öğle",
        morning: "sabah",
        afternoon: "öğleden sonra",
        evening: "akşam",
        night: "gece"
      }
    };
    const formattingDayPeriodValues$1 = {
      narrow: {
        am: "öö",
        pm: "ös",
        midnight: "gy",
        noon: "ö",
        morning: "sa",
        afternoon: "ös",
        evening: "ak",
        night: "ge"
      },
      abbreviated: {
        am: "ÖÖ",
        pm: "ÖS",
        midnight: "gece yarısı",
        noon: "öğlen",
        morning: "sabahleyin",
        afternoon: "öğleden sonra",
        evening: "akşamleyin",
        night: "geceleyin"
      },
      wide: {
        am: "ö.ö.",
        pm: "ö.s.",
        midnight: "gece yarısı",
        noon: "öğlen",
        morning: "sabahleyin",
        afternoon: "öğleden sonra",
        evening: "akşamleyin",
        night: "geceleyin"
      }
    };
    const ordinalNumber$1 = (dirtyNumber, _options) => {
      const number = Number(dirtyNumber);
      return number + ".";
    };
    const localize$1 = {
      ordinalNumber: ordinalNumber$1,
      era: buildLocalizeFn({
        values: eraValues$1,
        defaultWidth: "wide"
      }),
      quarter: buildLocalizeFn({
        values: quarterValues$1,
        defaultWidth: "wide",
        argumentCallback: (quarter) => Number(quarter) - 1
      }),
      month: buildLocalizeFn({
        values: monthValues$1,
        defaultWidth: "wide"
      }),
      day: buildLocalizeFn({
        values: dayValues$1,
        defaultWidth: "wide"
      }),
      dayPeriod: buildLocalizeFn({
        values: dayPeriodValues$1,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues$1,
        defaultFormattingWidth: "wide"
      })
    };
    const matchOrdinalNumberPattern$1 = /^(\d+)(\.)?/i;
    const parseOrdinalNumberPattern$1 = /\d+/i;
    const matchEraPatterns$1 = {
      narrow: /^(mö|ms)/i,
      abbreviated: /^(mö|ms)/i,
      wide: /^(milattan önce|milattan sonra)/i
    };
    const parseEraPatterns$1 = {
      any: [/(^mö|^milattan önce)/i, /(^ms|^milattan sonra)/i]
    };
    const matchQuarterPatterns$1 = {
      narrow: /^[1234]/i,
      abbreviated: /^[1234]ç/i,
      wide: /^((i|İ)lk|(i|İ)kinci|üçüncü|son) çeyrek/i
    };
    const parseQuarterPatterns$1 = {
      any: [/1/i, /2/i, /3/i, /4/i],
      abbreviated: [/1ç/i, /2ç/i, /3ç/i, /4ç/i],
      wide: [
        /^(i|İ)lk çeyrek/i,
        /(i|İ)kinci çeyrek/i,
        /üçüncü çeyrek/i,
        /son çeyrek/i
      ]
    };
    const matchMonthPatterns$1 = {
      narrow: /^[oşmnhtaek]/i,
      abbreviated: /^(oca|şub|mar|nis|may|haz|tem|ağu|eyl|eki|kas|ara)/i,
      wide: /^(ocak|şubat|mart|nisan|mayıs|haziran|temmuz|ağustos|eylül|ekim|kasım|aralık)/i
    };
    const parseMonthPatterns$1 = {
      narrow: [
        /^o/i,
        /^ş/i,
        /^m/i,
        /^n/i,
        /^m/i,
        /^h/i,
        /^t/i,
        /^a/i,
        /^e/i,
        /^e/i,
        /^k/i,
        /^a/i
      ],
      any: [
        /^o/i,
        /^ş/i,
        /^mar/i,
        /^n/i,
        /^may/i,
        /^h/i,
        /^t/i,
        /^ağ/i,
        /^ey/i,
        /^ek/i,
        /^k/i,
        /^ar/i
      ]
    };
    const matchDayPatterns$1 = {
      narrow: /^[psçc]/i,
      short: /^(pz|pt|sa|ça|pe|cu|ct)/i,
      abbreviated: /^(paz|pzt|sal|çar|per|cum|cts)/i,
      wide: /^(pazar(?!tesi)|pazartesi|salı|çarşamba|perşembe|cuma(?!rtesi)|cumartesi)/i
    };
    const parseDayPatterns$1 = {
      narrow: [/^p/i, /^p/i, /^s/i, /^ç/i, /^p/i, /^c/i, /^c/i],
      any: [/^pz/i, /^pt/i, /^sa/i, /^ça/i, /^pe/i, /^cu/i, /^ct/i],
      wide: [
        /^pazar(?!tesi)/i,
        /^pazartesi/i,
        /^salı/i,
        /^çarşamba/i,
        /^perşembe/i,
        /^cuma(?!rtesi)/i,
        /^cumartesi/i
      ]
    };
    const matchDayPeriodPatterns$1 = {
      narrow: /^(öö|ös|gy|ö|sa|ös|ak|ge)/i,
      any: /^(ö\.?\s?[ös]\.?|öğleden sonra|gece yarısı|öğle|(sabah|öğ|akşam|gece)(leyin))/i
    };
    const parseDayPeriodPatterns$1 = {
      any: {
        am: /^ö\.?ö\.?/i,
        pm: /^ö\.?s\.?/i,
        midnight: /^(gy|gece yarısı)/i,
        noon: /^öğ/i,
        morning: /^sa/i,
        afternoon: /^öğleden sonra/i,
        evening: /^ak/i,
        night: /^ge/i
      }
    };
    const match$1 = {
      ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern$1,
        parsePattern: parseOrdinalNumberPattern$1,
        valueCallback: function(value2) {
          return parseInt(value2, 10);
        }
      }),
      era: buildMatchFn({
        matchPatterns: matchEraPatterns$1,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns$1,
        defaultParseWidth: "any"
      }),
      quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns$1,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns$1,
        defaultParseWidth: "any",
        valueCallback: (index2) => index2 + 1
      }),
      month: buildMatchFn({
        matchPatterns: matchMonthPatterns$1,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns$1,
        defaultParseWidth: "any"
      }),
      day: buildMatchFn({
        matchPatterns: matchDayPatterns$1,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns$1,
        defaultParseWidth: "any"
      }),
      dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns$1,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns$1,
        defaultParseWidth: "any"
      })
    };
    const tr = {
      code: "tr",
      formatDistance: formatDistance$1,
      formatLong: formatLong$1,
      formatRelative: formatRelative$1,
      localize: localize$1,
      match: match$1,
      options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 1
      }
    };
    const formatDistanceLocale = {
      lessThanXSeconds: {
        one: "不到 1 秒",
        other: "不到 {{count}} 秒"
      },
      xSeconds: {
        one: "1 秒",
        other: "{{count}} 秒"
      },
      halfAMinute: "半分钟",
      lessThanXMinutes: {
        one: "不到 1 分钟",
        other: "不到 {{count}} 分钟"
      },
      xMinutes: {
        one: "1 分钟",
        other: "{{count}} 分钟"
      },
      xHours: {
        one: "1 小时",
        other: "{{count}} 小时"
      },
      aboutXHours: {
        one: "大约 1 小时",
        other: "大约 {{count}} 小时"
      },
      xDays: {
        one: "1 天",
        other: "{{count}} 天"
      },
      aboutXWeeks: {
        one: "大约 1 个星期",
        other: "大约 {{count}} 个星期"
      },
      xWeeks: {
        one: "1 个星期",
        other: "{{count}} 个星期"
      },
      aboutXMonths: {
        one: "大约 1 个月",
        other: "大约 {{count}} 个月"
      },
      xMonths: {
        one: "1 个月",
        other: "{{count}} 个月"
      },
      aboutXYears: {
        one: "大约 1 年",
        other: "大约 {{count}} 年"
      },
      xYears: {
        one: "1 年",
        other: "{{count}} 年"
      },
      overXYears: {
        one: "超过 1 年",
        other: "超过 {{count}} 年"
      },
      almostXYears: {
        one: "将近 1 年",
        other: "将近 {{count}} 年"
      }
    };
    const formatDistance = (token, count, options) => {
      let result;
      const tokenValue = formatDistanceLocale[token];
      if (typeof tokenValue === "string") {
        result = tokenValue;
      } else if (count === 1) {
        result = tokenValue.one;
      } else {
        result = tokenValue.other.replace("{{count}}", String(count));
      }
      if (options?.addSuffix) {
        if (options.comparison && options.comparison > 0) {
          return result + "内";
        } else {
          return result + "前";
        }
      }
      return result;
    };
    const dateFormats = {
      full: "y'年'M'月'd'日' EEEE",
      long: "y'年'M'月'd'日'",
      medium: "yyyy-MM-dd",
      short: "yy-MM-dd"
    };
    const timeFormats = {
      full: "zzzz a h:mm:ss",
      long: "z a h:mm:ss",
      medium: "a h:mm:ss",
      short: "a h:mm"
    };
    const dateTimeFormats = {
      full: "{{date}} {{time}}",
      long: "{{date}} {{time}}",
      medium: "{{date}} {{time}}",
      short: "{{date}} {{time}}"
    };
    const formatLong = {
      date: buildFormatLongFn({
        formats: dateFormats,
        defaultWidth: "full"
      }),
      time: buildFormatLongFn({
        formats: timeFormats,
        defaultWidth: "full"
      }),
      dateTime: buildFormatLongFn({
        formats: dateTimeFormats,
        defaultWidth: "full"
      })
    };
    function checkWeek(date, baseDate, options) {
      const baseFormat = "eeee p";
      if (isSameWeek(date, baseDate, options)) {
        return baseFormat;
      } else if (date.getTime() > baseDate.getTime()) {
        return "'下个'" + baseFormat;
      }
      return "'上个'" + baseFormat;
    }
    const formatRelativeLocale = {
      lastWeek: checkWeek,
      // days before yesterday, maybe in this week or last week
      yesterday: "'昨天' p",
      today: "'今天' p",
      tomorrow: "'明天' p",
      nextWeek: checkWeek,
      // days after tomorrow, maybe in this week or next week
      other: "PP p"
    };
    const formatRelative = (token, date, baseDate, options) => {
      const format2 = formatRelativeLocale[token];
      if (typeof format2 === "function") {
        return format2(date, baseDate, options);
      }
      return format2;
    };
    const eraValues = {
      narrow: ["前", "公元"],
      abbreviated: ["前", "公元"],
      wide: ["公元前", "公元"]
    };
    const quarterValues = {
      narrow: ["1", "2", "3", "4"],
      abbreviated: ["第一季", "第二季", "第三季", "第四季"],
      wide: ["第一季度", "第二季度", "第三季度", "第四季度"]
    };
    const monthValues = {
      narrow: [
        "一",
        "二",
        "三",
        "四",
        "五",
        "六",
        "七",
        "八",
        "九",
        "十",
        "十一",
        "十二"
      ],
      abbreviated: [
        "1月",
        "2月",
        "3月",
        "4月",
        "5月",
        "6月",
        "7月",
        "8月",
        "9月",
        "10月",
        "11月",
        "12月"
      ],
      wide: [
        "一月",
        "二月",
        "三月",
        "四月",
        "五月",
        "六月",
        "七月",
        "八月",
        "九月",
        "十月",
        "十一月",
        "十二月"
      ]
    };
    const dayValues = {
      narrow: ["日", "一", "二", "三", "四", "五", "六"],
      short: ["日", "一", "二", "三", "四", "五", "六"],
      abbreviated: ["周日", "周一", "周二", "周三", "周四", "周五", "周六"],
      wide: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"]
    };
    const dayPeriodValues = {
      narrow: {
        am: "上",
        pm: "下",
        midnight: "凌晨",
        noon: "午",
        morning: "早",
        afternoon: "下午",
        evening: "晚",
        night: "夜"
      },
      abbreviated: {
        am: "上午",
        pm: "下午",
        midnight: "凌晨",
        noon: "中午",
        morning: "早晨",
        afternoon: "中午",
        evening: "晚上",
        night: "夜间"
      },
      wide: {
        am: "上午",
        pm: "下午",
        midnight: "凌晨",
        noon: "中午",
        morning: "早晨",
        afternoon: "中午",
        evening: "晚上",
        night: "夜间"
      }
    };
    const formattingDayPeriodValues = {
      narrow: {
        am: "上",
        pm: "下",
        midnight: "凌晨",
        noon: "午",
        morning: "早",
        afternoon: "下午",
        evening: "晚",
        night: "夜"
      },
      abbreviated: {
        am: "上午",
        pm: "下午",
        midnight: "凌晨",
        noon: "中午",
        morning: "早晨",
        afternoon: "中午",
        evening: "晚上",
        night: "夜间"
      },
      wide: {
        am: "上午",
        pm: "下午",
        midnight: "凌晨",
        noon: "中午",
        morning: "早晨",
        afternoon: "中午",
        evening: "晚上",
        night: "夜间"
      }
    };
    const ordinalNumber = (dirtyNumber, options) => {
      const number = Number(dirtyNumber);
      switch (options?.unit) {
        case "date":
          return number.toString() + "日";
        case "hour":
          return number.toString() + "时";
        case "minute":
          return number.toString() + "分";
        case "second":
          return number.toString() + "秒";
        default:
          return "第 " + number.toString();
      }
    };
    const localize = {
      ordinalNumber,
      era: buildLocalizeFn({
        values: eraValues,
        defaultWidth: "wide"
      }),
      quarter: buildLocalizeFn({
        values: quarterValues,
        defaultWidth: "wide",
        argumentCallback: (quarter) => quarter - 1
      }),
      month: buildLocalizeFn({
        values: monthValues,
        defaultWidth: "wide"
      }),
      day: buildLocalizeFn({
        values: dayValues,
        defaultWidth: "wide"
      }),
      dayPeriod: buildLocalizeFn({
        values: dayPeriodValues,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues,
        defaultFormattingWidth: "wide"
      })
    };
    const matchOrdinalNumberPattern = /^(第\s*)?\d+(日|时|分|秒)?/i;
    const parseOrdinalNumberPattern = /\d+/i;
    const matchEraPatterns = {
      narrow: /^(前)/i,
      abbreviated: /^(前)/i,
      wide: /^(公元前|公元)/i
    };
    const parseEraPatterns = {
      any: [/^(前)/i, /^(公元)/i]
    };
    const matchQuarterPatterns = {
      narrow: /^[1234]/i,
      abbreviated: /^第[一二三四]刻/i,
      wide: /^第[一二三四]刻钟/i
    };
    const parseQuarterPatterns = {
      any: [/(1|一)/i, /(2|二)/i, /(3|三)/i, /(4|四)/i]
    };
    const matchMonthPatterns = {
      narrow: /^(一|二|三|四|五|六|七|八|九|十[二一])/i,
      abbreviated: /^(一|二|三|四|五|六|七|八|九|十[二一]|\d|1[12])月/i,
      wide: /^(一|二|三|四|五|六|七|八|九|十[二一])月/i
    };
    const parseMonthPatterns = {
      narrow: [
        /^一/i,
        /^二/i,
        /^三/i,
        /^四/i,
        /^五/i,
        /^六/i,
        /^七/i,
        /^八/i,
        /^九/i,
        /^十(?!(一|二))/i,
        /^十一/i,
        /^十二/i
      ],
      any: [
        /^一|1/i,
        /^二|2/i,
        /^三|3/i,
        /^四|4/i,
        /^五|5/i,
        /^六|6/i,
        /^七|7/i,
        /^八|8/i,
        /^九|9/i,
        /^十(?!(一|二))|10/i,
        /^十一|11/i,
        /^十二|12/i
      ]
    };
    const matchDayPatterns = {
      narrow: /^[一二三四五六日]/i,
      short: /^[一二三四五六日]/i,
      abbreviated: /^周[一二三四五六日]/i,
      wide: /^星期[一二三四五六日]/i
    };
    const parseDayPatterns = {
      any: [/日/i, /一/i, /二/i, /三/i, /四/i, /五/i, /六/i]
    };
    const matchDayPeriodPatterns = {
      any: /^(上午?|下午?|午夜|[中正]午|早上?|下午|晚上?|凌晨|)/i
    };
    const parseDayPeriodPatterns = {
      any: {
        am: /^上午?/i,
        pm: /^下午?/i,
        midnight: /^午夜/i,
        noon: /^[中正]午/i,
        morning: /^早上/i,
        afternoon: /^下午/i,
        evening: /^晚上?/i,
        night: /^凌晨/i
      }
    };
    const match = {
      ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern,
        parsePattern: parseOrdinalNumberPattern,
        valueCallback: (value2) => parseInt(value2, 10)
      }),
      era: buildMatchFn({
        matchPatterns: matchEraPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns,
        defaultParseWidth: "any"
      }),
      quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns,
        defaultParseWidth: "any",
        valueCallback: (index2) => index2 + 1
      }),
      month: buildMatchFn({
        matchPatterns: matchMonthPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns,
        defaultParseWidth: "any"
      }),
      day: buildMatchFn({
        matchPatterns: matchDayPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns,
        defaultParseWidth: "any"
      }),
      dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns,
        defaultParseWidth: "any"
      })
    };
    const zhCN = {
      code: "zh-CN",
      formatDistance,
      formatLong,
      formatRelative,
      localize,
      match,
      options: {
        weekStartsOn: 1,
        firstWeekContainsDate: 4
      }
    };
    function useDate() {
      const { i18n } = useTranslation();
      const { language } = i18n;
      const getDateLocale = () => {
        if (language.startsWith("pt"))
          return ptBR;
        if (language.startsWith("es"))
          return es;
        if (language.startsWith("fr"))
          return fr$2;
        if (language.startsWith("hu"))
          return hu;
        if (language.startsWith("pl"))
          return pl;
        if (language.startsWith("tr"))
          return tr;
        if (language.startsWith("ru"))
          return ru;
        if (language.startsWith("it"))
          return it;
        if (language.startsWith("be"))
          return be;
        if (language.startsWith("zh"))
          return zhCN;
        if (language.startsWith("da"))
          return da;
        return enUS;
      };
      return {
        formatDistance: (date, baseDate, options) => {
          try {
            return formatDistance$b(date, baseDate, {
              ...options,
              locale: getDateLocale()
            });
          } catch (err) {
            return "";
          }
        },
        formatDiffInMillis: (millis, baseDate, options) => {
          try {
            return formatDistance$b(subMilliseconds(/* @__PURE__ */ new Date(), millis), baseDate, {
              ...options,
              locale: getDateLocale()
            });
          } catch (err) {
            return "";
          }
        }
      };
    }
    var Downloader = /* @__PURE__ */ ((Downloader2) => {
      Downloader2[Downloader2["RealDebrid"] = 0] = "RealDebrid";
      Downloader2[Downloader2["Torrent"] = 1] = "Torrent";
      return Downloader2;
    })(Downloader || {});
    var DownloadSourceStatus = /* @__PURE__ */ ((DownloadSourceStatus2) => {
      DownloadSourceStatus2[DownloadSourceStatus2["UpToDate"] = 0] = "UpToDate";
      DownloadSourceStatus2[DownloadSourceStatus2["Errored"] = 1] = "Errored";
      return DownloadSourceStatus2;
    })(DownloadSourceStatus || {});
    const FORMAT = ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
    const formatBytes = (bytes) => {
      if (!Number.isFinite(bytes) || isNaN(bytes) || bytes <= 0) {
        return `0 ${FORMAT[0]}`;
      }
      const byteKBase = 1024;
      const base = Math.floor(Math.log(bytes) / Math.log(byteKBase));
      const formatedByte = bytes / byteKBase ** base;
      return `${Math.trunc(formatedByte * 10) / 10} ${FORMAT[base]}`;
    };
    function useDownload() {
      const { updateLibrary } = useLibrary();
      const { formatDistance: formatDistance2 } = useDate();
      const { lastPacket, gamesWithDeletionInProgress } = useAppSelector(
        (state) => state.download
      );
      const dispatch = useAppDispatch();
      const startDownload = (payload) => {
        dispatch(clearDownload());
        window.electron.startGameDownload(payload).then((game) => {
          updateLibrary();
          return game;
        });
      };
      const pauseDownload = async (gameId) => {
        await window.electron.pauseGameDownload(gameId);
        await updateLibrary();
        dispatch(clearDownload());
      };
      const resumeDownload = async (gameId) => {
        await window.electron.resumeGameDownload(gameId);
        return updateLibrary();
      };
      const removeGameInstaller = async (gameId) => {
        dispatch(setGameDeleting(gameId));
        try {
          await window.electron.deleteGameFolder(gameId);
          updateLibrary();
        } finally {
          dispatch(removeGameFromDeleting(gameId));
        }
      };
      const cancelDownload = async (gameId) => {
        await window.electron.cancelGameDownload(gameId);
        dispatch(clearDownload());
        updateLibrary();
        removeGameInstaller(gameId);
      };
      const removeGameFromLibrary = (gameId) => window.electron.removeGameFromLibrary(gameId).then(() => {
        updateLibrary();
      });
      const calculateETA = () => {
        if (!lastPacket || lastPacket.timeRemaining < 0)
          return "";
        try {
          return formatDistance2(
            addMilliseconds(/* @__PURE__ */ new Date(), lastPacket.timeRemaining),
            /* @__PURE__ */ new Date(),
            { addSuffix: true }
          );
        } catch (err) {
          return "";
        }
      };
      const isGameDeleting = (gameId) => {
        return gamesWithDeletionInProgress.includes(gameId);
      };
      return {
        downloadSpeed: `${formatBytes(lastPacket?.downloadSpeed ?? 0)}/s`,
        progress: formatDownloadProgress(lastPacket?.progress ?? 0),
        lastPacket,
        eta: calculateETA(),
        startDownload,
        pauseDownload,
        resumeDownload,
        cancelDownload,
        removeGameFromLibrary,
        removeGameInstaller,
        isGameDeleting,
        clearDownload: () => dispatch(clearDownload()),
        setLastPacket: (packet) => dispatch(setLastPacket(packet))
      };
    }
    function useToast() {
      const dispatch = useAppDispatch();
      const showSuccessToast = reactExports.useCallback(
        (message2) => {
          dispatch(
            showToast({
              message: message2,
              type: "success"
            })
          );
        },
        [dispatch]
      );
      const showErrorToast = reactExports.useCallback(
        (message2) => {
          dispatch(
            showToast({
              message: message2,
              type: "error"
            })
          );
        },
        [dispatch]
      );
      const showWarningToast = reactExports.useCallback(
        (message2) => {
          dispatch(
            showToast({
              message: message2,
              type: "warning"
            })
          );
        },
        [dispatch]
      );
      return { showSuccessToast, showErrorToast, showWarningToast };
    }
    var getSrc = (item) => typeof item === "string" ? item : item.src;
    var getArgs = ({
      amount = 3,
      format: format2 = "array",
      group = 20,
      sample = 10
    } = {}) => ({
      amount,
      format: format2,
      group,
      sample
    });
    var format = (input, args) => {
      var list = input.map((val2) => {
        var rgb = Array.isArray(val2) ? val2 : val2.split(",").map(Number);
        return args.format === "hex" ? rgbToHex(rgb) : rgb;
      });
      return args.amount === 1 || list.length === 1 ? list[0] : list;
    };
    var rgbToHex = (rgb) => "#" + rgb.map((val2) => {
      var hex = val2.toString(16);
      return hex.length === 1 ? "0" + hex : hex;
    }).join("");
    var getImageData = (src2) => new Promise((resolve, reject) => {
      var canvas = document.createElement("canvas");
      var context = canvas.getContext("2d");
      var img = new Image();
      img.onload = () => {
        canvas.height = img.height;
        canvas.width = img.width;
        context.drawImage(img, 0, 0);
        var data2 = context.getImageData(0, 0, img.width, img.height).data;
        resolve(data2);
      };
      img.onerror = () => reject(Error("Image loading failed."));
      img.crossOrigin = "";
      img.src = src2;
    });
    var getAverage = (data2, args) => {
      var gap = 4 * args.sample;
      var amount = data2.length / gap;
      var rgb = {
        r: 0,
        g: 0,
        b: 0
      };
      for (var i2 = 0; i2 < data2.length; i2 += gap) {
        rgb.r += data2[i2];
        rgb.g += data2[i2 + 1];
        rgb.b += data2[i2 + 2];
      }
      return format([[Math.round(rgb.r / amount), Math.round(rgb.g / amount), Math.round(rgb.b / amount)]], args);
    };
    var process$1 = (handler, item, args) => new Promise((resolve, reject) => getImageData(getSrc(item)).then((data2) => resolve(handler(data2, getArgs(args)))).catch((error) => reject(error)));
    var average = (item, args) => process$1(getAverage, item, args);
    function useUserDetails() {
      const dispatch = useAppDispatch();
      const { userDetails, profileBackground: profileBackground2 } = useAppSelector(
        (state) => state.userDetails
      );
      const clearUserDetails = reactExports.useCallback(async () => {
        dispatch(setUserDetails(null));
        dispatch(setProfileBackground(null));
        window.localStorage.removeItem("userDetails");
      }, [dispatch]);
      const signOut = reactExports.useCallback(async () => {
        clearUserDetails();
        return window.electron.signOut();
      }, [clearUserDetails]);
      const updateUserDetails = reactExports.useCallback(
        async (userDetails2) => {
          dispatch(setUserDetails(userDetails2));
          if (userDetails2.profileImageUrl) {
            const output = await average(userDetails2.profileImageUrl, {
              amount: 1,
              format: "hex"
            });
            const profileBackground22 = `linear-gradient(135deg, ${darkenColor(output, 0.6)}, ${darkenColor(output, 0.8, 0.7)})`;
            dispatch(setProfileBackground(profileBackground22));
            window.localStorage.setItem(
              "userDetails",
              JSON.stringify({ ...userDetails2, profileBackground: profileBackground22 })
            );
          } else {
            const profileBackground22 = `#151515B3`;
            dispatch(setProfileBackground(profileBackground22));
            window.localStorage.setItem(
              "userDetails",
              JSON.stringify({ ...userDetails2, profileBackground: profileBackground22 })
            );
          }
        },
        [dispatch]
      );
      const fetchUserDetails = reactExports.useCallback(async () => {
        return window.electron.getMe().then((userDetails2) => {
          if (userDetails2 == null) {
            clearUserDetails();
          }
          return userDetails2;
        });
      }, [clearUserDetails]);
      const patchUser = reactExports.useCallback(
        async (displayName, imageProfileUrl) => {
          const response = await window.electron.updateProfile(
            displayName,
            imageProfileUrl
          );
          return updateUserDetails(response);
        },
        [updateUserDetails]
      );
      return {
        userDetails,
        fetchUserDetails,
        signOut,
        clearUserDetails,
        updateUserDetails,
        patchUser,
        profileBackground: profileBackground2
      };
    }
    var bottomPanel = "xykbj00";
    var downloadsButton = "xykbj01";
    const VERSION_CODENAME = "NoFinder v0.1";
    const DOWNLOADER_NAME = {
      [Downloader.RealDebrid]: "Real-Debrid",
      [Downloader.Torrent]: "Torrent"
    };
    function BottomPanel() {
      const { t: t2 } = useTranslation("bottom_panel");
      const navigate = useNavigate();
      const { userDetails } = useUserDetails();
      const { lastPacket, progress: progress2, downloadSpeed, eta } = useDownload();
      const isGameDownloading = !!lastPacket?.game;
      const [version, setVersion] = reactExports.useState("");
      const [sessionHash, setSessionHash] = reactExports.useState("");
      reactExports.useEffect(() => {
        window.electron.getVersion().then((result) => setVersion(result));
      }, []);
      reactExports.useEffect(() => {
        window.electron.getSessionHash().then((result) => setSessionHash(result));
      }, [userDetails?.id]);
      const status = reactExports.useMemo(() => {
        if (isGameDownloading) {
          if (lastPacket?.isCheckingFiles)
            return t2("checking_files", {
              title: lastPacket?.game.title,
              percentage: progress2
            });
          if (lastPacket?.isDownloadingMetadata)
            return t2("downloading_metadata", {
              title: lastPacket?.game.title,
              percentage: progress2
            });
          if (!eta) {
            return t2("calculating_eta", {
              title: lastPacket?.game.title,
              percentage: progress2
            });
          }
          return t2("downloading", {
            title: lastPacket?.game.title,
            percentage: progress2,
            eta,
            speed: downloadSpeed
          });
        }
        return t2("no_downloads_in_progress");
      }, [
        t2,
        isGameDownloading,
        lastPacket?.game,
        lastPacket?.isDownloadingMetadata,
        lastPacket?.isCheckingFiles,
        progress2,
        eta,
        downloadSpeed
      ]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("footer", { className: bottomPanel, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            type: "button",
            className: downloadsButton,
            onClick: () => navigate("/downloads"),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: status })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { children: [
          sessionHash ? `${sessionHash} -` : "",
          ' Cet Autocrack est une fork de HydraLauncher v2.0.3 "',
          VERSION_CODENAME,
          '"'
        ] })
      ] });
    }
    var classnames = { exports: {} };
    /*!
    	Copyright (c) 2018 Jed Watson.
    	Licensed under the MIT License (MIT), see
    	http://jedwatson.github.io/classnames
    */
    (function(module2) {
      (function() {
        var hasOwn = {}.hasOwnProperty;
        function classNames() {
          var classes = "";
          for (var i2 = 0; i2 < arguments.length; i2++) {
            var arg = arguments[i2];
            if (arg) {
              classes = appendClass(classes, parseValue(arg));
            }
          }
          return classes;
        }
        function parseValue(arg) {
          if (typeof arg === "string" || typeof arg === "number") {
            return arg;
          }
          if (typeof arg !== "object") {
            return "";
          }
          if (Array.isArray(arg)) {
            return classNames.apply(null, arg);
          }
          if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
            return arg.toString();
          }
          var classes = "";
          for (var key2 in arg) {
            if (hasOwn.call(arg, key2) && arg[key2]) {
              classes = appendClass(classes, key2);
            }
          }
          return classes;
        }
        function appendClass(value2, newClass) {
          if (!newClass) {
            return value2;
          }
          if (value2) {
            return value2 + " " + newClass;
          }
          return value2 + newClass;
        }
        if (module2.exports) {
          classNames.default = classNames;
          module2.exports = classNames;
        } else {
          window.classNames = classNames;
        }
      })();
    })(classnames);
    var classnamesExports = classnames.exports;
    const cn = /* @__PURE__ */ getDefaultExportFromCjs(classnamesExports);
    var button = { primary: "_1gdbk601 _1gdbk600", outline: "_1gdbk602 _1gdbk600", dark: "_1gdbk603 _1gdbk600", danger: "_1gdbk604 _1gdbk600" };
    function Button({
      children,
      theme = "primary",
      className,
      ...props
    }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          type: "button",
          className: cn(button[theme], className),
          ...props,
          children
        }
      );
    }
    var sizeMap = {
      small: 16,
      medium: 32,
      large: 64
    };
    function createIconComponent(name2, defaultClassName, getSVGData) {
      var svgDataByHeight = getSVGData();
      var heights = Object.keys(svgDataByHeight);
      var Icon = /* @__PURE__ */ React$1.forwardRef(function(_ref, forwardedRef) {
        var ariaLabel = _ref["aria-label"], arialabelledby = _ref["aria-labelledby"], tabIndex = _ref.tabIndex, _ref$className = _ref.className, className = _ref$className === void 0 ? defaultClassName : _ref$className, _ref$fill = _ref.fill, fill2 = _ref$fill === void 0 ? "currentColor" : _ref$fill, _ref$size = _ref.size, size = _ref$size === void 0 ? 16 : _ref$size, _ref$verticalAlign = _ref.verticalAlign, verticalAlign = _ref$verticalAlign === void 0 ? "text-bottom" : _ref$verticalAlign, id2 = _ref.id, title2 = _ref.title;
        var height2 = sizeMap[size] || size;
        var naturalHeight = closestNaturalHeight(heights, height2);
        var naturalWidth = svgDataByHeight[naturalHeight].width;
        var width2 = height2 * (naturalWidth / naturalHeight);
        var path2 = svgDataByHeight[naturalHeight].path;
        var labelled = ariaLabel || arialabelledby;
        var role = labelled ? "img" : void 0;
        return /* @__PURE__ */ React$1.createElement("svg", {
          ref: forwardedRef,
          "aria-hidden": labelled ? void 0 : "true",
          tabIndex,
          focusable: tabIndex >= 0 ? "true" : "false",
          "aria-label": ariaLabel,
          "aria-labelledby": arialabelledby,
          className,
          role,
          viewBox: "0 0 ".concat(naturalWidth, " ").concat(naturalHeight),
          width: width2,
          height: height2,
          fill: fill2,
          id: id2,
          style: {
            display: "inline-block",
            userSelect: "none",
            verticalAlign,
            overflow: "visible"
          }
        }, title2 ? /* @__PURE__ */ React$1.createElement("title", null, title2) : null, path2);
      });
      Icon.displayName = name2;
      return Icon;
    }
    function closestNaturalHeight(naturalHeights, height2) {
      return naturalHeights.map(function(naturalHeight) {
        return parseInt(naturalHeight, 10);
      }).reduce(function(acc, naturalHeight) {
        return naturalHeight <= height2 ? naturalHeight : acc;
      }, naturalHeights[0]);
    }
    var AlertIcon = /* @__PURE__ */ createIconComponent("AlertIcon", "octicon octicon-alert", function() {
      return {
        "16": {
          "width": 16,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M6.457 1.047c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0 1 14.082 15H1.918a1.75 1.75 0 0 1-1.543-2.575Zm1.763.707a.25.25 0 0 0-.44 0L1.698 13.132a.25.25 0 0 0 .22.368h12.164a.25.25 0 0 0 .22-.368Zm.53 3.996v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 11a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"
          })
        },
        "24": {
          "width": 24,
          "path": /* @__PURE__ */ React$1.createElement(React$1.Fragment, null, /* @__PURE__ */ React$1.createElement("path", {
            d: "M13 17.5a1 1 0 1 1-2 0 1 1 0 0 1 2 0Zm-.25-8.25a.75.75 0 0 0-1.5 0v4.5a.75.75 0 0 0 1.5 0v-4.5Z"
          }), /* @__PURE__ */ React$1.createElement("path", {
            d: "M9.836 3.244c.963-1.665 3.365-1.665 4.328 0l8.967 15.504c.963 1.667-.24 3.752-2.165 3.752H3.034c-1.926 0-3.128-2.085-2.165-3.752Zm3.03.751a1.002 1.002 0 0 0-1.732 0L2.168 19.499A1.002 1.002 0 0 0 3.034 21h17.932a1.002 1.002 0 0 0 .866-1.5L12.866 3.994Z"
          }))
        }
      };
    });
    var AppsIcon = /* @__PURE__ */ createIconComponent("AppsIcon", "octicon octicon-apps", function() {
      return {
        "16": {
          "width": 16,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M1.5 3.25c0-.966.784-1.75 1.75-1.75h2.5c.966 0 1.75.784 1.75 1.75v2.5A1.75 1.75 0 0 1 5.75 7.5h-2.5A1.75 1.75 0 0 1 1.5 5.75Zm7 0c0-.966.784-1.75 1.75-1.75h2.5c.966 0 1.75.784 1.75 1.75v2.5a1.75 1.75 0 0 1-1.75 1.75h-2.5A1.75 1.75 0 0 1 8.5 5.75Zm-7 7c0-.966.784-1.75 1.75-1.75h2.5c.966 0 1.75.784 1.75 1.75v2.5a1.75 1.75 0 0 1-1.75 1.75h-2.5a1.75 1.75 0 0 1-1.75-1.75Zm7 0c0-.966.784-1.75 1.75-1.75h2.5c.966 0 1.75.784 1.75 1.75v2.5a1.75 1.75 0 0 1-1.75 1.75h-2.5a1.75 1.75 0 0 1-1.75-1.75ZM3.25 3a.25.25 0 0 0-.25.25v2.5c0 .138.112.25.25.25h2.5A.25.25 0 0 0 6 5.75v-2.5A.25.25 0 0 0 5.75 3Zm7 0a.25.25 0 0 0-.25.25v2.5c0 .138.112.25.25.25h2.5a.25.25 0 0 0 .25-.25v-2.5a.25.25 0 0 0-.25-.25Zm-7 7a.25.25 0 0 0-.25.25v2.5c0 .138.112.25.25.25h2.5a.25.25 0 0 0 .25-.25v-2.5a.25.25 0 0 0-.25-.25Zm7 0a.25.25 0 0 0-.25.25v2.5c0 .138.112.25.25.25h2.5a.25.25 0 0 0 .25-.25v-2.5a.25.25 0 0 0-.25-.25Z"
          })
        }
      };
    });
    var ArrowDownIcon = /* @__PURE__ */ createIconComponent("ArrowDownIcon", "octicon octicon-arrow-down", function() {
      return {
        "16": {
          "width": 16,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M13.03 8.22a.75.75 0 0 1 0 1.06l-4.25 4.25a.75.75 0 0 1-1.06 0L3.47 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018l2.97 2.97V3.75a.75.75 0 0 1 1.5 0v7.44l2.97-2.97a.75.75 0 0 1 1.06 0Z"
          })
        },
        "24": {
          "width": 24,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M4.97 13.22a.75.75 0 0 1 1.06 0L11 18.19V3.75a.75.75 0 0 1 1.5 0v14.44l4.97-4.97a.749.749 0 0 1 1.275.326.749.749 0 0 1-.215.734l-6.25 6.25a.75.75 0 0 1-1.06 0l-6.25-6.25a.75.75 0 0 1 0-1.06Z"
          })
        }
      };
    });
    var ArrowLeftIcon = /* @__PURE__ */ createIconComponent("ArrowLeftIcon", "octicon octicon-arrow-left", function() {
      return {
        "16": {
          "width": 16,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M7.78 12.53a.75.75 0 0 1-1.06 0L2.47 8.28a.75.75 0 0 1 0-1.06l4.25-4.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042L4.81 7h7.44a.75.75 0 0 1 0 1.5H4.81l2.97 2.97a.75.75 0 0 1 0 1.06Z"
          })
        },
        "24": {
          "width": 24,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M10.78 19.03a.75.75 0 0 1-1.06 0l-6.25-6.25a.75.75 0 0 1 0-1.06l6.25-6.25a.749.749 0 0 1 1.275.326.749.749 0 0 1-.215.734L5.81 11.5h14.44a.75.75 0 0 1 0 1.5H5.81l4.97 4.97a.75.75 0 0 1 0 1.06Z"
          })
        }
      };
    });
    var ArrowRightIcon = /* @__PURE__ */ createIconComponent("ArrowRightIcon", "octicon octicon-arrow-right", function() {
      return {
        "16": {
          "width": 16,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M8.22 2.97a.75.75 0 0 1 1.06 0l4.25 4.25a.75.75 0 0 1 0 1.06l-4.25 4.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042l2.97-2.97H3.75a.75.75 0 0 1 0-1.5h7.44L8.22 4.03a.75.75 0 0 1 0-1.06Z"
          })
        },
        "24": {
          "width": 24,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M13.22 19.03a.75.75 0 0 1 0-1.06L18.19 13H3.75a.75.75 0 0 1 0-1.5h14.44l-4.97-4.97a.749.749 0 0 1 .326-1.275.749.749 0 0 1 .734.215l6.25 6.25a.75.75 0 0 1 0 1.06l-6.25 6.25a.75.75 0 0 1-1.06 0Z"
          })
        }
      };
    });
    var CheckIcon = /* @__PURE__ */ createIconComponent("CheckIcon", "octicon octicon-check", function() {
      return {
        "16": {
          "width": 16,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z"
          })
        },
        "24": {
          "width": 24,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M21.03 5.72a.75.75 0 0 1 0 1.06l-11.5 11.5a.747.747 0 0 1-1.072-.012l-5.5-5.75a.75.75 0 1 1 1.084-1.036l4.97 5.195L19.97 5.72a.75.75 0 0 1 1.06 0Z"
          })
        }
      };
    });
    var CheckCircleFillIcon = /* @__PURE__ */ createIconComponent("CheckCircleFillIcon", "octicon octicon-check-circle-fill", function() {
      return {
        "12": {
          "width": 12,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M6 0a6 6 0 1 1 0 12A6 6 0 0 1 6 0Zm-.705 8.737L9.63 4.403 8.392 3.166 5.295 6.263l-1.7-1.702L2.356 5.8l2.938 2.938Z"
          })
        },
        "16": {
          "width": 16,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M8 16A8 8 0 1 1 8 0a8 8 0 0 1 0 16Zm3.78-9.72a.751.751 0 0 0-.018-1.042.751.751 0 0 0-1.042-.018L6.75 9.19 5.28 7.72a.751.751 0 0 0-1.042.018.751.751 0 0 0-.018 1.042l2 2a.75.75 0 0 0 1.06 0Z"
          })
        },
        "24": {
          "width": 24,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M1 12C1 5.925 5.925 1 12 1s11 4.925 11 11-4.925 11-11 11S1 18.075 1 12Zm16.28-2.72a.751.751 0 0 0-.018-1.042.751.751 0 0 0-1.042-.018l-5.97 5.97-2.47-2.47a.751.751 0 0 0-1.042.018.751.751 0 0 0-.018 1.042l3 3a.75.75 0 0 0 1.06 0Z"
          })
        }
      };
    });
    var ChevronLeftIcon = /* @__PURE__ */ createIconComponent("ChevronLeftIcon", "octicon octicon-chevron-left", function() {
      return {
        "16": {
          "width": 16,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M9.78 12.78a.75.75 0 0 1-1.06 0L4.47 8.53a.75.75 0 0 1 0-1.06l4.25-4.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042L6.06 8l3.72 3.72a.75.75 0 0 1 0 1.06Z"
          })
        },
        "24": {
          "width": 24,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M15.28 5.22a.75.75 0 0 1 0 1.06L9.56 12l5.72 5.72a.749.749 0 0 1-.326 1.275.749.749 0 0 1-.734-.215l-6.25-6.25a.75.75 0 0 1 0-1.06l6.25-6.25a.75.75 0 0 1 1.06 0Z"
          })
        }
      };
    });
    var ChevronRightIcon = /* @__PURE__ */ createIconComponent("ChevronRightIcon", "octicon octicon-chevron-right", function() {
      return {
        "12": {
          "width": 12,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M4.7 10c-.2 0-.4-.1-.5-.2-.3-.3-.3-.8 0-1.1L6.9 6 4.2 3.3c-.3-.3-.3-.8 0-1.1.3-.3.8-.3 1.1 0l3.3 3.2c.3.3.3.8 0 1.1L5.3 9.7c-.2.2-.4.3-.6.3Z"
          })
        },
        "16": {
          "width": 16,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M6.22 3.22a.75.75 0 0 1 1.06 0l4.25 4.25a.75.75 0 0 1 0 1.06l-4.25 4.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042L9.94 8 6.22 4.28a.75.75 0 0 1 0-1.06Z"
          })
        },
        "24": {
          "width": 24,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M8.72 18.78a.75.75 0 0 1 0-1.06L14.44 12 8.72 6.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018l6.25 6.25a.75.75 0 0 1 0 1.06l-6.25 6.25a.75.75 0 0 1-1.06 0Z"
          })
        }
      };
    });
    var DeviceCameraIcon = /* @__PURE__ */ createIconComponent("DeviceCameraIcon", "octicon octicon-device-camera", function() {
      return {
        "16": {
          "width": 16,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M15 3c.55 0 1 .45 1 1v9c0 .55-.45 1-1 1H1c-.55 0-1-.45-1-1V4c0-.55.45-1 1-1 0-.55.45-1 1-1h4c.55 0 1 .45 1 1Zm-4.5 9c1.94 0 3.5-1.56 3.5-3.5S12.44 5 10.5 5 7 6.56 7 8.5 8.56 12 10.5 12ZM13 8.5c0 1.38-1.13 2.5-2.5 2.5S8 9.87 8 8.5 9.13 6 10.5 6 13 7.13 13 8.5ZM6 5V4H2v1Z"
          })
        }
      };
    });
    var DownloadIcon$1 = /* @__PURE__ */ createIconComponent("DownloadIcon", "octicon octicon-download", function() {
      return {
        "16": {
          "width": 16,
          "path": /* @__PURE__ */ React$1.createElement(React$1.Fragment, null, /* @__PURE__ */ React$1.createElement("path", {
            d: "M2.75 14A1.75 1.75 0 0 1 1 12.25v-2.5a.75.75 0 0 1 1.5 0v2.5c0 .138.112.25.25.25h10.5a.25.25 0 0 0 .25-.25v-2.5a.75.75 0 0 1 1.5 0v2.5A1.75 1.75 0 0 1 13.25 14Z"
          }), /* @__PURE__ */ React$1.createElement("path", {
            d: "M7.25 7.689V2a.75.75 0 0 1 1.5 0v5.689l1.97-1.969a.749.749 0 1 1 1.06 1.06l-3.25 3.25a.749.749 0 0 1-1.06 0L4.22 6.78a.749.749 0 1 1 1.06-1.06l1.97 1.969Z"
          }))
        },
        "24": {
          "width": 24,
          "path": /* @__PURE__ */ React$1.createElement(React$1.Fragment, null, /* @__PURE__ */ React$1.createElement("path", {
            d: "M4.75 17.25a.75.75 0 0 1 .75.75v2.25c0 .138.112.25.25.25h12.5a.25.25 0 0 0 .25-.25V18a.75.75 0 0 1 1.5 0v2.25A1.75 1.75 0 0 1 18.25 22H5.75A1.75 1.75 0 0 1 4 20.25V18a.75.75 0 0 1 .75-.75Z"
          }), /* @__PURE__ */ React$1.createElement("path", {
            d: "M5.22 9.97a.749.749 0 0 1 1.06 0l4.97 4.969V2.75a.75.75 0 0 1 1.5 0v12.189l4.97-4.969a.749.749 0 1 1 1.06 1.06l-6.25 6.25a.749.749 0 0 1-1.06 0l-6.25-6.25a.749.749 0 0 1 0-1.06Z"
          }))
        }
      };
    });
    var EyeIcon = /* @__PURE__ */ createIconComponent("EyeIcon", "octicon octicon-eye", function() {
      return {
        "16": {
          "width": 16,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M8 2c1.981 0 3.671.992 4.933 2.078 1.27 1.091 2.187 2.345 2.637 3.023a1.62 1.62 0 0 1 0 1.798c-.45.678-1.367 1.932-2.637 3.023C11.67 13.008 9.981 14 8 14c-1.981 0-3.671-.992-4.933-2.078C1.797 10.83.88 9.576.43 8.898a1.62 1.62 0 0 1 0-1.798c.45-.677 1.367-1.931 2.637-3.022C4.33 2.992 6.019 2 8 2ZM1.679 7.932a.12.12 0 0 0 0 .136c.411.622 1.241 1.75 2.366 2.717C5.176 11.758 6.527 12.5 8 12.5c1.473 0 2.825-.742 3.955-1.715 1.124-.967 1.954-2.096 2.366-2.717a.12.12 0 0 0 0-.136c-.412-.621-1.242-1.75-2.366-2.717C10.824 4.242 9.473 3.5 8 3.5c-1.473 0-2.825.742-3.955 1.715-1.124.967-1.954 2.096-2.366 2.717ZM8 10a2 2 0 1 1-.001-3.999A2 2 0 0 1 8 10Z"
          })
        },
        "24": {
          "width": 24,
          "path": /* @__PURE__ */ React$1.createElement(React$1.Fragment, null, /* @__PURE__ */ React$1.createElement("path", {
            d: "M15.5 12a3.5 3.5 0 1 1-7 0 3.5 3.5 0 0 1 7 0Z"
          }), /* @__PURE__ */ React$1.createElement("path", {
            d: "M12 3.5c3.432 0 6.124 1.534 8.054 3.241 1.926 1.703 3.132 3.61 3.616 4.46a1.6 1.6 0 0 1 0 1.598c-.484.85-1.69 2.757-3.616 4.461-1.929 1.706-4.622 3.24-8.054 3.24-3.432 0-6.124-1.534-8.054-3.24C2.02 15.558.814 13.65.33 12.8a1.6 1.6 0 0 1 0-1.598c.484-.85 1.69-2.757 3.616-4.462C5.875 5.034 8.568 3.5 12 3.5ZM1.633 11.945a.115.115 0 0 0-.017.055c.001.02.006.039.017.056.441.774 1.551 2.527 3.307 4.08C6.691 17.685 9.045 19 12 19c2.955 0 5.31-1.315 7.06-2.864 1.756-1.553 2.866-3.306 3.307-4.08a.111.111 0 0 0 .017-.056.111.111 0 0 0-.017-.056c-.441-.773-1.551-2.527-3.307-4.08C17.309 6.315 14.955 5 12 5 9.045 5 6.69 6.314 4.94 7.865c-1.756 1.552-2.866 3.306-3.307 4.08Z"
          }))
        }
      };
    });
    var EyeClosedIcon = /* @__PURE__ */ createIconComponent("EyeClosedIcon", "octicon octicon-eye-closed", function() {
      return {
        "16": {
          "width": 16,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M.143 2.31a.75.75 0 0 1 1.047-.167l14.5 10.5a.75.75 0 1 1-.88 1.214l-2.248-1.628C11.346 13.19 9.792 14 8 14c-1.981 0-3.67-.992-4.933-2.078C1.797 10.832.88 9.577.43 8.9a1.619 1.619 0 0 1 0-1.797c.353-.533.995-1.42 1.868-2.305L.31 3.357A.75.75 0 0 1 .143 2.31Zm1.536 5.622A.12.12 0 0 0 1.657 8c0 .021.006.045.022.068.412.621 1.242 1.75 2.366 2.717C5.175 11.758 6.527 12.5 8 12.5c1.195 0 2.31-.488 3.29-1.191L9.063 9.695A2 2 0 0 1 6.058 7.52L3.529 5.688a14.207 14.207 0 0 0-1.85 2.244ZM8 3.5c-.516 0-1.017.09-1.499.251a.75.75 0 1 1-.473-1.423A6.207 6.207 0 0 1 8 2c1.981 0 3.67.992 4.933 2.078 1.27 1.091 2.187 2.345 2.637 3.023a1.62 1.62 0 0 1 0 1.798c-.11.166-.248.365-.41.587a.75.75 0 1 1-1.21-.887c.148-.201.272-.382.371-.53a.119.119 0 0 0 0-.137c-.412-.621-1.242-1.75-2.366-2.717C10.825 4.242 9.473 3.5 8 3.5Z"
          })
        },
        "24": {
          "width": 24,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M8.052 5.837A9.715 9.715 0 0 1 12 5c2.955 0 5.309 1.315 7.06 2.864 1.756 1.553 2.866 3.307 3.307 4.08a.11.11 0 0 1 .016.055.122.122 0 0 1-.017.06 16.766 16.766 0 0 1-1.53 2.218.75.75 0 1 0 1.163.946 18.253 18.253 0 0 0 1.67-2.42 1.607 1.607 0 0 0 .001-1.602c-.485-.85-1.69-2.757-3.616-4.46C18.124 5.034 15.432 3.5 12 3.5c-1.695 0-3.215.374-4.552.963a.75.75 0 0 0 .604 1.373Zm11.114 12.15C17.328 19.38 14.933 20.5 12 20.5c-3.432 0-6.125-1.534-8.054-3.24C2.02 15.556.814 13.648.33 12.798a1.606 1.606 0 0 1 .001-1.6A18.283 18.283 0 0 1 3.648 7.01L1.317 5.362a.75.75 0 1 1 .866-1.224l20.5 14.5a.75.75 0 1 1-.866 1.224ZM4.902 7.898c-1.73 1.541-2.828 3.273-3.268 4.044a.112.112 0 0 0-.017.059c0 .015.003.034.016.055.441.774 1.551 2.527 3.307 4.08C6.69 17.685 9.045 19 12 19c2.334 0 4.29-.82 5.874-1.927l-3.516-2.487a3.5 3.5 0 0 1-5.583-3.949L4.902 7.899Z"
          })
        }
      };
    });
    var FileDirectoryIcon = /* @__PURE__ */ createIconComponent("FileDirectoryIcon", "octicon octicon-file-directory", function() {
      return {
        "16": {
          "width": 16,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M0 2.75C0 1.784.784 1 1.75 1H5c.55 0 1.07.26 1.4.7l.9 1.2a.25.25 0 0 0 .2.1h6.75c.966 0 1.75.784 1.75 1.75v8.5A1.75 1.75 0 0 1 14.25 15H1.75A1.75 1.75 0 0 1 0 13.25Zm1.75-.25a.25.25 0 0 0-.25.25v10.5c0 .138.112.25.25.25h12.5a.25.25 0 0 0 .25-.25v-8.5a.25.25 0 0 0-.25-.25H7.5c-.55 0-1.07-.26-1.4-.7l-.9-1.2a.25.25 0 0 0-.2-.1Z"
          })
        },
        "24": {
          "width": 24,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M2 4.75C2 3.784 2.784 3 3.75 3h4.971c.58 0 1.12.286 1.447.765l1.404 2.063c.046.069.124.11.207.11h8.471c.966 0 1.75.783 1.75 1.75V19.25A1.75 1.75 0 0 1 20.25 21H3.75A1.75 1.75 0 0 1 2 19.25Zm1.75-.25a.25.25 0 0 0-.25.25v14.5c0 .138.112.25.25.25h16.5a.25.25 0 0 0 .25-.25V7.687a.25.25 0 0 0-.25-.25h-8.471a1.75 1.75 0 0 1-1.447-.765L8.928 4.61a.252.252 0 0 0-.208-.11Z"
          })
        }
      };
    });
    var GearIcon = /* @__PURE__ */ createIconComponent("GearIcon", "octicon octicon-gear", function() {
      return {
        "16": {
          "width": 16,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M8 0a8.2 8.2 0 0 1 .701.031C9.444.095 9.99.645 10.16 1.29l.288 1.107c.018.066.079.158.212.224.231.114.454.243.668.386.123.082.233.09.299.071l1.103-.303c.644-.176 1.392.021 1.82.63.27.385.506.792.704 1.218.315.675.111 1.422-.364 1.891l-.814.806c-.049.048-.098.147-.088.294.016.257.016.515 0 .772-.01.147.038.246.088.294l.814.806c.475.469.679 1.216.364 1.891a7.977 7.977 0 0 1-.704 1.217c-.428.61-1.176.807-1.82.63l-1.102-.302c-.067-.019-.177-.011-.3.071a5.909 5.909 0 0 1-.668.386c-.133.066-.194.158-.211.224l-.29 1.106c-.168.646-.715 1.196-1.458 1.26a8.006 8.006 0 0 1-1.402 0c-.743-.064-1.289-.614-1.458-1.26l-.289-1.106c-.018-.066-.079-.158-.212-.224a5.738 5.738 0 0 1-.668-.386c-.123-.082-.233-.09-.299-.071l-1.103.303c-.644.176-1.392-.021-1.82-.63a8.12 8.12 0 0 1-.704-1.218c-.315-.675-.111-1.422.363-1.891l.815-.806c.05-.048.098-.147.088-.294a6.214 6.214 0 0 1 0-.772c.01-.147-.038-.246-.088-.294l-.815-.806C.635 6.045.431 5.298.746 4.623a7.92 7.92 0 0 1 .704-1.217c.428-.61 1.176-.807 1.82-.63l1.102.302c.067.019.177.011.3-.071.214-.143.437-.272.668-.386.133-.066.194-.158.211-.224l.29-1.106C6.009.645 6.556.095 7.299.03 7.53.01 7.764 0 8 0Zm-.571 1.525c-.036.003-.108.036-.137.146l-.289 1.105c-.147.561-.549.967-.998 1.189-.173.086-.34.183-.5.29-.417.278-.97.423-1.529.27l-1.103-.303c-.109-.03-.175.016-.195.045-.22.312-.412.644-.573.99-.014.031-.021.11.059.19l.815.806c.411.406.562.957.53 1.456a4.709 4.709 0 0 0 0 .582c.032.499-.119 1.05-.53 1.456l-.815.806c-.081.08-.073.159-.059.19.162.346.353.677.573.989.02.03.085.076.195.046l1.102-.303c.56-.153 1.113-.008 1.53.27.161.107.328.204.501.29.447.222.85.629.997 1.189l.289 1.105c.029.109.101.143.137.146a6.6 6.6 0 0 0 1.142 0c.036-.003.108-.036.137-.146l.289-1.105c.147-.561.549-.967.998-1.189.173-.086.34-.183.5-.29.417-.278.97-.423 1.529-.27l1.103.303c.109.029.175-.016.195-.045.22-.313.411-.644.573-.99.014-.031.021-.11-.059-.19l-.815-.806c-.411-.406-.562-.957-.53-1.456a4.709 4.709 0 0 0 0-.582c-.032-.499.119-1.05.53-1.456l.815-.806c.081-.08.073-.159.059-.19a6.464 6.464 0 0 0-.573-.989c-.02-.03-.085-.076-.195-.046l-1.102.303c-.56.153-1.113.008-1.53-.27a4.44 4.44 0 0 0-.501-.29c-.447-.222-.85-.629-.997-1.189l-.289-1.105c-.029-.11-.101-.143-.137-.146a6.6 6.6 0 0 0-1.142 0ZM11 8a3 3 0 1 1-6 0 3 3 0 0 1 6 0ZM9.5 8a1.5 1.5 0 1 0-3.001.001A1.5 1.5 0 0 0 9.5 8Z"
          })
        },
        "24": {
          "width": 24,
          "path": /* @__PURE__ */ React$1.createElement(React$1.Fragment, null, /* @__PURE__ */ React$1.createElement("path", {
            d: "M16 12a4 4 0 1 1-8 0 4 4 0 0 1 8 0Zm-1.5 0a2.5 2.5 0 1 0-5 0 2.5 2.5 0 0 0 5 0Z"
          }), /* @__PURE__ */ React$1.createElement("path", {
            d: "M12 1c.266 0 .532.009.797.028.763.055 1.345.617 1.512 1.304l.352 1.45c.019.078.09.171.225.221.247.089.49.19.728.302.13.061.246.044.315.002l1.275-.776c.603-.368 1.411-.353 1.99.147.402.349.78.726 1.128 1.129.501.578.515 1.386.147 1.99l-.776 1.274c-.042.069-.058.185.002.315.112.238.213.481.303.728.048.135.142.205.22.225l1.45.352c.687.167 1.249.749 1.303 1.512.038.531.038 1.063 0 1.594-.054.763-.616 1.345-1.303 1.512l-1.45.352c-.078.019-.171.09-.221.225-.089.248-.19.491-.302.728-.061.13-.044.246-.002.315l.776 1.275c.368.603.353 1.411-.147 1.99-.349.402-.726.78-1.129 1.128-.578.501-1.386.515-1.99.147l-1.274-.776c-.069-.042-.185-.058-.314.002a8.606 8.606 0 0 1-.729.303c-.135.048-.205.142-.225.22l-.352 1.45c-.167.687-.749 1.249-1.512 1.303-.531.038-1.063.038-1.594 0-.763-.054-1.345-.616-1.512-1.303l-.352-1.45c-.019-.078-.09-.171-.225-.221a8.138 8.138 0 0 1-.728-.302c-.13-.061-.246-.044-.315-.002l-1.275.776c-.603.368-1.411.353-1.99-.147-.402-.349-.78-.726-1.128-1.129-.501-.578-.515-1.386-.147-1.99l.776-1.274c.042-.069.058-.185-.002-.314a8.606 8.606 0 0 1-.303-.729c-.048-.135-.142-.205-.22-.225l-1.45-.352c-.687-.167-1.249-.749-1.304-1.512a11.158 11.158 0 0 1 0-1.594c.055-.763.617-1.345 1.304-1.512l1.45-.352c.078-.019.171-.09.221-.225.089-.248.19-.491.302-.728.061-.13.044-.246.002-.315l-.776-1.275c-.368-.603-.353-1.411.147-1.99.349-.402.726-.78 1.129-1.128.578-.501 1.386-.515 1.99-.147l1.274.776c.069.042.185.058.315-.002.238-.112.481-.213.728-.303.135-.048.205-.142.225-.22l.352-1.45c.167-.687.749-1.249 1.512-1.304C11.466 1.01 11.732 1 12 1Zm-.69 1.525c-.055.004-.135.05-.161.161l-.353 1.45a1.832 1.832 0 0 1-1.172 1.277 7.147 7.147 0 0 0-.6.249 1.833 1.833 0 0 1-1.734-.074l-1.274-.776c-.098-.06-.186-.036-.228 0a9.774 9.774 0 0 0-.976.976c-.036.042-.06.131 0 .228l.776 1.274c.314.529.342 1.18.074 1.734a7.147 7.147 0 0 0-.249.6 1.831 1.831 0 0 1-1.278 1.173l-1.45.351c-.11.027-.156.107-.16.162a9.63 9.63 0 0 0 0 1.38c.004.055.05.135.161.161l1.45.353a1.832 1.832 0 0 1 1.277 1.172c.074.204.157.404.249.6.268.553.24 1.204-.074 1.733l-.776 1.275c-.06.098-.036.186 0 .228.301.348.628.675.976.976.042.036.131.06.228 0l1.274-.776a1.83 1.83 0 0 1 1.734-.075c.196.093.396.176.6.25a1.831 1.831 0 0 1 1.173 1.278l.351 1.45c.027.11.107.156.162.16a9.63 9.63 0 0 0 1.38 0c.055-.004.135-.05.161-.161l.353-1.45a1.834 1.834 0 0 1 1.172-1.278 6.82 6.82 0 0 0 .6-.248 1.831 1.831 0 0 1 1.733.074l1.275.776c.098.06.186.036.228 0 .348-.301.675-.628.976-.976.036-.042.06-.131 0-.228l-.776-1.275a1.834 1.834 0 0 1-.075-1.733c.093-.196.176-.396.25-.6a1.831 1.831 0 0 1 1.278-1.173l1.45-.351c.11-.027.156-.107.16-.162a9.63 9.63 0 0 0 0-1.38c-.004-.055-.05-.135-.161-.161l-1.45-.353c-.626-.152-1.08-.625-1.278-1.172a6.576 6.576 0 0 0-.248-.6 1.833 1.833 0 0 1 .074-1.734l.776-1.274c.06-.098.036-.186 0-.228a9.774 9.774 0 0 0-.976-.976c-.042-.036-.131-.06-.228 0l-1.275.776a1.831 1.831 0 0 1-1.733.074 6.88 6.88 0 0 0-.6-.249 1.835 1.835 0 0 1-1.173-1.278l-.351-1.45c-.027-.11-.107-.156-.162-.16a9.63 9.63 0 0 0-1.38 0Z"
          }))
        }
      };
    });
    var HomeIcon = /* @__PURE__ */ createIconComponent("HomeIcon", "octicon octicon-home", function() {
      return {
        "16": {
          "width": 16,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z"
          })
        },
        "24": {
          "width": 24,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M11.03 2.59a1.501 1.501 0 0 1 1.94 0l7.5 6.363a1.5 1.5 0 0 1 .53 1.144V19.5a1.5 1.5 0 0 1-1.5 1.5h-5.75a.75.75 0 0 1-.75-.75V14h-2v6.25a.75.75 0 0 1-.75.75H4.5A1.5 1.5 0 0 1 3 19.5v-9.403c0-.44.194-.859.53-1.144ZM12 3.734l-7.5 6.363V19.5h5v-6.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v6.25h5v-9.403Z"
          })
        }
      };
    });
    var InboxIcon = /* @__PURE__ */ createIconComponent("InboxIcon", "octicon octicon-inbox", function() {
      return {
        "16": {
          "width": 16,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M2.8 2.06A1.75 1.75 0 0 1 4.41 1h7.18c.7 0 1.333.417 1.61 1.06l2.74 6.395c.04.093.06.194.06.295v4.5A1.75 1.75 0 0 1 14.25 15H1.75A1.75 1.75 0 0 1 0 13.25v-4.5c0-.101.02-.202.06-.295Zm1.61.44a.25.25 0 0 0-.23.152L1.887 8H4.75a.75.75 0 0 1 .6.3L6.625 10h2.75l1.275-1.7a.75.75 0 0 1 .6-.3h2.863L11.82 2.652a.25.25 0 0 0-.23-.152Zm10.09 7h-2.875l-1.275 1.7a.75.75 0 0 1-.6.3h-3.5a.75.75 0 0 1-.6-.3L4.375 9.5H1.5v3.75c0 .138.112.25.25.25h12.5a.25.25 0 0 0 .25-.25Z"
          })
        },
        "24": {
          "width": 24,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M4.801 3.57A1.75 1.75 0 0 1 6.414 2.5h11.174c.702 0 1.337.42 1.611 1.067l3.741 8.828c.04.092.06.192.06.293v7.562A1.75 1.75 0 0 1 21.25 22H2.75A1.75 1.75 0 0 1 1 20.25v-7.5c0-.1.02-.199.059-.291L4.8 3.571ZM6.414 4a.25.25 0 0 0-.23.153L2.88 12H8a.75.75 0 0 1 .648.372L10.18 15h3.638l1.533-2.628a.75.75 0 0 1 .64-.372l5.13-.051-3.304-7.797a.25.25 0 0 0-.23-.152ZM21.5 13.445l-5.067.05-1.535 2.633a.75.75 0 0 1-.648.372h-4.5a.75.75 0 0 1-.648-.372L7.57 13.5H2.5v6.75c0 .138.112.25.25.25h18.5a.25.25 0 0 0 .25-.25Z"
          })
        }
      };
    });
    var NoEntryIcon = /* @__PURE__ */ createIconComponent("NoEntryIcon", "octicon octicon-no-entry", function() {
      return {
        "16": {
          "width": 16,
          "path": /* @__PURE__ */ React$1.createElement(React$1.Fragment, null, /* @__PURE__ */ React$1.createElement("path", {
            d: "M4.25 7.25a.75.75 0 0 0 0 1.5h7.5a.75.75 0 0 0 0-1.5h-7.5Z"
          }), /* @__PURE__ */ React$1.createElement("path", {
            d: "M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0Zm-1.5 0a6.5 6.5 0 1 0-13 0 6.5 6.5 0 0 0 13 0Z"
          }))
        },
        "24": {
          "width": 24,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M12 1c6.075 0 11 4.925 11 11s-4.925 11-11 11S1 18.075 1 12 5.925 1 12 1ZM2.5 12a9.5 9.5 0 0 0 9.5 9.5 9.5 9.5 0 0 0 9.5-9.5A9.5 9.5 0 0 0 12 2.5 9.5 9.5 0 0 0 2.5 12Zm15.75.75H5.75a.75.75 0 0 1 0-1.5h12.5a.75.75 0 0 1 0 1.5Z"
          })
        }
      };
    });
    var PersonIcon = /* @__PURE__ */ createIconComponent("PersonIcon", "octicon octicon-person", function() {
      return {
        "16": {
          "width": 16,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M10.561 8.073a6.005 6.005 0 0 1 3.432 5.142.75.75 0 1 1-1.498.07 4.5 4.5 0 0 0-8.99 0 .75.75 0 0 1-1.498-.07 6.004 6.004 0 0 1 3.431-5.142 3.999 3.999 0 1 1 5.123 0ZM10.5 5a2.5 2.5 0 1 0-5 0 2.5 2.5 0 0 0 5 0Z"
          })
        },
        "24": {
          "width": 24,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M12 2.5a5.5 5.5 0 0 1 3.096 10.047 9.005 9.005 0 0 1 5.9 8.181.75.75 0 1 1-1.499.044 7.5 7.5 0 0 0-14.993 0 .75.75 0 0 1-1.5-.045 9.005 9.005 0 0 1 5.9-8.18A5.5 5.5 0 0 1 12 2.5ZM8 8a4 4 0 1 0 8 0 4 4 0 0 0-8 0Z"
          })
        }
      };
    });
    var PlayIcon = /* @__PURE__ */ createIconComponent("PlayIcon", "octicon octicon-play", function() {
      return {
        "16": {
          "width": 16,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M8 0a8 8 0 1 1 0 16A8 8 0 0 1 8 0ZM1.5 8a6.5 6.5 0 1 0 13 0 6.5 6.5 0 0 0-13 0Zm4.879-2.773 4.264 2.559a.25.25 0 0 1 0 .428l-4.264 2.559A.25.25 0 0 1 6 10.559V5.442a.25.25 0 0 1 .379-.215Z"
          })
        },
        "24": {
          "width": 24,
          "path": /* @__PURE__ */ React$1.createElement(React$1.Fragment, null, /* @__PURE__ */ React$1.createElement("path", {
            d: "M9.5 15.584V8.416a.5.5 0 0 1 .77-.42l5.576 3.583a.5.5 0 0 1 0 .842l-5.576 3.584a.5.5 0 0 1-.77-.42Z"
          }), /* @__PURE__ */ React$1.createElement("path", {
            d: "M1 12C1 5.925 5.925 1 12 1s11 4.925 11 11-4.925 11-11 11S1 18.075 1 12Zm11-9.5A9.5 9.5 0 0 0 2.5 12a9.5 9.5 0 0 0 9.5 9.5 9.5 9.5 0 0 0 9.5-9.5A9.5 9.5 0 0 0 12 2.5Z"
          }))
        }
      };
    });
    var PlusCircleIcon = /* @__PURE__ */ createIconComponent("PlusCircleIcon", "octicon octicon-plus-circle", function() {
      return {
        "16": {
          "width": 16,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M8 0a8 8 0 1 1 0 16A8 8 0 0 1 8 0ZM1.5 8a6.5 6.5 0 1 0 13 0 6.5 6.5 0 0 0-13 0Zm7.25-3.25v2.5h2.5a.75.75 0 0 1 0 1.5h-2.5v2.5a.75.75 0 0 1-1.5 0v-2.5h-2.5a.75.75 0 0 1 0-1.5h2.5v-2.5a.75.75 0 0 1 1.5 0Z"
          })
        },
        "24": {
          "width": 24,
          "path": /* @__PURE__ */ React$1.createElement(React$1.Fragment, null, /* @__PURE__ */ React$1.createElement("path", {
            d: "M12.75 7.75a.75.75 0 0 0-1.5 0v3.5h-3.5a.75.75 0 0 0 0 1.5h3.5v3.5a.75.75 0 0 0 1.5 0v-3.5h3.5a.75.75 0 0 0 0-1.5h-3.5v-3.5Z"
          }), /* @__PURE__ */ React$1.createElement("path", {
            d: "M12 1c6.075 0 11 4.925 11 11s-4.925 11-11 11S1 18.075 1 12 5.925 1 12 1ZM2.5 12a9.5 9.5 0 0 0 9.5 9.5 9.5 9.5 0 0 0 9.5-9.5A9.5 9.5 0 0 0 12 2.5 9.5 9.5 0 0 0 2.5 12Z"
          }))
        }
      };
    });
    var SearchIcon = /* @__PURE__ */ createIconComponent("SearchIcon", "octicon octicon-search", function() {
      return {
        "16": {
          "width": 16,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M10.68 11.74a6 6 0 0 1-7.922-8.982 6 6 0 0 1 8.982 7.922l3.04 3.04a.749.749 0 0 1-.326 1.275.749.749 0 0 1-.734-.215ZM11.5 7a4.499 4.499 0 1 0-8.997 0A4.499 4.499 0 0 0 11.5 7Z"
          })
        },
        "24": {
          "width": 24,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M10.25 2a8.25 8.25 0 0 1 6.34 13.53l5.69 5.69a.749.749 0 0 1-.326 1.275.749.749 0 0 1-.734-.215l-5.69-5.69A8.25 8.25 0 1 1 10.25 2ZM3.5 10.25a6.75 6.75 0 1 0 13.5 0 6.75 6.75 0 0 0-13.5 0Z"
          })
        }
      };
    });
    var SyncIcon = /* @__PURE__ */ createIconComponent("SyncIcon", "octicon octicon-sync", function() {
      return {
        "16": {
          "width": 16,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z"
          })
        },
        "24": {
          "width": 24,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M3.38 8A9.502 9.502 0 0 1 12 2.5a9.502 9.502 0 0 1 9.215 7.182.75.75 0 1 0 1.456-.364C21.473 4.539 17.15 1 12 1a10.995 10.995 0 0 0-9.5 5.452V4.75a.75.75 0 0 0-1.5 0V8.5a1 1 0 0 0 1 1h3.75a.75.75 0 0 0 0-1.5H3.38Zm-.595 6.318a.75.75 0 0 0-1.455.364C2.527 19.461 6.85 23 12 23c4.052 0 7.592-2.191 9.5-5.451v1.701a.75.75 0 0 0 1.5 0V15.5a1 1 0 0 0-1-1h-3.75a.75.75 0 0 0 0 1.5h2.37A9.502 9.502 0 0 1 12 21.5c-4.446 0-8.181-3.055-9.215-7.182Z"
          })
        }
      };
    });
    var TelescopeIcon = /* @__PURE__ */ createIconComponent("TelescopeIcon", "octicon octicon-telescope", function() {
      return {
        "16": {
          "width": 16,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M14.184 1.143v-.001l1.422 2.464a1.75 1.75 0 0 1-.757 2.451L3.104 11.713a1.75 1.75 0 0 1-2.275-.702l-.447-.775a1.75 1.75 0 0 1 .53-2.32L11.682.573a1.748 1.748 0 0 1 2.502.57Zm-4.709 9.32h-.001l2.644 3.863a.75.75 0 1 1-1.238.848l-1.881-2.75v2.826a.75.75 0 0 1-1.5 0v-2.826l-1.881 2.75a.75.75 0 1 1-1.238-.848l2.049-2.992a.746.746 0 0 1 .293-.253l1.809-.87a.749.749 0 0 1 .944.252ZM9.436 3.92h-.001l-4.97 3.39.942 1.63 5.42-2.61Zm3.091-2.108h.001l-1.85 1.26 1.505 2.605 2.016-.97a.247.247 0 0 0 .13-.151.247.247 0 0 0-.022-.199l-1.422-2.464a.253.253 0 0 0-.161-.119.254.254 0 0 0-.197.038ZM1.756 9.157a.25.25 0 0 0-.075.33l.447.775a.25.25 0 0 0 .325.1l1.598-.769-.83-1.436-1.465 1Z"
          })
        },
        "24": {
          "width": 24,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M.408 15.13a2 2 0 0 1 .59-2.642L17.038 1.33a1.999 1.999 0 0 1 2.85.602l2.828 4.644a2 2 0 0 1-.851 2.847l-17.762 8.43a2 2 0 0 1-2.59-.807Zm5.263-4.066 1.987 3.44 8.712-4.135-2.857-4.76Zm12.06-1.34.001-.001 3.49-1.656a.498.498 0 0 0 .212-.712l-2.826-4.644a.503.503 0 0 0-.713-.151l-3.148 2.19Zm-13.295 2.2L1.854 13.72a.5.5 0 0 0-.147.66l1.105 1.915a.5.5 0 0 0 .648.201l2.838-1.347ZM17.155 22.87a.75.75 0 0 0 .226-1.036l-4-6.239a.75.75 0 0 0-.941-.278l-2.75 1.25a.75.75 0 0 0-.318.274l-3.25 4.989a.75.75 0 0 0 1.256.819l3.131-4.806.51-.232v5.64a.75.75 0 1 0 1.5 0v-6.22l3.6 5.613a.75.75 0 0 0 1.036.226Z"
          })
        }
      };
    });
    var XIcon = /* @__PURE__ */ createIconComponent("XIcon", "octicon octicon-x", function() {
      return {
        "12": {
          "width": 12,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M2.22 2.22a.749.749 0 0 1 1.06 0L6 4.939 8.72 2.22a.749.749 0 1 1 1.06 1.06L7.061 6 9.78 8.72a.749.749 0 1 1-1.06 1.06L6 7.061 3.28 9.78a.749.749 0 1 1-1.06-1.06L4.939 6 2.22 3.28a.749.749 0 0 1 0-1.06Z"
          })
        },
        "16": {
          "width": 16,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M3.72 3.72a.75.75 0 0 1 1.06 0L8 6.94l3.22-3.22a.749.749 0 0 1 1.275.326.749.749 0 0 1-.215.734L9.06 8l3.22 3.22a.749.749 0 0 1-.326 1.275.749.749 0 0 1-.734-.215L8 9.06l-3.22 3.22a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042L6.94 8 3.72 4.78a.75.75 0 0 1 0-1.06Z"
          })
        },
        "24": {
          "width": 24,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M5.72 5.72a.75.75 0 0 1 1.06 0L12 10.94l5.22-5.22a.749.749 0 0 1 1.275.326.749.749 0 0 1-.215.734L13.06 12l5.22 5.22a.749.749 0 0 1-.326 1.275.749.749 0 0 1-.734-.215L12 13.06l-5.22 5.22a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042L10.94 12 5.72 6.78a.75.75 0 0 1 0-1.06Z"
          })
        }
      };
    });
    var XCircleFillIcon = /* @__PURE__ */ createIconComponent("XCircleFillIcon", "octicon octicon-x-circle-fill", function() {
      return {
        "12": {
          "width": 12,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M1.757 10.243a6.001 6.001 0 1 1 8.488-8.486 6.001 6.001 0 0 1-8.488 8.486ZM6 4.763l-2-2L2.763 4l2 2-2 2L4 9.237l2-2 2 2L9.237 8l-2-2 2-2L8 2.763Z"
          })
        },
        "16": {
          "width": 16,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M2.343 13.657A8 8 0 1 1 13.658 2.343 8 8 0 0 1 2.343 13.657ZM6.03 4.97a.751.751 0 0 0-1.042.018.751.751 0 0 0-.018 1.042L6.94 8 4.97 9.97a.749.749 0 0 0 .326 1.275.749.749 0 0 0 .734-.215L8 9.06l1.97 1.97a.749.749 0 0 0 1.275-.326.749.749 0 0 0-.215-.734L9.06 8l1.97-1.97a.749.749 0 0 0-.326-1.275.749.749 0 0 0-.734.215L8 6.94Z"
          })
        },
        "24": {
          "width": 24,
          "path": /* @__PURE__ */ React$1.createElement("path", {
            d: "M1 12C1 5.925 5.925 1 12 1s11 4.925 11 11-4.925 11-11 11S1 18.075 1 12Zm8.036-4.024a.751.751 0 0 0-1.042.018.751.751 0 0 0-.018 1.042L10.939 12l-2.963 2.963a.749.749 0 0 0 .326 1.275.749.749 0 0 0 .734-.215L12 13.06l2.963 2.964a.75.75 0 0 0 1.061-1.06L13.061 12l2.963-2.964a.749.749 0 0 0-.326-1.275.749.749 0 0 0-.734.215L12 10.939Z"
          })
        }
      };
    });
    const SvgSteamLogo = (props) => /* @__PURE__ */ reactExports.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 20, height: 20, viewBox: "0 0 24 24", ...props }, /* @__PURE__ */ reactExports.createElement("path", { fill: "currentColor", d: "M12 2a10 10 0 0 1 10 10a10 10 0 0 1-10 10c-4.6 0-8.45-3.08-9.64-7.27l3.83 1.58a2.843 2.843 0 0 0 2.78 2.27c1.56 0 2.83-1.27 2.83-2.83v-.13l3.4-2.43h.08c2.08 0 3.77-1.69 3.77-3.77s-1.69-3.77-3.77-3.77s-3.78 1.69-3.78 3.77v.05l-2.37 3.46l-.16-.01c-.59 0-1.14.18-1.59.49L2 11.2C2.43 6.05 6.73 2 12 2M8.28 17.17c.8.33 1.72-.04 2.05-.84c.33-.8-.05-1.71-.83-2.04l-1.28-.53c.49-.18 1.04-.19 1.56.03c.53.21.94.62 1.15 1.15c.22.52.22 1.1 0 1.62c-.43 1.08-1.7 1.6-2.78 1.15c-.5-.21-.88-.59-1.09-1.04zm9.52-7.75c0 1.39-1.13 2.52-2.52 2.52a2.52 2.52 0 0 1-2.51-2.52a2.5 2.5 0 0 1 2.51-2.51a2.52 2.52 0 0 1 2.52 2.51m-4.4 0c0 1.04.84 1.89 1.89 1.89c1.04 0 1.88-.85 1.88-1.89s-.84-1.89-1.88-1.89c-1.05 0-1.89.85-1.89 1.89" }));
    var card = "_126ztf90";
    var backdrop$2 = "_126ztf91";
    var cover = "_126ztf92";
    var content$6 = "_126ztf93";
    var title$1 = "_126ztf94";
    var downloadOptions = "_126ztf95";
    var specifics = "_126ztf96";
    var specificsItem = "_126ztf97";
    var titleContainer = "_126ztf98";
    var shopIcon$1 = "_126ztf99";
    var noDownloadsLabel = "_126ztf9a";
    var badge = "_11nhos70";
    function Badge({ children }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: badge, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children }) });
    }
    const shopIcon = {
      steam: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgSteamLogo, { className: shopIcon$1 })
    };
    function GameCard({ game, ...props }) {
      const { t: t2 } = useTranslation("game_card");
      const uniqueRepackers = Array.from(
        new Set(game.repacks.map(({ repacker }) => repacker))
      );
      return /* @__PURE__ */ jsxRuntimeExports.jsx("button", { ...props, type: "button", className: card, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: backdrop$2, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: game.cover, alt: game.title, className: cover }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: content$6, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: titleContainer, children: [
            shopIcon[game.shop],
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: title$1, children: game.title })
          ] }),
          uniqueRepackers.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: downloadOptions, children: uniqueRepackers.map((repacker) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { children: repacker }) }, repacker)) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: noDownloadsLabel, children: t2("no_downloads") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: specifics, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: specificsItem, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(DownloadIcon$1, {}),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: game.repacks.length })
            ] }),
            game.repacks.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: specificsItem, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(FileDirectoryIcon, {}),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: game.repacks.at(0)?.fileSize })
            ] })
          ] })
        ] })
      ] }) });
    }
    function toPrimitive(t2, r2) {
      if ("object" != typeof t2 || !t2)
        return t2;
      var e2 = t2[Symbol.toPrimitive];
      if (void 0 !== e2) {
        var i2 = e2.call(t2, r2 || "default");
        if ("object" != typeof i2)
          return i2;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r2 ? String : Number)(t2);
    }
    function toPropertyKey(t2) {
      var i2 = toPrimitive(t2, "string");
      return "symbol" == typeof i2 ? i2 : String(i2);
    }
    function _defineProperty$1(obj, key2, value2) {
      key2 = toPropertyKey(key2);
      if (key2 in obj) {
        Object.defineProperty(obj, key2, {
          value: value2,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key2] = value2;
      }
      return obj;
    }
    function ownKeys$1(e2, r2) {
      var t2 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e2);
        r2 && (o = o.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
        })), t2.push.apply(t2, o);
      }
      return t2;
    }
    function _objectSpread2$1(e2) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$1(Object(t2), true).forEach(function(r3) {
          _defineProperty$1(e2, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$1(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e2;
    }
    function mapValues(input, fn) {
      var result = {};
      for (var _key in input) {
        result[_key] = fn(input[_key], _key);
      }
      return result;
    }
    var shouldApplyCompound = (compoundCheck, selections, defaultVariants) => {
      for (var key2 of Object.keys(compoundCheck)) {
        var _selections$key;
        if (compoundCheck[key2] !== ((_selections$key = selections[key2]) !== null && _selections$key !== void 0 ? _selections$key : defaultVariants[key2])) {
          return false;
        }
      }
      return true;
    };
    var createRuntimeFn = (config) => {
      var runtimeFn = (options) => {
        var className = config.defaultClassName;
        var selections = _objectSpread2$1(_objectSpread2$1({}, config.defaultVariants), options);
        for (var variantName in selections) {
          var _selections$variantNa;
          var variantSelection = (_selections$variantNa = selections[variantName]) !== null && _selections$variantNa !== void 0 ? _selections$variantNa : config.defaultVariants[variantName];
          if (variantSelection != null) {
            var selection = variantSelection;
            if (typeof selection === "boolean") {
              selection = selection === true ? "true" : "false";
            }
            var selectionClassName = (
              // @ts-expect-error
              config.variantClassNames[variantName][selection]
            );
            if (selectionClassName) {
              className += " " + selectionClassName;
            }
          }
        }
        for (var [compoundCheck, compoundClassName] of config.compoundVariants) {
          if (shouldApplyCompound(compoundCheck, selections, config.defaultVariants)) {
            className += " " + compoundClassName;
          }
        }
        return className;
      };
      runtimeFn.variants = () => Object.keys(config.variantClassNames);
      runtimeFn.classNames = {
        get base() {
          return config.defaultClassName.split(" ")[0];
        },
        get variants() {
          return mapValues(config.variantClassNames, (classNames) => mapValues(classNames, (className) => className.split(" ")[0]));
        }
      };
      return runtimeFn;
    };
    var header$l = createRuntimeFn({ defaultClassName: "as2sbw2", variantClassNames: { draggingDisabled: { true: "as2sbw3" }, isWindows: { true: "as2sbw4" } }, defaultVariants: {}, compoundVariants: [] });
    var search = createRuntimeFn({ defaultClassName: "as2sbw5", variantClassNames: { focused: { true: "as2sbw6", false: "as2sbw7" } }, defaultVariants: {}, compoundVariants: [] });
    var searchInput = "as2sbw8";
    var actionButton = "as2sbw9";
    var section$1 = "as2sbwa";
    var backButton = createRuntimeFn({ defaultClassName: "as2sbwb", variantClassNames: { enabled: { true: "as2sbwc", false: "as2sbwd" } }, defaultVariants: {}, compoundVariants: [] });
    var title = createRuntimeFn({ defaultClassName: "as2sbwe", variantClassNames: { hasBackButton: { true: "as2sbwf" } }, defaultVariants: {}, compoundVariants: [] });
    var subheader = "as2sbwg";
    var newVersionButton = "as2sbwh";
    var newVersionLink = "as2sbwi";
    var newVersionIcon = "as2sbwj";
    var link = "zja4r30";
    function Link({ children, to, className, ...props }) {
      const openExternal = (event) => {
        event.preventDefault();
        window.electron.openExternal(to);
      };
      if (typeof to === "string" && to.startsWith("http")) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "a",
          {
            href: to,
            className: cn(link, className),
            onClick: openExternal,
            ...props,
            children
          }
        );
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Link$1,
        {
          className: cn(link, className),
          to,
          ...props,
          children
        }
      );
    }
    const releasesPageUrl = "https://github.com/AnzioFckr/NoFinder/releases/latest";
    function AutoUpdateSubHeader() {
      const [isReadyToInstall, setIsReadyToInstall] = reactExports.useState(false);
      const [newVersion, setNewVersion] = reactExports.useState(null);
      const [isAutoInstallAvailable, setIsAutoInstallAvailable] = reactExports.useState(false);
      const { t: t2 } = useTranslation("header");
      const handleClickInstallUpdate = () => {
        window.electron.restartAndInstallUpdate();
      };
      reactExports.useEffect(() => {
        const unsubscribe = window.electron.onAutoUpdaterEvent(
          (event) => {
            if (event.type == "update-available") {
              setNewVersion(event.info.version);
            }
            if (event.type == "update-downloaded") {
              setIsReadyToInstall(true);
            }
          }
        );
        window.electron.checkForUpdates().then((isAutoInstallAvailable2) => {
          setIsAutoInstallAvailable(isAutoInstallAvailable2);
        });
        return () => {
          unsubscribe();
        };
      }, []);
      if (!newVersion)
        return null;
      if (!isAutoInstallAvailable) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx("header", { className: subheader, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Link, { to: releasesPageUrl, className: newVersionLink, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(SyncIcon, { className: newVersionIcon, size: 12 }),
          t2("version_available_download", { version: newVersion })
        ] }) });
      }
      if (isReadyToInstall) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx("header", { className: subheader, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            type: "button",
            className: newVersionButton,
            onClick: handleClickInstallUpdate,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(SyncIcon, { className: newVersionIcon, size: 12 }),
              t2("version_available_install", { version: newVersion })
            ]
          }
        ) });
      }
      return null;
    }
    const pathTitle = {
      "/": "home",
      "/catalogue": "catalogue",
      "/downloads": "downloads",
      "/settings": "settings"
    };
    function Header({ onSearch, onClear, search: search$1 }) {
      const inputRef = reactExports.useRef(null);
      const navigate = useNavigate();
      const location = useLocation();
      const { headerTitle, draggingDisabled } = useAppSelector(
        (state) => state.window
      );
      const dispatch = useAppDispatch();
      const [isFocused, setIsFocused] = reactExports.useState(false);
      const { t: t2 } = useTranslation("header");
      const title$12 = reactExports.useMemo(() => {
        if (location.pathname.startsWith("/game"))
          return headerTitle;
        if (location.pathname.startsWith("/user"))
          return headerTitle;
        if (location.pathname.startsWith("/search"))
          return t2("search_results");
        return t2(pathTitle[location.pathname]);
      }, [location.pathname, headerTitle, t2]);
      reactExports.useEffect(() => {
        if (search$1 && !location.pathname.startsWith("/search")) {
          dispatch(clearSearch());
        }
      }, [location.pathname, search$1, dispatch]);
      const focusInput = () => {
        setIsFocused(true);
        inputRef.current?.focus();
      };
      const handleBlur = () => {
        setIsFocused(false);
      };
      const handleBackButtonClick = () => {
        navigate(-1);
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "header",
          {
            className: header$l({
              draggingDisabled,
              isWindows: window.electron.platform === "win32"
            }),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: section$1, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    className: backButton({
                      enabled: location.key !== "default"
                    }),
                    onClick: handleBackButtonClick,
                    disabled: location.key === "default",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowLeftIcon, {})
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "h3",
                  {
                    className: title({
                      hasBackButton: location.key !== "default"
                    }),
                    children: title$12
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: section$1, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: search({ focused: isFocused }), children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    className: actionButton,
                    onClick: focusInput,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(SearchIcon, {})
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    ref: inputRef,
                    type: "text",
                    name: "search",
                    placeholder: t2("search"),
                    value: search$1,
                    className: searchInput,
                    onChange: (event) => onSearch(event.target.value),
                    onFocus: () => setIsFocused(true),
                    onBlur: handleBlur
                  }
                ),
                search$1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    onClick: onClear,
                    className: actionButton,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(XIcon, {})
                  }
                )
              ] }) })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(AutoUpdateSubHeader, {})
      ] });
    }
    var hero$1 = "_1655e30";
    var heroMedia = "_1655e31";
    var backdrop$1 = "_1655e32";
    var description$2 = "_1655e33";
    var content$5 = "_1655e34";
    const FEATURED_GAME_TITLE = "ELDEN RING";
    const FEATURED_GAME_ID = "1245620";
    function Hero() {
      const [featuredGameDetails, setFeaturedGameDetails] = reactExports.useState(null);
      const [isLoading, setIsLoading] = reactExports.useState(false);
      const { i18n } = useTranslation();
      const navigate = useNavigate();
      reactExports.useEffect(() => {
        setIsLoading(true);
        window.electron.getGameShopDetails(
          FEATURED_GAME_ID,
          "steam",
          getSteamLanguage(i18n.language)
        ).then((result) => {
          setFeaturedGameDetails(result);
        }).finally(() => {
          setIsLoading(false);
        });
      }, [i18n.language]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          type: "button",
          onClick: () => navigate(
            buildGameDetailsPath({
              title: FEATURED_GAME_TITLE,
              objectID: FEATURED_GAME_ID,
              shop: "steam"
            })
          ),
          className: hero$1,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: backdrop$1, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: "https://cdn2.steamgriddb.com/hero/95eb39b541856d43649b208b65b6ca9f.jpg",
                alt: FEATURED_GAME_TITLE,
                className: heroMedia
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: content$5, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "img",
                {
                  src: steamUrlBuilder.logo(FEATURED_GAME_ID),
                  width: "250px",
                  alt: FEATURED_GAME_TITLE
                }
              ),
              !isLoading && featuredGameDetails && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: description$2, children: featuredGameDetails?.short_description })
            ] })
          ] })
        }
      );
    }
    var modal$j = createRuntimeFn({ defaultClassName: "dlejqf2", variantClassNames: { closing: { true: "dlejqf3" }, large: { true: "dlejqf4" } }, defaultVariants: {}, compoundVariants: [] });
    var modalContent = "dlejqf5";
    var modalHeader = "dlejqf6";
    var closeModalButton = "dlejqf7";
    var closeModalButtonIcon = "dlejqf8";
    var backdrop = createRuntimeFn({ defaultClassName: "bwhts12", variantClassNames: { closing: { true: "bwhts13" }, windows: { true: "bwhts14" } }, defaultVariants: {}, compoundVariants: [] });
    function Backdrop({ isClosing = false, children }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: backdrop({
            closing: isClosing,
            windows: window.electron.platform === "win32"
          }),
          children
        }
      );
    }
    function Modal({
      visible,
      title: title2,
      description: description2,
      onClose,
      large,
      children,
      clickOutsideToClose = true
    }) {
      const [isClosing, setIsClosing] = reactExports.useState(false);
      const modalContentRef = reactExports.useRef(null);
      const { t: t2 } = useTranslation("modal");
      const handleCloseClick = reactExports.useCallback(() => {
        setIsClosing(true);
        const zero = performance.now();
        requestAnimationFrame(function animateClosing(time2) {
          if (time2 - zero <= 400) {
            requestAnimationFrame(animateClosing);
          } else {
            onClose();
            setIsClosing(false);
          }
        });
      }, [onClose]);
      const isTopMostModal = () => {
        const openModals = document.querySelectorAll("[role=dialog]");
        return openModals.length && openModals[openModals.length - 1] === modalContentRef.current;
      };
      reactExports.useEffect(() => {
        if (visible) {
          const onKeyDown = (e2) => {
            if (e2.key === "Escape" && isTopMostModal()) {
              handleCloseClick();
            }
          };
          window.addEventListener("keydown", onKeyDown);
          return () => {
            window.removeEventListener("keydown", onKeyDown);
          };
        }
        return () => {
        };
      }, [handleCloseClick, visible]);
      reactExports.useEffect(() => {
        if (clickOutsideToClose) {
          const onMouseDown = (e2) => {
            if (!isTopMostModal())
              return;
            if (modalContentRef.current) {
              const clickedWithinModal = modalContentRef.current.contains(
                e2.target
              );
              if (!clickedWithinModal) {
                handleCloseClick();
              }
            }
          };
          window.addEventListener("mousedown", onMouseDown);
          return () => {
            window.removeEventListener("mousedown", onMouseDown);
          };
        }
        return () => {
        };
      }, [clickOutsideToClose, handleCloseClick]);
      if (!visible)
        return null;
      return reactDomExports.createPortal(
        /* @__PURE__ */ jsxRuntimeExports.jsx(Backdrop, { isClosing, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: modal$j({ closing: isClosing, large }),
            role: "dialog",
            "aria-labelledby": title2,
            "aria-describedby": description2,
            ref: modalContentRef,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: modalHeader, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: 4, flexDirection: "column" }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: title2 }),
                  description2 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: description2 })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    onClick: handleCloseClick,
                    className: closeModalButton,
                    "aria-label": t2("close"),
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(XIcon, { className: closeModalButtonIcon, size: 24 })
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: modalContent, children })
            ]
          }
        ) }),
        document.body
      );
    }
    var lottie$1 = { exports: {} };
    (function(module, exports) {
      typeof navigator !== "undefined" && function(global2, factory) {
        module.exports = factory();
      }(commonjsGlobal, function() {
        var svgNS = "http://www.w3.org/2000/svg";
        var locationHref = "";
        var _useWebWorker = false;
        var initialDefaultFrame = -999999;
        var setWebWorker = function setWebWorker2(flag) {
          _useWebWorker = !!flag;
        };
        var getWebWorker = function getWebWorker2() {
          return _useWebWorker;
        };
        var setLocationHref = function setLocationHref2(value2) {
          locationHref = value2;
        };
        var getLocationHref = function getLocationHref2() {
          return locationHref;
        };
        function createTag(type) {
          return document.createElement(type);
        }
        function extendPrototype(sources, destination) {
          var i2;
          var len = sources.length;
          var sourcePrototype;
          for (i2 = 0; i2 < len; i2 += 1) {
            sourcePrototype = sources[i2].prototype;
            for (var attr in sourcePrototype) {
              if (Object.prototype.hasOwnProperty.call(sourcePrototype, attr))
                destination.prototype[attr] = sourcePrototype[attr];
            }
          }
        }
        function getDescriptor(object, prop) {
          return Object.getOwnPropertyDescriptor(object, prop);
        }
        function createProxyFunction(prototype) {
          function ProxyFunction() {
          }
          ProxyFunction.prototype = prototype;
          return ProxyFunction;
        }
        var audioControllerFactory = function() {
          function AudioController(audioFactory) {
            this.audios = [];
            this.audioFactory = audioFactory;
            this._volume = 1;
            this._isMuted = false;
          }
          AudioController.prototype = {
            addAudio: function addAudio(audio) {
              this.audios.push(audio);
            },
            pause: function pause() {
              var i2;
              var len = this.audios.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                this.audios[i2].pause();
              }
            },
            resume: function resume() {
              var i2;
              var len = this.audios.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                this.audios[i2].resume();
              }
            },
            setRate: function setRate(rateValue) {
              var i2;
              var len = this.audios.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                this.audios[i2].setRate(rateValue);
              }
            },
            createAudio: function createAudio(assetPath) {
              if (this.audioFactory) {
                return this.audioFactory(assetPath);
              }
              if (window.Howl) {
                return new window.Howl({
                  src: [assetPath]
                });
              }
              return {
                isPlaying: false,
                play: function play() {
                  this.isPlaying = true;
                },
                seek: function seek() {
                  this.isPlaying = false;
                },
                playing: function playing() {
                },
                rate: function rate() {
                },
                setVolume: function setVolume() {
                }
              };
            },
            setAudioFactory: function setAudioFactory(audioFactory) {
              this.audioFactory = audioFactory;
            },
            setVolume: function setVolume(value2) {
              this._volume = value2;
              this._updateVolume();
            },
            mute: function mute() {
              this._isMuted = true;
              this._updateVolume();
            },
            unmute: function unmute() {
              this._isMuted = false;
              this._updateVolume();
            },
            getVolume: function getVolume() {
              return this._volume;
            },
            _updateVolume: function _updateVolume() {
              var i2;
              var len = this.audios.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                this.audios[i2].volume(this._volume * (this._isMuted ? 0 : 1));
              }
            }
          };
          return function() {
            return new AudioController();
          };
        }();
        var createTypedArray = function() {
          function createRegularArray(type, len) {
            var i2 = 0;
            var arr2 = [];
            var value2;
            switch (type) {
              case "int16":
              case "uint8c":
                value2 = 1;
                break;
              default:
                value2 = 1.1;
                break;
            }
            for (i2 = 0; i2 < len; i2 += 1) {
              arr2.push(value2);
            }
            return arr2;
          }
          function createTypedArrayFactory(type, len) {
            if (type === "float32") {
              return new Float32Array(len);
            }
            if (type === "int16") {
              return new Int16Array(len);
            }
            if (type === "uint8c") {
              return new Uint8ClampedArray(len);
            }
            return createRegularArray(type, len);
          }
          if (typeof Uint8ClampedArray === "function" && typeof Float32Array === "function") {
            return createTypedArrayFactory;
          }
          return createRegularArray;
        }();
        function createSizedArray(len) {
          return Array.apply(null, {
            length: len
          });
        }
        function _typeof$6(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof$6 = function _typeof2(obj2) {
              return typeof obj2;
            };
          } else {
            _typeof$6 = function _typeof2(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return _typeof$6(obj);
        }
        var subframeEnabled = true;
        var expressionsPlugin = null;
        var expressionsInterfaces = null;
        var idPrefix$1 = "";
        var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        var bmPow = Math.pow;
        var bmSqrt = Math.sqrt;
        var bmFloor = Math.floor;
        var bmMax = Math.max;
        var bmMin = Math.min;
        var BMMath = {};
        (function() {
          var propertyNames = ["abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "cbrt", "expm1", "clz32", "cos", "cosh", "exp", "floor", "fround", "hypot", "imul", "log", "log1p", "log2", "log10", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh", "trunc", "E", "LN10", "LN2", "LOG10E", "LOG2E", "PI", "SQRT1_2", "SQRT2"];
          var i2;
          var len = propertyNames.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            BMMath[propertyNames[i2]] = Math[propertyNames[i2]];
          }
        })();
        BMMath.random = Math.random;
        BMMath.abs = function(val2) {
          var tOfVal = _typeof$6(val2);
          if (tOfVal === "object" && val2.length) {
            var absArr = createSizedArray(val2.length);
            var i2;
            var len = val2.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              absArr[i2] = Math.abs(val2[i2]);
            }
            return absArr;
          }
          return Math.abs(val2);
        };
        var defaultCurveSegments = 150;
        var degToRads = Math.PI / 180;
        var roundCorner = 0.5519;
        function styleDiv(element) {
          element.style.position = "absolute";
          element.style.top = 0;
          element.style.left = 0;
          element.style.display = "block";
          element.style.transformOrigin = "0 0";
          element.style.webkitTransformOrigin = "0 0";
          element.style.backfaceVisibility = "visible";
          element.style.webkitBackfaceVisibility = "visible";
          element.style.transformStyle = "preserve-3d";
          element.style.webkitTransformStyle = "preserve-3d";
          element.style.mozTransformStyle = "preserve-3d";
        }
        function BMEnterFrameEvent(type, currentTime, totalTime, frameMultiplier) {
          this.type = type;
          this.currentTime = currentTime;
          this.totalTime = totalTime;
          this.direction = frameMultiplier < 0 ? -1 : 1;
        }
        function BMCompleteEvent(type, frameMultiplier) {
          this.type = type;
          this.direction = frameMultiplier < 0 ? -1 : 1;
        }
        function BMCompleteLoopEvent(type, totalLoops, currentLoop, frameMultiplier) {
          this.type = type;
          this.currentLoop = currentLoop;
          this.totalLoops = totalLoops;
          this.direction = frameMultiplier < 0 ? -1 : 1;
        }
        function BMSegmentStartEvent(type, firstFrame, totalFrames) {
          this.type = type;
          this.firstFrame = firstFrame;
          this.totalFrames = totalFrames;
        }
        function BMDestroyEvent(type, target) {
          this.type = type;
          this.target = target;
        }
        function BMRenderFrameErrorEvent(nativeError, currentTime) {
          this.type = "renderFrameError";
          this.nativeError = nativeError;
          this.currentTime = currentTime;
        }
        function BMConfigErrorEvent(nativeError) {
          this.type = "configError";
          this.nativeError = nativeError;
        }
        var createElementID = /* @__PURE__ */ function() {
          var _count = 0;
          return function createID() {
            _count += 1;
            return idPrefix$1 + "__lottie_element_" + _count;
          };
        }();
        function HSVtoRGB(h2, s2, v2) {
          var r2;
          var g2;
          var b;
          var i2;
          var f2;
          var p2;
          var q2;
          var t2;
          i2 = Math.floor(h2 * 6);
          f2 = h2 * 6 - i2;
          p2 = v2 * (1 - s2);
          q2 = v2 * (1 - f2 * s2);
          t2 = v2 * (1 - (1 - f2) * s2);
          switch (i2 % 6) {
            case 0:
              r2 = v2;
              g2 = t2;
              b = p2;
              break;
            case 1:
              r2 = q2;
              g2 = v2;
              b = p2;
              break;
            case 2:
              r2 = p2;
              g2 = v2;
              b = t2;
              break;
            case 3:
              r2 = p2;
              g2 = q2;
              b = v2;
              break;
            case 4:
              r2 = t2;
              g2 = p2;
              b = v2;
              break;
            case 5:
              r2 = v2;
              g2 = p2;
              b = q2;
              break;
          }
          return [r2, g2, b];
        }
        function RGBtoHSV(r2, g2, b) {
          var max = Math.max(r2, g2, b);
          var min = Math.min(r2, g2, b);
          var d = max - min;
          var h2;
          var s2 = max === 0 ? 0 : d / max;
          var v2 = max / 255;
          switch (max) {
            case min:
              h2 = 0;
              break;
            case r2:
              h2 = g2 - b + d * (g2 < b ? 6 : 0);
              h2 /= 6 * d;
              break;
            case g2:
              h2 = b - r2 + d * 2;
              h2 /= 6 * d;
              break;
            case b:
              h2 = r2 - g2 + d * 4;
              h2 /= 6 * d;
              break;
          }
          return [h2, s2, v2];
        }
        function addSaturationToRGB(color2, offset) {
          var hsv = RGBtoHSV(color2[0] * 255, color2[1] * 255, color2[2] * 255);
          hsv[1] += offset;
          if (hsv[1] > 1) {
            hsv[1] = 1;
          } else if (hsv[1] <= 0) {
            hsv[1] = 0;
          }
          return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
        }
        function addBrightnessToRGB(color2, offset) {
          var hsv = RGBtoHSV(color2[0] * 255, color2[1] * 255, color2[2] * 255);
          hsv[2] += offset;
          if (hsv[2] > 1) {
            hsv[2] = 1;
          } else if (hsv[2] < 0) {
            hsv[2] = 0;
          }
          return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
        }
        function addHueToRGB(color2, offset) {
          var hsv = RGBtoHSV(color2[0] * 255, color2[1] * 255, color2[2] * 255);
          hsv[0] += offset / 360;
          if (hsv[0] > 1) {
            hsv[0] -= 1;
          } else if (hsv[0] < 0) {
            hsv[0] += 1;
          }
          return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
        }
        var rgbToHex = function() {
          var colorMap = [];
          var i2;
          var hex;
          for (i2 = 0; i2 < 256; i2 += 1) {
            hex = i2.toString(16);
            colorMap[i2] = hex.length === 1 ? "0" + hex : hex;
          }
          return function(r2, g2, b) {
            if (r2 < 0) {
              r2 = 0;
            }
            if (g2 < 0) {
              g2 = 0;
            }
            if (b < 0) {
              b = 0;
            }
            return "#" + colorMap[r2] + colorMap[g2] + colorMap[b];
          };
        }();
        var setSubframeEnabled = function setSubframeEnabled2(flag) {
          subframeEnabled = !!flag;
        };
        var getSubframeEnabled = function getSubframeEnabled2() {
          return subframeEnabled;
        };
        var setExpressionsPlugin = function setExpressionsPlugin2(value2) {
          expressionsPlugin = value2;
        };
        var getExpressionsPlugin = function getExpressionsPlugin2() {
          return expressionsPlugin;
        };
        var setExpressionInterfaces = function setExpressionInterfaces2(value2) {
          expressionsInterfaces = value2;
        };
        var getExpressionInterfaces = function getExpressionInterfaces2() {
          return expressionsInterfaces;
        };
        var setDefaultCurveSegments = function setDefaultCurveSegments2(value2) {
          defaultCurveSegments = value2;
        };
        var getDefaultCurveSegments = function getDefaultCurveSegments2() {
          return defaultCurveSegments;
        };
        var setIdPrefix = function setIdPrefix2(value2) {
          idPrefix$1 = value2;
        };
        function createNS(type) {
          return document.createElementNS(svgNS, type);
        }
        function _typeof$5(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof$5 = function _typeof2(obj2) {
              return typeof obj2;
            };
          } else {
            _typeof$5 = function _typeof2(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return _typeof$5(obj);
        }
        var dataManager = /* @__PURE__ */ function() {
          var _counterId = 1;
          var processes = [];
          var workerFn;
          var workerInstance;
          var workerProxy = {
            onmessage: function onmessage() {
            },
            postMessage: function postMessage(path2) {
              workerFn({
                data: path2
              });
            }
          };
          var _workerSelf = {
            postMessage: function postMessage(data2) {
              workerProxy.onmessage({
                data: data2
              });
            }
          };
          function createWorker(fn) {
            if (window.Worker && window.Blob && getWebWorker()) {
              var blob = new Blob(["var _workerSelf = self; self.onmessage = ", fn.toString()], {
                type: "text/javascript"
              });
              var url = URL.createObjectURL(blob);
              return new Worker(url);
            }
            workerFn = fn;
            return workerProxy;
          }
          function setupWorker() {
            if (!workerInstance) {
              workerInstance = createWorker(function workerStart(e2) {
                function dataFunctionManager() {
                  function completeLayers(layers2, comps) {
                    var layerData;
                    var i2;
                    var len = layers2.length;
                    var j;
                    var jLen;
                    var k2;
                    var kLen;
                    for (i2 = 0; i2 < len; i2 += 1) {
                      layerData = layers2[i2];
                      if ("ks" in layerData && !layerData.completed) {
                        layerData.completed = true;
                        if (layerData.hasMask) {
                          var maskProps = layerData.masksProperties;
                          jLen = maskProps.length;
                          for (j = 0; j < jLen; j += 1) {
                            if (maskProps[j].pt.k.i) {
                              convertPathsToAbsoluteValues(maskProps[j].pt.k);
                            } else {
                              kLen = maskProps[j].pt.k.length;
                              for (k2 = 0; k2 < kLen; k2 += 1) {
                                if (maskProps[j].pt.k[k2].s) {
                                  convertPathsToAbsoluteValues(maskProps[j].pt.k[k2].s[0]);
                                }
                                if (maskProps[j].pt.k[k2].e) {
                                  convertPathsToAbsoluteValues(maskProps[j].pt.k[k2].e[0]);
                                }
                              }
                            }
                          }
                        }
                        if (layerData.ty === 0) {
                          layerData.layers = findCompLayers(layerData.refId, comps);
                          completeLayers(layerData.layers, comps);
                        } else if (layerData.ty === 4) {
                          completeShapes(layerData.shapes);
                        } else if (layerData.ty === 5) {
                          completeText(layerData);
                        }
                      }
                    }
                  }
                  function completeChars(chars2, assets2) {
                    if (chars2) {
                      var i2 = 0;
                      var len = chars2.length;
                      for (i2 = 0; i2 < len; i2 += 1) {
                        if (chars2[i2].t === 1) {
                          chars2[i2].data.layers = findCompLayers(chars2[i2].data.refId, assets2);
                          completeLayers(chars2[i2].data.layers, assets2);
                        }
                      }
                    }
                  }
                  function findComp(id2, comps) {
                    var i2 = 0;
                    var len = comps.length;
                    while (i2 < len) {
                      if (comps[i2].id === id2) {
                        return comps[i2];
                      }
                      i2 += 1;
                    }
                    return null;
                  }
                  function findCompLayers(id2, comps) {
                    var comp2 = findComp(id2, comps);
                    if (comp2) {
                      if (!comp2.layers.__used) {
                        comp2.layers.__used = true;
                        return comp2.layers;
                      }
                      return JSON.parse(JSON.stringify(comp2.layers));
                    }
                    return null;
                  }
                  function completeShapes(arr2) {
                    var i2;
                    var len = arr2.length;
                    var j;
                    var jLen;
                    for (i2 = len - 1; i2 >= 0; i2 -= 1) {
                      if (arr2[i2].ty === "sh") {
                        if (arr2[i2].ks.k.i) {
                          convertPathsToAbsoluteValues(arr2[i2].ks.k);
                        } else {
                          jLen = arr2[i2].ks.k.length;
                          for (j = 0; j < jLen; j += 1) {
                            if (arr2[i2].ks.k[j].s) {
                              convertPathsToAbsoluteValues(arr2[i2].ks.k[j].s[0]);
                            }
                            if (arr2[i2].ks.k[j].e) {
                              convertPathsToAbsoluteValues(arr2[i2].ks.k[j].e[0]);
                            }
                          }
                        }
                      } else if (arr2[i2].ty === "gr") {
                        completeShapes(arr2[i2].it);
                      }
                    }
                  }
                  function convertPathsToAbsoluteValues(path2) {
                    var i2;
                    var len = path2.i.length;
                    for (i2 = 0; i2 < len; i2 += 1) {
                      path2.i[i2][0] += path2.v[i2][0];
                      path2.i[i2][1] += path2.v[i2][1];
                      path2.o[i2][0] += path2.v[i2][0];
                      path2.o[i2][1] += path2.v[i2][1];
                    }
                  }
                  function checkVersion(minimum, animVersionString) {
                    var animVersion = animVersionString ? animVersionString.split(".") : [100, 100, 100];
                    if (minimum[0] > animVersion[0]) {
                      return true;
                    }
                    if (animVersion[0] > minimum[0]) {
                      return false;
                    }
                    if (minimum[1] > animVersion[1]) {
                      return true;
                    }
                    if (animVersion[1] > minimum[1]) {
                      return false;
                    }
                    if (minimum[2] > animVersion[2]) {
                      return true;
                    }
                    if (animVersion[2] > minimum[2]) {
                      return false;
                    }
                    return null;
                  }
                  var checkText = /* @__PURE__ */ function() {
                    var minimumVersion = [4, 4, 14];
                    function updateTextLayer(textLayer) {
                      var documentData = textLayer.t.d;
                      textLayer.t.d = {
                        k: [{
                          s: documentData,
                          t: 0
                        }]
                      };
                    }
                    function iterateLayers(layers2) {
                      var i2;
                      var len = layers2.length;
                      for (i2 = 0; i2 < len; i2 += 1) {
                        if (layers2[i2].ty === 5) {
                          updateTextLayer(layers2[i2]);
                        }
                      }
                    }
                    return function(animationData) {
                      if (checkVersion(minimumVersion, animationData.v)) {
                        iterateLayers(animationData.layers);
                        if (animationData.assets) {
                          var i2;
                          var len = animationData.assets.length;
                          for (i2 = 0; i2 < len; i2 += 1) {
                            if (animationData.assets[i2].layers) {
                              iterateLayers(animationData.assets[i2].layers);
                            }
                          }
                        }
                      }
                    };
                  }();
                  var checkChars = /* @__PURE__ */ function() {
                    var minimumVersion = [4, 7, 99];
                    return function(animationData) {
                      if (animationData.chars && !checkVersion(minimumVersion, animationData.v)) {
                        var i2;
                        var len = animationData.chars.length;
                        for (i2 = 0; i2 < len; i2 += 1) {
                          var charData = animationData.chars[i2];
                          if (charData.data && charData.data.shapes) {
                            completeShapes(charData.data.shapes);
                            charData.data.ip = 0;
                            charData.data.op = 99999;
                            charData.data.st = 0;
                            charData.data.sr = 1;
                            charData.data.ks = {
                              p: {
                                k: [0, 0],
                                a: 0
                              },
                              s: {
                                k: [100, 100],
                                a: 0
                              },
                              a: {
                                k: [0, 0],
                                a: 0
                              },
                              r: {
                                k: 0,
                                a: 0
                              },
                              o: {
                                k: 100,
                                a: 0
                              }
                            };
                            if (!animationData.chars[i2].t) {
                              charData.data.shapes.push({
                                ty: "no"
                              });
                              charData.data.shapes[0].it.push({
                                p: {
                                  k: [0, 0],
                                  a: 0
                                },
                                s: {
                                  k: [100, 100],
                                  a: 0
                                },
                                a: {
                                  k: [0, 0],
                                  a: 0
                                },
                                r: {
                                  k: 0,
                                  a: 0
                                },
                                o: {
                                  k: 100,
                                  a: 0
                                },
                                sk: {
                                  k: 0,
                                  a: 0
                                },
                                sa: {
                                  k: 0,
                                  a: 0
                                },
                                ty: "tr"
                              });
                            }
                          }
                        }
                      }
                    };
                  }();
                  var checkPathProperties = /* @__PURE__ */ function() {
                    var minimumVersion = [5, 7, 15];
                    function updateTextLayer(textLayer) {
                      var pathData = textLayer.t.p;
                      if (typeof pathData.a === "number") {
                        pathData.a = {
                          a: 0,
                          k: pathData.a
                        };
                      }
                      if (typeof pathData.p === "number") {
                        pathData.p = {
                          a: 0,
                          k: pathData.p
                        };
                      }
                      if (typeof pathData.r === "number") {
                        pathData.r = {
                          a: 0,
                          k: pathData.r
                        };
                      }
                    }
                    function iterateLayers(layers2) {
                      var i2;
                      var len = layers2.length;
                      for (i2 = 0; i2 < len; i2 += 1) {
                        if (layers2[i2].ty === 5) {
                          updateTextLayer(layers2[i2]);
                        }
                      }
                    }
                    return function(animationData) {
                      if (checkVersion(minimumVersion, animationData.v)) {
                        iterateLayers(animationData.layers);
                        if (animationData.assets) {
                          var i2;
                          var len = animationData.assets.length;
                          for (i2 = 0; i2 < len; i2 += 1) {
                            if (animationData.assets[i2].layers) {
                              iterateLayers(animationData.assets[i2].layers);
                            }
                          }
                        }
                      }
                    };
                  }();
                  var checkColors = /* @__PURE__ */ function() {
                    var minimumVersion = [4, 1, 9];
                    function iterateShapes(shapes) {
                      var i2;
                      var len = shapes.length;
                      var j;
                      var jLen;
                      for (i2 = 0; i2 < len; i2 += 1) {
                        if (shapes[i2].ty === "gr") {
                          iterateShapes(shapes[i2].it);
                        } else if (shapes[i2].ty === "fl" || shapes[i2].ty === "st") {
                          if (shapes[i2].c.k && shapes[i2].c.k[0].i) {
                            jLen = shapes[i2].c.k.length;
                            for (j = 0; j < jLen; j += 1) {
                              if (shapes[i2].c.k[j].s) {
                                shapes[i2].c.k[j].s[0] /= 255;
                                shapes[i2].c.k[j].s[1] /= 255;
                                shapes[i2].c.k[j].s[2] /= 255;
                                shapes[i2].c.k[j].s[3] /= 255;
                              }
                              if (shapes[i2].c.k[j].e) {
                                shapes[i2].c.k[j].e[0] /= 255;
                                shapes[i2].c.k[j].e[1] /= 255;
                                shapes[i2].c.k[j].e[2] /= 255;
                                shapes[i2].c.k[j].e[3] /= 255;
                              }
                            }
                          } else {
                            shapes[i2].c.k[0] /= 255;
                            shapes[i2].c.k[1] /= 255;
                            shapes[i2].c.k[2] /= 255;
                            shapes[i2].c.k[3] /= 255;
                          }
                        }
                      }
                    }
                    function iterateLayers(layers2) {
                      var i2;
                      var len = layers2.length;
                      for (i2 = 0; i2 < len; i2 += 1) {
                        if (layers2[i2].ty === 4) {
                          iterateShapes(layers2[i2].shapes);
                        }
                      }
                    }
                    return function(animationData) {
                      if (checkVersion(minimumVersion, animationData.v)) {
                        iterateLayers(animationData.layers);
                        if (animationData.assets) {
                          var i2;
                          var len = animationData.assets.length;
                          for (i2 = 0; i2 < len; i2 += 1) {
                            if (animationData.assets[i2].layers) {
                              iterateLayers(animationData.assets[i2].layers);
                            }
                          }
                        }
                      }
                    };
                  }();
                  var checkShapes = /* @__PURE__ */ function() {
                    var minimumVersion = [4, 4, 18];
                    function completeClosingShapes(arr2) {
                      var i2;
                      var len = arr2.length;
                      var j;
                      var jLen;
                      for (i2 = len - 1; i2 >= 0; i2 -= 1) {
                        if (arr2[i2].ty === "sh") {
                          if (arr2[i2].ks.k.i) {
                            arr2[i2].ks.k.c = arr2[i2].closed;
                          } else {
                            jLen = arr2[i2].ks.k.length;
                            for (j = 0; j < jLen; j += 1) {
                              if (arr2[i2].ks.k[j].s) {
                                arr2[i2].ks.k[j].s[0].c = arr2[i2].closed;
                              }
                              if (arr2[i2].ks.k[j].e) {
                                arr2[i2].ks.k[j].e[0].c = arr2[i2].closed;
                              }
                            }
                          }
                        } else if (arr2[i2].ty === "gr") {
                          completeClosingShapes(arr2[i2].it);
                        }
                      }
                    }
                    function iterateLayers(layers2) {
                      var layerData;
                      var i2;
                      var len = layers2.length;
                      var j;
                      var jLen;
                      var k2;
                      var kLen;
                      for (i2 = 0; i2 < len; i2 += 1) {
                        layerData = layers2[i2];
                        if (layerData.hasMask) {
                          var maskProps = layerData.masksProperties;
                          jLen = maskProps.length;
                          for (j = 0; j < jLen; j += 1) {
                            if (maskProps[j].pt.k.i) {
                              maskProps[j].pt.k.c = maskProps[j].cl;
                            } else {
                              kLen = maskProps[j].pt.k.length;
                              for (k2 = 0; k2 < kLen; k2 += 1) {
                                if (maskProps[j].pt.k[k2].s) {
                                  maskProps[j].pt.k[k2].s[0].c = maskProps[j].cl;
                                }
                                if (maskProps[j].pt.k[k2].e) {
                                  maskProps[j].pt.k[k2].e[0].c = maskProps[j].cl;
                                }
                              }
                            }
                          }
                        }
                        if (layerData.ty === 4) {
                          completeClosingShapes(layerData.shapes);
                        }
                      }
                    }
                    return function(animationData) {
                      if (checkVersion(minimumVersion, animationData.v)) {
                        iterateLayers(animationData.layers);
                        if (animationData.assets) {
                          var i2;
                          var len = animationData.assets.length;
                          for (i2 = 0; i2 < len; i2 += 1) {
                            if (animationData.assets[i2].layers) {
                              iterateLayers(animationData.assets[i2].layers);
                            }
                          }
                        }
                      }
                    };
                  }();
                  function completeData(animationData) {
                    if (animationData.__complete) {
                      return;
                    }
                    checkColors(animationData);
                    checkText(animationData);
                    checkChars(animationData);
                    checkPathProperties(animationData);
                    checkShapes(animationData);
                    completeLayers(animationData.layers, animationData.assets);
                    completeChars(animationData.chars, animationData.assets);
                    animationData.__complete = true;
                  }
                  function completeText(data2) {
                    if (data2.t.a.length === 0 && !("m" in data2.t.p))
                      ;
                  }
                  var moduleOb = {};
                  moduleOb.completeData = completeData;
                  moduleOb.checkColors = checkColors;
                  moduleOb.checkChars = checkChars;
                  moduleOb.checkPathProperties = checkPathProperties;
                  moduleOb.checkShapes = checkShapes;
                  moduleOb.completeLayers = completeLayers;
                  return moduleOb;
                }
                if (!_workerSelf.dataManager) {
                  _workerSelf.dataManager = dataFunctionManager();
                }
                if (!_workerSelf.assetLoader) {
                  _workerSelf.assetLoader = /* @__PURE__ */ function() {
                    function formatResponse(xhr) {
                      var contentTypeHeader = xhr.getResponseHeader("content-type");
                      if (contentTypeHeader && xhr.responseType === "json" && contentTypeHeader.indexOf("json") !== -1) {
                        return xhr.response;
                      }
                      if (xhr.response && _typeof$5(xhr.response) === "object") {
                        return xhr.response;
                      }
                      if (xhr.response && typeof xhr.response === "string") {
                        return JSON.parse(xhr.response);
                      }
                      if (xhr.responseText) {
                        return JSON.parse(xhr.responseText);
                      }
                      return null;
                    }
                    function loadAsset(path2, fullPath, callback, errorCallback) {
                      var response;
                      var xhr = new XMLHttpRequest();
                      try {
                        xhr.responseType = "json";
                      } catch (err) {
                      }
                      xhr.onreadystatechange = function() {
                        if (xhr.readyState === 4) {
                          if (xhr.status === 200) {
                            response = formatResponse(xhr);
                            callback(response);
                          } else {
                            try {
                              response = formatResponse(xhr);
                              callback(response);
                            } catch (err) {
                              if (errorCallback) {
                                errorCallback(err);
                              }
                            }
                          }
                        }
                      };
                      try {
                        xhr.open(["G", "E", "T"].join(""), path2, true);
                      } catch (error) {
                        xhr.open(["G", "E", "T"].join(""), fullPath + "/" + path2, true);
                      }
                      xhr.send();
                    }
                    return {
                      load: loadAsset
                    };
                  }();
                }
                if (e2.data.type === "loadAnimation") {
                  _workerSelf.assetLoader.load(e2.data.path, e2.data.fullPath, function(data2) {
                    _workerSelf.dataManager.completeData(data2);
                    _workerSelf.postMessage({
                      id: e2.data.id,
                      payload: data2,
                      status: "success"
                    });
                  }, function() {
                    _workerSelf.postMessage({
                      id: e2.data.id,
                      status: "error"
                    });
                  });
                } else if (e2.data.type === "complete") {
                  var animation = e2.data.animation;
                  _workerSelf.dataManager.completeData(animation);
                  _workerSelf.postMessage({
                    id: e2.data.id,
                    payload: animation,
                    status: "success"
                  });
                } else if (e2.data.type === "loadData") {
                  _workerSelf.assetLoader.load(e2.data.path, e2.data.fullPath, function(data2) {
                    _workerSelf.postMessage({
                      id: e2.data.id,
                      payload: data2,
                      status: "success"
                    });
                  }, function() {
                    _workerSelf.postMessage({
                      id: e2.data.id,
                      status: "error"
                    });
                  });
                }
              });
              workerInstance.onmessage = function(event) {
                var data2 = event.data;
                var id2 = data2.id;
                var process2 = processes[id2];
                processes[id2] = null;
                if (data2.status === "success") {
                  process2.onComplete(data2.payload);
                } else if (process2.onError) {
                  process2.onError();
                }
              };
            }
          }
          function createProcess(onComplete, onError) {
            _counterId += 1;
            var id2 = "processId_" + _counterId;
            processes[id2] = {
              onComplete,
              onError
            };
            return id2;
          }
          function loadAnimation2(path2, onComplete, onError) {
            setupWorker();
            var processId = createProcess(onComplete, onError);
            workerInstance.postMessage({
              type: "loadAnimation",
              path: path2,
              fullPath: window.location.origin + window.location.pathname,
              id: processId
            });
          }
          function loadData(path2, onComplete, onError) {
            setupWorker();
            var processId = createProcess(onComplete, onError);
            workerInstance.postMessage({
              type: "loadData",
              path: path2,
              fullPath: window.location.origin + window.location.pathname,
              id: processId
            });
          }
          function completeAnimation(anim, onComplete, onError) {
            setupWorker();
            var processId = createProcess(onComplete, onError);
            workerInstance.postMessage({
              type: "complete",
              animation: anim,
              id: processId
            });
          }
          return {
            loadAnimation: loadAnimation2,
            loadData,
            completeAnimation
          };
        }();
        var ImagePreloader = function() {
          var proxyImage = function() {
            var canvas = createTag("canvas");
            canvas.width = 1;
            canvas.height = 1;
            var ctx = canvas.getContext("2d");
            ctx.fillStyle = "rgba(0,0,0,0)";
            ctx.fillRect(0, 0, 1, 1);
            return canvas;
          }();
          function imageLoaded() {
            this.loadedAssets += 1;
            if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
              if (this.imagesLoadedCb) {
                this.imagesLoadedCb(null);
              }
            }
          }
          function footageLoaded() {
            this.loadedFootagesCount += 1;
            if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
              if (this.imagesLoadedCb) {
                this.imagesLoadedCb(null);
              }
            }
          }
          function getAssetsPath(assetData, assetsPath, originalPath) {
            var path2 = "";
            if (assetData.e) {
              path2 = assetData.p;
            } else if (assetsPath) {
              var imagePath = assetData.p;
              if (imagePath.indexOf("images/") !== -1) {
                imagePath = imagePath.split("/")[1];
              }
              path2 = assetsPath + imagePath;
            } else {
              path2 = originalPath;
              path2 += assetData.u ? assetData.u : "";
              path2 += assetData.p;
            }
            return path2;
          }
          function testImageLoaded(img) {
            var _count = 0;
            var intervalId = setInterval(function() {
              var box = img.getBBox();
              if (box.width || _count > 500) {
                this._imageLoaded();
                clearInterval(intervalId);
              }
              _count += 1;
            }.bind(this), 50);
          }
          function createImageData(assetData) {
            var path2 = getAssetsPath(assetData, this.assetsPath, this.path);
            var img = createNS("image");
            if (isSafari) {
              this.testImageLoaded(img);
            } else {
              img.addEventListener("load", this._imageLoaded, false);
            }
            img.addEventListener("error", function() {
              ob2.img = proxyImage;
              this._imageLoaded();
            }.bind(this), false);
            img.setAttributeNS("http://www.w3.org/1999/xlink", "href", path2);
            if (this._elementHelper.append) {
              this._elementHelper.append(img);
            } else {
              this._elementHelper.appendChild(img);
            }
            var ob2 = {
              img,
              assetData
            };
            return ob2;
          }
          function createImgData(assetData) {
            var path2 = getAssetsPath(assetData, this.assetsPath, this.path);
            var img = createTag("img");
            img.crossOrigin = "anonymous";
            img.addEventListener("load", this._imageLoaded, false);
            img.addEventListener("error", function() {
              ob2.img = proxyImage;
              this._imageLoaded();
            }.bind(this), false);
            img.src = path2;
            var ob2 = {
              img,
              assetData
            };
            return ob2;
          }
          function createFootageData(data2) {
            var ob2 = {
              assetData: data2
            };
            var path2 = getAssetsPath(data2, this.assetsPath, this.path);
            dataManager.loadData(path2, function(footageData) {
              ob2.img = footageData;
              this._footageLoaded();
            }.bind(this), function() {
              ob2.img = {};
              this._footageLoaded();
            }.bind(this));
            return ob2;
          }
          function loadAssets(assets2, cb2) {
            this.imagesLoadedCb = cb2;
            var i2;
            var len = assets2.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              if (!assets2[i2].layers) {
                if (!assets2[i2].t || assets2[i2].t === "seq") {
                  this.totalImages += 1;
                  this.images.push(this._createImageData(assets2[i2]));
                } else if (assets2[i2].t === 3) {
                  this.totalFootages += 1;
                  this.images.push(this.createFootageData(assets2[i2]));
                }
              }
            }
          }
          function setPath2(path2) {
            this.path = path2 || "";
          }
          function setAssetsPath(path2) {
            this.assetsPath = path2 || "";
          }
          function getAsset(assetData) {
            var i2 = 0;
            var len = this.images.length;
            while (i2 < len) {
              if (this.images[i2].assetData === assetData) {
                return this.images[i2].img;
              }
              i2 += 1;
            }
            return null;
          }
          function destroy() {
            this.imagesLoadedCb = null;
            this.images.length = 0;
          }
          function loadedImages() {
            return this.totalImages === this.loadedAssets;
          }
          function loadedFootages() {
            return this.totalFootages === this.loadedFootagesCount;
          }
          function setCacheType(type, elementHelper) {
            if (type === "svg") {
              this._elementHelper = elementHelper;
              this._createImageData = this.createImageData.bind(this);
            } else {
              this._createImageData = this.createImgData.bind(this);
            }
          }
          function ImagePreloaderFactory() {
            this._imageLoaded = imageLoaded.bind(this);
            this._footageLoaded = footageLoaded.bind(this);
            this.testImageLoaded = testImageLoaded.bind(this);
            this.createFootageData = createFootageData.bind(this);
            this.assetsPath = "";
            this.path = "";
            this.totalImages = 0;
            this.totalFootages = 0;
            this.loadedAssets = 0;
            this.loadedFootagesCount = 0;
            this.imagesLoadedCb = null;
            this.images = [];
          }
          ImagePreloaderFactory.prototype = {
            loadAssets,
            setAssetsPath,
            setPath: setPath2,
            loadedImages,
            loadedFootages,
            destroy,
            getAsset,
            createImgData,
            createImageData,
            imageLoaded,
            footageLoaded,
            setCacheType
          };
          return ImagePreloaderFactory;
        }();
        function BaseEvent() {
        }
        BaseEvent.prototype = {
          triggerEvent: function triggerEvent(eventName, args) {
            if (this._cbs[eventName]) {
              var callbacks = this._cbs[eventName];
              for (var i2 = 0; i2 < callbacks.length; i2 += 1) {
                callbacks[i2](args);
              }
            }
          },
          addEventListener: function addEventListener(eventName, callback) {
            if (!this._cbs[eventName]) {
              this._cbs[eventName] = [];
            }
            this._cbs[eventName].push(callback);
            return function() {
              this.removeEventListener(eventName, callback);
            }.bind(this);
          },
          removeEventListener: function removeEventListener(eventName, callback) {
            if (!callback) {
              this._cbs[eventName] = null;
            } else if (this._cbs[eventName]) {
              var i2 = 0;
              var len = this._cbs[eventName].length;
              while (i2 < len) {
                if (this._cbs[eventName][i2] === callback) {
                  this._cbs[eventName].splice(i2, 1);
                  i2 -= 1;
                  len -= 1;
                }
                i2 += 1;
              }
              if (!this._cbs[eventName].length) {
                this._cbs[eventName] = null;
              }
            }
          }
        };
        var markerParser = /* @__PURE__ */ function() {
          function parsePayloadLines(payload) {
            var lines = payload.split("\r\n");
            var keys2 = {};
            var line;
            var keysCount = 0;
            for (var i2 = 0; i2 < lines.length; i2 += 1) {
              line = lines[i2].split(":");
              if (line.length === 2) {
                keys2[line[0]] = line[1].trim();
                keysCount += 1;
              }
            }
            if (keysCount === 0) {
              throw new Error();
            }
            return keys2;
          }
          return function(_markers) {
            var markers2 = [];
            for (var i2 = 0; i2 < _markers.length; i2 += 1) {
              var _marker = _markers[i2];
              var markerData = {
                time: _marker.tm,
                duration: _marker.dr
              };
              try {
                markerData.payload = JSON.parse(_markers[i2].cm);
              } catch (_) {
                try {
                  markerData.payload = parsePayloadLines(_markers[i2].cm);
                } catch (__) {
                  markerData.payload = {
                    name: _markers[i2].cm
                  };
                }
              }
              markers2.push(markerData);
            }
            return markers2;
          };
        }();
        var ProjectInterface = /* @__PURE__ */ function() {
          function registerComposition(comp2) {
            this.compositions.push(comp2);
          }
          return function() {
            function _thisProjectFunction(name2) {
              var i2 = 0;
              var len = this.compositions.length;
              while (i2 < len) {
                if (this.compositions[i2].data && this.compositions[i2].data.nm === name2) {
                  if (this.compositions[i2].prepareFrame && this.compositions[i2].data.xt) {
                    this.compositions[i2].prepareFrame(this.currentFrame);
                  }
                  return this.compositions[i2].compInterface;
                }
                i2 += 1;
              }
              return null;
            }
            _thisProjectFunction.compositions = [];
            _thisProjectFunction.currentFrame = 0;
            _thisProjectFunction.registerComposition = registerComposition;
            return _thisProjectFunction;
          };
        }();
        var renderers = {};
        var registerRenderer = function registerRenderer2(key2, value2) {
          renderers[key2] = value2;
        };
        function getRenderer(key2) {
          return renderers[key2];
        }
        function getRegisteredRenderer() {
          if (renderers.canvas) {
            return "canvas";
          }
          for (var key2 in renderers) {
            if (renderers[key2]) {
              return key2;
            }
          }
          return "";
        }
        function _typeof$4(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof$4 = function _typeof2(obj2) {
              return typeof obj2;
            };
          } else {
            _typeof$4 = function _typeof2(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return _typeof$4(obj);
        }
        var AnimationItem = function AnimationItem2() {
          this._cbs = [];
          this.name = "";
          this.path = "";
          this.isLoaded = false;
          this.currentFrame = 0;
          this.currentRawFrame = 0;
          this.firstFrame = 0;
          this.totalFrames = 0;
          this.frameRate = 0;
          this.frameMult = 0;
          this.playSpeed = 1;
          this.playDirection = 1;
          this.playCount = 0;
          this.animationData = {};
          this.assets = [];
          this.isPaused = true;
          this.autoplay = false;
          this.loop = true;
          this.renderer = null;
          this.animationID = createElementID();
          this.assetsPath = "";
          this.timeCompleted = 0;
          this.segmentPos = 0;
          this.isSubframeEnabled = getSubframeEnabled();
          this.segments = [];
          this._idle = true;
          this._completedLoop = false;
          this.projectInterface = ProjectInterface();
          this.imagePreloader = new ImagePreloader();
          this.audioController = audioControllerFactory();
          this.markers = [];
          this.configAnimation = this.configAnimation.bind(this);
          this.onSetupError = this.onSetupError.bind(this);
          this.onSegmentComplete = this.onSegmentComplete.bind(this);
          this.drawnFrameEvent = new BMEnterFrameEvent("drawnFrame", 0, 0, 0);
          this.expressionsPlugin = getExpressionsPlugin();
        };
        extendPrototype([BaseEvent], AnimationItem);
        AnimationItem.prototype.setParams = function(params) {
          if (params.wrapper || params.container) {
            this.wrapper = params.wrapper || params.container;
          }
          var animType = "svg";
          if (params.animType) {
            animType = params.animType;
          } else if (params.renderer) {
            animType = params.renderer;
          }
          var RendererClass = getRenderer(animType);
          this.renderer = new RendererClass(this, params.rendererSettings);
          this.imagePreloader.setCacheType(animType, this.renderer.globalData.defs);
          this.renderer.setProjectInterface(this.projectInterface);
          this.animType = animType;
          if (params.loop === "" || params.loop === null || params.loop === void 0 || params.loop === true) {
            this.loop = true;
          } else if (params.loop === false) {
            this.loop = false;
          } else {
            this.loop = parseInt(params.loop, 10);
          }
          this.autoplay = "autoplay" in params ? params.autoplay : true;
          this.name = params.name ? params.name : "";
          this.autoloadSegments = Object.prototype.hasOwnProperty.call(params, "autoloadSegments") ? params.autoloadSegments : true;
          this.assetsPath = params.assetsPath;
          this.initialSegment = params.initialSegment;
          if (params.audioFactory) {
            this.audioController.setAudioFactory(params.audioFactory);
          }
          if (params.animationData) {
            this.setupAnimation(params.animationData);
          } else if (params.path) {
            if (params.path.lastIndexOf("\\") !== -1) {
              this.path = params.path.substr(0, params.path.lastIndexOf("\\") + 1);
            } else {
              this.path = params.path.substr(0, params.path.lastIndexOf("/") + 1);
            }
            this.fileName = params.path.substr(params.path.lastIndexOf("/") + 1);
            this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf(".json"));
            dataManager.loadAnimation(params.path, this.configAnimation, this.onSetupError);
          }
        };
        AnimationItem.prototype.onSetupError = function() {
          this.trigger("data_failed");
        };
        AnimationItem.prototype.setupAnimation = function(data2) {
          dataManager.completeAnimation(data2, this.configAnimation);
        };
        AnimationItem.prototype.setData = function(wrapper2, animationData) {
          if (animationData) {
            if (_typeof$4(animationData) !== "object") {
              animationData = JSON.parse(animationData);
            }
          }
          var params = {
            wrapper: wrapper2,
            animationData
          };
          var wrapperAttributes = wrapper2.attributes;
          params.path = wrapperAttributes.getNamedItem("data-animation-path") ? wrapperAttributes.getNamedItem("data-animation-path").value : wrapperAttributes.getNamedItem("data-bm-path") ? wrapperAttributes.getNamedItem("data-bm-path").value : wrapperAttributes.getNamedItem("bm-path") ? wrapperAttributes.getNamedItem("bm-path").value : "";
          params.animType = wrapperAttributes.getNamedItem("data-anim-type") ? wrapperAttributes.getNamedItem("data-anim-type").value : wrapperAttributes.getNamedItem("data-bm-type") ? wrapperAttributes.getNamedItem("data-bm-type").value : wrapperAttributes.getNamedItem("bm-type") ? wrapperAttributes.getNamedItem("bm-type").value : wrapperAttributes.getNamedItem("data-bm-renderer") ? wrapperAttributes.getNamedItem("data-bm-renderer").value : wrapperAttributes.getNamedItem("bm-renderer") ? wrapperAttributes.getNamedItem("bm-renderer").value : getRegisteredRenderer() || "canvas";
          var loop = wrapperAttributes.getNamedItem("data-anim-loop") ? wrapperAttributes.getNamedItem("data-anim-loop").value : wrapperAttributes.getNamedItem("data-bm-loop") ? wrapperAttributes.getNamedItem("data-bm-loop").value : wrapperAttributes.getNamedItem("bm-loop") ? wrapperAttributes.getNamedItem("bm-loop").value : "";
          if (loop === "false") {
            params.loop = false;
          } else if (loop === "true") {
            params.loop = true;
          } else if (loop !== "") {
            params.loop = parseInt(loop, 10);
          }
          var autoplay = wrapperAttributes.getNamedItem("data-anim-autoplay") ? wrapperAttributes.getNamedItem("data-anim-autoplay").value : wrapperAttributes.getNamedItem("data-bm-autoplay") ? wrapperAttributes.getNamedItem("data-bm-autoplay").value : wrapperAttributes.getNamedItem("bm-autoplay") ? wrapperAttributes.getNamedItem("bm-autoplay").value : true;
          params.autoplay = autoplay !== "false";
          params.name = wrapperAttributes.getNamedItem("data-name") ? wrapperAttributes.getNamedItem("data-name").value : wrapperAttributes.getNamedItem("data-bm-name") ? wrapperAttributes.getNamedItem("data-bm-name").value : wrapperAttributes.getNamedItem("bm-name") ? wrapperAttributes.getNamedItem("bm-name").value : "";
          var prerender = wrapperAttributes.getNamedItem("data-anim-prerender") ? wrapperAttributes.getNamedItem("data-anim-prerender").value : wrapperAttributes.getNamedItem("data-bm-prerender") ? wrapperAttributes.getNamedItem("data-bm-prerender").value : wrapperAttributes.getNamedItem("bm-prerender") ? wrapperAttributes.getNamedItem("bm-prerender").value : "";
          if (prerender === "false") {
            params.prerender = false;
          }
          if (!params.path) {
            this.trigger("destroy");
          } else {
            this.setParams(params);
          }
        };
        AnimationItem.prototype.includeLayers = function(data2) {
          if (data2.op > this.animationData.op) {
            this.animationData.op = data2.op;
            this.totalFrames = Math.floor(data2.op - this.animationData.ip);
          }
          var layers2 = this.animationData.layers;
          var i2;
          var len = layers2.length;
          var newLayers = data2.layers;
          var j;
          var jLen = newLayers.length;
          for (j = 0; j < jLen; j += 1) {
            i2 = 0;
            while (i2 < len) {
              if (layers2[i2].id === newLayers[j].id) {
                layers2[i2] = newLayers[j];
                break;
              }
              i2 += 1;
            }
          }
          if (data2.chars || data2.fonts) {
            this.renderer.globalData.fontManager.addChars(data2.chars);
            this.renderer.globalData.fontManager.addFonts(data2.fonts, this.renderer.globalData.defs);
          }
          if (data2.assets) {
            len = data2.assets.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              this.animationData.assets.push(data2.assets[i2]);
            }
          }
          this.animationData.__complete = false;
          dataManager.completeAnimation(this.animationData, this.onSegmentComplete);
        };
        AnimationItem.prototype.onSegmentComplete = function(data2) {
          this.animationData = data2;
          var expressionsPlugin2 = getExpressionsPlugin();
          if (expressionsPlugin2) {
            expressionsPlugin2.initExpressions(this);
          }
          this.loadNextSegment();
        };
        AnimationItem.prototype.loadNextSegment = function() {
          var segments = this.animationData.segments;
          if (!segments || segments.length === 0 || !this.autoloadSegments) {
            this.trigger("data_ready");
            this.timeCompleted = this.totalFrames;
            return;
          }
          var segment = segments.shift();
          this.timeCompleted = segment.time * this.frameRate;
          var segmentPath = this.path + this.fileName + "_" + this.segmentPos + ".json";
          this.segmentPos += 1;
          dataManager.loadData(segmentPath, this.includeLayers.bind(this), function() {
            this.trigger("data_failed");
          }.bind(this));
        };
        AnimationItem.prototype.loadSegments = function() {
          var segments = this.animationData.segments;
          if (!segments) {
            this.timeCompleted = this.totalFrames;
          }
          this.loadNextSegment();
        };
        AnimationItem.prototype.imagesLoaded = function() {
          this.trigger("loaded_images");
          this.checkLoaded();
        };
        AnimationItem.prototype.preloadImages = function() {
          this.imagePreloader.setAssetsPath(this.assetsPath);
          this.imagePreloader.setPath(this.path);
          this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this));
        };
        AnimationItem.prototype.configAnimation = function(animData) {
          if (!this.renderer) {
            return;
          }
          try {
            this.animationData = animData;
            if (this.initialSegment) {
              this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]);
              this.firstFrame = Math.round(this.initialSegment[0]);
            } else {
              this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip);
              this.firstFrame = Math.round(this.animationData.ip);
            }
            this.renderer.configAnimation(animData);
            if (!animData.assets) {
              animData.assets = [];
            }
            this.assets = this.animationData.assets;
            this.frameRate = this.animationData.fr;
            this.frameMult = this.animationData.fr / 1e3;
            this.renderer.searchExtraCompositions(animData.assets);
            this.markers = markerParser(animData.markers || []);
            this.trigger("config_ready");
            this.preloadImages();
            this.loadSegments();
            this.updaFrameModifier();
            this.waitForFontsLoaded();
            if (this.isPaused) {
              this.audioController.pause();
            }
          } catch (error) {
            this.triggerConfigError(error);
          }
        };
        AnimationItem.prototype.waitForFontsLoaded = function() {
          if (!this.renderer) {
            return;
          }
          if (this.renderer.globalData.fontManager.isLoaded) {
            this.checkLoaded();
          } else {
            setTimeout(this.waitForFontsLoaded.bind(this), 20);
          }
        };
        AnimationItem.prototype.checkLoaded = function() {
          if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== "canvas") && this.imagePreloader.loadedFootages()) {
            this.isLoaded = true;
            var expressionsPlugin2 = getExpressionsPlugin();
            if (expressionsPlugin2) {
              expressionsPlugin2.initExpressions(this);
            }
            this.renderer.initItems();
            setTimeout(function() {
              this.trigger("DOMLoaded");
            }.bind(this), 0);
            this.gotoFrame();
            if (this.autoplay) {
              this.play();
            }
          }
        };
        AnimationItem.prototype.resize = function(width2, height2) {
          var _width = typeof width2 === "number" ? width2 : void 0;
          var _height = typeof height2 === "number" ? height2 : void 0;
          this.renderer.updateContainerSize(_width, _height);
        };
        AnimationItem.prototype.setSubframe = function(flag) {
          this.isSubframeEnabled = !!flag;
        };
        AnimationItem.prototype.gotoFrame = function() {
          this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame;
          if (this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted) {
            this.currentFrame = this.timeCompleted;
          }
          this.trigger("enterFrame");
          this.renderFrame();
          this.trigger("drawnFrame");
        };
        AnimationItem.prototype.renderFrame = function() {
          if (this.isLoaded === false || !this.renderer) {
            return;
          }
          try {
            if (this.expressionsPlugin) {
              this.expressionsPlugin.resetFrame();
            }
            this.renderer.renderFrame(this.currentFrame + this.firstFrame);
          } catch (error) {
            this.triggerRenderFrameError(error);
          }
        };
        AnimationItem.prototype.play = function(name2) {
          if (name2 && this.name !== name2) {
            return;
          }
          if (this.isPaused === true) {
            this.isPaused = false;
            this.trigger("_play");
            this.audioController.resume();
            if (this._idle) {
              this._idle = false;
              this.trigger("_active");
            }
          }
        };
        AnimationItem.prototype.pause = function(name2) {
          if (name2 && this.name !== name2) {
            return;
          }
          if (this.isPaused === false) {
            this.isPaused = true;
            this.trigger("_pause");
            this._idle = true;
            this.trigger("_idle");
            this.audioController.pause();
          }
        };
        AnimationItem.prototype.togglePause = function(name2) {
          if (name2 && this.name !== name2) {
            return;
          }
          if (this.isPaused === true) {
            this.play();
          } else {
            this.pause();
          }
        };
        AnimationItem.prototype.stop = function(name2) {
          if (name2 && this.name !== name2) {
            return;
          }
          this.pause();
          this.playCount = 0;
          this._completedLoop = false;
          this.setCurrentRawFrameValue(0);
        };
        AnimationItem.prototype.getMarkerData = function(markerName) {
          var marker;
          for (var i2 = 0; i2 < this.markers.length; i2 += 1) {
            marker = this.markers[i2];
            if (marker.payload && marker.payload.name === markerName) {
              return marker;
            }
          }
          return null;
        };
        AnimationItem.prototype.goToAndStop = function(value2, isFrame, name2) {
          if (name2 && this.name !== name2) {
            return;
          }
          var numValue = Number(value2);
          if (isNaN(numValue)) {
            var marker = this.getMarkerData(value2);
            if (marker) {
              this.goToAndStop(marker.time, true);
            }
          } else if (isFrame) {
            this.setCurrentRawFrameValue(value2);
          } else {
            this.setCurrentRawFrameValue(value2 * this.frameModifier);
          }
          this.pause();
        };
        AnimationItem.prototype.goToAndPlay = function(value2, isFrame, name2) {
          if (name2 && this.name !== name2) {
            return;
          }
          var numValue = Number(value2);
          if (isNaN(numValue)) {
            var marker = this.getMarkerData(value2);
            if (marker) {
              if (!marker.duration) {
                this.goToAndStop(marker.time, true);
              } else {
                this.playSegments([marker.time, marker.time + marker.duration], true);
              }
            }
          } else {
            this.goToAndStop(numValue, isFrame, name2);
          }
          this.play();
        };
        AnimationItem.prototype.advanceTime = function(value2) {
          if (this.isPaused === true || this.isLoaded === false) {
            return;
          }
          var nextValue = this.currentRawFrame + value2 * this.frameModifier;
          var _isComplete = false;
          if (nextValue >= this.totalFrames - 1 && this.frameModifier > 0) {
            if (!this.loop || this.playCount === this.loop) {
              if (!this.checkSegments(nextValue > this.totalFrames ? nextValue % this.totalFrames : 0)) {
                _isComplete = true;
                nextValue = this.totalFrames - 1;
              }
            } else if (nextValue >= this.totalFrames) {
              this.playCount += 1;
              if (!this.checkSegments(nextValue % this.totalFrames)) {
                this.setCurrentRawFrameValue(nextValue % this.totalFrames);
                this._completedLoop = true;
                this.trigger("loopComplete");
              }
            } else {
              this.setCurrentRawFrameValue(nextValue);
            }
          } else if (nextValue < 0) {
            if (!this.checkSegments(nextValue % this.totalFrames)) {
              if (this.loop && !(this.playCount-- <= 0 && this.loop !== true)) {
                this.setCurrentRawFrameValue(this.totalFrames + nextValue % this.totalFrames);
                if (!this._completedLoop) {
                  this._completedLoop = true;
                } else {
                  this.trigger("loopComplete");
                }
              } else {
                _isComplete = true;
                nextValue = 0;
              }
            }
          } else {
            this.setCurrentRawFrameValue(nextValue);
          }
          if (_isComplete) {
            this.setCurrentRawFrameValue(nextValue);
            this.pause();
            this.trigger("complete");
          }
        };
        AnimationItem.prototype.adjustSegment = function(arr2, offset) {
          this.playCount = 0;
          if (arr2[1] < arr2[0]) {
            if (this.frameModifier > 0) {
              if (this.playSpeed < 0) {
                this.setSpeed(-this.playSpeed);
              } else {
                this.setDirection(-1);
              }
            }
            this.totalFrames = arr2[0] - arr2[1];
            this.timeCompleted = this.totalFrames;
            this.firstFrame = arr2[1];
            this.setCurrentRawFrameValue(this.totalFrames - 1e-3 - offset);
          } else if (arr2[1] > arr2[0]) {
            if (this.frameModifier < 0) {
              if (this.playSpeed < 0) {
                this.setSpeed(-this.playSpeed);
              } else {
                this.setDirection(1);
              }
            }
            this.totalFrames = arr2[1] - arr2[0];
            this.timeCompleted = this.totalFrames;
            this.firstFrame = arr2[0];
            this.setCurrentRawFrameValue(1e-3 + offset);
          }
          this.trigger("segmentStart");
        };
        AnimationItem.prototype.setSegment = function(init2, end) {
          var pendingFrame = -1;
          if (this.isPaused) {
            if (this.currentRawFrame + this.firstFrame < init2) {
              pendingFrame = init2;
            } else if (this.currentRawFrame + this.firstFrame > end) {
              pendingFrame = end - init2;
            }
          }
          this.firstFrame = init2;
          this.totalFrames = end - init2;
          this.timeCompleted = this.totalFrames;
          if (pendingFrame !== -1) {
            this.goToAndStop(pendingFrame, true);
          }
        };
        AnimationItem.prototype.playSegments = function(arr2, forceFlag) {
          if (forceFlag) {
            this.segments.length = 0;
          }
          if (_typeof$4(arr2[0]) === "object") {
            var i2;
            var len = arr2.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              this.segments.push(arr2[i2]);
            }
          } else {
            this.segments.push(arr2);
          }
          if (this.segments.length && forceFlag) {
            this.adjustSegment(this.segments.shift(), 0);
          }
          if (this.isPaused) {
            this.play();
          }
        };
        AnimationItem.prototype.resetSegments = function(forceFlag) {
          this.segments.length = 0;
          this.segments.push([this.animationData.ip, this.animationData.op]);
          if (forceFlag) {
            this.checkSegments(0);
          }
        };
        AnimationItem.prototype.checkSegments = function(offset) {
          if (this.segments.length) {
            this.adjustSegment(this.segments.shift(), offset);
            return true;
          }
          return false;
        };
        AnimationItem.prototype.destroy = function(name2) {
          if (name2 && this.name !== name2 || !this.renderer) {
            return;
          }
          this.renderer.destroy();
          this.imagePreloader.destroy();
          this.trigger("destroy");
          this._cbs = null;
          this.onEnterFrame = null;
          this.onLoopComplete = null;
          this.onComplete = null;
          this.onSegmentStart = null;
          this.onDestroy = null;
          this.renderer = null;
          this.expressionsPlugin = null;
          this.imagePreloader = null;
          this.projectInterface = null;
        };
        AnimationItem.prototype.setCurrentRawFrameValue = function(value2) {
          this.currentRawFrame = value2;
          this.gotoFrame();
        };
        AnimationItem.prototype.setSpeed = function(val2) {
          this.playSpeed = val2;
          this.updaFrameModifier();
        };
        AnimationItem.prototype.setDirection = function(val2) {
          this.playDirection = val2 < 0 ? -1 : 1;
          this.updaFrameModifier();
        };
        AnimationItem.prototype.setLoop = function(isLooping) {
          this.loop = isLooping;
        };
        AnimationItem.prototype.setVolume = function(val2, name2) {
          if (name2 && this.name !== name2) {
            return;
          }
          this.audioController.setVolume(val2);
        };
        AnimationItem.prototype.getVolume = function() {
          return this.audioController.getVolume();
        };
        AnimationItem.prototype.mute = function(name2) {
          if (name2 && this.name !== name2) {
            return;
          }
          this.audioController.mute();
        };
        AnimationItem.prototype.unmute = function(name2) {
          if (name2 && this.name !== name2) {
            return;
          }
          this.audioController.unmute();
        };
        AnimationItem.prototype.updaFrameModifier = function() {
          this.frameModifier = this.frameMult * this.playSpeed * this.playDirection;
          this.audioController.setRate(this.playSpeed * this.playDirection);
        };
        AnimationItem.prototype.getPath = function() {
          return this.path;
        };
        AnimationItem.prototype.getAssetsPath = function(assetData) {
          var path2 = "";
          if (assetData.e) {
            path2 = assetData.p;
          } else if (this.assetsPath) {
            var imagePath = assetData.p;
            if (imagePath.indexOf("images/") !== -1) {
              imagePath = imagePath.split("/")[1];
            }
            path2 = this.assetsPath + imagePath;
          } else {
            path2 = this.path;
            path2 += assetData.u ? assetData.u : "";
            path2 += assetData.p;
          }
          return path2;
        };
        AnimationItem.prototype.getAssetData = function(id2) {
          var i2 = 0;
          var len = this.assets.length;
          while (i2 < len) {
            if (id2 === this.assets[i2].id) {
              return this.assets[i2];
            }
            i2 += 1;
          }
          return null;
        };
        AnimationItem.prototype.hide = function() {
          this.renderer.hide();
        };
        AnimationItem.prototype.show = function() {
          this.renderer.show();
        };
        AnimationItem.prototype.getDuration = function(isFrame) {
          return isFrame ? this.totalFrames : this.totalFrames / this.frameRate;
        };
        AnimationItem.prototype.updateDocumentData = function(path2, documentData, index2) {
          try {
            var element = this.renderer.getElementByPath(path2);
            element.updateDocumentData(documentData, index2);
          } catch (error) {
          }
        };
        AnimationItem.prototype.trigger = function(name2) {
          if (this._cbs && this._cbs[name2]) {
            switch (name2) {
              case "enterFrame":
                this.triggerEvent(name2, new BMEnterFrameEvent(name2, this.currentFrame, this.totalFrames, this.frameModifier));
                break;
              case "drawnFrame":
                this.drawnFrameEvent.currentTime = this.currentFrame;
                this.drawnFrameEvent.totalTime = this.totalFrames;
                this.drawnFrameEvent.direction = this.frameModifier;
                this.triggerEvent(name2, this.drawnFrameEvent);
                break;
              case "loopComplete":
                this.triggerEvent(name2, new BMCompleteLoopEvent(name2, this.loop, this.playCount, this.frameMult));
                break;
              case "complete":
                this.triggerEvent(name2, new BMCompleteEvent(name2, this.frameMult));
                break;
              case "segmentStart":
                this.triggerEvent(name2, new BMSegmentStartEvent(name2, this.firstFrame, this.totalFrames));
                break;
              case "destroy":
                this.triggerEvent(name2, new BMDestroyEvent(name2, this));
                break;
              default:
                this.triggerEvent(name2);
            }
          }
          if (name2 === "enterFrame" && this.onEnterFrame) {
            this.onEnterFrame.call(this, new BMEnterFrameEvent(name2, this.currentFrame, this.totalFrames, this.frameMult));
          }
          if (name2 === "loopComplete" && this.onLoopComplete) {
            this.onLoopComplete.call(this, new BMCompleteLoopEvent(name2, this.loop, this.playCount, this.frameMult));
          }
          if (name2 === "complete" && this.onComplete) {
            this.onComplete.call(this, new BMCompleteEvent(name2, this.frameMult));
          }
          if (name2 === "segmentStart" && this.onSegmentStart) {
            this.onSegmentStart.call(this, new BMSegmentStartEvent(name2, this.firstFrame, this.totalFrames));
          }
          if (name2 === "destroy" && this.onDestroy) {
            this.onDestroy.call(this, new BMDestroyEvent(name2, this));
          }
        };
        AnimationItem.prototype.triggerRenderFrameError = function(nativeError) {
          var error = new BMRenderFrameErrorEvent(nativeError, this.currentFrame);
          this.triggerEvent("error", error);
          if (this.onError) {
            this.onError.call(this, error);
          }
        };
        AnimationItem.prototype.triggerConfigError = function(nativeError) {
          var error = new BMConfigErrorEvent(nativeError, this.currentFrame);
          this.triggerEvent("error", error);
          if (this.onError) {
            this.onError.call(this, error);
          }
        };
        var animationManager = function() {
          var moduleOb = {};
          var registeredAnimations = [];
          var initTime = 0;
          var len = 0;
          var playingAnimationsNum = 0;
          var _stopped = true;
          var _isFrozen = false;
          function removeElement(ev) {
            var i2 = 0;
            var animItem = ev.target;
            while (i2 < len) {
              if (registeredAnimations[i2].animation === animItem) {
                registeredAnimations.splice(i2, 1);
                i2 -= 1;
                len -= 1;
                if (!animItem.isPaused) {
                  subtractPlayingCount();
                }
              }
              i2 += 1;
            }
          }
          function registerAnimation(element, animationData) {
            if (!element) {
              return null;
            }
            var i2 = 0;
            while (i2 < len) {
              if (registeredAnimations[i2].elem === element && registeredAnimations[i2].elem !== null) {
                return registeredAnimations[i2].animation;
              }
              i2 += 1;
            }
            var animItem = new AnimationItem();
            setupAnimation(animItem, element);
            animItem.setData(element, animationData);
            return animItem;
          }
          function getRegisteredAnimations() {
            var i2;
            var lenAnims = registeredAnimations.length;
            var animations = [];
            for (i2 = 0; i2 < lenAnims; i2 += 1) {
              animations.push(registeredAnimations[i2].animation);
            }
            return animations;
          }
          function addPlayingCount() {
            playingAnimationsNum += 1;
            activate();
          }
          function subtractPlayingCount() {
            playingAnimationsNum -= 1;
          }
          function setupAnimation(animItem, element) {
            animItem.addEventListener("destroy", removeElement);
            animItem.addEventListener("_active", addPlayingCount);
            animItem.addEventListener("_idle", subtractPlayingCount);
            registeredAnimations.push({
              elem: element,
              animation: animItem
            });
            len += 1;
          }
          function loadAnimation2(params) {
            var animItem = new AnimationItem();
            setupAnimation(animItem, null);
            animItem.setParams(params);
            return animItem;
          }
          function setSpeed(val2, animation) {
            var i2;
            for (i2 = 0; i2 < len; i2 += 1) {
              registeredAnimations[i2].animation.setSpeed(val2, animation);
            }
          }
          function setDirection(val2, animation) {
            var i2;
            for (i2 = 0; i2 < len; i2 += 1) {
              registeredAnimations[i2].animation.setDirection(val2, animation);
            }
          }
          function play(animation) {
            var i2;
            for (i2 = 0; i2 < len; i2 += 1) {
              registeredAnimations[i2].animation.play(animation);
            }
          }
          function resume(nowTime) {
            var elapsedTime = nowTime - initTime;
            var i2;
            for (i2 = 0; i2 < len; i2 += 1) {
              registeredAnimations[i2].animation.advanceTime(elapsedTime);
            }
            initTime = nowTime;
            if (playingAnimationsNum && !_isFrozen) {
              window.requestAnimationFrame(resume);
            } else {
              _stopped = true;
            }
          }
          function first(nowTime) {
            initTime = nowTime;
            window.requestAnimationFrame(resume);
          }
          function pause(animation) {
            var i2;
            for (i2 = 0; i2 < len; i2 += 1) {
              registeredAnimations[i2].animation.pause(animation);
            }
          }
          function goToAndStop(value2, isFrame, animation) {
            var i2;
            for (i2 = 0; i2 < len; i2 += 1) {
              registeredAnimations[i2].animation.goToAndStop(value2, isFrame, animation);
            }
          }
          function stop(animation) {
            var i2;
            for (i2 = 0; i2 < len; i2 += 1) {
              registeredAnimations[i2].animation.stop(animation);
            }
          }
          function togglePause(animation) {
            var i2;
            for (i2 = 0; i2 < len; i2 += 1) {
              registeredAnimations[i2].animation.togglePause(animation);
            }
          }
          function destroy(animation) {
            var i2;
            for (i2 = len - 1; i2 >= 0; i2 -= 1) {
              registeredAnimations[i2].animation.destroy(animation);
            }
          }
          function searchAnimations2(animationData, standalone, renderer) {
            var animElements = [].concat([].slice.call(document.getElementsByClassName("lottie")), [].slice.call(document.getElementsByClassName("bodymovin")));
            var i2;
            var lenAnims = animElements.length;
            for (i2 = 0; i2 < lenAnims; i2 += 1) {
              if (renderer) {
                animElements[i2].setAttribute("data-bm-type", renderer);
              }
              registerAnimation(animElements[i2], animationData);
            }
            if (standalone && lenAnims === 0) {
              if (!renderer) {
                renderer = "svg";
              }
              var body = document.getElementsByTagName("body")[0];
              body.innerText = "";
              var div2 = createTag("div");
              div2.style.width = "100%";
              div2.style.height = "100%";
              div2.setAttribute("data-bm-type", renderer);
              body.appendChild(div2);
              registerAnimation(div2, animationData);
            }
          }
          function resize() {
            var i2;
            for (i2 = 0; i2 < len; i2 += 1) {
              registeredAnimations[i2].animation.resize();
            }
          }
          function activate() {
            if (!_isFrozen && playingAnimationsNum) {
              if (_stopped) {
                window.requestAnimationFrame(first);
                _stopped = false;
              }
            }
          }
          function freeze2() {
            _isFrozen = true;
          }
          function unfreeze() {
            _isFrozen = false;
            activate();
          }
          function setVolume(val2, animation) {
            var i2;
            for (i2 = 0; i2 < len; i2 += 1) {
              registeredAnimations[i2].animation.setVolume(val2, animation);
            }
          }
          function mute(animation) {
            var i2;
            for (i2 = 0; i2 < len; i2 += 1) {
              registeredAnimations[i2].animation.mute(animation);
            }
          }
          function unmute(animation) {
            var i2;
            for (i2 = 0; i2 < len; i2 += 1) {
              registeredAnimations[i2].animation.unmute(animation);
            }
          }
          moduleOb.registerAnimation = registerAnimation;
          moduleOb.loadAnimation = loadAnimation2;
          moduleOb.setSpeed = setSpeed;
          moduleOb.setDirection = setDirection;
          moduleOb.play = play;
          moduleOb.pause = pause;
          moduleOb.stop = stop;
          moduleOb.togglePause = togglePause;
          moduleOb.searchAnimations = searchAnimations2;
          moduleOb.resize = resize;
          moduleOb.goToAndStop = goToAndStop;
          moduleOb.destroy = destroy;
          moduleOb.freeze = freeze2;
          moduleOb.unfreeze = unfreeze;
          moduleOb.setVolume = setVolume;
          moduleOb.mute = mute;
          moduleOb.unmute = unmute;
          moduleOb.getRegisteredAnimations = getRegisteredAnimations;
          return moduleOb;
        }();
        var BezierFactory = function() {
          var ob2 = {};
          ob2.getBezierEasing = getBezierEasing;
          var beziers = {};
          function getBezierEasing(a2, b, c2, d, nm2) {
            var str = nm2 || ("bez_" + a2 + "_" + b + "_" + c2 + "_" + d).replace(/\./g, "p");
            if (beziers[str]) {
              return beziers[str];
            }
            var bezEasing = new BezierEasing([a2, b, c2, d]);
            beziers[str] = bezEasing;
            return bezEasing;
          }
          var NEWTON_ITERATIONS = 4;
          var NEWTON_MIN_SLOPE = 1e-3;
          var SUBDIVISION_PRECISION = 1e-7;
          var SUBDIVISION_MAX_ITERATIONS = 10;
          var kSplineTableSize = 11;
          var kSampleStepSize = 1 / (kSplineTableSize - 1);
          var float32ArraySupported = typeof Float32Array === "function";
          function A2(aA1, aA2) {
            return 1 - 3 * aA2 + 3 * aA1;
          }
          function B2(aA1, aA2) {
            return 3 * aA2 - 6 * aA1;
          }
          function C2(aA1) {
            return 3 * aA1;
          }
          function calcBezier(aT, aA1, aA2) {
            return ((A2(aA1, aA2) * aT + B2(aA1, aA2)) * aT + C2(aA1)) * aT;
          }
          function getSlope(aT, aA1, aA2) {
            return 3 * A2(aA1, aA2) * aT * aT + 2 * B2(aA1, aA2) * aT + C2(aA1);
          }
          function binarySubdivide(aX, aA, aB, mX1, mX2) {
            var currentX, currentT, i2 = 0;
            do {
              currentT = aA + (aB - aA) / 2;
              currentX = calcBezier(currentT, mX1, mX2) - aX;
              if (currentX > 0) {
                aB = currentT;
              } else {
                aA = currentT;
              }
            } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i2 < SUBDIVISION_MAX_ITERATIONS);
            return currentT;
          }
          function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
            for (var i2 = 0; i2 < NEWTON_ITERATIONS; ++i2) {
              var currentSlope = getSlope(aGuessT, mX1, mX2);
              if (currentSlope === 0)
                return aGuessT;
              var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
              aGuessT -= currentX / currentSlope;
            }
            return aGuessT;
          }
          function BezierEasing(points) {
            this._p = points;
            this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
            this._precomputed = false;
            this.get = this.get.bind(this);
          }
          BezierEasing.prototype = {
            get: function get2(x2) {
              var mX1 = this._p[0], mY1 = this._p[1], mX2 = this._p[2], mY2 = this._p[3];
              if (!this._precomputed)
                this._precompute();
              if (mX1 === mY1 && mX2 === mY2)
                return x2;
              if (x2 === 0)
                return 0;
              if (x2 === 1)
                return 1;
              return calcBezier(this._getTForX(x2), mY1, mY2);
            },
            // Private part
            _precompute: function _precompute() {
              var mX1 = this._p[0], mY1 = this._p[1], mX2 = this._p[2], mY2 = this._p[3];
              this._precomputed = true;
              if (mX1 !== mY1 || mX2 !== mY2) {
                this._calcSampleValues();
              }
            },
            _calcSampleValues: function _calcSampleValues() {
              var mX1 = this._p[0], mX2 = this._p[2];
              for (var i2 = 0; i2 < kSplineTableSize; ++i2) {
                this._mSampleValues[i2] = calcBezier(i2 * kSampleStepSize, mX1, mX2);
              }
            },
            /**
                 * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.
                 */
            _getTForX: function _getTForX(aX) {
              var mX1 = this._p[0], mX2 = this._p[2], mSampleValues = this._mSampleValues;
              var intervalStart = 0;
              var currentSample = 1;
              var lastSample = kSplineTableSize - 1;
              for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
                intervalStart += kSampleStepSize;
              }
              --currentSample;
              var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]);
              var guessForT = intervalStart + dist * kSampleStepSize;
              var initialSlope = getSlope(guessForT, mX1, mX2);
              if (initialSlope >= NEWTON_MIN_SLOPE) {
                return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
              }
              if (initialSlope === 0) {
                return guessForT;
              }
              return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
            }
          };
          return ob2;
        }();
        var pooling = /* @__PURE__ */ function() {
          function _double(arr2) {
            return arr2.concat(createSizedArray(arr2.length));
          }
          return {
            "double": _double
          };
        }();
        var poolFactory = /* @__PURE__ */ function() {
          return function(initialLength, _create, _release) {
            var _length = 0;
            var _maxLength = initialLength;
            var pool = createSizedArray(_maxLength);
            var ob2 = {
              newElement,
              release
            };
            function newElement() {
              var element;
              if (_length) {
                _length -= 1;
                element = pool[_length];
              } else {
                element = _create();
              }
              return element;
            }
            function release(element) {
              if (_length === _maxLength) {
                pool = pooling["double"](pool);
                _maxLength *= 2;
              }
              if (_release) {
                _release(element);
              }
              pool[_length] = element;
              _length += 1;
            }
            return ob2;
          };
        }();
        var bezierLengthPool = function() {
          function create() {
            return {
              addedLength: 0,
              percents: createTypedArray("float32", getDefaultCurveSegments()),
              lengths: createTypedArray("float32", getDefaultCurveSegments())
            };
          }
          return poolFactory(8, create);
        }();
        var segmentsLengthPool = function() {
          function create() {
            return {
              lengths: [],
              totalLength: 0
            };
          }
          function release(element) {
            var i2;
            var len = element.lengths.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              bezierLengthPool.release(element.lengths[i2]);
            }
            element.lengths.length = 0;
          }
          return poolFactory(8, create, release);
        }();
        function bezFunction() {
          var math = Math;
          function pointOnLine2D(x1, y1, x2, y2, x3, y3) {
            var det1 = x1 * y2 + y1 * x3 + x2 * y3 - x3 * y2 - y3 * x1 - x2 * y1;
            return det1 > -1e-3 && det1 < 1e-3;
          }
          function pointOnLine3D(x1, y1, z1, x2, y2, z2, x3, y3, z3) {
            if (z1 === 0 && z2 === 0 && z3 === 0) {
              return pointOnLine2D(x1, y1, x2, y2, x3, y3);
            }
            var dist1 = math.sqrt(math.pow(x2 - x1, 2) + math.pow(y2 - y1, 2) + math.pow(z2 - z1, 2));
            var dist2 = math.sqrt(math.pow(x3 - x1, 2) + math.pow(y3 - y1, 2) + math.pow(z3 - z1, 2));
            var dist3 = math.sqrt(math.pow(x3 - x2, 2) + math.pow(y3 - y2, 2) + math.pow(z3 - z2, 2));
            var diffDist;
            if (dist1 > dist2) {
              if (dist1 > dist3) {
                diffDist = dist1 - dist2 - dist3;
              } else {
                diffDist = dist3 - dist2 - dist1;
              }
            } else if (dist3 > dist2) {
              diffDist = dist3 - dist2 - dist1;
            } else {
              diffDist = dist2 - dist1 - dist3;
            }
            return diffDist > -1e-4 && diffDist < 1e-4;
          }
          var getBezierLength = /* @__PURE__ */ function() {
            return function(pt1, pt2, pt3, pt4) {
              var curveSegments = getDefaultCurveSegments();
              var k2;
              var i2;
              var len;
              var ptCoord;
              var perc;
              var addedLength = 0;
              var ptDistance;
              var point = [];
              var lastPoint = [];
              var lengthData = bezierLengthPool.newElement();
              len = pt3.length;
              for (k2 = 0; k2 < curveSegments; k2 += 1) {
                perc = k2 / (curveSegments - 1);
                ptDistance = 0;
                for (i2 = 0; i2 < len; i2 += 1) {
                  ptCoord = bmPow(1 - perc, 3) * pt1[i2] + 3 * bmPow(1 - perc, 2) * perc * pt3[i2] + 3 * (1 - perc) * bmPow(perc, 2) * pt4[i2] + bmPow(perc, 3) * pt2[i2];
                  point[i2] = ptCoord;
                  if (lastPoint[i2] !== null) {
                    ptDistance += bmPow(point[i2] - lastPoint[i2], 2);
                  }
                  lastPoint[i2] = point[i2];
                }
                if (ptDistance) {
                  ptDistance = bmSqrt(ptDistance);
                  addedLength += ptDistance;
                }
                lengthData.percents[k2] = perc;
                lengthData.lengths[k2] = addedLength;
              }
              lengthData.addedLength = addedLength;
              return lengthData;
            };
          }();
          function getSegmentsLength(shapeData) {
            var segmentsLength = segmentsLengthPool.newElement();
            var closed = shapeData.c;
            var pathV = shapeData.v;
            var pathO = shapeData.o;
            var pathI = shapeData.i;
            var i2;
            var len = shapeData._length;
            var lengths = segmentsLength.lengths;
            var totalLength = 0;
            for (i2 = 0; i2 < len - 1; i2 += 1) {
              lengths[i2] = getBezierLength(pathV[i2], pathV[i2 + 1], pathO[i2], pathI[i2 + 1]);
              totalLength += lengths[i2].addedLength;
            }
            if (closed && len) {
              lengths[i2] = getBezierLength(pathV[i2], pathV[0], pathO[i2], pathI[0]);
              totalLength += lengths[i2].addedLength;
            }
            segmentsLength.totalLength = totalLength;
            return segmentsLength;
          }
          function BezierData(length2) {
            this.segmentLength = 0;
            this.points = new Array(length2);
          }
          function PointData(partial, point) {
            this.partialLength = partial;
            this.point = point;
          }
          var buildBezierData = /* @__PURE__ */ function() {
            var storedData = {};
            return function(pt1, pt2, pt3, pt4) {
              var bezierName = (pt1[0] + "_" + pt1[1] + "_" + pt2[0] + "_" + pt2[1] + "_" + pt3[0] + "_" + pt3[1] + "_" + pt4[0] + "_" + pt4[1]).replace(/\./g, "p");
              if (!storedData[bezierName]) {
                var curveSegments = getDefaultCurveSegments();
                var k2;
                var i2;
                var len;
                var ptCoord;
                var perc;
                var addedLength = 0;
                var ptDistance;
                var point;
                var lastPoint = null;
                if (pt1.length === 2 && (pt1[0] !== pt2[0] || pt1[1] !== pt2[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt1[0] + pt3[0], pt1[1] + pt3[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt2[0] + pt4[0], pt2[1] + pt4[1])) {
                  curveSegments = 2;
                }
                var bezierData = new BezierData(curveSegments);
                len = pt3.length;
                for (k2 = 0; k2 < curveSegments; k2 += 1) {
                  point = createSizedArray(len);
                  perc = k2 / (curveSegments - 1);
                  ptDistance = 0;
                  for (i2 = 0; i2 < len; i2 += 1) {
                    ptCoord = bmPow(1 - perc, 3) * pt1[i2] + 3 * bmPow(1 - perc, 2) * perc * (pt1[i2] + pt3[i2]) + 3 * (1 - perc) * bmPow(perc, 2) * (pt2[i2] + pt4[i2]) + bmPow(perc, 3) * pt2[i2];
                    point[i2] = ptCoord;
                    if (lastPoint !== null) {
                      ptDistance += bmPow(point[i2] - lastPoint[i2], 2);
                    }
                  }
                  ptDistance = bmSqrt(ptDistance);
                  addedLength += ptDistance;
                  bezierData.points[k2] = new PointData(ptDistance, point);
                  lastPoint = point;
                }
                bezierData.segmentLength = addedLength;
                storedData[bezierName] = bezierData;
              }
              return storedData[bezierName];
            };
          }();
          function getDistancePerc(perc, bezierData) {
            var percents = bezierData.percents;
            var lengths = bezierData.lengths;
            var len = percents.length;
            var initPos = bmFloor((len - 1) * perc);
            var lengthPos = perc * bezierData.addedLength;
            var lPerc = 0;
            if (initPos === len - 1 || initPos === 0 || lengthPos === lengths[initPos]) {
              return percents[initPos];
            }
            var dir = lengths[initPos] > lengthPos ? -1 : 1;
            var flag = true;
            while (flag) {
              if (lengths[initPos] <= lengthPos && lengths[initPos + 1] > lengthPos) {
                lPerc = (lengthPos - lengths[initPos]) / (lengths[initPos + 1] - lengths[initPos]);
                flag = false;
              } else {
                initPos += dir;
              }
              if (initPos < 0 || initPos >= len - 1) {
                if (initPos === len - 1) {
                  return percents[initPos];
                }
                flag = false;
              }
            }
            return percents[initPos] + (percents[initPos + 1] - percents[initPos]) * lPerc;
          }
          function getPointInSegment(pt1, pt2, pt3, pt4, percent, bezierData) {
            var t1 = getDistancePerc(percent, bezierData);
            var u1 = 1 - t1;
            var ptX = math.round((u1 * u1 * u1 * pt1[0] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[0] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[0] + t1 * t1 * t1 * pt2[0]) * 1e3) / 1e3;
            var ptY = math.round((u1 * u1 * u1 * pt1[1] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[1] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[1] + t1 * t1 * t1 * pt2[1]) * 1e3) / 1e3;
            return [ptX, ptY];
          }
          var bezierSegmentPoints = createTypedArray("float32", 8);
          function getNewSegment(pt1, pt2, pt3, pt4, startPerc, endPerc, bezierData) {
            if (startPerc < 0) {
              startPerc = 0;
            } else if (startPerc > 1) {
              startPerc = 1;
            }
            var t0 = getDistancePerc(startPerc, bezierData);
            endPerc = endPerc > 1 ? 1 : endPerc;
            var t1 = getDistancePerc(endPerc, bezierData);
            var i2;
            var len = pt1.length;
            var u0 = 1 - t0;
            var u1 = 1 - t1;
            var u0u0u0 = u0 * u0 * u0;
            var t0u0u0_3 = t0 * u0 * u0 * 3;
            var t0t0u0_3 = t0 * t0 * u0 * 3;
            var t0t0t0 = t0 * t0 * t0;
            var u0u0u1 = u0 * u0 * u1;
            var t0u0u1_3 = t0 * u0 * u1 + u0 * t0 * u1 + u0 * u0 * t1;
            var t0t0u1_3 = t0 * t0 * u1 + u0 * t0 * t1 + t0 * u0 * t1;
            var t0t0t1 = t0 * t0 * t1;
            var u0u1u1 = u0 * u1 * u1;
            var t0u1u1_3 = t0 * u1 * u1 + u0 * t1 * u1 + u0 * u1 * t1;
            var t0t1u1_3 = t0 * t1 * u1 + u0 * t1 * t1 + t0 * u1 * t1;
            var t0t1t1 = t0 * t1 * t1;
            var u1u1u1 = u1 * u1 * u1;
            var t1u1u1_3 = t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1;
            var t1t1u1_3 = t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1;
            var t1t1t1 = t1 * t1 * t1;
            for (i2 = 0; i2 < len; i2 += 1) {
              bezierSegmentPoints[i2 * 4] = math.round((u0u0u0 * pt1[i2] + t0u0u0_3 * pt3[i2] + t0t0u0_3 * pt4[i2] + t0t0t0 * pt2[i2]) * 1e3) / 1e3;
              bezierSegmentPoints[i2 * 4 + 1] = math.round((u0u0u1 * pt1[i2] + t0u0u1_3 * pt3[i2] + t0t0u1_3 * pt4[i2] + t0t0t1 * pt2[i2]) * 1e3) / 1e3;
              bezierSegmentPoints[i2 * 4 + 2] = math.round((u0u1u1 * pt1[i2] + t0u1u1_3 * pt3[i2] + t0t1u1_3 * pt4[i2] + t0t1t1 * pt2[i2]) * 1e3) / 1e3;
              bezierSegmentPoints[i2 * 4 + 3] = math.round((u1u1u1 * pt1[i2] + t1u1u1_3 * pt3[i2] + t1t1u1_3 * pt4[i2] + t1t1t1 * pt2[i2]) * 1e3) / 1e3;
            }
            return bezierSegmentPoints;
          }
          return {
            getSegmentsLength,
            getNewSegment,
            getPointInSegment,
            buildBezierData,
            pointOnLine2D,
            pointOnLine3D
          };
        }
        var bez = bezFunction();
        var initFrame = initialDefaultFrame;
        var mathAbs = Math.abs;
        function interpolateValue(frameNum, caching) {
          var offsetTime = this.offsetTime;
          var newValue;
          if (this.propType === "multidimensional") {
            newValue = createTypedArray("float32", this.pv.length);
          }
          var iterationIndex = caching.lastIndex;
          var i2 = iterationIndex;
          var len = this.keyframes.length - 1;
          var flag = true;
          var keyData;
          var nextKeyData;
          var keyframeMetadata;
          while (flag) {
            keyData = this.keyframes[i2];
            nextKeyData = this.keyframes[i2 + 1];
            if (i2 === len - 1 && frameNum >= nextKeyData.t - offsetTime) {
              if (keyData.h) {
                keyData = nextKeyData;
              }
              iterationIndex = 0;
              break;
            }
            if (nextKeyData.t - offsetTime > frameNum) {
              iterationIndex = i2;
              break;
            }
            if (i2 < len - 1) {
              i2 += 1;
            } else {
              iterationIndex = 0;
              flag = false;
            }
          }
          keyframeMetadata = this.keyframesMetadata[i2] || {};
          var k2;
          var kLen;
          var perc;
          var jLen;
          var j;
          var fnc;
          var nextKeyTime = nextKeyData.t - offsetTime;
          var keyTime = keyData.t - offsetTime;
          var endValue;
          if (keyData.to) {
            if (!keyframeMetadata.bezierData) {
              keyframeMetadata.bezierData = bez.buildBezierData(keyData.s, nextKeyData.s || keyData.e, keyData.to, keyData.ti);
            }
            var bezierData = keyframeMetadata.bezierData;
            if (frameNum >= nextKeyTime || frameNum < keyTime) {
              var ind = frameNum >= nextKeyTime ? bezierData.points.length - 1 : 0;
              kLen = bezierData.points[ind].point.length;
              for (k2 = 0; k2 < kLen; k2 += 1) {
                newValue[k2] = bezierData.points[ind].point[k2];
              }
            } else {
              if (keyframeMetadata.__fnct) {
                fnc = keyframeMetadata.__fnct;
              } else {
                fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y, keyData.n).get;
                keyframeMetadata.__fnct = fnc;
              }
              perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
              var distanceInLine = bezierData.segmentLength * perc;
              var segmentPerc;
              var addedLength = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i2 ? caching._lastAddedLength : 0;
              j = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i2 ? caching._lastPoint : 0;
              flag = true;
              jLen = bezierData.points.length;
              while (flag) {
                addedLength += bezierData.points[j].partialLength;
                if (distanceInLine === 0 || perc === 0 || j === bezierData.points.length - 1) {
                  kLen = bezierData.points[j].point.length;
                  for (k2 = 0; k2 < kLen; k2 += 1) {
                    newValue[k2] = bezierData.points[j].point[k2];
                  }
                  break;
                } else if (distanceInLine >= addedLength && distanceInLine < addedLength + bezierData.points[j + 1].partialLength) {
                  segmentPerc = (distanceInLine - addedLength) / bezierData.points[j + 1].partialLength;
                  kLen = bezierData.points[j].point.length;
                  for (k2 = 0; k2 < kLen; k2 += 1) {
                    newValue[k2] = bezierData.points[j].point[k2] + (bezierData.points[j + 1].point[k2] - bezierData.points[j].point[k2]) * segmentPerc;
                  }
                  break;
                }
                if (j < jLen - 1) {
                  j += 1;
                } else {
                  flag = false;
                }
              }
              caching._lastPoint = j;
              caching._lastAddedLength = addedLength - bezierData.points[j].partialLength;
              caching._lastKeyframeIndex = i2;
            }
          } else {
            var outX;
            var outY;
            var inX;
            var inY;
            var keyValue;
            len = keyData.s.length;
            endValue = nextKeyData.s || keyData.e;
            if (this.sh && keyData.h !== 1) {
              if (frameNum >= nextKeyTime) {
                newValue[0] = endValue[0];
                newValue[1] = endValue[1];
                newValue[2] = endValue[2];
              } else if (frameNum <= keyTime) {
                newValue[0] = keyData.s[0];
                newValue[1] = keyData.s[1];
                newValue[2] = keyData.s[2];
              } else {
                var quatStart = createQuaternion(keyData.s);
                var quatEnd = createQuaternion(endValue);
                var time2 = (frameNum - keyTime) / (nextKeyTime - keyTime);
                quaternionToEuler(newValue, slerp(quatStart, quatEnd, time2));
              }
            } else {
              for (i2 = 0; i2 < len; i2 += 1) {
                if (keyData.h !== 1) {
                  if (frameNum >= nextKeyTime) {
                    perc = 1;
                  } else if (frameNum < keyTime) {
                    perc = 0;
                  } else {
                    if (keyData.o.x.constructor === Array) {
                      if (!keyframeMetadata.__fnct) {
                        keyframeMetadata.__fnct = [];
                      }
                      if (!keyframeMetadata.__fnct[i2]) {
                        outX = keyData.o.x[i2] === void 0 ? keyData.o.x[0] : keyData.o.x[i2];
                        outY = keyData.o.y[i2] === void 0 ? keyData.o.y[0] : keyData.o.y[i2];
                        inX = keyData.i.x[i2] === void 0 ? keyData.i.x[0] : keyData.i.x[i2];
                        inY = keyData.i.y[i2] === void 0 ? keyData.i.y[0] : keyData.i.y[i2];
                        fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                        keyframeMetadata.__fnct[i2] = fnc;
                      } else {
                        fnc = keyframeMetadata.__fnct[i2];
                      }
                    } else if (!keyframeMetadata.__fnct) {
                      outX = keyData.o.x;
                      outY = keyData.o.y;
                      inX = keyData.i.x;
                      inY = keyData.i.y;
                      fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                      keyData.keyframeMetadata = fnc;
                    } else {
                      fnc = keyframeMetadata.__fnct;
                    }
                    perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
                  }
                }
                endValue = nextKeyData.s || keyData.e;
                keyValue = keyData.h === 1 ? keyData.s[i2] : keyData.s[i2] + (endValue[i2] - keyData.s[i2]) * perc;
                if (this.propType === "multidimensional") {
                  newValue[i2] = keyValue;
                } else {
                  newValue = keyValue;
                }
              }
            }
          }
          caching.lastIndex = iterationIndex;
          return newValue;
        }
        function slerp(a2, b, t2) {
          var out = [];
          var ax = a2[0];
          var ay = a2[1];
          var az = a2[2];
          var aw = a2[3];
          var bx = b[0];
          var by = b[1];
          var bz = b[2];
          var bw = b[3];
          var omega;
          var cosom;
          var sinom;
          var scale0;
          var scale1;
          cosom = ax * bx + ay * by + az * bz + aw * bw;
          if (cosom < 0) {
            cosom = -cosom;
            bx = -bx;
            by = -by;
            bz = -bz;
            bw = -bw;
          }
          if (1 - cosom > 1e-6) {
            omega = Math.acos(cosom);
            sinom = Math.sin(omega);
            scale0 = Math.sin((1 - t2) * omega) / sinom;
            scale1 = Math.sin(t2 * omega) / sinom;
          } else {
            scale0 = 1 - t2;
            scale1 = t2;
          }
          out[0] = scale0 * ax + scale1 * bx;
          out[1] = scale0 * ay + scale1 * by;
          out[2] = scale0 * az + scale1 * bz;
          out[3] = scale0 * aw + scale1 * bw;
          return out;
        }
        function quaternionToEuler(out, quat) {
          var qx = quat[0];
          var qy = quat[1];
          var qz = quat[2];
          var qw = quat[3];
          var heading = Math.atan2(2 * qy * qw - 2 * qx * qz, 1 - 2 * qy * qy - 2 * qz * qz);
          var attitude = Math.asin(2 * qx * qy + 2 * qz * qw);
          var bank = Math.atan2(2 * qx * qw - 2 * qy * qz, 1 - 2 * qx * qx - 2 * qz * qz);
          out[0] = heading / degToRads;
          out[1] = attitude / degToRads;
          out[2] = bank / degToRads;
        }
        function createQuaternion(values) {
          var heading = values[0] * degToRads;
          var attitude = values[1] * degToRads;
          var bank = values[2] * degToRads;
          var c1 = Math.cos(heading / 2);
          var c2 = Math.cos(attitude / 2);
          var c3 = Math.cos(bank / 2);
          var s1 = Math.sin(heading / 2);
          var s2 = Math.sin(attitude / 2);
          var s3 = Math.sin(bank / 2);
          var w2 = c1 * c2 * c3 - s1 * s2 * s3;
          var x2 = s1 * s2 * c3 + c1 * c2 * s3;
          var y2 = s1 * c2 * c3 + c1 * s2 * s3;
          var z2 = c1 * s2 * c3 - s1 * c2 * s3;
          return [x2, y2, z2, w2];
        }
        function getValueAtCurrentTime() {
          var frameNum = this.comp.renderedFrame - this.offsetTime;
          var initTime = this.keyframes[0].t - this.offsetTime;
          var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
          if (!(frameNum === this._caching.lastFrame || this._caching.lastFrame !== initFrame && (this._caching.lastFrame >= endTime && frameNum >= endTime || this._caching.lastFrame < initTime && frameNum < initTime))) {
            if (this._caching.lastFrame >= frameNum) {
              this._caching._lastKeyframeIndex = -1;
              this._caching.lastIndex = 0;
            }
            var renderResult = this.interpolateValue(frameNum, this._caching);
            this.pv = renderResult;
          }
          this._caching.lastFrame = frameNum;
          return this.pv;
        }
        function setVValue(val2) {
          var multipliedValue;
          if (this.propType === "unidimensional") {
            multipliedValue = val2 * this.mult;
            if (mathAbs(this.v - multipliedValue) > 1e-5) {
              this.v = multipliedValue;
              this._mdf = true;
            }
          } else {
            var i2 = 0;
            var len = this.v.length;
            while (i2 < len) {
              multipliedValue = val2[i2] * this.mult;
              if (mathAbs(this.v[i2] - multipliedValue) > 1e-5) {
                this.v[i2] = multipliedValue;
                this._mdf = true;
              }
              i2 += 1;
            }
          }
        }
        function processEffectsSequence() {
          if (this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) {
            return;
          }
          if (this.lock) {
            this.setVValue(this.pv);
            return;
          }
          this.lock = true;
          this._mdf = this._isFirstFrame;
          var i2;
          var len = this.effectsSequence.length;
          var finalValue = this.kf ? this.pv : this.data.k;
          for (i2 = 0; i2 < len; i2 += 1) {
            finalValue = this.effectsSequence[i2](finalValue);
          }
          this.setVValue(finalValue);
          this._isFirstFrame = false;
          this.lock = false;
          this.frameId = this.elem.globalData.frameId;
        }
        function addEffect(effectFunction) {
          this.effectsSequence.push(effectFunction);
          this.container.addDynamicProperty(this);
        }
        function ValueProperty(elem2, data2, mult, container2) {
          this.propType = "unidimensional";
          this.mult = mult || 1;
          this.data = data2;
          this.v = mult ? data2.k * mult : data2.k;
          this.pv = data2.k;
          this._mdf = false;
          this.elem = elem2;
          this.container = container2;
          this.comp = elem2.comp;
          this.k = false;
          this.kf = false;
          this.vel = 0;
          this.effectsSequence = [];
          this._isFirstFrame = true;
          this.getValue = processEffectsSequence;
          this.setVValue = setVValue;
          this.addEffect = addEffect;
        }
        function MultiDimensionalProperty(elem2, data2, mult, container2) {
          this.propType = "multidimensional";
          this.mult = mult || 1;
          this.data = data2;
          this._mdf = false;
          this.elem = elem2;
          this.container = container2;
          this.comp = elem2.comp;
          this.k = false;
          this.kf = false;
          this.frameId = -1;
          var i2;
          var len = data2.k.length;
          this.v = createTypedArray("float32", len);
          this.pv = createTypedArray("float32", len);
          this.vel = createTypedArray("float32", len);
          for (i2 = 0; i2 < len; i2 += 1) {
            this.v[i2] = data2.k[i2] * this.mult;
            this.pv[i2] = data2.k[i2];
          }
          this._isFirstFrame = true;
          this.effectsSequence = [];
          this.getValue = processEffectsSequence;
          this.setVValue = setVValue;
          this.addEffect = addEffect;
        }
        function KeyframedValueProperty(elem2, data2, mult, container2) {
          this.propType = "unidimensional";
          this.keyframes = data2.k;
          this.keyframesMetadata = [];
          this.offsetTime = elem2.data.st;
          this.frameId = -1;
          this._caching = {
            lastFrame: initFrame,
            lastIndex: 0,
            value: 0,
            _lastKeyframeIndex: -1
          };
          this.k = true;
          this.kf = true;
          this.data = data2;
          this.mult = mult || 1;
          this.elem = elem2;
          this.container = container2;
          this.comp = elem2.comp;
          this.v = initFrame;
          this.pv = initFrame;
          this._isFirstFrame = true;
          this.getValue = processEffectsSequence;
          this.setVValue = setVValue;
          this.interpolateValue = interpolateValue;
          this.effectsSequence = [getValueAtCurrentTime.bind(this)];
          this.addEffect = addEffect;
        }
        function KeyframedMultidimensionalProperty(elem2, data2, mult, container2) {
          this.propType = "multidimensional";
          var i2;
          var len = data2.k.length;
          var s2;
          var e2;
          var to;
          var ti2;
          for (i2 = 0; i2 < len - 1; i2 += 1) {
            if (data2.k[i2].to && data2.k[i2].s && data2.k[i2 + 1] && data2.k[i2 + 1].s) {
              s2 = data2.k[i2].s;
              e2 = data2.k[i2 + 1].s;
              to = data2.k[i2].to;
              ti2 = data2.k[i2].ti;
              if (s2.length === 2 && !(s2[0] === e2[0] && s2[1] === e2[1]) && bez.pointOnLine2D(s2[0], s2[1], e2[0], e2[1], s2[0] + to[0], s2[1] + to[1]) && bez.pointOnLine2D(s2[0], s2[1], e2[0], e2[1], e2[0] + ti2[0], e2[1] + ti2[1]) || s2.length === 3 && !(s2[0] === e2[0] && s2[1] === e2[1] && s2[2] === e2[2]) && bez.pointOnLine3D(s2[0], s2[1], s2[2], e2[0], e2[1], e2[2], s2[0] + to[0], s2[1] + to[1], s2[2] + to[2]) && bez.pointOnLine3D(s2[0], s2[1], s2[2], e2[0], e2[1], e2[2], e2[0] + ti2[0], e2[1] + ti2[1], e2[2] + ti2[2])) {
                data2.k[i2].to = null;
                data2.k[i2].ti = null;
              }
              if (s2[0] === e2[0] && s2[1] === e2[1] && to[0] === 0 && to[1] === 0 && ti2[0] === 0 && ti2[1] === 0) {
                if (s2.length === 2 || s2[2] === e2[2] && to[2] === 0 && ti2[2] === 0) {
                  data2.k[i2].to = null;
                  data2.k[i2].ti = null;
                }
              }
            }
          }
          this.effectsSequence = [getValueAtCurrentTime.bind(this)];
          this.data = data2;
          this.keyframes = data2.k;
          this.keyframesMetadata = [];
          this.offsetTime = elem2.data.st;
          this.k = true;
          this.kf = true;
          this._isFirstFrame = true;
          this.mult = mult || 1;
          this.elem = elem2;
          this.container = container2;
          this.comp = elem2.comp;
          this.getValue = processEffectsSequence;
          this.setVValue = setVValue;
          this.interpolateValue = interpolateValue;
          this.frameId = -1;
          var arrLen = data2.k[0].s.length;
          this.v = createTypedArray("float32", arrLen);
          this.pv = createTypedArray("float32", arrLen);
          for (i2 = 0; i2 < arrLen; i2 += 1) {
            this.v[i2] = initFrame;
            this.pv[i2] = initFrame;
          }
          this._caching = {
            lastFrame: initFrame,
            lastIndex: 0,
            value: createTypedArray("float32", arrLen)
          };
          this.addEffect = addEffect;
        }
        var PropertyFactory = /* @__PURE__ */ function() {
          function getProp(elem2, data2, type, mult, container2) {
            if (data2.sid) {
              data2 = elem2.globalData.slotManager.getProp(data2);
            }
            var p2;
            if (!data2.k.length) {
              p2 = new ValueProperty(elem2, data2, mult, container2);
            } else if (typeof data2.k[0] === "number") {
              p2 = new MultiDimensionalProperty(elem2, data2, mult, container2);
            } else {
              switch (type) {
                case 0:
                  p2 = new KeyframedValueProperty(elem2, data2, mult, container2);
                  break;
                case 1:
                  p2 = new KeyframedMultidimensionalProperty(elem2, data2, mult, container2);
                  break;
              }
            }
            if (p2.effectsSequence.length) {
              container2.addDynamicProperty(p2);
            }
            return p2;
          }
          var ob2 = {
            getProp
          };
          return ob2;
        }();
        function DynamicPropertyContainer() {
        }
        DynamicPropertyContainer.prototype = {
          addDynamicProperty: function addDynamicProperty(prop) {
            if (this.dynamicProperties.indexOf(prop) === -1) {
              this.dynamicProperties.push(prop);
              this.container.addDynamicProperty(this);
              this._isAnimated = true;
            }
          },
          iterateDynamicProperties: function iterateDynamicProperties() {
            this._mdf = false;
            var i2;
            var len = this.dynamicProperties.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              this.dynamicProperties[i2].getValue();
              if (this.dynamicProperties[i2]._mdf) {
                this._mdf = true;
              }
            }
          },
          initDynamicPropertyContainer: function initDynamicPropertyContainer(container2) {
            this.container = container2;
            this.dynamicProperties = [];
            this._mdf = false;
            this._isAnimated = false;
          }
        };
        var pointPool = function() {
          function create() {
            return createTypedArray("float32", 2);
          }
          return poolFactory(8, create);
        }();
        function ShapePath() {
          this.c = false;
          this._length = 0;
          this._maxLength = 8;
          this.v = createSizedArray(this._maxLength);
          this.o = createSizedArray(this._maxLength);
          this.i = createSizedArray(this._maxLength);
        }
        ShapePath.prototype.setPathData = function(closed, len) {
          this.c = closed;
          this.setLength(len);
          var i2 = 0;
          while (i2 < len) {
            this.v[i2] = pointPool.newElement();
            this.o[i2] = pointPool.newElement();
            this.i[i2] = pointPool.newElement();
            i2 += 1;
          }
        };
        ShapePath.prototype.setLength = function(len) {
          while (this._maxLength < len) {
            this.doubleArrayLength();
          }
          this._length = len;
        };
        ShapePath.prototype.doubleArrayLength = function() {
          this.v = this.v.concat(createSizedArray(this._maxLength));
          this.i = this.i.concat(createSizedArray(this._maxLength));
          this.o = this.o.concat(createSizedArray(this._maxLength));
          this._maxLength *= 2;
        };
        ShapePath.prototype.setXYAt = function(x2, y2, type, pos, replace) {
          var arr2;
          this._length = Math.max(this._length, pos + 1);
          if (this._length >= this._maxLength) {
            this.doubleArrayLength();
          }
          switch (type) {
            case "v":
              arr2 = this.v;
              break;
            case "i":
              arr2 = this.i;
              break;
            case "o":
              arr2 = this.o;
              break;
            default:
              arr2 = [];
              break;
          }
          if (!arr2[pos] || arr2[pos] && !replace) {
            arr2[pos] = pointPool.newElement();
          }
          arr2[pos][0] = x2;
          arr2[pos][1] = y2;
        };
        ShapePath.prototype.setTripleAt = function(vX, vY, oX, oY, iX, iY, pos, replace) {
          this.setXYAt(vX, vY, "v", pos, replace);
          this.setXYAt(oX, oY, "o", pos, replace);
          this.setXYAt(iX, iY, "i", pos, replace);
        };
        ShapePath.prototype.reverse = function() {
          var newPath = new ShapePath();
          newPath.setPathData(this.c, this._length);
          var vertices = this.v;
          var outPoints = this.o;
          var inPoints = this.i;
          var init2 = 0;
          if (this.c) {
            newPath.setTripleAt(vertices[0][0], vertices[0][1], inPoints[0][0], inPoints[0][1], outPoints[0][0], outPoints[0][1], 0, false);
            init2 = 1;
          }
          var cnt = this._length - 1;
          var len = this._length;
          var i2;
          for (i2 = init2; i2 < len; i2 += 1) {
            newPath.setTripleAt(vertices[cnt][0], vertices[cnt][1], inPoints[cnt][0], inPoints[cnt][1], outPoints[cnt][0], outPoints[cnt][1], i2, false);
            cnt -= 1;
          }
          return newPath;
        };
        ShapePath.prototype.length = function() {
          return this._length;
        };
        var shapePool = function() {
          function create() {
            return new ShapePath();
          }
          function release(shapePath) {
            var len = shapePath._length;
            var i2;
            for (i2 = 0; i2 < len; i2 += 1) {
              pointPool.release(shapePath.v[i2]);
              pointPool.release(shapePath.i[i2]);
              pointPool.release(shapePath.o[i2]);
              shapePath.v[i2] = null;
              shapePath.i[i2] = null;
              shapePath.o[i2] = null;
            }
            shapePath._length = 0;
            shapePath.c = false;
          }
          function clone(shape) {
            var cloned = factory.newElement();
            var i2;
            var len = shape._length === void 0 ? shape.v.length : shape._length;
            cloned.setLength(len);
            cloned.c = shape.c;
            for (i2 = 0; i2 < len; i2 += 1) {
              cloned.setTripleAt(shape.v[i2][0], shape.v[i2][1], shape.o[i2][0], shape.o[i2][1], shape.i[i2][0], shape.i[i2][1], i2);
            }
            return cloned;
          }
          var factory = poolFactory(4, create, release);
          factory.clone = clone;
          return factory;
        }();
        function ShapeCollection() {
          this._length = 0;
          this._maxLength = 4;
          this.shapes = createSizedArray(this._maxLength);
        }
        ShapeCollection.prototype.addShape = function(shapeData) {
          if (this._length === this._maxLength) {
            this.shapes = this.shapes.concat(createSizedArray(this._maxLength));
            this._maxLength *= 2;
          }
          this.shapes[this._length] = shapeData;
          this._length += 1;
        };
        ShapeCollection.prototype.releaseShapes = function() {
          var i2;
          for (i2 = 0; i2 < this._length; i2 += 1) {
            shapePool.release(this.shapes[i2]);
          }
          this._length = 0;
        };
        var shapeCollectionPool = function() {
          var ob2 = {
            newShapeCollection,
            release
          };
          var _length = 0;
          var _maxLength = 4;
          var pool = createSizedArray(_maxLength);
          function newShapeCollection() {
            var shapeCollection;
            if (_length) {
              _length -= 1;
              shapeCollection = pool[_length];
            } else {
              shapeCollection = new ShapeCollection();
            }
            return shapeCollection;
          }
          function release(shapeCollection) {
            var i2;
            var len = shapeCollection._length;
            for (i2 = 0; i2 < len; i2 += 1) {
              shapePool.release(shapeCollection.shapes[i2]);
            }
            shapeCollection._length = 0;
            if (_length === _maxLength) {
              pool = pooling["double"](pool);
              _maxLength *= 2;
            }
            pool[_length] = shapeCollection;
            _length += 1;
          }
          return ob2;
        }();
        var ShapePropertyFactory = function() {
          var initFrame2 = -999999;
          function interpolateShape(frameNum, previousValue, caching) {
            var iterationIndex = caching.lastIndex;
            var keyPropS;
            var keyPropE;
            var isHold;
            var j;
            var k2;
            var jLen;
            var kLen;
            var perc;
            var vertexValue;
            var kf2 = this.keyframes;
            if (frameNum < kf2[0].t - this.offsetTime) {
              keyPropS = kf2[0].s[0];
              isHold = true;
              iterationIndex = 0;
            } else if (frameNum >= kf2[kf2.length - 1].t - this.offsetTime) {
              keyPropS = kf2[kf2.length - 1].s ? kf2[kf2.length - 1].s[0] : kf2[kf2.length - 2].e[0];
              isHold = true;
            } else {
              var i2 = iterationIndex;
              var len = kf2.length - 1;
              var flag = true;
              var keyData;
              var nextKeyData;
              var keyframeMetadata;
              while (flag) {
                keyData = kf2[i2];
                nextKeyData = kf2[i2 + 1];
                if (nextKeyData.t - this.offsetTime > frameNum) {
                  break;
                }
                if (i2 < len - 1) {
                  i2 += 1;
                } else {
                  flag = false;
                }
              }
              keyframeMetadata = this.keyframesMetadata[i2] || {};
              isHold = keyData.h === 1;
              iterationIndex = i2;
              if (!isHold) {
                if (frameNum >= nextKeyData.t - this.offsetTime) {
                  perc = 1;
                } else if (frameNum < keyData.t - this.offsetTime) {
                  perc = 0;
                } else {
                  var fnc;
                  if (keyframeMetadata.__fnct) {
                    fnc = keyframeMetadata.__fnct;
                  } else {
                    fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y).get;
                    keyframeMetadata.__fnct = fnc;
                  }
                  perc = fnc((frameNum - (keyData.t - this.offsetTime)) / (nextKeyData.t - this.offsetTime - (keyData.t - this.offsetTime)));
                }
                keyPropE = nextKeyData.s ? nextKeyData.s[0] : keyData.e[0];
              }
              keyPropS = keyData.s[0];
            }
            jLen = previousValue._length;
            kLen = keyPropS.i[0].length;
            caching.lastIndex = iterationIndex;
            for (j = 0; j < jLen; j += 1) {
              for (k2 = 0; k2 < kLen; k2 += 1) {
                vertexValue = isHold ? keyPropS.i[j][k2] : keyPropS.i[j][k2] + (keyPropE.i[j][k2] - keyPropS.i[j][k2]) * perc;
                previousValue.i[j][k2] = vertexValue;
                vertexValue = isHold ? keyPropS.o[j][k2] : keyPropS.o[j][k2] + (keyPropE.o[j][k2] - keyPropS.o[j][k2]) * perc;
                previousValue.o[j][k2] = vertexValue;
                vertexValue = isHold ? keyPropS.v[j][k2] : keyPropS.v[j][k2] + (keyPropE.v[j][k2] - keyPropS.v[j][k2]) * perc;
                previousValue.v[j][k2] = vertexValue;
              }
            }
          }
          function interpolateShapeCurrentTime() {
            var frameNum = this.comp.renderedFrame - this.offsetTime;
            var initTime = this.keyframes[0].t - this.offsetTime;
            var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
            var lastFrame = this._caching.lastFrame;
            if (!(lastFrame !== initFrame2 && (lastFrame < initTime && frameNum < initTime || lastFrame > endTime && frameNum > endTime))) {
              this._caching.lastIndex = lastFrame < frameNum ? this._caching.lastIndex : 0;
              this.interpolateShape(frameNum, this.pv, this._caching);
            }
            this._caching.lastFrame = frameNum;
            return this.pv;
          }
          function resetShape() {
            this.paths = this.localShapeCollection;
          }
          function shapesEqual(shape1, shape2) {
            if (shape1._length !== shape2._length || shape1.c !== shape2.c) {
              return false;
            }
            var i2;
            var len = shape1._length;
            for (i2 = 0; i2 < len; i2 += 1) {
              if (shape1.v[i2][0] !== shape2.v[i2][0] || shape1.v[i2][1] !== shape2.v[i2][1] || shape1.o[i2][0] !== shape2.o[i2][0] || shape1.o[i2][1] !== shape2.o[i2][1] || shape1.i[i2][0] !== shape2.i[i2][0] || shape1.i[i2][1] !== shape2.i[i2][1]) {
                return false;
              }
            }
            return true;
          }
          function setVValue2(newPath) {
            if (!shapesEqual(this.v, newPath)) {
              this.v = shapePool.clone(newPath);
              this.localShapeCollection.releaseShapes();
              this.localShapeCollection.addShape(this.v);
              this._mdf = true;
              this.paths = this.localShapeCollection;
            }
          }
          function processEffectsSequence2() {
            if (this.elem.globalData.frameId === this.frameId) {
              return;
            }
            if (!this.effectsSequence.length) {
              this._mdf = false;
              return;
            }
            if (this.lock) {
              this.setVValue(this.pv);
              return;
            }
            this.lock = true;
            this._mdf = false;
            var finalValue;
            if (this.kf) {
              finalValue = this.pv;
            } else if (this.data.ks) {
              finalValue = this.data.ks.k;
            } else {
              finalValue = this.data.pt.k;
            }
            var i2;
            var len = this.effectsSequence.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              finalValue = this.effectsSequence[i2](finalValue);
            }
            this.setVValue(finalValue);
            this.lock = false;
            this.frameId = this.elem.globalData.frameId;
          }
          function ShapeProperty(elem2, data2, type) {
            this.propType = "shape";
            this.comp = elem2.comp;
            this.container = elem2;
            this.elem = elem2;
            this.data = data2;
            this.k = false;
            this.kf = false;
            this._mdf = false;
            var pathData = type === 3 ? data2.pt.k : data2.ks.k;
            this.v = shapePool.clone(pathData);
            this.pv = shapePool.clone(this.v);
            this.localShapeCollection = shapeCollectionPool.newShapeCollection();
            this.paths = this.localShapeCollection;
            this.paths.addShape(this.v);
            this.reset = resetShape;
            this.effectsSequence = [];
          }
          function addEffect2(effectFunction) {
            this.effectsSequence.push(effectFunction);
            this.container.addDynamicProperty(this);
          }
          ShapeProperty.prototype.interpolateShape = interpolateShape;
          ShapeProperty.prototype.getValue = processEffectsSequence2;
          ShapeProperty.prototype.setVValue = setVValue2;
          ShapeProperty.prototype.addEffect = addEffect2;
          function KeyframedShapeProperty(elem2, data2, type) {
            this.propType = "shape";
            this.comp = elem2.comp;
            this.elem = elem2;
            this.container = elem2;
            this.offsetTime = elem2.data.st;
            this.keyframes = type === 3 ? data2.pt.k : data2.ks.k;
            this.keyframesMetadata = [];
            this.k = true;
            this.kf = true;
            var len = this.keyframes[0].s[0].i.length;
            this.v = shapePool.newElement();
            this.v.setPathData(this.keyframes[0].s[0].c, len);
            this.pv = shapePool.clone(this.v);
            this.localShapeCollection = shapeCollectionPool.newShapeCollection();
            this.paths = this.localShapeCollection;
            this.paths.addShape(this.v);
            this.lastFrame = initFrame2;
            this.reset = resetShape;
            this._caching = {
              lastFrame: initFrame2,
              lastIndex: 0
            };
            this.effectsSequence = [interpolateShapeCurrentTime.bind(this)];
          }
          KeyframedShapeProperty.prototype.getValue = processEffectsSequence2;
          KeyframedShapeProperty.prototype.interpolateShape = interpolateShape;
          KeyframedShapeProperty.prototype.setVValue = setVValue2;
          KeyframedShapeProperty.prototype.addEffect = addEffect2;
          var EllShapeProperty = function() {
            var cPoint = roundCorner;
            function EllShapePropertyFactory(elem2, data2) {
              this.v = shapePool.newElement();
              this.v.setPathData(true, 4);
              this.localShapeCollection = shapeCollectionPool.newShapeCollection();
              this.paths = this.localShapeCollection;
              this.localShapeCollection.addShape(this.v);
              this.d = data2.d;
              this.elem = elem2;
              this.comp = elem2.comp;
              this.frameId = -1;
              this.initDynamicPropertyContainer(elem2);
              this.p = PropertyFactory.getProp(elem2, data2.p, 1, 0, this);
              this.s = PropertyFactory.getProp(elem2, data2.s, 1, 0, this);
              if (this.dynamicProperties.length) {
                this.k = true;
              } else {
                this.k = false;
                this.convertEllToPath();
              }
            }
            EllShapePropertyFactory.prototype = {
              reset: resetShape,
              getValue: function getValue2() {
                if (this.elem.globalData.frameId === this.frameId) {
                  return;
                }
                this.frameId = this.elem.globalData.frameId;
                this.iterateDynamicProperties();
                if (this._mdf) {
                  this.convertEllToPath();
                }
              },
              convertEllToPath: function convertEllToPath() {
                var p0 = this.p.v[0];
                var p1 = this.p.v[1];
                var s0 = this.s.v[0] / 2;
                var s1 = this.s.v[1] / 2;
                var _cw = this.d !== 3;
                var _v = this.v;
                _v.v[0][0] = p0;
                _v.v[0][1] = p1 - s1;
                _v.v[1][0] = _cw ? p0 + s0 : p0 - s0;
                _v.v[1][1] = p1;
                _v.v[2][0] = p0;
                _v.v[2][1] = p1 + s1;
                _v.v[3][0] = _cw ? p0 - s0 : p0 + s0;
                _v.v[3][1] = p1;
                _v.i[0][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
                _v.i[0][1] = p1 - s1;
                _v.i[1][0] = _cw ? p0 + s0 : p0 - s0;
                _v.i[1][1] = p1 - s1 * cPoint;
                _v.i[2][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
                _v.i[2][1] = p1 + s1;
                _v.i[3][0] = _cw ? p0 - s0 : p0 + s0;
                _v.i[3][1] = p1 + s1 * cPoint;
                _v.o[0][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
                _v.o[0][1] = p1 - s1;
                _v.o[1][0] = _cw ? p0 + s0 : p0 - s0;
                _v.o[1][1] = p1 + s1 * cPoint;
                _v.o[2][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
                _v.o[2][1] = p1 + s1;
                _v.o[3][0] = _cw ? p0 - s0 : p0 + s0;
                _v.o[3][1] = p1 - s1 * cPoint;
              }
            };
            extendPrototype([DynamicPropertyContainer], EllShapePropertyFactory);
            return EllShapePropertyFactory;
          }();
          var StarShapeProperty = function() {
            function StarShapePropertyFactory(elem2, data2) {
              this.v = shapePool.newElement();
              this.v.setPathData(true, 0);
              this.elem = elem2;
              this.comp = elem2.comp;
              this.data = data2;
              this.frameId = -1;
              this.d = data2.d;
              this.initDynamicPropertyContainer(elem2);
              if (data2.sy === 1) {
                this.ir = PropertyFactory.getProp(elem2, data2.ir, 0, 0, this);
                this.is = PropertyFactory.getProp(elem2, data2.is, 0, 0.01, this);
                this.convertToPath = this.convertStarToPath;
              } else {
                this.convertToPath = this.convertPolygonToPath;
              }
              this.pt = PropertyFactory.getProp(elem2, data2.pt, 0, 0, this);
              this.p = PropertyFactory.getProp(elem2, data2.p, 1, 0, this);
              this.r = PropertyFactory.getProp(elem2, data2.r, 0, degToRads, this);
              this.or = PropertyFactory.getProp(elem2, data2.or, 0, 0, this);
              this.os = PropertyFactory.getProp(elem2, data2.os, 0, 0.01, this);
              this.localShapeCollection = shapeCollectionPool.newShapeCollection();
              this.localShapeCollection.addShape(this.v);
              this.paths = this.localShapeCollection;
              if (this.dynamicProperties.length) {
                this.k = true;
              } else {
                this.k = false;
                this.convertToPath();
              }
            }
            StarShapePropertyFactory.prototype = {
              reset: resetShape,
              getValue: function getValue2() {
                if (this.elem.globalData.frameId === this.frameId) {
                  return;
                }
                this.frameId = this.elem.globalData.frameId;
                this.iterateDynamicProperties();
                if (this._mdf) {
                  this.convertToPath();
                }
              },
              convertStarToPath: function convertStarToPath() {
                var numPts = Math.floor(this.pt.v) * 2;
                var angle = Math.PI * 2 / numPts;
                var longFlag = true;
                var longRad = this.or.v;
                var shortRad = this.ir.v;
                var longRound = this.os.v;
                var shortRound = this.is.v;
                var longPerimSegment = 2 * Math.PI * longRad / (numPts * 2);
                var shortPerimSegment = 2 * Math.PI * shortRad / (numPts * 2);
                var i2;
                var rad;
                var roundness;
                var perimSegment;
                var currentAng = -Math.PI / 2;
                currentAng += this.r.v;
                var dir = this.data.d === 3 ? -1 : 1;
                this.v._length = 0;
                for (i2 = 0; i2 < numPts; i2 += 1) {
                  rad = longFlag ? longRad : shortRad;
                  roundness = longFlag ? longRound : shortRound;
                  perimSegment = longFlag ? longPerimSegment : shortPerimSegment;
                  var x2 = rad * Math.cos(currentAng);
                  var y2 = rad * Math.sin(currentAng);
                  var ox = x2 === 0 && y2 === 0 ? 0 : y2 / Math.sqrt(x2 * x2 + y2 * y2);
                  var oy = x2 === 0 && y2 === 0 ? 0 : -x2 / Math.sqrt(x2 * x2 + y2 * y2);
                  x2 += +this.p.v[0];
                  y2 += +this.p.v[1];
                  this.v.setTripleAt(x2, y2, x2 - ox * perimSegment * roundness * dir, y2 - oy * perimSegment * roundness * dir, x2 + ox * perimSegment * roundness * dir, y2 + oy * perimSegment * roundness * dir, i2, true);
                  longFlag = !longFlag;
                  currentAng += angle * dir;
                }
              },
              convertPolygonToPath: function convertPolygonToPath() {
                var numPts = Math.floor(this.pt.v);
                var angle = Math.PI * 2 / numPts;
                var rad = this.or.v;
                var roundness = this.os.v;
                var perimSegment = 2 * Math.PI * rad / (numPts * 4);
                var i2;
                var currentAng = -Math.PI * 0.5;
                var dir = this.data.d === 3 ? -1 : 1;
                currentAng += this.r.v;
                this.v._length = 0;
                for (i2 = 0; i2 < numPts; i2 += 1) {
                  var x2 = rad * Math.cos(currentAng);
                  var y2 = rad * Math.sin(currentAng);
                  var ox = x2 === 0 && y2 === 0 ? 0 : y2 / Math.sqrt(x2 * x2 + y2 * y2);
                  var oy = x2 === 0 && y2 === 0 ? 0 : -x2 / Math.sqrt(x2 * x2 + y2 * y2);
                  x2 += +this.p.v[0];
                  y2 += +this.p.v[1];
                  this.v.setTripleAt(x2, y2, x2 - ox * perimSegment * roundness * dir, y2 - oy * perimSegment * roundness * dir, x2 + ox * perimSegment * roundness * dir, y2 + oy * perimSegment * roundness * dir, i2, true);
                  currentAng += angle * dir;
                }
                this.paths.length = 0;
                this.paths[0] = this.v;
              }
            };
            extendPrototype([DynamicPropertyContainer], StarShapePropertyFactory);
            return StarShapePropertyFactory;
          }();
          var RectShapeProperty = function() {
            function RectShapePropertyFactory(elem2, data2) {
              this.v = shapePool.newElement();
              this.v.c = true;
              this.localShapeCollection = shapeCollectionPool.newShapeCollection();
              this.localShapeCollection.addShape(this.v);
              this.paths = this.localShapeCollection;
              this.elem = elem2;
              this.comp = elem2.comp;
              this.frameId = -1;
              this.d = data2.d;
              this.initDynamicPropertyContainer(elem2);
              this.p = PropertyFactory.getProp(elem2, data2.p, 1, 0, this);
              this.s = PropertyFactory.getProp(elem2, data2.s, 1, 0, this);
              this.r = PropertyFactory.getProp(elem2, data2.r, 0, 0, this);
              if (this.dynamicProperties.length) {
                this.k = true;
              } else {
                this.k = false;
                this.convertRectToPath();
              }
            }
            RectShapePropertyFactory.prototype = {
              convertRectToPath: function convertRectToPath() {
                var p0 = this.p.v[0];
                var p1 = this.p.v[1];
                var v0 = this.s.v[0] / 2;
                var v1 = this.s.v[1] / 2;
                var round = bmMin(v0, v1, this.r.v);
                var cPoint = round * (1 - roundCorner);
                this.v._length = 0;
                if (this.d === 2 || this.d === 1) {
                  this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, 0, true);
                  this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, p0 + v0, p1 + v1 - round, 1, true);
                  if (round !== 0) {
                    this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, 2, true);
                    this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0 + round, p1 + v1, 3, true);
                    this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, 4, true);
                    this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1 + round, 5, true);
                    this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, 6, true);
                    this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, p0 + v0 - round, p1 - v1, 7, true);
                  } else {
                    this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0, p1 + v1, 2);
                    this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1, 3);
                  }
                } else {
                  this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, p0 + v0, p1 - v1 + round, 0, true);
                  if (round !== 0) {
                    this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, 1, true);
                    this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0 + round, p1 - v1, 2, true);
                    this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, 3, true);
                    this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1 - round, 4, true);
                    this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, 5, true);
                    this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0 - round, p1 + v1, 6, true);
                    this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, 7, true);
                  } else {
                    this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0, p1 - v1, 1, true);
                    this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1, 2, true);
                    this.v.setTripleAt(p0 + v0, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0, p1 + v1, 3, true);
                  }
                }
              },
              getValue: function getValue2() {
                if (this.elem.globalData.frameId === this.frameId) {
                  return;
                }
                this.frameId = this.elem.globalData.frameId;
                this.iterateDynamicProperties();
                if (this._mdf) {
                  this.convertRectToPath();
                }
              },
              reset: resetShape
            };
            extendPrototype([DynamicPropertyContainer], RectShapePropertyFactory);
            return RectShapePropertyFactory;
          }();
          function getShapeProp(elem2, data2, type) {
            var prop;
            if (type === 3 || type === 4) {
              var dataProp = type === 3 ? data2.pt : data2.ks;
              var keys2 = dataProp.k;
              if (keys2.length) {
                prop = new KeyframedShapeProperty(elem2, data2, type);
              } else {
                prop = new ShapeProperty(elem2, data2, type);
              }
            } else if (type === 5) {
              prop = new RectShapeProperty(elem2, data2);
            } else if (type === 6) {
              prop = new EllShapeProperty(elem2, data2);
            } else if (type === 7) {
              prop = new StarShapeProperty(elem2, data2);
            }
            if (prop.k) {
              elem2.addDynamicProperty(prop);
            }
            return prop;
          }
          function getConstructorFunction() {
            return ShapeProperty;
          }
          function getKeyframedConstructorFunction() {
            return KeyframedShapeProperty;
          }
          var ob2 = {};
          ob2.getShapeProp = getShapeProp;
          ob2.getConstructorFunction = getConstructorFunction;
          ob2.getKeyframedConstructorFunction = getKeyframedConstructorFunction;
          return ob2;
        }();
        /*!
         Transformation Matrix v2.0
         (c) Epistemex 2014-2015
         www.epistemex.com
         By Ken Fyrstenberg
         Contributions by leeoniya.
         License: MIT, header required.
         */
        var Matrix = /* @__PURE__ */ function() {
          var _cos = Math.cos;
          var _sin = Math.sin;
          var _tan = Math.tan;
          var _rnd = Math.round;
          function reset() {
            this.props[0] = 1;
            this.props[1] = 0;
            this.props[2] = 0;
            this.props[3] = 0;
            this.props[4] = 0;
            this.props[5] = 1;
            this.props[6] = 0;
            this.props[7] = 0;
            this.props[8] = 0;
            this.props[9] = 0;
            this.props[10] = 1;
            this.props[11] = 0;
            this.props[12] = 0;
            this.props[13] = 0;
            this.props[14] = 0;
            this.props[15] = 1;
            return this;
          }
          function rotate(angle) {
            if (angle === 0) {
              return this;
            }
            var mCos = _cos(angle);
            var mSin = _sin(angle);
            return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
          }
          function rotateX(angle) {
            if (angle === 0) {
              return this;
            }
            var mCos = _cos(angle);
            var mSin = _sin(angle);
            return this._t(1, 0, 0, 0, 0, mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1);
          }
          function rotateY(angle) {
            if (angle === 0) {
              return this;
            }
            var mCos = _cos(angle);
            var mSin = _sin(angle);
            return this._t(mCos, 0, mSin, 0, 0, 1, 0, 0, -mSin, 0, mCos, 0, 0, 0, 0, 1);
          }
          function rotateZ(angle) {
            if (angle === 0) {
              return this;
            }
            var mCos = _cos(angle);
            var mSin = _sin(angle);
            return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
          }
          function shear(sx, sy) {
            return this._t(1, sy, sx, 1, 0, 0);
          }
          function skew(ax, ay) {
            return this.shear(_tan(ax), _tan(ay));
          }
          function skewFromAxis(ax, angle) {
            var mCos = _cos(angle);
            var mSin = _sin(angle);
            return this._t(mCos, mSin, 0, 0, -mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, _tan(ax), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
          }
          function scale2(sx, sy, sz) {
            if (!sz && sz !== 0) {
              sz = 1;
            }
            if (sx === 1 && sy === 1 && sz === 1) {
              return this;
            }
            return this._t(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);
          }
          function setTransform(a2, b, c2, d, e2, f2, g2, h2, i2, j, k2, l2, m2, n2, o, p2) {
            this.props[0] = a2;
            this.props[1] = b;
            this.props[2] = c2;
            this.props[3] = d;
            this.props[4] = e2;
            this.props[5] = f2;
            this.props[6] = g2;
            this.props[7] = h2;
            this.props[8] = i2;
            this.props[9] = j;
            this.props[10] = k2;
            this.props[11] = l2;
            this.props[12] = m2;
            this.props[13] = n2;
            this.props[14] = o;
            this.props[15] = p2;
            return this;
          }
          function translate(tx, ty, tz) {
            tz = tz || 0;
            if (tx !== 0 || ty !== 0 || tz !== 0) {
              return this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1);
            }
            return this;
          }
          function transform2(a2, b2, c2, d2, e2, f2, g2, h2, i2, j2, k2, l2, m2, n2, o2, p2) {
            var _p = this.props;
            if (a2 === 1 && b2 === 0 && c2 === 0 && d2 === 0 && e2 === 0 && f2 === 1 && g2 === 0 && h2 === 0 && i2 === 0 && j2 === 0 && k2 === 1 && l2 === 0) {
              _p[12] = _p[12] * a2 + _p[15] * m2;
              _p[13] = _p[13] * f2 + _p[15] * n2;
              _p[14] = _p[14] * k2 + _p[15] * o2;
              _p[15] *= p2;
              this._identityCalculated = false;
              return this;
            }
            var a1 = _p[0];
            var b1 = _p[1];
            var c1 = _p[2];
            var d1 = _p[3];
            var e1 = _p[4];
            var f1 = _p[5];
            var g1 = _p[6];
            var h1 = _p[7];
            var i1 = _p[8];
            var j1 = _p[9];
            var k1 = _p[10];
            var l1 = _p[11];
            var m1 = _p[12];
            var n1 = _p[13];
            var o1 = _p[14];
            var p1 = _p[15];
            _p[0] = a1 * a2 + b1 * e2 + c1 * i2 + d1 * m2;
            _p[1] = a1 * b2 + b1 * f2 + c1 * j2 + d1 * n2;
            _p[2] = a1 * c2 + b1 * g2 + c1 * k2 + d1 * o2;
            _p[3] = a1 * d2 + b1 * h2 + c1 * l2 + d1 * p2;
            _p[4] = e1 * a2 + f1 * e2 + g1 * i2 + h1 * m2;
            _p[5] = e1 * b2 + f1 * f2 + g1 * j2 + h1 * n2;
            _p[6] = e1 * c2 + f1 * g2 + g1 * k2 + h1 * o2;
            _p[7] = e1 * d2 + f1 * h2 + g1 * l2 + h1 * p2;
            _p[8] = i1 * a2 + j1 * e2 + k1 * i2 + l1 * m2;
            _p[9] = i1 * b2 + j1 * f2 + k1 * j2 + l1 * n2;
            _p[10] = i1 * c2 + j1 * g2 + k1 * k2 + l1 * o2;
            _p[11] = i1 * d2 + j1 * h2 + k1 * l2 + l1 * p2;
            _p[12] = m1 * a2 + n1 * e2 + o1 * i2 + p1 * m2;
            _p[13] = m1 * b2 + n1 * f2 + o1 * j2 + p1 * n2;
            _p[14] = m1 * c2 + n1 * g2 + o1 * k2 + p1 * o2;
            _p[15] = m1 * d2 + n1 * h2 + o1 * l2 + p1 * p2;
            this._identityCalculated = false;
            return this;
          }
          function multiply(matrix) {
            var matrixProps = matrix.props;
            return this.transform(matrixProps[0], matrixProps[1], matrixProps[2], matrixProps[3], matrixProps[4], matrixProps[5], matrixProps[6], matrixProps[7], matrixProps[8], matrixProps[9], matrixProps[10], matrixProps[11], matrixProps[12], matrixProps[13], matrixProps[14], matrixProps[15]);
          }
          function isIdentity() {
            if (!this._identityCalculated) {
              this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1);
              this._identityCalculated = true;
            }
            return this._identity;
          }
          function equals(matr) {
            var i2 = 0;
            while (i2 < 16) {
              if (matr.props[i2] !== this.props[i2]) {
                return false;
              }
              i2 += 1;
            }
            return true;
          }
          function clone(matr) {
            var i2;
            for (i2 = 0; i2 < 16; i2 += 1) {
              matr.props[i2] = this.props[i2];
            }
            return matr;
          }
          function cloneFromProps(props) {
            var i2;
            for (i2 = 0; i2 < 16; i2 += 1) {
              this.props[i2] = props[i2];
            }
          }
          function applyToPoint(x2, y2, z2) {
            return {
              x: x2 * this.props[0] + y2 * this.props[4] + z2 * this.props[8] + this.props[12],
              y: x2 * this.props[1] + y2 * this.props[5] + z2 * this.props[9] + this.props[13],
              z: x2 * this.props[2] + y2 * this.props[6] + z2 * this.props[10] + this.props[14]
            };
          }
          function applyToX(x2, y2, z2) {
            return x2 * this.props[0] + y2 * this.props[4] + z2 * this.props[8] + this.props[12];
          }
          function applyToY(x2, y2, z2) {
            return x2 * this.props[1] + y2 * this.props[5] + z2 * this.props[9] + this.props[13];
          }
          function applyToZ(x2, y2, z2) {
            return x2 * this.props[2] + y2 * this.props[6] + z2 * this.props[10] + this.props[14];
          }
          function getInverseMatrix() {
            var determinant = this.props[0] * this.props[5] - this.props[1] * this.props[4];
            var a2 = this.props[5] / determinant;
            var b = -this.props[1] / determinant;
            var c2 = -this.props[4] / determinant;
            var d = this.props[0] / determinant;
            var e2 = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / determinant;
            var f2 = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / determinant;
            var inverseMatrix = new Matrix();
            inverseMatrix.props[0] = a2;
            inverseMatrix.props[1] = b;
            inverseMatrix.props[4] = c2;
            inverseMatrix.props[5] = d;
            inverseMatrix.props[12] = e2;
            inverseMatrix.props[13] = f2;
            return inverseMatrix;
          }
          function inversePoint(pt) {
            var inverseMatrix = this.getInverseMatrix();
            return inverseMatrix.applyToPointArray(pt[0], pt[1], pt[2] || 0);
          }
          function inversePoints(pts) {
            var i2;
            var len = pts.length;
            var retPts = [];
            for (i2 = 0; i2 < len; i2 += 1) {
              retPts[i2] = inversePoint(pts[i2]);
            }
            return retPts;
          }
          function applyToTriplePoints(pt1, pt2, pt3) {
            var arr2 = createTypedArray("float32", 6);
            if (this.isIdentity()) {
              arr2[0] = pt1[0];
              arr2[1] = pt1[1];
              arr2[2] = pt2[0];
              arr2[3] = pt2[1];
              arr2[4] = pt3[0];
              arr2[5] = pt3[1];
            } else {
              var p0 = this.props[0];
              var p1 = this.props[1];
              var p4 = this.props[4];
              var p5 = this.props[5];
              var p12 = this.props[12];
              var p13 = this.props[13];
              arr2[0] = pt1[0] * p0 + pt1[1] * p4 + p12;
              arr2[1] = pt1[0] * p1 + pt1[1] * p5 + p13;
              arr2[2] = pt2[0] * p0 + pt2[1] * p4 + p12;
              arr2[3] = pt2[0] * p1 + pt2[1] * p5 + p13;
              arr2[4] = pt3[0] * p0 + pt3[1] * p4 + p12;
              arr2[5] = pt3[0] * p1 + pt3[1] * p5 + p13;
            }
            return arr2;
          }
          function applyToPointArray(x2, y2, z2) {
            var arr2;
            if (this.isIdentity()) {
              arr2 = [x2, y2, z2];
            } else {
              arr2 = [x2 * this.props[0] + y2 * this.props[4] + z2 * this.props[8] + this.props[12], x2 * this.props[1] + y2 * this.props[5] + z2 * this.props[9] + this.props[13], x2 * this.props[2] + y2 * this.props[6] + z2 * this.props[10] + this.props[14]];
            }
            return arr2;
          }
          function applyToPointStringified(x2, y2) {
            if (this.isIdentity()) {
              return x2 + "," + y2;
            }
            var _p = this.props;
            return Math.round((x2 * _p[0] + y2 * _p[4] + _p[12]) * 100) / 100 + "," + Math.round((x2 * _p[1] + y2 * _p[5] + _p[13]) * 100) / 100;
          }
          function toCSS() {
            var i2 = 0;
            var props = this.props;
            var cssValue = "matrix3d(";
            var v2 = 1e4;
            while (i2 < 16) {
              cssValue += _rnd(props[i2] * v2) / v2;
              cssValue += i2 === 15 ? ")" : ",";
              i2 += 1;
            }
            return cssValue;
          }
          function roundMatrixProperty(val2) {
            var v2 = 1e4;
            if (val2 < 1e-6 && val2 > 0 || val2 > -1e-6 && val2 < 0) {
              return _rnd(val2 * v2) / v2;
            }
            return val2;
          }
          function to2dCSS() {
            var props = this.props;
            var _a = roundMatrixProperty(props[0]);
            var _b = roundMatrixProperty(props[1]);
            var _c = roundMatrixProperty(props[4]);
            var _d = roundMatrixProperty(props[5]);
            var _e = roundMatrixProperty(props[12]);
            var _f = roundMatrixProperty(props[13]);
            return "matrix(" + _a + "," + _b + "," + _c + "," + _d + "," + _e + "," + _f + ")";
          }
          return function() {
            this.reset = reset;
            this.rotate = rotate;
            this.rotateX = rotateX;
            this.rotateY = rotateY;
            this.rotateZ = rotateZ;
            this.skew = skew;
            this.skewFromAxis = skewFromAxis;
            this.shear = shear;
            this.scale = scale2;
            this.setTransform = setTransform;
            this.translate = translate;
            this.transform = transform2;
            this.multiply = multiply;
            this.applyToPoint = applyToPoint;
            this.applyToX = applyToX;
            this.applyToY = applyToY;
            this.applyToZ = applyToZ;
            this.applyToPointArray = applyToPointArray;
            this.applyToTriplePoints = applyToTriplePoints;
            this.applyToPointStringified = applyToPointStringified;
            this.toCSS = toCSS;
            this.to2dCSS = to2dCSS;
            this.clone = clone;
            this.cloneFromProps = cloneFromProps;
            this.equals = equals;
            this.inversePoints = inversePoints;
            this.inversePoint = inversePoint;
            this.getInverseMatrix = getInverseMatrix;
            this._t = this.transform;
            this.isIdentity = isIdentity;
            this._identity = true;
            this._identityCalculated = false;
            this.props = createTypedArray("float32", 16);
            this.reset();
          };
        }();
        function _typeof$3(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof$3 = function _typeof2(obj2) {
              return typeof obj2;
            };
          } else {
            _typeof$3 = function _typeof2(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return _typeof$3(obj);
        }
        var lottie = {};
        function setLocation(href) {
          setLocationHref(href);
        }
        function searchAnimations() {
          {
            animationManager.searchAnimations();
          }
        }
        function setSubframeRendering(flag) {
          setSubframeEnabled(flag);
        }
        function setPrefix(prefix) {
          setIdPrefix(prefix);
        }
        function loadAnimation(params) {
          return animationManager.loadAnimation(params);
        }
        function setQuality(value2) {
          if (typeof value2 === "string") {
            switch (value2) {
              case "high":
                setDefaultCurveSegments(200);
                break;
              default:
              case "medium":
                setDefaultCurveSegments(50);
                break;
              case "low":
                setDefaultCurveSegments(10);
                break;
            }
          } else if (!isNaN(value2) && value2 > 1) {
            setDefaultCurveSegments(value2);
          }
        }
        function inBrowser() {
          return typeof navigator !== "undefined";
        }
        function installPlugin(type, plugin) {
          if (type === "expressions") {
            setExpressionsPlugin(plugin);
          }
        }
        function getFactory(name2) {
          switch (name2) {
            case "propertyFactory":
              return PropertyFactory;
            case "shapePropertyFactory":
              return ShapePropertyFactory;
            case "matrix":
              return Matrix;
            default:
              return null;
          }
        }
        lottie.play = animationManager.play;
        lottie.pause = animationManager.pause;
        lottie.setLocationHref = setLocation;
        lottie.togglePause = animationManager.togglePause;
        lottie.setSpeed = animationManager.setSpeed;
        lottie.setDirection = animationManager.setDirection;
        lottie.stop = animationManager.stop;
        lottie.searchAnimations = searchAnimations;
        lottie.registerAnimation = animationManager.registerAnimation;
        lottie.loadAnimation = loadAnimation;
        lottie.setSubframeRendering = setSubframeRendering;
        lottie.resize = animationManager.resize;
        lottie.goToAndStop = animationManager.goToAndStop;
        lottie.destroy = animationManager.destroy;
        lottie.setQuality = setQuality;
        lottie.inBrowser = inBrowser;
        lottie.installPlugin = installPlugin;
        lottie.freeze = animationManager.freeze;
        lottie.unfreeze = animationManager.unfreeze;
        lottie.setVolume = animationManager.setVolume;
        lottie.mute = animationManager.mute;
        lottie.unmute = animationManager.unmute;
        lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations;
        lottie.useWebWorker = setWebWorker;
        lottie.setIDPrefix = setPrefix;
        lottie.__getFactory = getFactory;
        lottie.version = "5.12.2";
        function checkReady() {
          if (document.readyState === "complete") {
            clearInterval(readyStateCheckInterval);
            searchAnimations();
          }
        }
        function getQueryVariable(variable) {
          var vars2 = queryString.split("&");
          for (var i2 = 0; i2 < vars2.length; i2 += 1) {
            var pair = vars2[i2].split("=");
            if (decodeURIComponent(pair[0]) == variable) {
              return decodeURIComponent(pair[1]);
            }
          }
          return null;
        }
        var queryString = "";
        {
          var scripts = document.getElementsByTagName("script");
          var index = scripts.length - 1;
          var myScript = scripts[index] || {
            src: ""
          };
          queryString = myScript.src ? myScript.src.replace(/^[^\?]+\??/, "") : "";
          getQueryVariable("renderer");
        }
        var readyStateCheckInterval = setInterval(checkReady, 100);
        try {
          if (!((false ? "undefined" : _typeof$3(exports)) === "object" && true) && true) {
            window.bodymovin = lottie;
          }
        } catch (err) {
        }
        var ShapeModifiers = function() {
          var ob2 = {};
          var modifiers = {};
          ob2.registerModifier = registerModifier;
          ob2.getModifier = getModifier;
          function registerModifier(nm2, factory) {
            if (!modifiers[nm2]) {
              modifiers[nm2] = factory;
            }
          }
          function getModifier(nm2, elem2, data2) {
            return new modifiers[nm2](elem2, data2);
          }
          return ob2;
        }();
        function ShapeModifier() {
        }
        ShapeModifier.prototype.initModifierProperties = function() {
        };
        ShapeModifier.prototype.addShapeToModifier = function() {
        };
        ShapeModifier.prototype.addShape = function(data2) {
          if (!this.closed) {
            data2.sh.container.addDynamicProperty(data2.sh);
            var shapeData = {
              shape: data2.sh,
              data: data2,
              localShapeCollection: shapeCollectionPool.newShapeCollection()
            };
            this.shapes.push(shapeData);
            this.addShapeToModifier(shapeData);
            if (this._isAnimated) {
              data2.setAsAnimated();
            }
          }
        };
        ShapeModifier.prototype.init = function(elem2, data2) {
          this.shapes = [];
          this.elem = elem2;
          this.initDynamicPropertyContainer(elem2);
          this.initModifierProperties(elem2, data2);
          this.frameId = initialDefaultFrame;
          this.closed = false;
          this.k = false;
          if (this.dynamicProperties.length) {
            this.k = true;
          } else {
            this.getValue(true);
          }
        };
        ShapeModifier.prototype.processKeys = function() {
          if (this.elem.globalData.frameId === this.frameId) {
            return;
          }
          this.frameId = this.elem.globalData.frameId;
          this.iterateDynamicProperties();
        };
        extendPrototype([DynamicPropertyContainer], ShapeModifier);
        function TrimModifier() {
        }
        extendPrototype([ShapeModifier], TrimModifier);
        TrimModifier.prototype.initModifierProperties = function(elem2, data2) {
          this.s = PropertyFactory.getProp(elem2, data2.s, 0, 0.01, this);
          this.e = PropertyFactory.getProp(elem2, data2.e, 0, 0.01, this);
          this.o = PropertyFactory.getProp(elem2, data2.o, 0, 0, this);
          this.sValue = 0;
          this.eValue = 0;
          this.getValue = this.processKeys;
          this.m = data2.m;
          this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length;
        };
        TrimModifier.prototype.addShapeToModifier = function(shapeData) {
          shapeData.pathsData = [];
        };
        TrimModifier.prototype.calculateShapeEdges = function(s2, e2, shapeLength, addedLength, totalModifierLength) {
          var segments = [];
          if (e2 <= 1) {
            segments.push({
              s: s2,
              e: e2
            });
          } else if (s2 >= 1) {
            segments.push({
              s: s2 - 1,
              e: e2 - 1
            });
          } else {
            segments.push({
              s: s2,
              e: 1
            });
            segments.push({
              s: 0,
              e: e2 - 1
            });
          }
          var shapeSegments = [];
          var i2;
          var len = segments.length;
          var segmentOb;
          for (i2 = 0; i2 < len; i2 += 1) {
            segmentOb = segments[i2];
            if (!(segmentOb.e * totalModifierLength < addedLength || segmentOb.s * totalModifierLength > addedLength + shapeLength)) {
              var shapeS;
              var shapeE;
              if (segmentOb.s * totalModifierLength <= addedLength) {
                shapeS = 0;
              } else {
                shapeS = (segmentOb.s * totalModifierLength - addedLength) / shapeLength;
              }
              if (segmentOb.e * totalModifierLength >= addedLength + shapeLength) {
                shapeE = 1;
              } else {
                shapeE = (segmentOb.e * totalModifierLength - addedLength) / shapeLength;
              }
              shapeSegments.push([shapeS, shapeE]);
            }
          }
          if (!shapeSegments.length) {
            shapeSegments.push([0, 0]);
          }
          return shapeSegments;
        };
        TrimModifier.prototype.releasePathsData = function(pathsData) {
          var i2;
          var len = pathsData.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            segmentsLengthPool.release(pathsData[i2]);
          }
          pathsData.length = 0;
          return pathsData;
        };
        TrimModifier.prototype.processShapes = function(_isFirstFrame) {
          var s2;
          var e2;
          if (this._mdf || _isFirstFrame) {
            var o = this.o.v % 360 / 360;
            if (o < 0) {
              o += 1;
            }
            if (this.s.v > 1) {
              s2 = 1 + o;
            } else if (this.s.v < 0) {
              s2 = 0 + o;
            } else {
              s2 = this.s.v + o;
            }
            if (this.e.v > 1) {
              e2 = 1 + o;
            } else if (this.e.v < 0) {
              e2 = 0 + o;
            } else {
              e2 = this.e.v + o;
            }
            if (s2 > e2) {
              var _s = s2;
              s2 = e2;
              e2 = _s;
            }
            s2 = Math.round(s2 * 1e4) * 1e-4;
            e2 = Math.round(e2 * 1e4) * 1e-4;
            this.sValue = s2;
            this.eValue = e2;
          } else {
            s2 = this.sValue;
            e2 = this.eValue;
          }
          var shapePaths;
          var i2;
          var len = this.shapes.length;
          var j;
          var jLen;
          var pathsData;
          var pathData;
          var totalShapeLength;
          var totalModifierLength = 0;
          if (e2 === s2) {
            for (i2 = 0; i2 < len; i2 += 1) {
              this.shapes[i2].localShapeCollection.releaseShapes();
              this.shapes[i2].shape._mdf = true;
              this.shapes[i2].shape.paths = this.shapes[i2].localShapeCollection;
              if (this._mdf) {
                this.shapes[i2].pathsData.length = 0;
              }
            }
          } else if (!(e2 === 1 && s2 === 0 || e2 === 0 && s2 === 1)) {
            var segments = [];
            var shapeData;
            var localShapeCollection;
            for (i2 = 0; i2 < len; i2 += 1) {
              shapeData = this.shapes[i2];
              if (!shapeData.shape._mdf && !this._mdf && !_isFirstFrame && this.m !== 2) {
                shapeData.shape.paths = shapeData.localShapeCollection;
              } else {
                shapePaths = shapeData.shape.paths;
                jLen = shapePaths._length;
                totalShapeLength = 0;
                if (!shapeData.shape._mdf && shapeData.pathsData.length) {
                  totalShapeLength = shapeData.totalShapeLength;
                } else {
                  pathsData = this.releasePathsData(shapeData.pathsData);
                  for (j = 0; j < jLen; j += 1) {
                    pathData = bez.getSegmentsLength(shapePaths.shapes[j]);
                    pathsData.push(pathData);
                    totalShapeLength += pathData.totalLength;
                  }
                  shapeData.totalShapeLength = totalShapeLength;
                  shapeData.pathsData = pathsData;
                }
                totalModifierLength += totalShapeLength;
                shapeData.shape._mdf = true;
              }
            }
            var shapeS = s2;
            var shapeE = e2;
            var addedLength = 0;
            var edges;
            for (i2 = len - 1; i2 >= 0; i2 -= 1) {
              shapeData = this.shapes[i2];
              if (shapeData.shape._mdf) {
                localShapeCollection = shapeData.localShapeCollection;
                localShapeCollection.releaseShapes();
                if (this.m === 2 && len > 1) {
                  edges = this.calculateShapeEdges(s2, e2, shapeData.totalShapeLength, addedLength, totalModifierLength);
                  addedLength += shapeData.totalShapeLength;
                } else {
                  edges = [[shapeS, shapeE]];
                }
                jLen = edges.length;
                for (j = 0; j < jLen; j += 1) {
                  shapeS = edges[j][0];
                  shapeE = edges[j][1];
                  segments.length = 0;
                  if (shapeE <= 1) {
                    segments.push({
                      s: shapeData.totalShapeLength * shapeS,
                      e: shapeData.totalShapeLength * shapeE
                    });
                  } else if (shapeS >= 1) {
                    segments.push({
                      s: shapeData.totalShapeLength * (shapeS - 1),
                      e: shapeData.totalShapeLength * (shapeE - 1)
                    });
                  } else {
                    segments.push({
                      s: shapeData.totalShapeLength * shapeS,
                      e: shapeData.totalShapeLength
                    });
                    segments.push({
                      s: 0,
                      e: shapeData.totalShapeLength * (shapeE - 1)
                    });
                  }
                  var newShapesData = this.addShapes(shapeData, segments[0]);
                  if (segments[0].s !== segments[0].e) {
                    if (segments.length > 1) {
                      var lastShapeInCollection = shapeData.shape.paths.shapes[shapeData.shape.paths._length - 1];
                      if (lastShapeInCollection.c) {
                        var lastShape = newShapesData.pop();
                        this.addPaths(newShapesData, localShapeCollection);
                        newShapesData = this.addShapes(shapeData, segments[1], lastShape);
                      } else {
                        this.addPaths(newShapesData, localShapeCollection);
                        newShapesData = this.addShapes(shapeData, segments[1]);
                      }
                    }
                    this.addPaths(newShapesData, localShapeCollection);
                  }
                }
                shapeData.shape.paths = localShapeCollection;
              }
            }
          } else if (this._mdf) {
            for (i2 = 0; i2 < len; i2 += 1) {
              this.shapes[i2].pathsData.length = 0;
              this.shapes[i2].shape._mdf = true;
            }
          }
        };
        TrimModifier.prototype.addPaths = function(newPaths, localShapeCollection) {
          var i2;
          var len = newPaths.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            localShapeCollection.addShape(newPaths[i2]);
          }
        };
        TrimModifier.prototype.addSegment = function(pt1, pt2, pt3, pt4, shapePath, pos, newShape) {
          shapePath.setXYAt(pt2[0], pt2[1], "o", pos);
          shapePath.setXYAt(pt3[0], pt3[1], "i", pos + 1);
          if (newShape) {
            shapePath.setXYAt(pt1[0], pt1[1], "v", pos);
          }
          shapePath.setXYAt(pt4[0], pt4[1], "v", pos + 1);
        };
        TrimModifier.prototype.addSegmentFromArray = function(points, shapePath, pos, newShape) {
          shapePath.setXYAt(points[1], points[5], "o", pos);
          shapePath.setXYAt(points[2], points[6], "i", pos + 1);
          if (newShape) {
            shapePath.setXYAt(points[0], points[4], "v", pos);
          }
          shapePath.setXYAt(points[3], points[7], "v", pos + 1);
        };
        TrimModifier.prototype.addShapes = function(shapeData, shapeSegment, shapePath) {
          var pathsData = shapeData.pathsData;
          var shapePaths = shapeData.shape.paths.shapes;
          var i2;
          var len = shapeData.shape.paths._length;
          var j;
          var jLen;
          var addedLength = 0;
          var currentLengthData;
          var segmentCount;
          var lengths;
          var segment;
          var shapes = [];
          var initPos;
          var newShape = true;
          if (!shapePath) {
            shapePath = shapePool.newElement();
            segmentCount = 0;
            initPos = 0;
          } else {
            segmentCount = shapePath._length;
            initPos = shapePath._length;
          }
          shapes.push(shapePath);
          for (i2 = 0; i2 < len; i2 += 1) {
            lengths = pathsData[i2].lengths;
            shapePath.c = shapePaths[i2].c;
            jLen = shapePaths[i2].c ? lengths.length : lengths.length + 1;
            for (j = 1; j < jLen; j += 1) {
              currentLengthData = lengths[j - 1];
              if (addedLength + currentLengthData.addedLength < shapeSegment.s) {
                addedLength += currentLengthData.addedLength;
                shapePath.c = false;
              } else if (addedLength > shapeSegment.e) {
                shapePath.c = false;
                break;
              } else {
                if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + currentLengthData.addedLength) {
                  this.addSegment(shapePaths[i2].v[j - 1], shapePaths[i2].o[j - 1], shapePaths[i2].i[j], shapePaths[i2].v[j], shapePath, segmentCount, newShape);
                  newShape = false;
                } else {
                  segment = bez.getNewSegment(shapePaths[i2].v[j - 1], shapePaths[i2].v[j], shapePaths[i2].o[j - 1], shapePaths[i2].i[j], (shapeSegment.s - addedLength) / currentLengthData.addedLength, (shapeSegment.e - addedLength) / currentLengthData.addedLength, lengths[j - 1]);
                  this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);
                  newShape = false;
                  shapePath.c = false;
                }
                addedLength += currentLengthData.addedLength;
                segmentCount += 1;
              }
            }
            if (shapePaths[i2].c && lengths.length) {
              currentLengthData = lengths[j - 1];
              if (addedLength <= shapeSegment.e) {
                var segmentLength = lengths[j - 1].addedLength;
                if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + segmentLength) {
                  this.addSegment(shapePaths[i2].v[j - 1], shapePaths[i2].o[j - 1], shapePaths[i2].i[0], shapePaths[i2].v[0], shapePath, segmentCount, newShape);
                  newShape = false;
                } else {
                  segment = bez.getNewSegment(shapePaths[i2].v[j - 1], shapePaths[i2].v[0], shapePaths[i2].o[j - 1], shapePaths[i2].i[0], (shapeSegment.s - addedLength) / segmentLength, (shapeSegment.e - addedLength) / segmentLength, lengths[j - 1]);
                  this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);
                  newShape = false;
                  shapePath.c = false;
                }
              } else {
                shapePath.c = false;
              }
              addedLength += currentLengthData.addedLength;
              segmentCount += 1;
            }
            if (shapePath._length) {
              shapePath.setXYAt(shapePath.v[initPos][0], shapePath.v[initPos][1], "i", initPos);
              shapePath.setXYAt(shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1], "o", shapePath._length - 1);
            }
            if (addedLength > shapeSegment.e) {
              break;
            }
            if (i2 < len - 1) {
              shapePath = shapePool.newElement();
              newShape = true;
              shapes.push(shapePath);
              segmentCount = 0;
            }
          }
          return shapes;
        };
        function PuckerAndBloatModifier() {
        }
        extendPrototype([ShapeModifier], PuckerAndBloatModifier);
        PuckerAndBloatModifier.prototype.initModifierProperties = function(elem2, data2) {
          this.getValue = this.processKeys;
          this.amount = PropertyFactory.getProp(elem2, data2.a, 0, null, this);
          this._isAnimated = !!this.amount.effectsSequence.length;
        };
        PuckerAndBloatModifier.prototype.processPath = function(path2, amount) {
          var percent = amount / 100;
          var centerPoint = [0, 0];
          var pathLength = path2._length;
          var i2 = 0;
          for (i2 = 0; i2 < pathLength; i2 += 1) {
            centerPoint[0] += path2.v[i2][0];
            centerPoint[1] += path2.v[i2][1];
          }
          centerPoint[0] /= pathLength;
          centerPoint[1] /= pathLength;
          var clonedPath = shapePool.newElement();
          clonedPath.c = path2.c;
          var vX;
          var vY;
          var oX;
          var oY;
          var iX;
          var iY;
          for (i2 = 0; i2 < pathLength; i2 += 1) {
            vX = path2.v[i2][0] + (centerPoint[0] - path2.v[i2][0]) * percent;
            vY = path2.v[i2][1] + (centerPoint[1] - path2.v[i2][1]) * percent;
            oX = path2.o[i2][0] + (centerPoint[0] - path2.o[i2][0]) * -percent;
            oY = path2.o[i2][1] + (centerPoint[1] - path2.o[i2][1]) * -percent;
            iX = path2.i[i2][0] + (centerPoint[0] - path2.i[i2][0]) * -percent;
            iY = path2.i[i2][1] + (centerPoint[1] - path2.i[i2][1]) * -percent;
            clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, i2);
          }
          return clonedPath;
        };
        PuckerAndBloatModifier.prototype.processShapes = function(_isFirstFrame) {
          var shapePaths;
          var i2;
          var len = this.shapes.length;
          var j;
          var jLen;
          var amount = this.amount.v;
          if (amount !== 0) {
            var shapeData;
            var localShapeCollection;
            for (i2 = 0; i2 < len; i2 += 1) {
              shapeData = this.shapes[i2];
              localShapeCollection = shapeData.localShapeCollection;
              if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
                localShapeCollection.releaseShapes();
                shapeData.shape._mdf = true;
                shapePaths = shapeData.shape.paths.shapes;
                jLen = shapeData.shape.paths._length;
                for (j = 0; j < jLen; j += 1) {
                  localShapeCollection.addShape(this.processPath(shapePaths[j], amount));
                }
              }
              shapeData.shape.paths = shapeData.localShapeCollection;
            }
          }
          if (!this.dynamicProperties.length) {
            this._mdf = false;
          }
        };
        var TransformPropertyFactory = function() {
          var defaultVector = [0, 0];
          function applyToMatrix(mat) {
            var _mdf = this._mdf;
            this.iterateDynamicProperties();
            this._mdf = this._mdf || _mdf;
            if (this.a) {
              mat.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
            }
            if (this.s) {
              mat.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
            }
            if (this.sk) {
              mat.skewFromAxis(-this.sk.v, this.sa.v);
            }
            if (this.r) {
              mat.rotate(-this.r.v);
            } else {
              mat.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
            }
            if (this.data.p.s) {
              if (this.data.p.z) {
                mat.translate(this.px.v, this.py.v, -this.pz.v);
              } else {
                mat.translate(this.px.v, this.py.v, 0);
              }
            } else {
              mat.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
            }
          }
          function processKeys(forceRender) {
            if (this.elem.globalData.frameId === this.frameId) {
              return;
            }
            if (this._isDirty) {
              this.precalculateMatrix();
              this._isDirty = false;
            }
            this.iterateDynamicProperties();
            if (this._mdf || forceRender) {
              var frameRate;
              this.v.cloneFromProps(this.pre.props);
              if (this.appliedTransformations < 1) {
                this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
              }
              if (this.appliedTransformations < 2) {
                this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
              }
              if (this.sk && this.appliedTransformations < 3) {
                this.v.skewFromAxis(-this.sk.v, this.sa.v);
              }
              if (this.r && this.appliedTransformations < 4) {
                this.v.rotate(-this.r.v);
              } else if (!this.r && this.appliedTransformations < 4) {
                this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
              }
              if (this.autoOriented) {
                var v1;
                var v2;
                frameRate = this.elem.globalData.frameRate;
                if (this.p && this.p.keyframes && this.p.getValueAtTime) {
                  if (this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t) {
                    v1 = this.p.getValueAtTime((this.p.keyframes[0].t + 0.01) / frameRate, 0);
                    v2 = this.p.getValueAtTime(this.p.keyframes[0].t / frameRate, 0);
                  } else if (this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t) {
                    v1 = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / frameRate, 0);
                    v2 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - 0.05) / frameRate, 0);
                  } else {
                    v1 = this.p.pv;
                    v2 = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - 0.01) / frameRate, this.p.offsetTime);
                  }
                } else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
                  v1 = [];
                  v2 = [];
                  var px = this.px;
                  var py = this.py;
                  if (px._caching.lastFrame + px.offsetTime <= px.keyframes[0].t) {
                    v1[0] = px.getValueAtTime((px.keyframes[0].t + 0.01) / frameRate, 0);
                    v1[1] = py.getValueAtTime((py.keyframes[0].t + 0.01) / frameRate, 0);
                    v2[0] = px.getValueAtTime(px.keyframes[0].t / frameRate, 0);
                    v2[1] = py.getValueAtTime(py.keyframes[0].t / frameRate, 0);
                  } else if (px._caching.lastFrame + px.offsetTime >= px.keyframes[px.keyframes.length - 1].t) {
                    v1[0] = px.getValueAtTime(px.keyframes[px.keyframes.length - 1].t / frameRate, 0);
                    v1[1] = py.getValueAtTime(py.keyframes[py.keyframes.length - 1].t / frameRate, 0);
                    v2[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t - 0.01) / frameRate, 0);
                    v2[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t - 0.01) / frameRate, 0);
                  } else {
                    v1 = [px.pv, py.pv];
                    v2[0] = px.getValueAtTime((px._caching.lastFrame + px.offsetTime - 0.01) / frameRate, px.offsetTime);
                    v2[1] = py.getValueAtTime((py._caching.lastFrame + py.offsetTime - 0.01) / frameRate, py.offsetTime);
                  }
                } else {
                  v2 = defaultVector;
                  v1 = v2;
                }
                this.v.rotate(-Math.atan2(v1[1] - v2[1], v1[0] - v2[0]));
              }
              if (this.data.p && this.data.p.s) {
                if (this.data.p.z) {
                  this.v.translate(this.px.v, this.py.v, -this.pz.v);
                } else {
                  this.v.translate(this.px.v, this.py.v, 0);
                }
              } else {
                this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
              }
            }
            this.frameId = this.elem.globalData.frameId;
          }
          function precalculateMatrix() {
            this.appliedTransformations = 0;
            this.pre.reset();
            if (!this.a.effectsSequence.length) {
              this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
              this.appliedTransformations = 1;
            } else {
              return;
            }
            if (!this.s.effectsSequence.length) {
              this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
              this.appliedTransformations = 2;
            } else {
              return;
            }
            if (this.sk) {
              if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length) {
                this.pre.skewFromAxis(-this.sk.v, this.sa.v);
                this.appliedTransformations = 3;
              } else {
                return;
              }
            }
            if (this.r) {
              if (!this.r.effectsSequence.length) {
                this.pre.rotate(-this.r.v);
                this.appliedTransformations = 4;
              }
            } else if (!this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length) {
              this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
              this.appliedTransformations = 4;
            }
          }
          function autoOrient() {
          }
          function addDynamicProperty(prop) {
            this._addDynamicProperty(prop);
            this.elem.addDynamicProperty(prop);
            this._isDirty = true;
          }
          function TransformProperty(elem2, data2, container2) {
            this.elem = elem2;
            this.frameId = -1;
            this.propType = "transform";
            this.data = data2;
            this.v = new Matrix();
            this.pre = new Matrix();
            this.appliedTransformations = 0;
            this.initDynamicPropertyContainer(container2 || elem2);
            if (data2.p && data2.p.s) {
              this.px = PropertyFactory.getProp(elem2, data2.p.x, 0, 0, this);
              this.py = PropertyFactory.getProp(elem2, data2.p.y, 0, 0, this);
              if (data2.p.z) {
                this.pz = PropertyFactory.getProp(elem2, data2.p.z, 0, 0, this);
              }
            } else {
              this.p = PropertyFactory.getProp(elem2, data2.p || {
                k: [0, 0, 0]
              }, 1, 0, this);
            }
            if (data2.rx) {
              this.rx = PropertyFactory.getProp(elem2, data2.rx, 0, degToRads, this);
              this.ry = PropertyFactory.getProp(elem2, data2.ry, 0, degToRads, this);
              this.rz = PropertyFactory.getProp(elem2, data2.rz, 0, degToRads, this);
              if (data2.or.k[0].ti) {
                var i2;
                var len = data2.or.k.length;
                for (i2 = 0; i2 < len; i2 += 1) {
                  data2.or.k[i2].to = null;
                  data2.or.k[i2].ti = null;
                }
              }
              this.or = PropertyFactory.getProp(elem2, data2.or, 1, degToRads, this);
              this.or.sh = true;
            } else {
              this.r = PropertyFactory.getProp(elem2, data2.r || {
                k: 0
              }, 0, degToRads, this);
            }
            if (data2.sk) {
              this.sk = PropertyFactory.getProp(elem2, data2.sk, 0, degToRads, this);
              this.sa = PropertyFactory.getProp(elem2, data2.sa, 0, degToRads, this);
            }
            this.a = PropertyFactory.getProp(elem2, data2.a || {
              k: [0, 0, 0]
            }, 1, 0, this);
            this.s = PropertyFactory.getProp(elem2, data2.s || {
              k: [100, 100, 100]
            }, 1, 0.01, this);
            if (data2.o) {
              this.o = PropertyFactory.getProp(elem2, data2.o, 0, 0.01, elem2);
            } else {
              this.o = {
                _mdf: false,
                v: 1
              };
            }
            this._isDirty = true;
            if (!this.dynamicProperties.length) {
              this.getValue(true);
            }
          }
          TransformProperty.prototype = {
            applyToMatrix,
            getValue: processKeys,
            precalculateMatrix,
            autoOrient
          };
          extendPrototype([DynamicPropertyContainer], TransformProperty);
          TransformProperty.prototype.addDynamicProperty = addDynamicProperty;
          TransformProperty.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;
          function getTransformProperty(elem2, data2, container2) {
            return new TransformProperty(elem2, data2, container2);
          }
          return {
            getTransformProperty
          };
        }();
        function RepeaterModifier() {
        }
        extendPrototype([ShapeModifier], RepeaterModifier);
        RepeaterModifier.prototype.initModifierProperties = function(elem2, data2) {
          this.getValue = this.processKeys;
          this.c = PropertyFactory.getProp(elem2, data2.c, 0, null, this);
          this.o = PropertyFactory.getProp(elem2, data2.o, 0, null, this);
          this.tr = TransformPropertyFactory.getTransformProperty(elem2, data2.tr, this);
          this.so = PropertyFactory.getProp(elem2, data2.tr.so, 0, 0.01, this);
          this.eo = PropertyFactory.getProp(elem2, data2.tr.eo, 0, 0.01, this);
          this.data = data2;
          if (!this.dynamicProperties.length) {
            this.getValue(true);
          }
          this._isAnimated = !!this.dynamicProperties.length;
          this.pMatrix = new Matrix();
          this.rMatrix = new Matrix();
          this.sMatrix = new Matrix();
          this.tMatrix = new Matrix();
          this.matrix = new Matrix();
        };
        RepeaterModifier.prototype.applyTransforms = function(pMatrix, rMatrix, sMatrix, transform2, perc, inv) {
          var dir = inv ? -1 : 1;
          var scaleX = transform2.s.v[0] + (1 - transform2.s.v[0]) * (1 - perc);
          var scaleY = transform2.s.v[1] + (1 - transform2.s.v[1]) * (1 - perc);
          pMatrix.translate(transform2.p.v[0] * dir * perc, transform2.p.v[1] * dir * perc, transform2.p.v[2]);
          rMatrix.translate(-transform2.a.v[0], -transform2.a.v[1], transform2.a.v[2]);
          rMatrix.rotate(-transform2.r.v * dir * perc);
          rMatrix.translate(transform2.a.v[0], transform2.a.v[1], transform2.a.v[2]);
          sMatrix.translate(-transform2.a.v[0], -transform2.a.v[1], transform2.a.v[2]);
          sMatrix.scale(inv ? 1 / scaleX : scaleX, inv ? 1 / scaleY : scaleY);
          sMatrix.translate(transform2.a.v[0], transform2.a.v[1], transform2.a.v[2]);
        };
        RepeaterModifier.prototype.init = function(elem2, arr2, pos, elemsData) {
          this.elem = elem2;
          this.arr = arr2;
          this.pos = pos;
          this.elemsData = elemsData;
          this._currentCopies = 0;
          this._elements = [];
          this._groups = [];
          this.frameId = -1;
          this.initDynamicPropertyContainer(elem2);
          this.initModifierProperties(elem2, arr2[pos]);
          while (pos > 0) {
            pos -= 1;
            this._elements.unshift(arr2[pos]);
          }
          if (this.dynamicProperties.length) {
            this.k = true;
          } else {
            this.getValue(true);
          }
        };
        RepeaterModifier.prototype.resetElements = function(elements) {
          var i2;
          var len = elements.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            elements[i2]._processed = false;
            if (elements[i2].ty === "gr") {
              this.resetElements(elements[i2].it);
            }
          }
        };
        RepeaterModifier.prototype.cloneElements = function(elements) {
          var newElements = JSON.parse(JSON.stringify(elements));
          this.resetElements(newElements);
          return newElements;
        };
        RepeaterModifier.prototype.changeGroupRender = function(elements, renderFlag) {
          var i2;
          var len = elements.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            elements[i2]._render = renderFlag;
            if (elements[i2].ty === "gr") {
              this.changeGroupRender(elements[i2].it, renderFlag);
            }
          }
        };
        RepeaterModifier.prototype.processShapes = function(_isFirstFrame) {
          var items;
          var itemsTransform;
          var i2;
          var dir;
          var cont;
          var hasReloaded = false;
          if (this._mdf || _isFirstFrame) {
            var copies = Math.ceil(this.c.v);
            if (this._groups.length < copies) {
              while (this._groups.length < copies) {
                var group = {
                  it: this.cloneElements(this._elements),
                  ty: "gr"
                };
                group.it.push({
                  a: {
                    a: 0,
                    ix: 1,
                    k: [0, 0]
                  },
                  nm: "Transform",
                  o: {
                    a: 0,
                    ix: 7,
                    k: 100
                  },
                  p: {
                    a: 0,
                    ix: 2,
                    k: [0, 0]
                  },
                  r: {
                    a: 1,
                    ix: 6,
                    k: [{
                      s: 0,
                      e: 0,
                      t: 0
                    }, {
                      s: 0,
                      e: 0,
                      t: 1
                    }]
                  },
                  s: {
                    a: 0,
                    ix: 3,
                    k: [100, 100]
                  },
                  sa: {
                    a: 0,
                    ix: 5,
                    k: 0
                  },
                  sk: {
                    a: 0,
                    ix: 4,
                    k: 0
                  },
                  ty: "tr"
                });
                this.arr.splice(0, 0, group);
                this._groups.splice(0, 0, group);
                this._currentCopies += 1;
              }
              this.elem.reloadShapes();
              hasReloaded = true;
            }
            cont = 0;
            var renderFlag;
            for (i2 = 0; i2 <= this._groups.length - 1; i2 += 1) {
              renderFlag = cont < copies;
              this._groups[i2]._render = renderFlag;
              this.changeGroupRender(this._groups[i2].it, renderFlag);
              if (!renderFlag) {
                var elems = this.elemsData[i2].it;
                var transformData = elems[elems.length - 1];
                if (transformData.transform.op.v !== 0) {
                  transformData.transform.op._mdf = true;
                  transformData.transform.op.v = 0;
                } else {
                  transformData.transform.op._mdf = false;
                }
              }
              cont += 1;
            }
            this._currentCopies = copies;
            var offset = this.o.v;
            var offsetModulo = offset % 1;
            var roundOffset = offset > 0 ? Math.floor(offset) : Math.ceil(offset);
            var pProps = this.pMatrix.props;
            var rProps = this.rMatrix.props;
            var sProps = this.sMatrix.props;
            this.pMatrix.reset();
            this.rMatrix.reset();
            this.sMatrix.reset();
            this.tMatrix.reset();
            this.matrix.reset();
            var iteration = 0;
            if (offset > 0) {
              while (iteration < roundOffset) {
                this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
                iteration += 1;
              }
              if (offsetModulo) {
                this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, offsetModulo, false);
                iteration += offsetModulo;
              }
            } else if (offset < 0) {
              while (iteration > roundOffset) {
                this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, true);
                iteration -= 1;
              }
              if (offsetModulo) {
                this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -offsetModulo, true);
                iteration -= offsetModulo;
              }
            }
            i2 = this.data.m === 1 ? 0 : this._currentCopies - 1;
            dir = this.data.m === 1 ? 1 : -1;
            cont = this._currentCopies;
            var j;
            var jLen;
            while (cont) {
              items = this.elemsData[i2].it;
              itemsTransform = items[items.length - 1].transform.mProps.v.props;
              jLen = itemsTransform.length;
              items[items.length - 1].transform.mProps._mdf = true;
              items[items.length - 1].transform.op._mdf = true;
              items[items.length - 1].transform.op.v = this._currentCopies === 1 ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (i2 / (this._currentCopies - 1));
              if (iteration !== 0) {
                if (i2 !== 0 && dir === 1 || i2 !== this._currentCopies - 1 && dir === -1) {
                  this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
                }
                this.matrix.transform(rProps[0], rProps[1], rProps[2], rProps[3], rProps[4], rProps[5], rProps[6], rProps[7], rProps[8], rProps[9], rProps[10], rProps[11], rProps[12], rProps[13], rProps[14], rProps[15]);
                this.matrix.transform(sProps[0], sProps[1], sProps[2], sProps[3], sProps[4], sProps[5], sProps[6], sProps[7], sProps[8], sProps[9], sProps[10], sProps[11], sProps[12], sProps[13], sProps[14], sProps[15]);
                this.matrix.transform(pProps[0], pProps[1], pProps[2], pProps[3], pProps[4], pProps[5], pProps[6], pProps[7], pProps[8], pProps[9], pProps[10], pProps[11], pProps[12], pProps[13], pProps[14], pProps[15]);
                for (j = 0; j < jLen; j += 1) {
                  itemsTransform[j] = this.matrix.props[j];
                }
                this.matrix.reset();
              } else {
                this.matrix.reset();
                for (j = 0; j < jLen; j += 1) {
                  itemsTransform[j] = this.matrix.props[j];
                }
              }
              iteration += 1;
              cont -= 1;
              i2 += dir;
            }
          } else {
            cont = this._currentCopies;
            i2 = 0;
            dir = 1;
            while (cont) {
              items = this.elemsData[i2].it;
              itemsTransform = items[items.length - 1].transform.mProps.v.props;
              items[items.length - 1].transform.mProps._mdf = false;
              items[items.length - 1].transform.op._mdf = false;
              cont -= 1;
              i2 += dir;
            }
          }
          return hasReloaded;
        };
        RepeaterModifier.prototype.addShape = function() {
        };
        function RoundCornersModifier() {
        }
        extendPrototype([ShapeModifier], RoundCornersModifier);
        RoundCornersModifier.prototype.initModifierProperties = function(elem2, data2) {
          this.getValue = this.processKeys;
          this.rd = PropertyFactory.getProp(elem2, data2.r, 0, null, this);
          this._isAnimated = !!this.rd.effectsSequence.length;
        };
        RoundCornersModifier.prototype.processPath = function(path2, round) {
          var clonedPath = shapePool.newElement();
          clonedPath.c = path2.c;
          var i2;
          var len = path2._length;
          var currentV;
          var currentI;
          var currentO;
          var closerV;
          var distance;
          var newPosPerc;
          var index2 = 0;
          var vX;
          var vY;
          var oX;
          var oY;
          var iX;
          var iY;
          for (i2 = 0; i2 < len; i2 += 1) {
            currentV = path2.v[i2];
            currentO = path2.o[i2];
            currentI = path2.i[i2];
            if (currentV[0] === currentO[0] && currentV[1] === currentO[1] && currentV[0] === currentI[0] && currentV[1] === currentI[1]) {
              if ((i2 === 0 || i2 === len - 1) && !path2.c) {
                clonedPath.setTripleAt(currentV[0], currentV[1], currentO[0], currentO[1], currentI[0], currentI[1], index2);
                index2 += 1;
              } else {
                if (i2 === 0) {
                  closerV = path2.v[len - 1];
                } else {
                  closerV = path2.v[i2 - 1];
                }
                distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
                newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
                iX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
                vX = iX;
                iY = currentV[1] - (currentV[1] - closerV[1]) * newPosPerc;
                vY = iY;
                oX = vX - (vX - currentV[0]) * roundCorner;
                oY = vY - (vY - currentV[1]) * roundCorner;
                clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index2);
                index2 += 1;
                if (i2 === len - 1) {
                  closerV = path2.v[0];
                } else {
                  closerV = path2.v[i2 + 1];
                }
                distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
                newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
                oX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
                vX = oX;
                oY = currentV[1] + (closerV[1] - currentV[1]) * newPosPerc;
                vY = oY;
                iX = vX - (vX - currentV[0]) * roundCorner;
                iY = vY - (vY - currentV[1]) * roundCorner;
                clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index2);
                index2 += 1;
              }
            } else {
              clonedPath.setTripleAt(path2.v[i2][0], path2.v[i2][1], path2.o[i2][0], path2.o[i2][1], path2.i[i2][0], path2.i[i2][1], index2);
              index2 += 1;
            }
          }
          return clonedPath;
        };
        RoundCornersModifier.prototype.processShapes = function(_isFirstFrame) {
          var shapePaths;
          var i2;
          var len = this.shapes.length;
          var j;
          var jLen;
          var rd2 = this.rd.v;
          if (rd2 !== 0) {
            var shapeData;
            var localShapeCollection;
            for (i2 = 0; i2 < len; i2 += 1) {
              shapeData = this.shapes[i2];
              localShapeCollection = shapeData.localShapeCollection;
              if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
                localShapeCollection.releaseShapes();
                shapeData.shape._mdf = true;
                shapePaths = shapeData.shape.paths.shapes;
                jLen = shapeData.shape.paths._length;
                for (j = 0; j < jLen; j += 1) {
                  localShapeCollection.addShape(this.processPath(shapePaths[j], rd2));
                }
              }
              shapeData.shape.paths = shapeData.localShapeCollection;
            }
          }
          if (!this.dynamicProperties.length) {
            this._mdf = false;
          }
        };
        function floatEqual(a2, b) {
          return Math.abs(a2 - b) * 1e5 <= Math.min(Math.abs(a2), Math.abs(b));
        }
        function floatZero(f2) {
          return Math.abs(f2) <= 1e-5;
        }
        function lerp(p0, p1, amount) {
          return p0 * (1 - amount) + p1 * amount;
        }
        function lerpPoint(p0, p1, amount) {
          return [lerp(p0[0], p1[0], amount), lerp(p0[1], p1[1], amount)];
        }
        function quadRoots(a2, b, c2) {
          if (a2 === 0)
            return [];
          var s2 = b * b - 4 * a2 * c2;
          if (s2 < 0)
            return [];
          var singleRoot = -b / (2 * a2);
          if (s2 === 0)
            return [singleRoot];
          var delta = Math.sqrt(s2) / (2 * a2);
          return [singleRoot - delta, singleRoot + delta];
        }
        function polynomialCoefficients(p0, p1, p2, p3) {
          return [-p0 + 3 * p1 - 3 * p2 + p3, 3 * p0 - 6 * p1 + 3 * p2, -3 * p0 + 3 * p1, p0];
        }
        function singlePoint(p2) {
          return new PolynomialBezier(p2, p2, p2, p2, false);
        }
        function PolynomialBezier(p0, p1, p2, p3, linearize) {
          if (linearize && pointEqual(p0, p1)) {
            p1 = lerpPoint(p0, p3, 1 / 3);
          }
          if (linearize && pointEqual(p2, p3)) {
            p2 = lerpPoint(p0, p3, 2 / 3);
          }
          var coeffx = polynomialCoefficients(p0[0], p1[0], p2[0], p3[0]);
          var coeffy = polynomialCoefficients(p0[1], p1[1], p2[1], p3[1]);
          this.a = [coeffx[0], coeffy[0]];
          this.b = [coeffx[1], coeffy[1]];
          this.c = [coeffx[2], coeffy[2]];
          this.d = [coeffx[3], coeffy[3]];
          this.points = [p0, p1, p2, p3];
        }
        PolynomialBezier.prototype.point = function(t2) {
          return [((this.a[0] * t2 + this.b[0]) * t2 + this.c[0]) * t2 + this.d[0], ((this.a[1] * t2 + this.b[1]) * t2 + this.c[1]) * t2 + this.d[1]];
        };
        PolynomialBezier.prototype.derivative = function(t2) {
          return [(3 * t2 * this.a[0] + 2 * this.b[0]) * t2 + this.c[0], (3 * t2 * this.a[1] + 2 * this.b[1]) * t2 + this.c[1]];
        };
        PolynomialBezier.prototype.tangentAngle = function(t2) {
          var p2 = this.derivative(t2);
          return Math.atan2(p2[1], p2[0]);
        };
        PolynomialBezier.prototype.normalAngle = function(t2) {
          var p2 = this.derivative(t2);
          return Math.atan2(p2[0], p2[1]);
        };
        PolynomialBezier.prototype.inflectionPoints = function() {
          var denom = this.a[1] * this.b[0] - this.a[0] * this.b[1];
          if (floatZero(denom))
            return [];
          var tcusp = -0.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1]) / denom;
          var square = tcusp * tcusp - 1 / 3 * (this.b[1] * this.c[0] - this.b[0] * this.c[1]) / denom;
          if (square < 0)
            return [];
          var root2 = Math.sqrt(square);
          if (floatZero(root2)) {
            if (root2 > 0 && root2 < 1)
              return [tcusp];
            return [];
          }
          return [tcusp - root2, tcusp + root2].filter(function(r2) {
            return r2 > 0 && r2 < 1;
          });
        };
        PolynomialBezier.prototype.split = function(t2) {
          if (t2 <= 0)
            return [singlePoint(this.points[0]), this];
          if (t2 >= 1)
            return [this, singlePoint(this.points[this.points.length - 1])];
          var p10 = lerpPoint(this.points[0], this.points[1], t2);
          var p11 = lerpPoint(this.points[1], this.points[2], t2);
          var p12 = lerpPoint(this.points[2], this.points[3], t2);
          var p20 = lerpPoint(p10, p11, t2);
          var p21 = lerpPoint(p11, p12, t2);
          var p3 = lerpPoint(p20, p21, t2);
          return [new PolynomialBezier(this.points[0], p10, p20, p3, true), new PolynomialBezier(p3, p21, p12, this.points[3], true)];
        };
        function extrema(bez2, comp2) {
          var min = bez2.points[0][comp2];
          var max = bez2.points[bez2.points.length - 1][comp2];
          if (min > max) {
            var e2 = max;
            max = min;
            min = e2;
          }
          var f2 = quadRoots(3 * bez2.a[comp2], 2 * bez2.b[comp2], bez2.c[comp2]);
          for (var i2 = 0; i2 < f2.length; i2 += 1) {
            if (f2[i2] > 0 && f2[i2] < 1) {
              var val2 = bez2.point(f2[i2])[comp2];
              if (val2 < min)
                min = val2;
              else if (val2 > max)
                max = val2;
            }
          }
          return {
            min,
            max
          };
        }
        PolynomialBezier.prototype.bounds = function() {
          return {
            x: extrema(this, 0),
            y: extrema(this, 1)
          };
        };
        PolynomialBezier.prototype.boundingBox = function() {
          var bounds = this.bounds();
          return {
            left: bounds.x.min,
            right: bounds.x.max,
            top: bounds.y.min,
            bottom: bounds.y.max,
            width: bounds.x.max - bounds.x.min,
            height: bounds.y.max - bounds.y.min,
            cx: (bounds.x.max + bounds.x.min) / 2,
            cy: (bounds.y.max + bounds.y.min) / 2
          };
        };
        function intersectData(bez2, t1, t2) {
          var box = bez2.boundingBox();
          return {
            cx: box.cx,
            cy: box.cy,
            width: box.width,
            height: box.height,
            bez: bez2,
            t: (t1 + t2) / 2,
            t1,
            t2
          };
        }
        function splitData(data2) {
          var split = data2.bez.split(0.5);
          return [intersectData(split[0], data2.t1, data2.t), intersectData(split[1], data2.t, data2.t2)];
        }
        function boxIntersect(b1, b2) {
          return Math.abs(b1.cx - b2.cx) * 2 < b1.width + b2.width && Math.abs(b1.cy - b2.cy) * 2 < b1.height + b2.height;
        }
        function intersectsImpl(d1, d2, depth, tolerance, intersections, maxRecursion) {
          if (!boxIntersect(d1, d2))
            return;
          if (depth >= maxRecursion || d1.width <= tolerance && d1.height <= tolerance && d2.width <= tolerance && d2.height <= tolerance) {
            intersections.push([d1.t, d2.t]);
            return;
          }
          var d1s = splitData(d1);
          var d2s = splitData(d2);
          intersectsImpl(d1s[0], d2s[0], depth + 1, tolerance, intersections, maxRecursion);
          intersectsImpl(d1s[0], d2s[1], depth + 1, tolerance, intersections, maxRecursion);
          intersectsImpl(d1s[1], d2s[0], depth + 1, tolerance, intersections, maxRecursion);
          intersectsImpl(d1s[1], d2s[1], depth + 1, tolerance, intersections, maxRecursion);
        }
        PolynomialBezier.prototype.intersections = function(other, tolerance, maxRecursion) {
          if (tolerance === void 0)
            tolerance = 2;
          if (maxRecursion === void 0)
            maxRecursion = 7;
          var intersections = [];
          intersectsImpl(intersectData(this, 0, 1), intersectData(other, 0, 1), 0, tolerance, intersections, maxRecursion);
          return intersections;
        };
        PolynomialBezier.shapeSegment = function(shapePath, index2) {
          var nextIndex = (index2 + 1) % shapePath.length();
          return new PolynomialBezier(shapePath.v[index2], shapePath.o[index2], shapePath.i[nextIndex], shapePath.v[nextIndex], true);
        };
        PolynomialBezier.shapeSegmentInverted = function(shapePath, index2) {
          var nextIndex = (index2 + 1) % shapePath.length();
          return new PolynomialBezier(shapePath.v[nextIndex], shapePath.i[nextIndex], shapePath.o[index2], shapePath.v[index2], true);
        };
        function crossProduct(a2, b) {
          return [a2[1] * b[2] - a2[2] * b[1], a2[2] * b[0] - a2[0] * b[2], a2[0] * b[1] - a2[1] * b[0]];
        }
        function lineIntersection(start1, end1, start2, end2) {
          var v1 = [start1[0], start1[1], 1];
          var v2 = [end1[0], end1[1], 1];
          var v3 = [start2[0], start2[1], 1];
          var v4 = [end2[0], end2[1], 1];
          var r2 = crossProduct(crossProduct(v1, v2), crossProduct(v3, v4));
          if (floatZero(r2[2]))
            return null;
          return [r2[0] / r2[2], r2[1] / r2[2]];
        }
        function polarOffset(p2, angle, length2) {
          return [p2[0] + Math.cos(angle) * length2, p2[1] - Math.sin(angle) * length2];
        }
        function pointDistance(p1, p2) {
          return Math.hypot(p1[0] - p2[0], p1[1] - p2[1]);
        }
        function pointEqual(p1, p2) {
          return floatEqual(p1[0], p2[0]) && floatEqual(p1[1], p2[1]);
        }
        function ZigZagModifier() {
        }
        extendPrototype([ShapeModifier], ZigZagModifier);
        ZigZagModifier.prototype.initModifierProperties = function(elem2, data2) {
          this.getValue = this.processKeys;
          this.amplitude = PropertyFactory.getProp(elem2, data2.s, 0, null, this);
          this.frequency = PropertyFactory.getProp(elem2, data2.r, 0, null, this);
          this.pointsType = PropertyFactory.getProp(elem2, data2.pt, 0, null, this);
          this._isAnimated = this.amplitude.effectsSequence.length !== 0 || this.frequency.effectsSequence.length !== 0 || this.pointsType.effectsSequence.length !== 0;
        };
        function setPoint(outputBezier, point, angle, direction, amplitude, outAmplitude, inAmplitude) {
          var angO = angle - Math.PI / 2;
          var angI = angle + Math.PI / 2;
          var px = point[0] + Math.cos(angle) * direction * amplitude;
          var py = point[1] - Math.sin(angle) * direction * amplitude;
          outputBezier.setTripleAt(px, py, px + Math.cos(angO) * outAmplitude, py - Math.sin(angO) * outAmplitude, px + Math.cos(angI) * inAmplitude, py - Math.sin(angI) * inAmplitude, outputBezier.length());
        }
        function getPerpendicularVector(pt1, pt2) {
          var vector = [pt2[0] - pt1[0], pt2[1] - pt1[1]];
          var rot = -Math.PI * 0.5;
          var rotatedVector = [Math.cos(rot) * vector[0] - Math.sin(rot) * vector[1], Math.sin(rot) * vector[0] + Math.cos(rot) * vector[1]];
          return rotatedVector;
        }
        function getProjectingAngle(path2, cur) {
          var prevIndex = cur === 0 ? path2.length() - 1 : cur - 1;
          var nextIndex = (cur + 1) % path2.length();
          var prevPoint = path2.v[prevIndex];
          var nextPoint = path2.v[nextIndex];
          var pVector = getPerpendicularVector(prevPoint, nextPoint);
          return Math.atan2(0, 1) - Math.atan2(pVector[1], pVector[0]);
        }
        function zigZagCorner(outputBezier, path2, cur, amplitude, frequency, pointType, direction) {
          var angle = getProjectingAngle(path2, cur);
          var point = path2.v[cur % path2._length];
          var prevPoint = path2.v[cur === 0 ? path2._length - 1 : cur - 1];
          var nextPoint = path2.v[(cur + 1) % path2._length];
          var prevDist = pointType === 2 ? Math.sqrt(Math.pow(point[0] - prevPoint[0], 2) + Math.pow(point[1] - prevPoint[1], 2)) : 0;
          var nextDist = pointType === 2 ? Math.sqrt(Math.pow(point[0] - nextPoint[0], 2) + Math.pow(point[1] - nextPoint[1], 2)) : 0;
          setPoint(outputBezier, path2.v[cur % path2._length], angle, direction, amplitude, nextDist / ((frequency + 1) * 2), prevDist / ((frequency + 1) * 2));
        }
        function zigZagSegment(outputBezier, segment, amplitude, frequency, pointType, direction) {
          for (var i2 = 0; i2 < frequency; i2 += 1) {
            var t2 = (i2 + 1) / (frequency + 1);
            var dist = pointType === 2 ? Math.sqrt(Math.pow(segment.points[3][0] - segment.points[0][0], 2) + Math.pow(segment.points[3][1] - segment.points[0][1], 2)) : 0;
            var angle = segment.normalAngle(t2);
            var point = segment.point(t2);
            setPoint(outputBezier, point, angle, direction, amplitude, dist / ((frequency + 1) * 2), dist / ((frequency + 1) * 2));
            direction = -direction;
          }
          return direction;
        }
        ZigZagModifier.prototype.processPath = function(path2, amplitude, frequency, pointType) {
          var count = path2._length;
          var clonedPath = shapePool.newElement();
          clonedPath.c = path2.c;
          if (!path2.c) {
            count -= 1;
          }
          if (count === 0)
            return clonedPath;
          var direction = -1;
          var segment = PolynomialBezier.shapeSegment(path2, 0);
          zigZagCorner(clonedPath, path2, 0, amplitude, frequency, pointType, direction);
          for (var i2 = 0; i2 < count; i2 += 1) {
            direction = zigZagSegment(clonedPath, segment, amplitude, frequency, pointType, -direction);
            if (i2 === count - 1 && !path2.c) {
              segment = null;
            } else {
              segment = PolynomialBezier.shapeSegment(path2, (i2 + 1) % count);
            }
            zigZagCorner(clonedPath, path2, i2 + 1, amplitude, frequency, pointType, direction);
          }
          return clonedPath;
        };
        ZigZagModifier.prototype.processShapes = function(_isFirstFrame) {
          var shapePaths;
          var i2;
          var len = this.shapes.length;
          var j;
          var jLen;
          var amplitude = this.amplitude.v;
          var frequency = Math.max(0, Math.round(this.frequency.v));
          var pointType = this.pointsType.v;
          if (amplitude !== 0) {
            var shapeData;
            var localShapeCollection;
            for (i2 = 0; i2 < len; i2 += 1) {
              shapeData = this.shapes[i2];
              localShapeCollection = shapeData.localShapeCollection;
              if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
                localShapeCollection.releaseShapes();
                shapeData.shape._mdf = true;
                shapePaths = shapeData.shape.paths.shapes;
                jLen = shapeData.shape.paths._length;
                for (j = 0; j < jLen; j += 1) {
                  localShapeCollection.addShape(this.processPath(shapePaths[j], amplitude, frequency, pointType));
                }
              }
              shapeData.shape.paths = shapeData.localShapeCollection;
            }
          }
          if (!this.dynamicProperties.length) {
            this._mdf = false;
          }
        };
        function linearOffset(p1, p2, amount) {
          var angle = Math.atan2(p2[0] - p1[0], p2[1] - p1[1]);
          return [polarOffset(p1, angle, amount), polarOffset(p2, angle, amount)];
        }
        function offsetSegment(segment, amount) {
          var p0;
          var p1a;
          var p1b;
          var p2b;
          var p2a;
          var p3;
          var e2;
          e2 = linearOffset(segment.points[0], segment.points[1], amount);
          p0 = e2[0];
          p1a = e2[1];
          e2 = linearOffset(segment.points[1], segment.points[2], amount);
          p1b = e2[0];
          p2b = e2[1];
          e2 = linearOffset(segment.points[2], segment.points[3], amount);
          p2a = e2[0];
          p3 = e2[1];
          var p1 = lineIntersection(p0, p1a, p1b, p2b);
          if (p1 === null)
            p1 = p1a;
          var p2 = lineIntersection(p2a, p3, p1b, p2b);
          if (p2 === null)
            p2 = p2a;
          return new PolynomialBezier(p0, p1, p2, p3);
        }
        function joinLines(outputBezier, seg1, seg2, lineJoin, miterLimit) {
          var p0 = seg1.points[3];
          var p1 = seg2.points[0];
          if (lineJoin === 3)
            return p0;
          if (pointEqual(p0, p1))
            return p0;
          if (lineJoin === 2) {
            var angleOut = -seg1.tangentAngle(1);
            var angleIn = -seg2.tangentAngle(0) + Math.PI;
            var center = lineIntersection(p0, polarOffset(p0, angleOut + Math.PI / 2, 100), p1, polarOffset(p1, angleOut + Math.PI / 2, 100));
            var radius = center ? pointDistance(center, p0) : pointDistance(p0, p1) / 2;
            var tan = polarOffset(p0, angleOut, 2 * radius * roundCorner);
            outputBezier.setXYAt(tan[0], tan[1], "o", outputBezier.length() - 1);
            tan = polarOffset(p1, angleIn, 2 * radius * roundCorner);
            outputBezier.setTripleAt(p1[0], p1[1], p1[0], p1[1], tan[0], tan[1], outputBezier.length());
            return p1;
          }
          var t0 = pointEqual(p0, seg1.points[2]) ? seg1.points[0] : seg1.points[2];
          var t1 = pointEqual(p1, seg2.points[1]) ? seg2.points[3] : seg2.points[1];
          var intersection = lineIntersection(t0, p0, p1, t1);
          if (intersection && pointDistance(intersection, p0) < miterLimit) {
            outputBezier.setTripleAt(intersection[0], intersection[1], intersection[0], intersection[1], intersection[0], intersection[1], outputBezier.length());
            return intersection;
          }
          return p0;
        }
        function getIntersection(a2, b) {
          var intersect = a2.intersections(b);
          if (intersect.length && floatEqual(intersect[0][0], 1))
            intersect.shift();
          if (intersect.length)
            return intersect[0];
          return null;
        }
        function pruneSegmentIntersection(a2, b) {
          var outa = a2.slice();
          var outb = b.slice();
          var intersect = getIntersection(a2[a2.length - 1], b[0]);
          if (intersect) {
            outa[a2.length - 1] = a2[a2.length - 1].split(intersect[0])[0];
            outb[0] = b[0].split(intersect[1])[1];
          }
          if (a2.length > 1 && b.length > 1) {
            intersect = getIntersection(a2[0], b[b.length - 1]);
            if (intersect) {
              return [[a2[0].split(intersect[0])[0]], [b[b.length - 1].split(intersect[1])[1]]];
            }
          }
          return [outa, outb];
        }
        function pruneIntersections(segments) {
          var e2;
          for (var i2 = 1; i2 < segments.length; i2 += 1) {
            e2 = pruneSegmentIntersection(segments[i2 - 1], segments[i2]);
            segments[i2 - 1] = e2[0];
            segments[i2] = e2[1];
          }
          if (segments.length > 1) {
            e2 = pruneSegmentIntersection(segments[segments.length - 1], segments[0]);
            segments[segments.length - 1] = e2[0];
            segments[0] = e2[1];
          }
          return segments;
        }
        function offsetSegmentSplit(segment, amount) {
          var flex = segment.inflectionPoints();
          var left;
          var right;
          var split;
          var mid;
          if (flex.length === 0) {
            return [offsetSegment(segment, amount)];
          }
          if (flex.length === 1 || floatEqual(flex[1], 1)) {
            split = segment.split(flex[0]);
            left = split[0];
            right = split[1];
            return [offsetSegment(left, amount), offsetSegment(right, amount)];
          }
          split = segment.split(flex[0]);
          left = split[0];
          var t2 = (flex[1] - flex[0]) / (1 - flex[0]);
          split = split[1].split(t2);
          mid = split[0];
          right = split[1];
          return [offsetSegment(left, amount), offsetSegment(mid, amount), offsetSegment(right, amount)];
        }
        function OffsetPathModifier() {
        }
        extendPrototype([ShapeModifier], OffsetPathModifier);
        OffsetPathModifier.prototype.initModifierProperties = function(elem2, data2) {
          this.getValue = this.processKeys;
          this.amount = PropertyFactory.getProp(elem2, data2.a, 0, null, this);
          this.miterLimit = PropertyFactory.getProp(elem2, data2.ml, 0, null, this);
          this.lineJoin = data2.lj;
          this._isAnimated = this.amount.effectsSequence.length !== 0;
        };
        OffsetPathModifier.prototype.processPath = function(inputBezier, amount, lineJoin, miterLimit) {
          var outputBezier = shapePool.newElement();
          outputBezier.c = inputBezier.c;
          var count = inputBezier.length();
          if (!inputBezier.c) {
            count -= 1;
          }
          var i2;
          var j;
          var segment;
          var multiSegments = [];
          for (i2 = 0; i2 < count; i2 += 1) {
            segment = PolynomialBezier.shapeSegment(inputBezier, i2);
            multiSegments.push(offsetSegmentSplit(segment, amount));
          }
          if (!inputBezier.c) {
            for (i2 = count - 1; i2 >= 0; i2 -= 1) {
              segment = PolynomialBezier.shapeSegmentInverted(inputBezier, i2);
              multiSegments.push(offsetSegmentSplit(segment, amount));
            }
          }
          multiSegments = pruneIntersections(multiSegments);
          var lastPoint = null;
          var lastSeg = null;
          for (i2 = 0; i2 < multiSegments.length; i2 += 1) {
            var multiSegment = multiSegments[i2];
            if (lastSeg)
              lastPoint = joinLines(outputBezier, lastSeg, multiSegment[0], lineJoin, miterLimit);
            lastSeg = multiSegment[multiSegment.length - 1];
            for (j = 0; j < multiSegment.length; j += 1) {
              segment = multiSegment[j];
              if (lastPoint && pointEqual(segment.points[0], lastPoint)) {
                outputBezier.setXYAt(segment.points[1][0], segment.points[1][1], "o", outputBezier.length() - 1);
              } else {
                outputBezier.setTripleAt(segment.points[0][0], segment.points[0][1], segment.points[1][0], segment.points[1][1], segment.points[0][0], segment.points[0][1], outputBezier.length());
              }
              outputBezier.setTripleAt(segment.points[3][0], segment.points[3][1], segment.points[3][0], segment.points[3][1], segment.points[2][0], segment.points[2][1], outputBezier.length());
              lastPoint = segment.points[3];
            }
          }
          if (multiSegments.length)
            joinLines(outputBezier, lastSeg, multiSegments[0][0], lineJoin, miterLimit);
          return outputBezier;
        };
        OffsetPathModifier.prototype.processShapes = function(_isFirstFrame) {
          var shapePaths;
          var i2;
          var len = this.shapes.length;
          var j;
          var jLen;
          var amount = this.amount.v;
          var miterLimit = this.miterLimit.v;
          var lineJoin = this.lineJoin;
          if (amount !== 0) {
            var shapeData;
            var localShapeCollection;
            for (i2 = 0; i2 < len; i2 += 1) {
              shapeData = this.shapes[i2];
              localShapeCollection = shapeData.localShapeCollection;
              if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
                localShapeCollection.releaseShapes();
                shapeData.shape._mdf = true;
                shapePaths = shapeData.shape.paths.shapes;
                jLen = shapeData.shape.paths._length;
                for (j = 0; j < jLen; j += 1) {
                  localShapeCollection.addShape(this.processPath(shapePaths[j], amount, lineJoin, miterLimit));
                }
              }
              shapeData.shape.paths = shapeData.localShapeCollection;
            }
          }
          if (!this.dynamicProperties.length) {
            this._mdf = false;
          }
        };
        function getFontProperties(fontData) {
          var styles = fontData.fStyle ? fontData.fStyle.split(" ") : [];
          var fWeight = "normal";
          var fStyle = "normal";
          var len = styles.length;
          var styleName;
          for (var i2 = 0; i2 < len; i2 += 1) {
            styleName = styles[i2].toLowerCase();
            switch (styleName) {
              case "italic":
                fStyle = "italic";
                break;
              case "bold":
                fWeight = "700";
                break;
              case "black":
                fWeight = "900";
                break;
              case "medium":
                fWeight = "500";
                break;
              case "regular":
              case "normal":
                fWeight = "400";
                break;
              case "light":
              case "thin":
                fWeight = "200";
                break;
            }
          }
          return {
            style: fStyle,
            weight: fontData.fWeight || fWeight
          };
        }
        var FontManager = function() {
          var maxWaitingTime = 5e3;
          var emptyChar = {
            w: 0,
            size: 0,
            shapes: [],
            data: {
              shapes: []
            }
          };
          var combinedCharacters = [];
          combinedCharacters = combinedCharacters.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);
          var BLACK_FLAG_CODE_POINT = 127988;
          var CANCEL_TAG_CODE_POINT = 917631;
          var A_TAG_CODE_POINT = 917601;
          var Z_TAG_CODE_POINT = 917626;
          var VARIATION_SELECTOR_16_CODE_POINT = 65039;
          var ZERO_WIDTH_JOINER_CODE_POINT = 8205;
          var REGIONAL_CHARACTER_A_CODE_POINT = 127462;
          var REGIONAL_CHARACTER_Z_CODE_POINT = 127487;
          var surrogateModifiers = ["d83cdffb", "d83cdffc", "d83cdffd", "d83cdffe", "d83cdfff"];
          function trimFontOptions(font) {
            var familyArray = font.split(",");
            var i2;
            var len = familyArray.length;
            var enabledFamilies = [];
            for (i2 = 0; i2 < len; i2 += 1) {
              if (familyArray[i2] !== "sans-serif" && familyArray[i2] !== "monospace") {
                enabledFamilies.push(familyArray[i2]);
              }
            }
            return enabledFamilies.join(",");
          }
          function setUpNode(font, family) {
            var parentNode = createTag("span");
            parentNode.setAttribute("aria-hidden", true);
            parentNode.style.fontFamily = family;
            var node2 = createTag("span");
            node2.innerText = "giItT1WQy@!-/#";
            parentNode.style.position = "absolute";
            parentNode.style.left = "-10000px";
            parentNode.style.top = "-10000px";
            parentNode.style.fontSize = "300px";
            parentNode.style.fontVariant = "normal";
            parentNode.style.fontStyle = "normal";
            parentNode.style.fontWeight = "normal";
            parentNode.style.letterSpacing = "0";
            parentNode.appendChild(node2);
            document.body.appendChild(parentNode);
            var width2 = node2.offsetWidth;
            node2.style.fontFamily = trimFontOptions(font) + ", " + family;
            return {
              node: node2,
              w: width2,
              parent: parentNode
            };
          }
          function checkLoadedFonts() {
            var i2;
            var len = this.fonts.length;
            var node2;
            var w2;
            var loadedCount = len;
            for (i2 = 0; i2 < len; i2 += 1) {
              if (this.fonts[i2].loaded) {
                loadedCount -= 1;
              } else if (this.fonts[i2].fOrigin === "n" || this.fonts[i2].origin === 0) {
                this.fonts[i2].loaded = true;
              } else {
                node2 = this.fonts[i2].monoCase.node;
                w2 = this.fonts[i2].monoCase.w;
                if (node2.offsetWidth !== w2) {
                  loadedCount -= 1;
                  this.fonts[i2].loaded = true;
                } else {
                  node2 = this.fonts[i2].sansCase.node;
                  w2 = this.fonts[i2].sansCase.w;
                  if (node2.offsetWidth !== w2) {
                    loadedCount -= 1;
                    this.fonts[i2].loaded = true;
                  }
                }
                if (this.fonts[i2].loaded) {
                  this.fonts[i2].sansCase.parent.parentNode.removeChild(this.fonts[i2].sansCase.parent);
                  this.fonts[i2].monoCase.parent.parentNode.removeChild(this.fonts[i2].monoCase.parent);
                }
              }
            }
            if (loadedCount !== 0 && Date.now() - this.initTime < maxWaitingTime) {
              setTimeout(this.checkLoadedFontsBinded, 20);
            } else {
              setTimeout(this.setIsLoadedBinded, 10);
            }
          }
          function createHelper(fontData, def) {
            var engine = document.body && def ? "svg" : "canvas";
            var helper;
            var fontProps = getFontProperties(fontData);
            if (engine === "svg") {
              var tHelper = createNS("text");
              tHelper.style.fontSize = "100px";
              tHelper.setAttribute("font-family", fontData.fFamily);
              tHelper.setAttribute("font-style", fontProps.style);
              tHelper.setAttribute("font-weight", fontProps.weight);
              tHelper.textContent = "1";
              if (fontData.fClass) {
                tHelper.style.fontFamily = "inherit";
                tHelper.setAttribute("class", fontData.fClass);
              } else {
                tHelper.style.fontFamily = fontData.fFamily;
              }
              def.appendChild(tHelper);
              helper = tHelper;
            } else {
              var tCanvasHelper = new OffscreenCanvas(500, 500).getContext("2d");
              tCanvasHelper.font = fontProps.style + " " + fontProps.weight + " 100px " + fontData.fFamily;
              helper = tCanvasHelper;
            }
            function measure(text2) {
              if (engine === "svg") {
                helper.textContent = text2;
                return helper.getComputedTextLength();
              }
              return helper.measureText(text2).width;
            }
            return {
              measureText: measure
            };
          }
          function addFonts(fontData, defs) {
            if (!fontData) {
              this.isLoaded = true;
              return;
            }
            if (this.chars) {
              this.isLoaded = true;
              this.fonts = fontData.list;
              return;
            }
            if (!document.body) {
              this.isLoaded = true;
              fontData.list.forEach(function(data2) {
                data2.helper = createHelper(data2);
                data2.cache = {};
              });
              this.fonts = fontData.list;
              return;
            }
            var fontArr = fontData.list;
            var i2;
            var len = fontArr.length;
            var _pendingFonts = len;
            for (i2 = 0; i2 < len; i2 += 1) {
              var shouldLoadFont = true;
              var loadedSelector;
              var j;
              fontArr[i2].loaded = false;
              fontArr[i2].monoCase = setUpNode(fontArr[i2].fFamily, "monospace");
              fontArr[i2].sansCase = setUpNode(fontArr[i2].fFamily, "sans-serif");
              if (!fontArr[i2].fPath) {
                fontArr[i2].loaded = true;
                _pendingFonts -= 1;
              } else if (fontArr[i2].fOrigin === "p" || fontArr[i2].origin === 3) {
                loadedSelector = document.querySelectorAll('style[f-forigin="p"][f-family="' + fontArr[i2].fFamily + '"], style[f-origin="3"][f-family="' + fontArr[i2].fFamily + '"]');
                if (loadedSelector.length > 0) {
                  shouldLoadFont = false;
                }
                if (shouldLoadFont) {
                  var s2 = createTag("style");
                  s2.setAttribute("f-forigin", fontArr[i2].fOrigin);
                  s2.setAttribute("f-origin", fontArr[i2].origin);
                  s2.setAttribute("f-family", fontArr[i2].fFamily);
                  s2.type = "text/css";
                  s2.innerText = "@font-face {font-family: " + fontArr[i2].fFamily + "; font-style: normal; src: url('" + fontArr[i2].fPath + "');}";
                  defs.appendChild(s2);
                }
              } else if (fontArr[i2].fOrigin === "g" || fontArr[i2].origin === 1) {
                loadedSelector = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]');
                for (j = 0; j < loadedSelector.length; j += 1) {
                  if (loadedSelector[j].href.indexOf(fontArr[i2].fPath) !== -1) {
                    shouldLoadFont = false;
                  }
                }
                if (shouldLoadFont) {
                  var l2 = createTag("link");
                  l2.setAttribute("f-forigin", fontArr[i2].fOrigin);
                  l2.setAttribute("f-origin", fontArr[i2].origin);
                  l2.type = "text/css";
                  l2.rel = "stylesheet";
                  l2.href = fontArr[i2].fPath;
                  document.body.appendChild(l2);
                }
              } else if (fontArr[i2].fOrigin === "t" || fontArr[i2].origin === 2) {
                loadedSelector = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]');
                for (j = 0; j < loadedSelector.length; j += 1) {
                  if (fontArr[i2].fPath === loadedSelector[j].src) {
                    shouldLoadFont = false;
                  }
                }
                if (shouldLoadFont) {
                  var sc2 = createTag("link");
                  sc2.setAttribute("f-forigin", fontArr[i2].fOrigin);
                  sc2.setAttribute("f-origin", fontArr[i2].origin);
                  sc2.setAttribute("rel", "stylesheet");
                  sc2.setAttribute("href", fontArr[i2].fPath);
                  defs.appendChild(sc2);
                }
              }
              fontArr[i2].helper = createHelper(fontArr[i2], defs);
              fontArr[i2].cache = {};
              this.fonts.push(fontArr[i2]);
            }
            if (_pendingFonts === 0) {
              this.isLoaded = true;
            } else {
              setTimeout(this.checkLoadedFonts.bind(this), 100);
            }
          }
          function addChars(chars2) {
            if (!chars2) {
              return;
            }
            if (!this.chars) {
              this.chars = [];
            }
            var i2;
            var len = chars2.length;
            var j;
            var jLen = this.chars.length;
            var found;
            for (i2 = 0; i2 < len; i2 += 1) {
              j = 0;
              found = false;
              while (j < jLen) {
                if (this.chars[j].style === chars2[i2].style && this.chars[j].fFamily === chars2[i2].fFamily && this.chars[j].ch === chars2[i2].ch) {
                  found = true;
                }
                j += 1;
              }
              if (!found) {
                this.chars.push(chars2[i2]);
                jLen += 1;
              }
            }
          }
          function getCharData(_char, style, font) {
            var i2 = 0;
            var len = this.chars.length;
            while (i2 < len) {
              if (this.chars[i2].ch === _char && this.chars[i2].style === style && this.chars[i2].fFamily === font) {
                return this.chars[i2];
              }
              i2 += 1;
            }
            if ((typeof _char === "string" && _char.charCodeAt(0) !== 13 || !_char) && console && console.warn && !this._warned) {
              this._warned = true;
              console.warn("Missing character from exported characters list: ", _char, style, font);
            }
            return emptyChar;
          }
          function measureText(_char2, fontName, size) {
            var fontData = this.getFontByName(fontName);
            var index2 = _char2;
            if (!fontData.cache[index2]) {
              var tHelper = fontData.helper;
              if (_char2 === " ") {
                var doubleSize = tHelper.measureText("|" + _char2 + "|");
                var singleSize = tHelper.measureText("||");
                fontData.cache[index2] = (doubleSize - singleSize) / 100;
              } else {
                fontData.cache[index2] = tHelper.measureText(_char2) / 100;
              }
            }
            return fontData.cache[index2] * size;
          }
          function getFontByName(name2) {
            var i2 = 0;
            var len = this.fonts.length;
            while (i2 < len) {
              if (this.fonts[i2].fName === name2) {
                return this.fonts[i2];
              }
              i2 += 1;
            }
            return this.fonts[0];
          }
          function getCodePoint(string) {
            var codePoint = 0;
            var first = string.charCodeAt(0);
            if (first >= 55296 && first <= 56319) {
              var second = string.charCodeAt(1);
              if (second >= 56320 && second <= 57343) {
                codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
              }
            }
            return codePoint;
          }
          function isModifier(firstCharCode, secondCharCode) {
            var sum2 = firstCharCode.toString(16) + secondCharCode.toString(16);
            return surrogateModifiers.indexOf(sum2) !== -1;
          }
          function isZeroWidthJoiner(charCode) {
            return charCode === ZERO_WIDTH_JOINER_CODE_POINT;
          }
          function isVariationSelector(charCode) {
            return charCode === VARIATION_SELECTOR_16_CODE_POINT;
          }
          function isRegionalCode(string) {
            var codePoint = getCodePoint(string);
            if (codePoint >= REGIONAL_CHARACTER_A_CODE_POINT && codePoint <= REGIONAL_CHARACTER_Z_CODE_POINT) {
              return true;
            }
            return false;
          }
          function isFlagEmoji(string) {
            return isRegionalCode(string.substr(0, 2)) && isRegionalCode(string.substr(2, 2));
          }
          function isCombinedCharacter(_char3) {
            return combinedCharacters.indexOf(_char3) !== -1;
          }
          function isRegionalFlag(text2, index2) {
            var codePoint = getCodePoint(text2.substr(index2, 2));
            if (codePoint !== BLACK_FLAG_CODE_POINT) {
              return false;
            }
            var count = 0;
            index2 += 2;
            while (count < 5) {
              codePoint = getCodePoint(text2.substr(index2, 2));
              if (codePoint < A_TAG_CODE_POINT || codePoint > Z_TAG_CODE_POINT) {
                return false;
              }
              count += 1;
              index2 += 2;
            }
            return getCodePoint(text2.substr(index2, 2)) === CANCEL_TAG_CODE_POINT;
          }
          function setIsLoaded() {
            this.isLoaded = true;
          }
          var Font = function Font2() {
            this.fonts = [];
            this.chars = null;
            this.typekitLoaded = 0;
            this.isLoaded = false;
            this._warned = false;
            this.initTime = Date.now();
            this.setIsLoadedBinded = this.setIsLoaded.bind(this);
            this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this);
          };
          Font.isModifier = isModifier;
          Font.isZeroWidthJoiner = isZeroWidthJoiner;
          Font.isFlagEmoji = isFlagEmoji;
          Font.isRegionalCode = isRegionalCode;
          Font.isCombinedCharacter = isCombinedCharacter;
          Font.isRegionalFlag = isRegionalFlag;
          Font.isVariationSelector = isVariationSelector;
          Font.BLACK_FLAG_CODE_POINT = BLACK_FLAG_CODE_POINT;
          var fontPrototype = {
            addChars,
            addFonts,
            getCharData,
            getFontByName,
            measureText,
            checkLoadedFonts,
            setIsLoaded
          };
          Font.prototype = fontPrototype;
          return Font;
        }();
        function SlotManager(animationData) {
          this.animationData = animationData;
        }
        SlotManager.prototype.getProp = function(data2) {
          if (this.animationData.slots && this.animationData.slots[data2.sid]) {
            return Object.assign(data2, this.animationData.slots[data2.sid].p);
          }
          return data2;
        };
        function slotFactory(animationData) {
          return new SlotManager(animationData);
        }
        function RenderableElement() {
        }
        RenderableElement.prototype = {
          initRenderable: function initRenderable() {
            this.isInRange = false;
            this.hidden = false;
            this.isTransparent = false;
            this.renderableComponents = [];
          },
          addRenderableComponent: function addRenderableComponent(component) {
            if (this.renderableComponents.indexOf(component) === -1) {
              this.renderableComponents.push(component);
            }
          },
          removeRenderableComponent: function removeRenderableComponent(component) {
            if (this.renderableComponents.indexOf(component) !== -1) {
              this.renderableComponents.splice(this.renderableComponents.indexOf(component), 1);
            }
          },
          prepareRenderableFrame: function prepareRenderableFrame(num) {
            this.checkLayerLimits(num);
          },
          checkTransparency: function checkTransparency() {
            if (this.finalTransform.mProp.o.v <= 0) {
              if (!this.isTransparent && this.globalData.renderConfig.hideOnTransparent) {
                this.isTransparent = true;
                this.hide();
              }
            } else if (this.isTransparent) {
              this.isTransparent = false;
              this.show();
            }
          },
          /**
             * @function
             * Initializes frame related properties.
             *
             * @param {number} num
             * current frame number in Layer's time
             *
             */
          checkLayerLimits: function checkLayerLimits(num) {
            if (this.data.ip - this.data.st <= num && this.data.op - this.data.st > num) {
              if (this.isInRange !== true) {
                this.globalData._mdf = true;
                this._mdf = true;
                this.isInRange = true;
                this.show();
              }
            } else if (this.isInRange !== false) {
              this.globalData._mdf = true;
              this.isInRange = false;
              this.hide();
            }
          },
          renderRenderable: function renderRenderable() {
            var i2;
            var len = this.renderableComponents.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              this.renderableComponents[i2].renderFrame(this._isFirstFrame);
            }
          },
          sourceRectAtTime: function sourceRectAtTime2() {
            return {
              top: 0,
              left: 0,
              width: 100,
              height: 100
            };
          },
          getLayerSize: function getLayerSize() {
            if (this.data.ty === 5) {
              return {
                w: this.data.textData.width,
                h: this.data.textData.height
              };
            }
            return {
              w: this.data.width,
              h: this.data.height
            };
          }
        };
        var getBlendMode = /* @__PURE__ */ function() {
          var blendModeEnums = {
            0: "source-over",
            1: "multiply",
            2: "screen",
            3: "overlay",
            4: "darken",
            5: "lighten",
            6: "color-dodge",
            7: "color-burn",
            8: "hard-light",
            9: "soft-light",
            10: "difference",
            11: "exclusion",
            12: "hue",
            13: "saturation",
            14: "color",
            15: "luminosity"
          };
          return function(mode) {
            return blendModeEnums[mode] || "";
          };
        }();
        function SliderEffect(data2, elem2, container2) {
          this.p = PropertyFactory.getProp(elem2, data2.v, 0, 0, container2);
        }
        function AngleEffect(data2, elem2, container2) {
          this.p = PropertyFactory.getProp(elem2, data2.v, 0, 0, container2);
        }
        function ColorEffect(data2, elem2, container2) {
          this.p = PropertyFactory.getProp(elem2, data2.v, 1, 0, container2);
        }
        function PointEffect(data2, elem2, container2) {
          this.p = PropertyFactory.getProp(elem2, data2.v, 1, 0, container2);
        }
        function LayerIndexEffect(data2, elem2, container2) {
          this.p = PropertyFactory.getProp(elem2, data2.v, 0, 0, container2);
        }
        function MaskIndexEffect(data2, elem2, container2) {
          this.p = PropertyFactory.getProp(elem2, data2.v, 0, 0, container2);
        }
        function CheckboxEffect(data2, elem2, container2) {
          this.p = PropertyFactory.getProp(elem2, data2.v, 0, 0, container2);
        }
        function NoValueEffect() {
          this.p = {};
        }
        function EffectsManager(data2, element) {
          var effects = data2.ef || [];
          this.effectElements = [];
          var i2;
          var len = effects.length;
          var effectItem;
          for (i2 = 0; i2 < len; i2 += 1) {
            effectItem = new GroupEffect(effects[i2], element);
            this.effectElements.push(effectItem);
          }
        }
        function GroupEffect(data2, element) {
          this.init(data2, element);
        }
        extendPrototype([DynamicPropertyContainer], GroupEffect);
        GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties;
        GroupEffect.prototype.init = function(data2, element) {
          this.data = data2;
          this.effectElements = [];
          this.initDynamicPropertyContainer(element);
          var i2;
          var len = this.data.ef.length;
          var eff;
          var effects = this.data.ef;
          for (i2 = 0; i2 < len; i2 += 1) {
            eff = null;
            switch (effects[i2].ty) {
              case 0:
                eff = new SliderEffect(effects[i2], element, this);
                break;
              case 1:
                eff = new AngleEffect(effects[i2], element, this);
                break;
              case 2:
                eff = new ColorEffect(effects[i2], element, this);
                break;
              case 3:
                eff = new PointEffect(effects[i2], element, this);
                break;
              case 4:
              case 7:
                eff = new CheckboxEffect(effects[i2], element, this);
                break;
              case 10:
                eff = new LayerIndexEffect(effects[i2], element, this);
                break;
              case 11:
                eff = new MaskIndexEffect(effects[i2], element, this);
                break;
              case 5:
                eff = new EffectsManager(effects[i2], element);
                break;
              default:
                eff = new NoValueEffect(effects[i2]);
                break;
            }
            if (eff) {
              this.effectElements.push(eff);
            }
          }
        };
        function BaseElement() {
        }
        BaseElement.prototype = {
          checkMasks: function checkMasks() {
            if (!this.data.hasMask) {
              return false;
            }
            var i2 = 0;
            var len = this.data.masksProperties.length;
            while (i2 < len) {
              if (this.data.masksProperties[i2].mode !== "n" && this.data.masksProperties[i2].cl !== false) {
                return true;
              }
              i2 += 1;
            }
            return false;
          },
          initExpressions: function initExpressions() {
            var expressionsInterfaces2 = getExpressionInterfaces();
            if (!expressionsInterfaces2) {
              return;
            }
            var LayerExpressionInterface2 = expressionsInterfaces2("layer");
            var EffectsExpressionInterface2 = expressionsInterfaces2("effects");
            var ShapeExpressionInterface2 = expressionsInterfaces2("shape");
            var TextExpressionInterface2 = expressionsInterfaces2("text");
            var CompExpressionInterface2 = expressionsInterfaces2("comp");
            this.layerInterface = LayerExpressionInterface2(this);
            if (this.data.hasMask && this.maskManager) {
              this.layerInterface.registerMaskInterface(this.maskManager);
            }
            var effectsInterface = EffectsExpressionInterface2.createEffectsInterface(this, this.layerInterface);
            this.layerInterface.registerEffectsInterface(effectsInterface);
            if (this.data.ty === 0 || this.data.xt) {
              this.compInterface = CompExpressionInterface2(this);
            } else if (this.data.ty === 4) {
              this.layerInterface.shapeInterface = ShapeExpressionInterface2(this.shapesData, this.itemsData, this.layerInterface);
              this.layerInterface.content = this.layerInterface.shapeInterface;
            } else if (this.data.ty === 5) {
              this.layerInterface.textInterface = TextExpressionInterface2(this);
              this.layerInterface.text = this.layerInterface.textInterface;
            }
          },
          setBlendMode: function setBlendMode() {
            var blendModeValue = getBlendMode(this.data.bm);
            var elem2 = this.baseElement || this.layerElement;
            elem2.style["mix-blend-mode"] = blendModeValue;
          },
          initBaseData: function initBaseData(data2, globalData2, comp2) {
            this.globalData = globalData2;
            this.comp = comp2;
            this.data = data2;
            this.layerId = createElementID();
            if (!this.data.sr) {
              this.data.sr = 1;
            }
            this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties);
          },
          getType: function getType2() {
            return this.type;
          },
          sourceRectAtTime: function sourceRectAtTime2() {
          }
        };
        function FrameElement() {
        }
        FrameElement.prototype = {
          /**
             * @function
             * Initializes frame related properties.
             *
             */
          initFrame: function initFrame2() {
            this._isFirstFrame = false;
            this.dynamicProperties = [];
            this._mdf = false;
          },
          /**
             * @function
             * Calculates all dynamic values
             *
             * @param {number} num
             * current frame number in Layer's time
             * @param {boolean} isVisible
             * if layers is currently in range
             *
             */
          prepareProperties: function prepareProperties(num, isVisible) {
            var i2;
            var len = this.dynamicProperties.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              if (isVisible || this._isParent && this.dynamicProperties[i2].propType === "transform") {
                this.dynamicProperties[i2].getValue();
                if (this.dynamicProperties[i2]._mdf) {
                  this.globalData._mdf = true;
                  this._mdf = true;
                }
              }
            }
          },
          addDynamicProperty: function addDynamicProperty(prop) {
            if (this.dynamicProperties.indexOf(prop) === -1) {
              this.dynamicProperties.push(prop);
            }
          }
        };
        function FootageElement(data2, globalData2, comp2) {
          this.initFrame();
          this.initRenderable();
          this.assetData = globalData2.getAssetData(data2.refId);
          this.footageData = globalData2.imageLoader.getAsset(this.assetData);
          this.initBaseData(data2, globalData2, comp2);
        }
        FootageElement.prototype.prepareFrame = function() {
        };
        extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement);
        FootageElement.prototype.getBaseElement = function() {
          return null;
        };
        FootageElement.prototype.renderFrame = function() {
        };
        FootageElement.prototype.destroy = function() {
        };
        FootageElement.prototype.initExpressions = function() {
          var expressionsInterfaces2 = getExpressionInterfaces();
          if (!expressionsInterfaces2) {
            return;
          }
          var FootageInterface2 = expressionsInterfaces2("footage");
          this.layerInterface = FootageInterface2(this);
        };
        FootageElement.prototype.getFootageData = function() {
          return this.footageData;
        };
        function AudioElement(data2, globalData2, comp2) {
          this.initFrame();
          this.initRenderable();
          this.assetData = globalData2.getAssetData(data2.refId);
          this.initBaseData(data2, globalData2, comp2);
          this._isPlaying = false;
          this._canPlay = false;
          var assetPath = this.globalData.getAssetsPath(this.assetData);
          this.audio = this.globalData.audioController.createAudio(assetPath);
          this._currentTime = 0;
          this.globalData.audioController.addAudio(this);
          this._volumeMultiplier = 1;
          this._volume = 1;
          this._previousVolume = null;
          this.tm = data2.tm ? PropertyFactory.getProp(this, data2.tm, 0, globalData2.frameRate, this) : {
            _placeholder: true
          };
          this.lv = PropertyFactory.getProp(this, data2.au && data2.au.lv ? data2.au.lv : {
            k: [100]
          }, 1, 0.01, this);
        }
        AudioElement.prototype.prepareFrame = function(num) {
          this.prepareRenderableFrame(num, true);
          this.prepareProperties(num, true);
          if (!this.tm._placeholder) {
            var timeRemapped = this.tm.v;
            this._currentTime = timeRemapped;
          } else {
            this._currentTime = num / this.data.sr;
          }
          this._volume = this.lv.v[0];
          var totalVolume = this._volume * this._volumeMultiplier;
          if (this._previousVolume !== totalVolume) {
            this._previousVolume = totalVolume;
            this.audio.volume(totalVolume);
          }
        };
        extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement);
        AudioElement.prototype.renderFrame = function() {
          if (this.isInRange && this._canPlay) {
            if (!this._isPlaying) {
              this.audio.play();
              this.audio.seek(this._currentTime / this.globalData.frameRate);
              this._isPlaying = true;
            } else if (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > 0.1) {
              this.audio.seek(this._currentTime / this.globalData.frameRate);
            }
          }
        };
        AudioElement.prototype.show = function() {
        };
        AudioElement.prototype.hide = function() {
          this.audio.pause();
          this._isPlaying = false;
        };
        AudioElement.prototype.pause = function() {
          this.audio.pause();
          this._isPlaying = false;
          this._canPlay = false;
        };
        AudioElement.prototype.resume = function() {
          this._canPlay = true;
        };
        AudioElement.prototype.setRate = function(rateValue) {
          this.audio.rate(rateValue);
        };
        AudioElement.prototype.volume = function(volumeValue) {
          this._volumeMultiplier = volumeValue;
          this._previousVolume = volumeValue * this._volume;
          this.audio.volume(this._previousVolume);
        };
        AudioElement.prototype.getBaseElement = function() {
          return null;
        };
        AudioElement.prototype.destroy = function() {
        };
        AudioElement.prototype.sourceRectAtTime = function() {
        };
        AudioElement.prototype.initExpressions = function() {
        };
        function BaseRenderer() {
        }
        BaseRenderer.prototype.checkLayers = function(num) {
          var i2;
          var len = this.layers.length;
          var data2;
          this.completeLayers = true;
          for (i2 = len - 1; i2 >= 0; i2 -= 1) {
            if (!this.elements[i2]) {
              data2 = this.layers[i2];
              if (data2.ip - data2.st <= num - this.layers[i2].st && data2.op - data2.st > num - this.layers[i2].st) {
                this.buildItem(i2);
              }
            }
            this.completeLayers = this.elements[i2] ? this.completeLayers : false;
          }
          this.checkPendingElements();
        };
        BaseRenderer.prototype.createItem = function(layer) {
          switch (layer.ty) {
            case 2:
              return this.createImage(layer);
            case 0:
              return this.createComp(layer);
            case 1:
              return this.createSolid(layer);
            case 3:
              return this.createNull(layer);
            case 4:
              return this.createShape(layer);
            case 5:
              return this.createText(layer);
            case 6:
              return this.createAudio(layer);
            case 13:
              return this.createCamera(layer);
            case 15:
              return this.createFootage(layer);
            default:
              return this.createNull(layer);
          }
        };
        BaseRenderer.prototype.createCamera = function() {
          throw new Error("You're using a 3d camera. Try the html renderer.");
        };
        BaseRenderer.prototype.createAudio = function(data2) {
          return new AudioElement(data2, this.globalData, this);
        };
        BaseRenderer.prototype.createFootage = function(data2) {
          return new FootageElement(data2, this.globalData, this);
        };
        BaseRenderer.prototype.buildAllItems = function() {
          var i2;
          var len = this.layers.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            this.buildItem(i2);
          }
          this.checkPendingElements();
        };
        BaseRenderer.prototype.includeLayers = function(newLayers) {
          this.completeLayers = false;
          var i2;
          var len = newLayers.length;
          var j;
          var jLen = this.layers.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            j = 0;
            while (j < jLen) {
              if (this.layers[j].id === newLayers[i2].id) {
                this.layers[j] = newLayers[i2];
                break;
              }
              j += 1;
            }
          }
        };
        BaseRenderer.prototype.setProjectInterface = function(pInterface) {
          this.globalData.projectInterface = pInterface;
        };
        BaseRenderer.prototype.initItems = function() {
          if (!this.globalData.progressiveLoad) {
            this.buildAllItems();
          }
        };
        BaseRenderer.prototype.buildElementParenting = function(element, parentName, hierarchy) {
          var elements = this.elements;
          var layers2 = this.layers;
          var i2 = 0;
          var len = layers2.length;
          while (i2 < len) {
            if (layers2[i2].ind == parentName) {
              if (!elements[i2] || elements[i2] === true) {
                this.buildItem(i2);
                this.addPendingElement(element);
              } else {
                hierarchy.push(elements[i2]);
                elements[i2].setAsParent();
                if (layers2[i2].parent !== void 0) {
                  this.buildElementParenting(element, layers2[i2].parent, hierarchy);
                } else {
                  element.setHierarchy(hierarchy);
                }
              }
            }
            i2 += 1;
          }
        };
        BaseRenderer.prototype.addPendingElement = function(element) {
          this.pendingElements.push(element);
        };
        BaseRenderer.prototype.searchExtraCompositions = function(assets2) {
          var i2;
          var len = assets2.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (assets2[i2].xt) {
              var comp2 = this.createComp(assets2[i2]);
              comp2.initExpressions();
              this.globalData.projectInterface.registerComposition(comp2);
            }
          }
        };
        BaseRenderer.prototype.getElementById = function(ind) {
          var i2;
          var len = this.elements.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (this.elements[i2].data.ind === ind) {
              return this.elements[i2];
            }
          }
          return null;
        };
        BaseRenderer.prototype.getElementByPath = function(path2) {
          var pathValue = path2.shift();
          var element;
          if (typeof pathValue === "number") {
            element = this.elements[pathValue];
          } else {
            var i2;
            var len = this.elements.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              if (this.elements[i2].data.nm === pathValue) {
                element = this.elements[i2];
                break;
              }
            }
          }
          if (path2.length === 0) {
            return element;
          }
          return element.getElementByPath(path2);
        };
        BaseRenderer.prototype.setupGlobalData = function(animData, fontsContainer) {
          this.globalData.fontManager = new FontManager();
          this.globalData.slotManager = slotFactory(animData);
          this.globalData.fontManager.addChars(animData.chars);
          this.globalData.fontManager.addFonts(animData.fonts, fontsContainer);
          this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem);
          this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem);
          this.globalData.imageLoader = this.animationItem.imagePreloader;
          this.globalData.audioController = this.animationItem.audioController;
          this.globalData.frameId = 0;
          this.globalData.frameRate = animData.fr;
          this.globalData.nm = animData.nm;
          this.globalData.compSize = {
            w: animData.w,
            h: animData.h
          };
        };
        var effectTypes = {
          TRANSFORM_EFFECT: "transformEFfect"
        };
        function TransformElement() {
        }
        TransformElement.prototype = {
          initTransform: function initTransform() {
            var mat = new Matrix();
            this.finalTransform = {
              mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {
                o: 0
              },
              _matMdf: false,
              _localMatMdf: false,
              _opMdf: false,
              mat,
              localMat: mat,
              localOpacity: 1
            };
            if (this.data.ao) {
              this.finalTransform.mProp.autoOriented = true;
            }
            if (this.data.ty !== 11)
              ;
          },
          renderTransform: function renderTransform() {
            this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame;
            this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame;
            if (this.hierarchy) {
              var mat;
              var finalMat = this.finalTransform.mat;
              var i2 = 0;
              var len = this.hierarchy.length;
              if (!this.finalTransform._matMdf) {
                while (i2 < len) {
                  if (this.hierarchy[i2].finalTransform.mProp._mdf) {
                    this.finalTransform._matMdf = true;
                    break;
                  }
                  i2 += 1;
                }
              }
              if (this.finalTransform._matMdf) {
                mat = this.finalTransform.mProp.v.props;
                finalMat.cloneFromProps(mat);
                for (i2 = 0; i2 < len; i2 += 1) {
                  finalMat.multiply(this.hierarchy[i2].finalTransform.mProp.v);
                }
              }
            }
            if (this.finalTransform._matMdf) {
              this.finalTransform._localMatMdf = this.finalTransform._matMdf;
            }
            if (this.finalTransform._opMdf) {
              this.finalTransform.localOpacity = this.finalTransform.mProp.o.v;
            }
          },
          renderLocalTransform: function renderLocalTransform() {
            if (this.localTransforms) {
              var i2 = 0;
              var len = this.localTransforms.length;
              this.finalTransform._localMatMdf = this.finalTransform._matMdf;
              if (!this.finalTransform._localMatMdf || !this.finalTransform._opMdf) {
                while (i2 < len) {
                  if (this.localTransforms[i2]._mdf) {
                    this.finalTransform._localMatMdf = true;
                  }
                  if (this.localTransforms[i2]._opMdf && !this.finalTransform._opMdf) {
                    this.finalTransform.localOpacity = this.finalTransform.mProp.o.v;
                    this.finalTransform._opMdf = true;
                  }
                  i2 += 1;
                }
              }
              if (this.finalTransform._localMatMdf) {
                var localMat = this.finalTransform.localMat;
                this.localTransforms[0].matrix.clone(localMat);
                for (i2 = 1; i2 < len; i2 += 1) {
                  var lmat = this.localTransforms[i2].matrix;
                  localMat.multiply(lmat);
                }
                localMat.multiply(this.finalTransform.mat);
              }
              if (this.finalTransform._opMdf) {
                var localOp = this.finalTransform.localOpacity;
                for (i2 = 0; i2 < len; i2 += 1) {
                  localOp *= this.localTransforms[i2].opacity * 0.01;
                }
                this.finalTransform.localOpacity = localOp;
              }
            }
          },
          searchEffectTransforms: function searchEffectTransforms() {
            if (this.renderableEffectsManager) {
              var transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
              if (transformEffects.length) {
                this.localTransforms = [];
                this.finalTransform.localMat = new Matrix();
                var i2 = 0;
                var len = transformEffects.length;
                for (i2 = 0; i2 < len; i2 += 1) {
                  this.localTransforms.push(transformEffects[i2]);
                }
              }
            }
          },
          globalToLocal: function globalToLocal(pt) {
            var transforms = [];
            transforms.push(this.finalTransform);
            var flag = true;
            var comp2 = this.comp;
            while (flag) {
              if (comp2.finalTransform) {
                if (comp2.data.hasMask) {
                  transforms.splice(0, 0, comp2.finalTransform);
                }
                comp2 = comp2.comp;
              } else {
                flag = false;
              }
            }
            var i2;
            var len = transforms.length;
            var ptNew;
            for (i2 = 0; i2 < len; i2 += 1) {
              ptNew = transforms[i2].mat.applyToPointArray(0, 0, 0);
              pt = [pt[0] - ptNew[0], pt[1] - ptNew[1], 0];
            }
            return pt;
          },
          mHelper: new Matrix()
        };
        function MaskElement(data2, element, globalData2) {
          this.data = data2;
          this.element = element;
          this.globalData = globalData2;
          this.storedData = [];
          this.masksProperties = this.data.masksProperties || [];
          this.maskElement = null;
          var defs = this.globalData.defs;
          var i2;
          var len = this.masksProperties ? this.masksProperties.length : 0;
          this.viewData = createSizedArray(len);
          this.solidPath = "";
          var path2;
          var properties = this.masksProperties;
          var count = 0;
          var currentMasks = [];
          var j;
          var jLen;
          var layerId = createElementID();
          var rect;
          var expansor;
          var feMorph;
          var x2;
          var maskType = "clipPath";
          var maskRef = "clip-path";
          for (i2 = 0; i2 < len; i2 += 1) {
            if (properties[i2].mode !== "a" && properties[i2].mode !== "n" || properties[i2].inv || properties[i2].o.k !== 100 || properties[i2].o.x) {
              maskType = "mask";
              maskRef = "mask";
            }
            if ((properties[i2].mode === "s" || properties[i2].mode === "i") && count === 0) {
              rect = createNS("rect");
              rect.setAttribute("fill", "#ffffff");
              rect.setAttribute("width", this.element.comp.data.w || 0);
              rect.setAttribute("height", this.element.comp.data.h || 0);
              currentMasks.push(rect);
            } else {
              rect = null;
            }
            path2 = createNS("path");
            if (properties[i2].mode === "n") {
              this.viewData[i2] = {
                op: PropertyFactory.getProp(this.element, properties[i2].o, 0, 0.01, this.element),
                prop: ShapePropertyFactory.getShapeProp(this.element, properties[i2], 3),
                elem: path2,
                lastPath: ""
              };
              defs.appendChild(path2);
            } else {
              count += 1;
              path2.setAttribute("fill", properties[i2].mode === "s" ? "#000000" : "#ffffff");
              path2.setAttribute("clip-rule", "nonzero");
              var filterID;
              if (properties[i2].x.k !== 0) {
                maskType = "mask";
                maskRef = "mask";
                x2 = PropertyFactory.getProp(this.element, properties[i2].x, 0, null, this.element);
                filterID = createElementID();
                expansor = createNS("filter");
                expansor.setAttribute("id", filterID);
                feMorph = createNS("feMorphology");
                feMorph.setAttribute("operator", "erode");
                feMorph.setAttribute("in", "SourceGraphic");
                feMorph.setAttribute("radius", "0");
                expansor.appendChild(feMorph);
                defs.appendChild(expansor);
                path2.setAttribute("stroke", properties[i2].mode === "s" ? "#000000" : "#ffffff");
              } else {
                feMorph = null;
                x2 = null;
              }
              this.storedData[i2] = {
                elem: path2,
                x: x2,
                expan: feMorph,
                lastPath: "",
                lastOperator: "",
                filterId: filterID,
                lastRadius: 0
              };
              if (properties[i2].mode === "i") {
                jLen = currentMasks.length;
                var g2 = createNS("g");
                for (j = 0; j < jLen; j += 1) {
                  g2.appendChild(currentMasks[j]);
                }
                var mask2 = createNS("mask");
                mask2.setAttribute("mask-type", "alpha");
                mask2.setAttribute("id", layerId + "_" + count);
                mask2.appendChild(path2);
                defs.appendChild(mask2);
                g2.setAttribute("mask", "url(" + getLocationHref() + "#" + layerId + "_" + count + ")");
                currentMasks.length = 0;
                currentMasks.push(g2);
              } else {
                currentMasks.push(path2);
              }
              if (properties[i2].inv && !this.solidPath) {
                this.solidPath = this.createLayerSolidPath();
              }
              this.viewData[i2] = {
                elem: path2,
                lastPath: "",
                op: PropertyFactory.getProp(this.element, properties[i2].o, 0, 0.01, this.element),
                prop: ShapePropertyFactory.getShapeProp(this.element, properties[i2], 3),
                invRect: rect
              };
              if (!this.viewData[i2].prop.k) {
                this.drawPath(properties[i2], this.viewData[i2].prop.v, this.viewData[i2]);
              }
            }
          }
          this.maskElement = createNS(maskType);
          len = currentMasks.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            this.maskElement.appendChild(currentMasks[i2]);
          }
          if (count > 0) {
            this.maskElement.setAttribute("id", layerId);
            this.element.maskedElement.setAttribute(maskRef, "url(" + getLocationHref() + "#" + layerId + ")");
            defs.appendChild(this.maskElement);
          }
          if (this.viewData.length) {
            this.element.addRenderableComponent(this);
          }
        }
        MaskElement.prototype.getMaskProperty = function(pos) {
          return this.viewData[pos].prop;
        };
        MaskElement.prototype.renderFrame = function(isFirstFrame) {
          var finalMat = this.element.finalTransform.mat;
          var i2;
          var len = this.masksProperties.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (this.viewData[i2].prop._mdf || isFirstFrame) {
              this.drawPath(this.masksProperties[i2], this.viewData[i2].prop.v, this.viewData[i2]);
            }
            if (this.viewData[i2].op._mdf || isFirstFrame) {
              this.viewData[i2].elem.setAttribute("fill-opacity", this.viewData[i2].op.v);
            }
            if (this.masksProperties[i2].mode !== "n") {
              if (this.viewData[i2].invRect && (this.element.finalTransform.mProp._mdf || isFirstFrame)) {
                this.viewData[i2].invRect.setAttribute("transform", finalMat.getInverseMatrix().to2dCSS());
              }
              if (this.storedData[i2].x && (this.storedData[i2].x._mdf || isFirstFrame)) {
                var feMorph = this.storedData[i2].expan;
                if (this.storedData[i2].x.v < 0) {
                  if (this.storedData[i2].lastOperator !== "erode") {
                    this.storedData[i2].lastOperator = "erode";
                    this.storedData[i2].elem.setAttribute("filter", "url(" + getLocationHref() + "#" + this.storedData[i2].filterId + ")");
                  }
                  feMorph.setAttribute("radius", -this.storedData[i2].x.v);
                } else {
                  if (this.storedData[i2].lastOperator !== "dilate") {
                    this.storedData[i2].lastOperator = "dilate";
                    this.storedData[i2].elem.setAttribute("filter", null);
                  }
                  this.storedData[i2].elem.setAttribute("stroke-width", this.storedData[i2].x.v * 2);
                }
              }
            }
          }
        };
        MaskElement.prototype.getMaskelement = function() {
          return this.maskElement;
        };
        MaskElement.prototype.createLayerSolidPath = function() {
          var path2 = "M0,0 ";
          path2 += " h" + this.globalData.compSize.w;
          path2 += " v" + this.globalData.compSize.h;
          path2 += " h-" + this.globalData.compSize.w;
          path2 += " v-" + this.globalData.compSize.h + " ";
          return path2;
        };
        MaskElement.prototype.drawPath = function(pathData, pathNodes, viewData) {
          var pathString = " M" + pathNodes.v[0][0] + "," + pathNodes.v[0][1];
          var i2;
          var len;
          len = pathNodes._length;
          for (i2 = 1; i2 < len; i2 += 1) {
            pathString += " C" + pathNodes.o[i2 - 1][0] + "," + pathNodes.o[i2 - 1][1] + " " + pathNodes.i[i2][0] + "," + pathNodes.i[i2][1] + " " + pathNodes.v[i2][0] + "," + pathNodes.v[i2][1];
          }
          if (pathNodes.c && len > 1) {
            pathString += " C" + pathNodes.o[i2 - 1][0] + "," + pathNodes.o[i2 - 1][1] + " " + pathNodes.i[0][0] + "," + pathNodes.i[0][1] + " " + pathNodes.v[0][0] + "," + pathNodes.v[0][1];
          }
          if (viewData.lastPath !== pathString) {
            var pathShapeValue = "";
            if (viewData.elem) {
              if (pathNodes.c) {
                pathShapeValue = pathData.inv ? this.solidPath + pathString : pathString;
              }
              viewData.elem.setAttribute("d", pathShapeValue);
            }
            viewData.lastPath = pathString;
          }
        };
        MaskElement.prototype.destroy = function() {
          this.element = null;
          this.globalData = null;
          this.maskElement = null;
          this.data = null;
          this.masksProperties = null;
        };
        var filtersFactory = function() {
          var ob2 = {};
          ob2.createFilter = createFilter;
          ob2.createAlphaToLuminanceFilter = createAlphaToLuminanceFilter;
          function createFilter(filId, skipCoordinates) {
            var fil = createNS("filter");
            fil.setAttribute("id", filId);
            if (skipCoordinates !== true) {
              fil.setAttribute("filterUnits", "objectBoundingBox");
              fil.setAttribute("x", "0%");
              fil.setAttribute("y", "0%");
              fil.setAttribute("width", "100%");
              fil.setAttribute("height", "100%");
            }
            return fil;
          }
          function createAlphaToLuminanceFilter() {
            var feColorMatrix = createNS("feColorMatrix");
            feColorMatrix.setAttribute("type", "matrix");
            feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
            feColorMatrix.setAttribute("values", "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1");
            return feColorMatrix;
          }
          return ob2;
        }();
        var featureSupport = function() {
          var ob2 = {
            maskType: true,
            svgLumaHidden: true,
            offscreenCanvas: typeof OffscreenCanvas !== "undefined"
          };
          if (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) {
            ob2.maskType = false;
          }
          if (/firefox/i.test(navigator.userAgent)) {
            ob2.svgLumaHidden = false;
          }
          return ob2;
        }();
        var registeredEffects$1 = {};
        var idPrefix = "filter_result_";
        function SVGEffects(elem2) {
          var i2;
          var source = "SourceGraphic";
          var len = elem2.data.ef ? elem2.data.ef.length : 0;
          var filId = createElementID();
          var fil = filtersFactory.createFilter(filId, true);
          var count = 0;
          this.filters = [];
          var filterManager;
          for (i2 = 0; i2 < len; i2 += 1) {
            filterManager = null;
            var type = elem2.data.ef[i2].ty;
            if (registeredEffects$1[type]) {
              var Effect = registeredEffects$1[type].effect;
              filterManager = new Effect(fil, elem2.effectsManager.effectElements[i2], elem2, idPrefix + count, source);
              source = idPrefix + count;
              if (registeredEffects$1[type].countsAsEffect) {
                count += 1;
              }
            }
            if (filterManager) {
              this.filters.push(filterManager);
            }
          }
          if (count) {
            elem2.globalData.defs.appendChild(fil);
            elem2.layerElement.setAttribute("filter", "url(" + getLocationHref() + "#" + filId + ")");
          }
          if (this.filters.length) {
            elem2.addRenderableComponent(this);
          }
        }
        SVGEffects.prototype.renderFrame = function(_isFirstFrame) {
          var i2;
          var len = this.filters.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            this.filters[i2].renderFrame(_isFirstFrame);
          }
        };
        SVGEffects.prototype.getEffects = function(type) {
          var i2;
          var len = this.filters.length;
          var effects = [];
          for (i2 = 0; i2 < len; i2 += 1) {
            if (this.filters[i2].type === type) {
              effects.push(this.filters[i2]);
            }
          }
          return effects;
        };
        function registerEffect$1(id2, effect2, countsAsEffect) {
          registeredEffects$1[id2] = {
            effect: effect2,
            countsAsEffect
          };
        }
        function SVGBaseElement() {
        }
        SVGBaseElement.prototype = {
          initRendererElement: function initRendererElement() {
            this.layerElement = createNS("g");
          },
          createContainerElements: function createContainerElements() {
            this.matteElement = createNS("g");
            this.transformedElement = this.layerElement;
            this.maskedElement = this.layerElement;
            this._sizeChanged = false;
            var layerElementParent = null;
            if (this.data.td) {
              this.matteMasks = {};
              var gg2 = createNS("g");
              gg2.setAttribute("id", this.layerId);
              gg2.appendChild(this.layerElement);
              layerElementParent = gg2;
              this.globalData.defs.appendChild(gg2);
            } else if (this.data.tt) {
              this.matteElement.appendChild(this.layerElement);
              layerElementParent = this.matteElement;
              this.baseElement = this.matteElement;
            } else {
              this.baseElement = this.layerElement;
            }
            if (this.data.ln) {
              this.layerElement.setAttribute("id", this.data.ln);
            }
            if (this.data.cl) {
              this.layerElement.setAttribute("class", this.data.cl);
            }
            if (this.data.ty === 0 && !this.data.hd) {
              var cp = createNS("clipPath");
              var pt = createNS("path");
              pt.setAttribute("d", "M0,0 L" + this.data.w + ",0 L" + this.data.w + "," + this.data.h + " L0," + this.data.h + "z");
              var clipId = createElementID();
              cp.setAttribute("id", clipId);
              cp.appendChild(pt);
              this.globalData.defs.appendChild(cp);
              if (this.checkMasks()) {
                var cpGroup = createNS("g");
                cpGroup.setAttribute("clip-path", "url(" + getLocationHref() + "#" + clipId + ")");
                cpGroup.appendChild(this.layerElement);
                this.transformedElement = cpGroup;
                if (layerElementParent) {
                  layerElementParent.appendChild(this.transformedElement);
                } else {
                  this.baseElement = this.transformedElement;
                }
              } else {
                this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + clipId + ")");
              }
            }
            if (this.data.bm !== 0) {
              this.setBlendMode();
            }
          },
          renderElement: function renderElement() {
            if (this.finalTransform._localMatMdf) {
              this.transformedElement.setAttribute("transform", this.finalTransform.localMat.to2dCSS());
            }
            if (this.finalTransform._opMdf) {
              this.transformedElement.setAttribute("opacity", this.finalTransform.localOpacity);
            }
          },
          destroyBaseElement: function destroyBaseElement() {
            this.layerElement = null;
            this.matteElement = null;
            this.maskManager.destroy();
          },
          getBaseElement: function getBaseElement() {
            if (this.data.hd) {
              return null;
            }
            return this.baseElement;
          },
          createRenderableComponents: function createRenderableComponents() {
            this.maskManager = new MaskElement(this.data, this, this.globalData);
            this.renderableEffectsManager = new SVGEffects(this);
            this.searchEffectTransforms();
          },
          getMatte: function getMatte(matteType) {
            if (!this.matteMasks) {
              this.matteMasks = {};
            }
            if (!this.matteMasks[matteType]) {
              var id2 = this.layerId + "_" + matteType;
              var filId;
              var fil;
              var useElement;
              var gg2;
              if (matteType === 1 || matteType === 3) {
                var masker = createNS("mask");
                masker.setAttribute("id", id2);
                masker.setAttribute("mask-type", matteType === 3 ? "luminance" : "alpha");
                useElement = createNS("use");
                useElement.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId);
                masker.appendChild(useElement);
                this.globalData.defs.appendChild(masker);
                if (!featureSupport.maskType && matteType === 1) {
                  masker.setAttribute("mask-type", "luminance");
                  filId = createElementID();
                  fil = filtersFactory.createFilter(filId);
                  this.globalData.defs.appendChild(fil);
                  fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
                  gg2 = createNS("g");
                  gg2.appendChild(useElement);
                  masker.appendChild(gg2);
                  gg2.setAttribute("filter", "url(" + getLocationHref() + "#" + filId + ")");
                }
              } else if (matteType === 2) {
                var maskGroup = createNS("mask");
                maskGroup.setAttribute("id", id2);
                maskGroup.setAttribute("mask-type", "alpha");
                var maskGrouper = createNS("g");
                maskGroup.appendChild(maskGrouper);
                filId = createElementID();
                fil = filtersFactory.createFilter(filId);
                var feCTr = createNS("feComponentTransfer");
                feCTr.setAttribute("in", "SourceGraphic");
                fil.appendChild(feCTr);
                var feFunc = createNS("feFuncA");
                feFunc.setAttribute("type", "table");
                feFunc.setAttribute("tableValues", "1.0 0.0");
                feCTr.appendChild(feFunc);
                this.globalData.defs.appendChild(fil);
                var alphaRect = createNS("rect");
                alphaRect.setAttribute("width", this.comp.data.w);
                alphaRect.setAttribute("height", this.comp.data.h);
                alphaRect.setAttribute("x", "0");
                alphaRect.setAttribute("y", "0");
                alphaRect.setAttribute("fill", "#ffffff");
                alphaRect.setAttribute("opacity", "0");
                maskGrouper.setAttribute("filter", "url(" + getLocationHref() + "#" + filId + ")");
                maskGrouper.appendChild(alphaRect);
                useElement = createNS("use");
                useElement.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId);
                maskGrouper.appendChild(useElement);
                if (!featureSupport.maskType) {
                  maskGroup.setAttribute("mask-type", "luminance");
                  fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
                  gg2 = createNS("g");
                  maskGrouper.appendChild(alphaRect);
                  gg2.appendChild(this.layerElement);
                  maskGrouper.appendChild(gg2);
                }
                this.globalData.defs.appendChild(maskGroup);
              }
              this.matteMasks[matteType] = id2;
            }
            return this.matteMasks[matteType];
          },
          setMatte: function setMatte(id2) {
            if (!this.matteElement) {
              return;
            }
            this.matteElement.setAttribute("mask", "url(" + getLocationHref() + "#" + id2 + ")");
          }
        };
        function HierarchyElement() {
        }
        HierarchyElement.prototype = {
          /**
             * @function
             * Initializes hierarchy properties
             *
             */
          initHierarchy: function initHierarchy() {
            this.hierarchy = [];
            this._isParent = false;
            this.checkParenting();
          },
          /**
             * @function
             * Sets layer's hierarchy.
             * @param {array} hierarch
             * layer's parent list
             *
             */
          setHierarchy: function setHierarchy(hierarchy) {
            this.hierarchy = hierarchy;
          },
          /**
             * @function
             * Sets layer as parent.
             *
             */
          setAsParent: function setAsParent() {
            this._isParent = true;
          },
          /**
             * @function
             * Searches layer's parenting chain
             *
             */
          checkParenting: function checkParenting() {
            if (this.data.parent !== void 0) {
              this.comp.buildElementParenting(this, this.data.parent, []);
            }
          }
        };
        function RenderableDOMElement() {
        }
        (function() {
          var _prototype = {
            initElement: function initElement(data2, globalData2, comp2) {
              this.initFrame();
              this.initBaseData(data2, globalData2, comp2);
              this.initTransform(data2, globalData2, comp2);
              this.initHierarchy();
              this.initRenderable();
              this.initRendererElement();
              this.createContainerElements();
              this.createRenderableComponents();
              this.createContent();
              this.hide();
            },
            hide: function hide() {
              if (!this.hidden && (!this.isInRange || this.isTransparent)) {
                var elem2 = this.baseElement || this.layerElement;
                elem2.style.display = "none";
                this.hidden = true;
              }
            },
            show: function show() {
              if (this.isInRange && !this.isTransparent) {
                if (!this.data.hd) {
                  var elem2 = this.baseElement || this.layerElement;
                  elem2.style.display = "block";
                }
                this.hidden = false;
                this._isFirstFrame = true;
              }
            },
            renderFrame: function renderFrame() {
              if (this.data.hd || this.hidden) {
                return;
              }
              this.renderTransform();
              this.renderRenderable();
              this.renderLocalTransform();
              this.renderElement();
              this.renderInnerContent();
              if (this._isFirstFrame) {
                this._isFirstFrame = false;
              }
            },
            renderInnerContent: function renderInnerContent() {
            },
            prepareFrame: function prepareFrame(num) {
              this._mdf = false;
              this.prepareRenderableFrame(num);
              this.prepareProperties(num, this.isInRange);
              this.checkTransparency();
            },
            destroy: function destroy() {
              this.innerElem = null;
              this.destroyBaseElement();
            }
          };
          extendPrototype([RenderableElement, createProxyFunction(_prototype)], RenderableDOMElement);
        })();
        function IImageElement(data2, globalData2, comp2) {
          this.assetData = globalData2.getAssetData(data2.refId);
          if (this.assetData && this.assetData.sid) {
            this.assetData = globalData2.slotManager.getProp(this.assetData);
          }
          this.initElement(data2, globalData2, comp2);
          this.sourceRect = {
            top: 0,
            left: 0,
            width: this.assetData.w,
            height: this.assetData.h
          };
        }
        extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement);
        IImageElement.prototype.createContent = function() {
          var assetPath = this.globalData.getAssetsPath(this.assetData);
          this.innerElem = createNS("image");
          this.innerElem.setAttribute("width", this.assetData.w + "px");
          this.innerElem.setAttribute("height", this.assetData.h + "px");
          this.innerElem.setAttribute("preserveAspectRatio", this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio);
          this.innerElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", assetPath);
          this.layerElement.appendChild(this.innerElem);
        };
        IImageElement.prototype.sourceRectAtTime = function() {
          return this.sourceRect;
        };
        function ProcessedElement(element, position2) {
          this.elem = element;
          this.pos = position2;
        }
        function IShapeElement() {
        }
        IShapeElement.prototype = {
          addShapeToModifiers: function addShapeToModifiers(data2) {
            var i2;
            var len = this.shapeModifiers.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              this.shapeModifiers[i2].addShape(data2);
            }
          },
          isShapeInAnimatedModifiers: function isShapeInAnimatedModifiers(data2) {
            var i2 = 0;
            var len = this.shapeModifiers.length;
            while (i2 < len) {
              if (this.shapeModifiers[i2].isAnimatedWithShape(data2)) {
                return true;
              }
            }
            return false;
          },
          renderModifiers: function renderModifiers() {
            if (!this.shapeModifiers.length) {
              return;
            }
            var i2;
            var len = this.shapes.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              this.shapes[i2].sh.reset();
            }
            len = this.shapeModifiers.length;
            var shouldBreakProcess;
            for (i2 = len - 1; i2 >= 0; i2 -= 1) {
              shouldBreakProcess = this.shapeModifiers[i2].processShapes(this._isFirstFrame);
              if (shouldBreakProcess) {
                break;
              }
            }
          },
          searchProcessedElement: function searchProcessedElement(elem2) {
            var elements = this.processedElements;
            var i2 = 0;
            var len = elements.length;
            while (i2 < len) {
              if (elements[i2].elem === elem2) {
                return elements[i2].pos;
              }
              i2 += 1;
            }
            return 0;
          },
          addProcessedElement: function addProcessedElement(elem2, pos) {
            var elements = this.processedElements;
            var i2 = elements.length;
            while (i2) {
              i2 -= 1;
              if (elements[i2].elem === elem2) {
                elements[i2].pos = pos;
                return;
              }
            }
            elements.push(new ProcessedElement(elem2, pos));
          },
          prepareFrame: function prepareFrame(num) {
            this.prepareRenderableFrame(num);
            this.prepareProperties(num, this.isInRange);
          }
        };
        var lineCapEnum = {
          1: "butt",
          2: "round",
          3: "square"
        };
        var lineJoinEnum = {
          1: "miter",
          2: "round",
          3: "bevel"
        };
        function SVGShapeData(transformers, level, shape) {
          this.caches = [];
          this.styles = [];
          this.transformers = transformers;
          this.lStr = "";
          this.sh = shape;
          this.lvl = level;
          this._isAnimated = !!shape.k;
          var i2 = 0;
          var len = transformers.length;
          while (i2 < len) {
            if (transformers[i2].mProps.dynamicProperties.length) {
              this._isAnimated = true;
              break;
            }
            i2 += 1;
          }
        }
        SVGShapeData.prototype.setAsAnimated = function() {
          this._isAnimated = true;
        };
        function SVGStyleData(data2, level) {
          this.data = data2;
          this.type = data2.ty;
          this.d = "";
          this.lvl = level;
          this._mdf = false;
          this.closed = data2.hd === true;
          this.pElem = createNS("path");
          this.msElem = null;
        }
        SVGStyleData.prototype.reset = function() {
          this.d = "";
          this._mdf = false;
        };
        function DashProperty(elem2, data2, renderer, container2) {
          this.elem = elem2;
          this.frameId = -1;
          this.dataProps = createSizedArray(data2.length);
          this.renderer = renderer;
          this.k = false;
          this.dashStr = "";
          this.dashArray = createTypedArray("float32", data2.length ? data2.length - 1 : 0);
          this.dashoffset = createTypedArray("float32", 1);
          this.initDynamicPropertyContainer(container2);
          var i2;
          var len = data2.length || 0;
          var prop;
          for (i2 = 0; i2 < len; i2 += 1) {
            prop = PropertyFactory.getProp(elem2, data2[i2].v, 0, 0, this);
            this.k = prop.k || this.k;
            this.dataProps[i2] = {
              n: data2[i2].n,
              p: prop
            };
          }
          if (!this.k) {
            this.getValue(true);
          }
          this._isAnimated = this.k;
        }
        DashProperty.prototype.getValue = function(forceRender) {
          if (this.elem.globalData.frameId === this.frameId && !forceRender) {
            return;
          }
          this.frameId = this.elem.globalData.frameId;
          this.iterateDynamicProperties();
          this._mdf = this._mdf || forceRender;
          if (this._mdf) {
            var i2 = 0;
            var len = this.dataProps.length;
            if (this.renderer === "svg") {
              this.dashStr = "";
            }
            for (i2 = 0; i2 < len; i2 += 1) {
              if (this.dataProps[i2].n !== "o") {
                if (this.renderer === "svg") {
                  this.dashStr += " " + this.dataProps[i2].p.v;
                } else {
                  this.dashArray[i2] = this.dataProps[i2].p.v;
                }
              } else {
                this.dashoffset[0] = this.dataProps[i2].p.v;
              }
            }
          }
        };
        extendPrototype([DynamicPropertyContainer], DashProperty);
        function SVGStrokeStyleData(elem2, data2, styleOb) {
          this.initDynamicPropertyContainer(elem2);
          this.getValue = this.iterateDynamicProperties;
          this.o = PropertyFactory.getProp(elem2, data2.o, 0, 0.01, this);
          this.w = PropertyFactory.getProp(elem2, data2.w, 0, null, this);
          this.d = new DashProperty(elem2, data2.d || {}, "svg", this);
          this.c = PropertyFactory.getProp(elem2, data2.c, 1, 255, this);
          this.style = styleOb;
          this._isAnimated = !!this._isAnimated;
        }
        extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);
        function SVGFillStyleData(elem2, data2, styleOb) {
          this.initDynamicPropertyContainer(elem2);
          this.getValue = this.iterateDynamicProperties;
          this.o = PropertyFactory.getProp(elem2, data2.o, 0, 0.01, this);
          this.c = PropertyFactory.getProp(elem2, data2.c, 1, 255, this);
          this.style = styleOb;
        }
        extendPrototype([DynamicPropertyContainer], SVGFillStyleData);
        function SVGNoStyleData(elem2, data2, styleOb) {
          this.initDynamicPropertyContainer(elem2);
          this.getValue = this.iterateDynamicProperties;
          this.style = styleOb;
        }
        extendPrototype([DynamicPropertyContainer], SVGNoStyleData);
        function GradientProperty(elem2, data2, container2) {
          this.data = data2;
          this.c = createTypedArray("uint8c", data2.p * 4);
          var cLength = data2.k.k[0].s ? data2.k.k[0].s.length - data2.p * 4 : data2.k.k.length - data2.p * 4;
          this.o = createTypedArray("float32", cLength);
          this._cmdf = false;
          this._omdf = false;
          this._collapsable = this.checkCollapsable();
          this._hasOpacity = cLength;
          this.initDynamicPropertyContainer(container2);
          this.prop = PropertyFactory.getProp(elem2, data2.k, 1, null, this);
          this.k = this.prop.k;
          this.getValue(true);
        }
        GradientProperty.prototype.comparePoints = function(values, points) {
          var i2 = 0;
          var len = this.o.length / 2;
          var diff;
          while (i2 < len) {
            diff = Math.abs(values[i2 * 4] - values[points * 4 + i2 * 2]);
            if (diff > 0.01) {
              return false;
            }
            i2 += 1;
          }
          return true;
        };
        GradientProperty.prototype.checkCollapsable = function() {
          if (this.o.length / 2 !== this.c.length / 4) {
            return false;
          }
          if (this.data.k.k[0].s) {
            var i2 = 0;
            var len = this.data.k.k.length;
            while (i2 < len) {
              if (!this.comparePoints(this.data.k.k[i2].s, this.data.p)) {
                return false;
              }
              i2 += 1;
            }
          } else if (!this.comparePoints(this.data.k.k, this.data.p)) {
            return false;
          }
          return true;
        };
        GradientProperty.prototype.getValue = function(forceRender) {
          this.prop.getValue();
          this._mdf = false;
          this._cmdf = false;
          this._omdf = false;
          if (this.prop._mdf || forceRender) {
            var i2;
            var len = this.data.p * 4;
            var mult;
            var val2;
            for (i2 = 0; i2 < len; i2 += 1) {
              mult = i2 % 4 === 0 ? 100 : 255;
              val2 = Math.round(this.prop.v[i2] * mult);
              if (this.c[i2] !== val2) {
                this.c[i2] = val2;
                this._cmdf = !forceRender;
              }
            }
            if (this.o.length) {
              len = this.prop.v.length;
              for (i2 = this.data.p * 4; i2 < len; i2 += 1) {
                mult = i2 % 2 === 0 ? 100 : 1;
                val2 = i2 % 2 === 0 ? Math.round(this.prop.v[i2] * 100) : this.prop.v[i2];
                if (this.o[i2 - this.data.p * 4] !== val2) {
                  this.o[i2 - this.data.p * 4] = val2;
                  this._omdf = !forceRender;
                }
              }
            }
            this._mdf = !forceRender;
          }
        };
        extendPrototype([DynamicPropertyContainer], GradientProperty);
        function SVGGradientFillStyleData(elem2, data2, styleOb) {
          this.initDynamicPropertyContainer(elem2);
          this.getValue = this.iterateDynamicProperties;
          this.initGradientData(elem2, data2, styleOb);
        }
        SVGGradientFillStyleData.prototype.initGradientData = function(elem2, data2, styleOb) {
          this.o = PropertyFactory.getProp(elem2, data2.o, 0, 0.01, this);
          this.s = PropertyFactory.getProp(elem2, data2.s, 1, null, this);
          this.e = PropertyFactory.getProp(elem2, data2.e, 1, null, this);
          this.h = PropertyFactory.getProp(elem2, data2.h || {
            k: 0
          }, 0, 0.01, this);
          this.a = PropertyFactory.getProp(elem2, data2.a || {
            k: 0
          }, 0, degToRads, this);
          this.g = new GradientProperty(elem2, data2.g, this);
          this.style = styleOb;
          this.stops = [];
          this.setGradientData(styleOb.pElem, data2);
          this.setGradientOpacity(data2, styleOb);
          this._isAnimated = !!this._isAnimated;
        };
        SVGGradientFillStyleData.prototype.setGradientData = function(pathElement, data2) {
          var gradientId = createElementID();
          var gfill = createNS(data2.t === 1 ? "linearGradient" : "radialGradient");
          gfill.setAttribute("id", gradientId);
          gfill.setAttribute("spreadMethod", "pad");
          gfill.setAttribute("gradientUnits", "userSpaceOnUse");
          var stops = [];
          var stop;
          var j;
          var jLen;
          jLen = data2.g.p * 4;
          for (j = 0; j < jLen; j += 4) {
            stop = createNS("stop");
            gfill.appendChild(stop);
            stops.push(stop);
          }
          pathElement.setAttribute(data2.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + gradientId + ")");
          this.gf = gfill;
          this.cst = stops;
        };
        SVGGradientFillStyleData.prototype.setGradientOpacity = function(data2, styleOb) {
          if (this.g._hasOpacity && !this.g._collapsable) {
            var stop;
            var j;
            var jLen;
            var mask2 = createNS("mask");
            var maskElement = createNS("path");
            mask2.appendChild(maskElement);
            var opacityId = createElementID();
            var maskId = createElementID();
            mask2.setAttribute("id", maskId);
            var opFill = createNS(data2.t === 1 ? "linearGradient" : "radialGradient");
            opFill.setAttribute("id", opacityId);
            opFill.setAttribute("spreadMethod", "pad");
            opFill.setAttribute("gradientUnits", "userSpaceOnUse");
            jLen = data2.g.k.k[0].s ? data2.g.k.k[0].s.length : data2.g.k.k.length;
            var stops = this.stops;
            for (j = data2.g.p * 4; j < jLen; j += 2) {
              stop = createNS("stop");
              stop.setAttribute("stop-color", "rgb(255,255,255)");
              opFill.appendChild(stop);
              stops.push(stop);
            }
            maskElement.setAttribute(data2.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + opacityId + ")");
            if (data2.ty === "gs") {
              maskElement.setAttribute("stroke-linecap", lineCapEnum[data2.lc || 2]);
              maskElement.setAttribute("stroke-linejoin", lineJoinEnum[data2.lj || 2]);
              if (data2.lj === 1) {
                maskElement.setAttribute("stroke-miterlimit", data2.ml);
              }
            }
            this.of = opFill;
            this.ms = mask2;
            this.ost = stops;
            this.maskId = maskId;
            styleOb.msElem = maskElement;
          }
        };
        extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);
        function SVGGradientStrokeStyleData(elem2, data2, styleOb) {
          this.initDynamicPropertyContainer(elem2);
          this.getValue = this.iterateDynamicProperties;
          this.w = PropertyFactory.getProp(elem2, data2.w, 0, null, this);
          this.d = new DashProperty(elem2, data2.d || {}, "svg", this);
          this.initGradientData(elem2, data2, styleOb);
          this._isAnimated = !!this._isAnimated;
        }
        extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);
        function ShapeGroupData() {
          this.it = [];
          this.prevViewData = [];
          this.gr = createNS("g");
        }
        function SVGTransformData(mProps, op2, container2) {
          this.transform = {
            mProps,
            op: op2,
            container: container2
          };
          this.elements = [];
          this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length;
        }
        var buildShapeString = function buildShapeString2(pathNodes, length2, closed, mat) {
          if (length2 === 0) {
            return "";
          }
          var _o = pathNodes.o;
          var _i = pathNodes.i;
          var _v = pathNodes.v;
          var i2;
          var shapeString = " M" + mat.applyToPointStringified(_v[0][0], _v[0][1]);
          for (i2 = 1; i2 < length2; i2 += 1) {
            shapeString += " C" + mat.applyToPointStringified(_o[i2 - 1][0], _o[i2 - 1][1]) + " " + mat.applyToPointStringified(_i[i2][0], _i[i2][1]) + " " + mat.applyToPointStringified(_v[i2][0], _v[i2][1]);
          }
          if (closed && length2) {
            shapeString += " C" + mat.applyToPointStringified(_o[i2 - 1][0], _o[i2 - 1][1]) + " " + mat.applyToPointStringified(_i[0][0], _i[0][1]) + " " + mat.applyToPointStringified(_v[0][0], _v[0][1]);
            shapeString += "z";
          }
          return shapeString;
        };
        var SVGElementsRenderer = function() {
          var _identityMatrix = new Matrix();
          var _matrixHelper = new Matrix();
          var ob2 = {
            createRenderFunction
          };
          function createRenderFunction(data2) {
            switch (data2.ty) {
              case "fl":
                return renderFill;
              case "gf":
                return renderGradient;
              case "gs":
                return renderGradientStroke;
              case "st":
                return renderStroke;
              case "sh":
              case "el":
              case "rc":
              case "sr":
                return renderPath;
              case "tr":
                return renderContentTransform;
              case "no":
                return renderNoop;
              default:
                return null;
            }
          }
          function renderContentTransform(styleData, itemData, isFirstFrame) {
            if (isFirstFrame || itemData.transform.op._mdf) {
              itemData.transform.container.setAttribute("opacity", itemData.transform.op.v);
            }
            if (isFirstFrame || itemData.transform.mProps._mdf) {
              itemData.transform.container.setAttribute("transform", itemData.transform.mProps.v.to2dCSS());
            }
          }
          function renderNoop() {
          }
          function renderPath(styleData, itemData, isFirstFrame) {
            var j;
            var jLen;
            var pathStringTransformed;
            var redraw;
            var pathNodes;
            var l2;
            var lLen = itemData.styles.length;
            var lvl = itemData.lvl;
            var paths;
            var mat;
            var iterations;
            var k2;
            for (l2 = 0; l2 < lLen; l2 += 1) {
              redraw = itemData.sh._mdf || isFirstFrame;
              if (itemData.styles[l2].lvl < lvl) {
                mat = _matrixHelper.reset();
                iterations = lvl - itemData.styles[l2].lvl;
                k2 = itemData.transformers.length - 1;
                while (!redraw && iterations > 0) {
                  redraw = itemData.transformers[k2].mProps._mdf || redraw;
                  iterations -= 1;
                  k2 -= 1;
                }
                if (redraw) {
                  iterations = lvl - itemData.styles[l2].lvl;
                  k2 = itemData.transformers.length - 1;
                  while (iterations > 0) {
                    mat.multiply(itemData.transformers[k2].mProps.v);
                    iterations -= 1;
                    k2 -= 1;
                  }
                }
              } else {
                mat = _identityMatrix;
              }
              paths = itemData.sh.paths;
              jLen = paths._length;
              if (redraw) {
                pathStringTransformed = "";
                for (j = 0; j < jLen; j += 1) {
                  pathNodes = paths.shapes[j];
                  if (pathNodes && pathNodes._length) {
                    pathStringTransformed += buildShapeString(pathNodes, pathNodes._length, pathNodes.c, mat);
                  }
                }
                itemData.caches[l2] = pathStringTransformed;
              } else {
                pathStringTransformed = itemData.caches[l2];
              }
              itemData.styles[l2].d += styleData.hd === true ? "" : pathStringTransformed;
              itemData.styles[l2]._mdf = redraw || itemData.styles[l2]._mdf;
            }
          }
          function renderFill(styleData, itemData, isFirstFrame) {
            var styleElem = itemData.style;
            if (itemData.c._mdf || isFirstFrame) {
              styleElem.pElem.setAttribute("fill", "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")");
            }
            if (itemData.o._mdf || isFirstFrame) {
              styleElem.pElem.setAttribute("fill-opacity", itemData.o.v);
            }
          }
          function renderGradientStroke(styleData, itemData, isFirstFrame) {
            renderGradient(styleData, itemData, isFirstFrame);
            renderStroke(styleData, itemData, isFirstFrame);
          }
          function renderGradient(styleData, itemData, isFirstFrame) {
            var gfill = itemData.gf;
            var hasOpacity = itemData.g._hasOpacity;
            var pt1 = itemData.s.v;
            var pt2 = itemData.e.v;
            if (itemData.o._mdf || isFirstFrame) {
              var attr = styleData.ty === "gf" ? "fill-opacity" : "stroke-opacity";
              itemData.style.pElem.setAttribute(attr, itemData.o.v);
            }
            if (itemData.s._mdf || isFirstFrame) {
              var attr1 = styleData.t === 1 ? "x1" : "cx";
              var attr2 = attr1 === "x1" ? "y1" : "cy";
              gfill.setAttribute(attr1, pt1[0]);
              gfill.setAttribute(attr2, pt1[1]);
              if (hasOpacity && !itemData.g._collapsable) {
                itemData.of.setAttribute(attr1, pt1[0]);
                itemData.of.setAttribute(attr2, pt1[1]);
              }
            }
            var stops;
            var i2;
            var len;
            var stop;
            if (itemData.g._cmdf || isFirstFrame) {
              stops = itemData.cst;
              var cValues = itemData.g.c;
              len = stops.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                stop = stops[i2];
                stop.setAttribute("offset", cValues[i2 * 4] + "%");
                stop.setAttribute("stop-color", "rgb(" + cValues[i2 * 4 + 1] + "," + cValues[i2 * 4 + 2] + "," + cValues[i2 * 4 + 3] + ")");
              }
            }
            if (hasOpacity && (itemData.g._omdf || isFirstFrame)) {
              var oValues = itemData.g.o;
              if (itemData.g._collapsable) {
                stops = itemData.cst;
              } else {
                stops = itemData.ost;
              }
              len = stops.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                stop = stops[i2];
                if (!itemData.g._collapsable) {
                  stop.setAttribute("offset", oValues[i2 * 2] + "%");
                }
                stop.setAttribute("stop-opacity", oValues[i2 * 2 + 1]);
              }
            }
            if (styleData.t === 1) {
              if (itemData.e._mdf || isFirstFrame) {
                gfill.setAttribute("x2", pt2[0]);
                gfill.setAttribute("y2", pt2[1]);
                if (hasOpacity && !itemData.g._collapsable) {
                  itemData.of.setAttribute("x2", pt2[0]);
                  itemData.of.setAttribute("y2", pt2[1]);
                }
              }
            } else {
              var rad;
              if (itemData.s._mdf || itemData.e._mdf || isFirstFrame) {
                rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
                gfill.setAttribute("r", rad);
                if (hasOpacity && !itemData.g._collapsable) {
                  itemData.of.setAttribute("r", rad);
                }
              }
              if (itemData.e._mdf || itemData.h._mdf || itemData.a._mdf || isFirstFrame) {
                if (!rad) {
                  rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
                }
                var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
                var percent = itemData.h.v;
                if (percent >= 1) {
                  percent = 0.99;
                } else if (percent <= -1) {
                  percent = -0.99;
                }
                var dist = rad * percent;
                var x2 = Math.cos(ang + itemData.a.v) * dist + pt1[0];
                var y2 = Math.sin(ang + itemData.a.v) * dist + pt1[1];
                gfill.setAttribute("fx", x2);
                gfill.setAttribute("fy", y2);
                if (hasOpacity && !itemData.g._collapsable) {
                  itemData.of.setAttribute("fx", x2);
                  itemData.of.setAttribute("fy", y2);
                }
              }
            }
          }
          function renderStroke(styleData, itemData, isFirstFrame) {
            var styleElem = itemData.style;
            var d = itemData.d;
            if (d && (d._mdf || isFirstFrame) && d.dashStr) {
              styleElem.pElem.setAttribute("stroke-dasharray", d.dashStr);
              styleElem.pElem.setAttribute("stroke-dashoffset", d.dashoffset[0]);
            }
            if (itemData.c && (itemData.c._mdf || isFirstFrame)) {
              styleElem.pElem.setAttribute("stroke", "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")");
            }
            if (itemData.o._mdf || isFirstFrame) {
              styleElem.pElem.setAttribute("stroke-opacity", itemData.o.v);
            }
            if (itemData.w._mdf || isFirstFrame) {
              styleElem.pElem.setAttribute("stroke-width", itemData.w.v);
              if (styleElem.msElem) {
                styleElem.msElem.setAttribute("stroke-width", itemData.w.v);
              }
            }
          }
          return ob2;
        }();
        function SVGShapeElement(data2, globalData2, comp2) {
          this.shapes = [];
          this.shapesData = data2.shapes;
          this.stylesList = [];
          this.shapeModifiers = [];
          this.itemsData = [];
          this.processedElements = [];
          this.animatedContents = [];
          this.initElement(data2, globalData2, comp2);
          this.prevViewData = [];
        }
        extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement);
        SVGShapeElement.prototype.initSecondaryElement = function() {
        };
        SVGShapeElement.prototype.identityMatrix = new Matrix();
        SVGShapeElement.prototype.buildExpressionInterface = function() {
        };
        SVGShapeElement.prototype.createContent = function() {
          this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
          this.filterUniqueShapes();
        };
        SVGShapeElement.prototype.filterUniqueShapes = function() {
          var i2;
          var len = this.shapes.length;
          var shape;
          var j;
          var jLen = this.stylesList.length;
          var style;
          var tempShapes = [];
          var areAnimated = false;
          for (j = 0; j < jLen; j += 1) {
            style = this.stylesList[j];
            areAnimated = false;
            tempShapes.length = 0;
            for (i2 = 0; i2 < len; i2 += 1) {
              shape = this.shapes[i2];
              if (shape.styles.indexOf(style) !== -1) {
                tempShapes.push(shape);
                areAnimated = shape._isAnimated || areAnimated;
              }
            }
            if (tempShapes.length > 1 && areAnimated) {
              this.setShapesAsAnimated(tempShapes);
            }
          }
        };
        SVGShapeElement.prototype.setShapesAsAnimated = function(shapes) {
          var i2;
          var len = shapes.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            shapes[i2].setAsAnimated();
          }
        };
        SVGShapeElement.prototype.createStyleElement = function(data2, level) {
          var elementData;
          var styleOb = new SVGStyleData(data2, level);
          var pathElement = styleOb.pElem;
          if (data2.ty === "st") {
            elementData = new SVGStrokeStyleData(this, data2, styleOb);
          } else if (data2.ty === "fl") {
            elementData = new SVGFillStyleData(this, data2, styleOb);
          } else if (data2.ty === "gf" || data2.ty === "gs") {
            var GradientConstructor = data2.ty === "gf" ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;
            elementData = new GradientConstructor(this, data2, styleOb);
            this.globalData.defs.appendChild(elementData.gf);
            if (elementData.maskId) {
              this.globalData.defs.appendChild(elementData.ms);
              this.globalData.defs.appendChild(elementData.of);
              pathElement.setAttribute("mask", "url(" + getLocationHref() + "#" + elementData.maskId + ")");
            }
          } else if (data2.ty === "no") {
            elementData = new SVGNoStyleData(this, data2, styleOb);
          }
          if (data2.ty === "st" || data2.ty === "gs") {
            pathElement.setAttribute("stroke-linecap", lineCapEnum[data2.lc || 2]);
            pathElement.setAttribute("stroke-linejoin", lineJoinEnum[data2.lj || 2]);
            pathElement.setAttribute("fill-opacity", "0");
            if (data2.lj === 1) {
              pathElement.setAttribute("stroke-miterlimit", data2.ml);
            }
          }
          if (data2.r === 2) {
            pathElement.setAttribute("fill-rule", "evenodd");
          }
          if (data2.ln) {
            pathElement.setAttribute("id", data2.ln);
          }
          if (data2.cl) {
            pathElement.setAttribute("class", data2.cl);
          }
          if (data2.bm) {
            pathElement.style["mix-blend-mode"] = getBlendMode(data2.bm);
          }
          this.stylesList.push(styleOb);
          this.addToAnimatedContents(data2, elementData);
          return elementData;
        };
        SVGShapeElement.prototype.createGroupElement = function(data2) {
          var elementData = new ShapeGroupData();
          if (data2.ln) {
            elementData.gr.setAttribute("id", data2.ln);
          }
          if (data2.cl) {
            elementData.gr.setAttribute("class", data2.cl);
          }
          if (data2.bm) {
            elementData.gr.style["mix-blend-mode"] = getBlendMode(data2.bm);
          }
          return elementData;
        };
        SVGShapeElement.prototype.createTransformElement = function(data2, container2) {
          var transformProperty = TransformPropertyFactory.getTransformProperty(this, data2, this);
          var elementData = new SVGTransformData(transformProperty, transformProperty.o, container2);
          this.addToAnimatedContents(data2, elementData);
          return elementData;
        };
        SVGShapeElement.prototype.createShapeElement = function(data2, ownTransformers, level) {
          var ty = 4;
          if (data2.ty === "rc") {
            ty = 5;
          } else if (data2.ty === "el") {
            ty = 6;
          } else if (data2.ty === "sr") {
            ty = 7;
          }
          var shapeProperty = ShapePropertyFactory.getShapeProp(this, data2, ty, this);
          var elementData = new SVGShapeData(ownTransformers, level, shapeProperty);
          this.shapes.push(elementData);
          this.addShapeToModifiers(elementData);
          this.addToAnimatedContents(data2, elementData);
          return elementData;
        };
        SVGShapeElement.prototype.addToAnimatedContents = function(data2, element) {
          var i2 = 0;
          var len = this.animatedContents.length;
          while (i2 < len) {
            if (this.animatedContents[i2].element === element) {
              return;
            }
            i2 += 1;
          }
          this.animatedContents.push({
            fn: SVGElementsRenderer.createRenderFunction(data2),
            element,
            data: data2
          });
        };
        SVGShapeElement.prototype.setElementStyles = function(elementData) {
          var arr2 = elementData.styles;
          var j;
          var jLen = this.stylesList.length;
          for (j = 0; j < jLen; j += 1) {
            if (!this.stylesList[j].closed) {
              arr2.push(this.stylesList[j]);
            }
          }
        };
        SVGShapeElement.prototype.reloadShapes = function() {
          this._isFirstFrame = true;
          var i2;
          var len = this.itemsData.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            this.prevViewData[i2] = this.itemsData[i2];
          }
          this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
          this.filterUniqueShapes();
          len = this.dynamicProperties.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            this.dynamicProperties[i2].getValue();
          }
          this.renderModifiers();
        };
        SVGShapeElement.prototype.searchShapes = function(arr2, itemsData, prevViewData, container2, level, transformers, render) {
          var ownTransformers = [].concat(transformers);
          var i2;
          var len = arr2.length - 1;
          var j;
          var jLen;
          var ownStyles = [];
          var ownModifiers = [];
          var currentTransform;
          var modifier;
          var processedPos;
          for (i2 = len; i2 >= 0; i2 -= 1) {
            processedPos = this.searchProcessedElement(arr2[i2]);
            if (!processedPos) {
              arr2[i2]._render = render;
            } else {
              itemsData[i2] = prevViewData[processedPos - 1];
            }
            if (arr2[i2].ty === "fl" || arr2[i2].ty === "st" || arr2[i2].ty === "gf" || arr2[i2].ty === "gs" || arr2[i2].ty === "no") {
              if (!processedPos) {
                itemsData[i2] = this.createStyleElement(arr2[i2], level);
              } else {
                itemsData[i2].style.closed = false;
              }
              if (arr2[i2]._render) {
                if (itemsData[i2].style.pElem.parentNode !== container2) {
                  container2.appendChild(itemsData[i2].style.pElem);
                }
              }
              ownStyles.push(itemsData[i2].style);
            } else if (arr2[i2].ty === "gr") {
              if (!processedPos) {
                itemsData[i2] = this.createGroupElement(arr2[i2]);
              } else {
                jLen = itemsData[i2].it.length;
                for (j = 0; j < jLen; j += 1) {
                  itemsData[i2].prevViewData[j] = itemsData[i2].it[j];
                }
              }
              this.searchShapes(arr2[i2].it, itemsData[i2].it, itemsData[i2].prevViewData, itemsData[i2].gr, level + 1, ownTransformers, render);
              if (arr2[i2]._render) {
                if (itemsData[i2].gr.parentNode !== container2) {
                  container2.appendChild(itemsData[i2].gr);
                }
              }
            } else if (arr2[i2].ty === "tr") {
              if (!processedPos) {
                itemsData[i2] = this.createTransformElement(arr2[i2], container2);
              }
              currentTransform = itemsData[i2].transform;
              ownTransformers.push(currentTransform);
            } else if (arr2[i2].ty === "sh" || arr2[i2].ty === "rc" || arr2[i2].ty === "el" || arr2[i2].ty === "sr") {
              if (!processedPos) {
                itemsData[i2] = this.createShapeElement(arr2[i2], ownTransformers, level);
              }
              this.setElementStyles(itemsData[i2]);
            } else if (arr2[i2].ty === "tm" || arr2[i2].ty === "rd" || arr2[i2].ty === "ms" || arr2[i2].ty === "pb" || arr2[i2].ty === "zz" || arr2[i2].ty === "op") {
              if (!processedPos) {
                modifier = ShapeModifiers.getModifier(arr2[i2].ty);
                modifier.init(this, arr2[i2]);
                itemsData[i2] = modifier;
                this.shapeModifiers.push(modifier);
              } else {
                modifier = itemsData[i2];
                modifier.closed = false;
              }
              ownModifiers.push(modifier);
            } else if (arr2[i2].ty === "rp") {
              if (!processedPos) {
                modifier = ShapeModifiers.getModifier(arr2[i2].ty);
                itemsData[i2] = modifier;
                modifier.init(this, arr2, i2, itemsData);
                this.shapeModifiers.push(modifier);
                render = false;
              } else {
                modifier = itemsData[i2];
                modifier.closed = true;
              }
              ownModifiers.push(modifier);
            }
            this.addProcessedElement(arr2[i2], i2 + 1);
          }
          len = ownStyles.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            ownStyles[i2].closed = true;
          }
          len = ownModifiers.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            ownModifiers[i2].closed = true;
          }
        };
        SVGShapeElement.prototype.renderInnerContent = function() {
          this.renderModifiers();
          var i2;
          var len = this.stylesList.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            this.stylesList[i2].reset();
          }
          this.renderShape();
          for (i2 = 0; i2 < len; i2 += 1) {
            if (this.stylesList[i2]._mdf || this._isFirstFrame) {
              if (this.stylesList[i2].msElem) {
                this.stylesList[i2].msElem.setAttribute("d", this.stylesList[i2].d);
                this.stylesList[i2].d = "M0 0" + this.stylesList[i2].d;
              }
              this.stylesList[i2].pElem.setAttribute("d", this.stylesList[i2].d || "M0 0");
            }
          }
        };
        SVGShapeElement.prototype.renderShape = function() {
          var i2;
          var len = this.animatedContents.length;
          var animatedContent;
          for (i2 = 0; i2 < len; i2 += 1) {
            animatedContent = this.animatedContents[i2];
            if ((this._isFirstFrame || animatedContent.element._isAnimated) && animatedContent.data !== true) {
              animatedContent.fn(animatedContent.data, animatedContent.element, this._isFirstFrame);
            }
          }
        };
        SVGShapeElement.prototype.destroy = function() {
          this.destroyBaseElement();
          this.shapesData = null;
          this.itemsData = null;
        };
        function LetterProps(o, sw, sc2, fc2, m2, p2) {
          this.o = o;
          this.sw = sw;
          this.sc = sc2;
          this.fc = fc2;
          this.m = m2;
          this.p = p2;
          this._mdf = {
            o: true,
            sw: !!sw,
            sc: !!sc2,
            fc: !!fc2,
            m: true,
            p: true
          };
        }
        LetterProps.prototype.update = function(o, sw, sc2, fc2, m2, p2) {
          this._mdf.o = false;
          this._mdf.sw = false;
          this._mdf.sc = false;
          this._mdf.fc = false;
          this._mdf.m = false;
          this._mdf.p = false;
          var updated = false;
          if (this.o !== o) {
            this.o = o;
            this._mdf.o = true;
            updated = true;
          }
          if (this.sw !== sw) {
            this.sw = sw;
            this._mdf.sw = true;
            updated = true;
          }
          if (this.sc !== sc2) {
            this.sc = sc2;
            this._mdf.sc = true;
            updated = true;
          }
          if (this.fc !== fc2) {
            this.fc = fc2;
            this._mdf.fc = true;
            updated = true;
          }
          if (this.m !== m2) {
            this.m = m2;
            this._mdf.m = true;
            updated = true;
          }
          if (p2.length && (this.p[0] !== p2[0] || this.p[1] !== p2[1] || this.p[4] !== p2[4] || this.p[5] !== p2[5] || this.p[12] !== p2[12] || this.p[13] !== p2[13])) {
            this.p = p2;
            this._mdf.p = true;
            updated = true;
          }
          return updated;
        };
        function TextProperty(elem2, data2) {
          this._frameId = initialDefaultFrame;
          this.pv = "";
          this.v = "";
          this.kf = false;
          this._isFirstFrame = true;
          this._mdf = false;
          if (data2.d && data2.d.sid) {
            data2.d = elem2.globalData.slotManager.getProp(data2.d);
          }
          this.data = data2;
          this.elem = elem2;
          this.comp = this.elem.comp;
          this.keysIndex = 0;
          this.canResize = false;
          this.minimumFontSize = 1;
          this.effectsSequence = [];
          this.currentData = {
            ascent: 0,
            boxWidth: this.defaultBoxWidth,
            f: "",
            fStyle: "",
            fWeight: "",
            fc: "",
            j: "",
            justifyOffset: "",
            l: [],
            lh: 0,
            lineWidths: [],
            ls: "",
            of: "",
            s: "",
            sc: "",
            sw: 0,
            t: 0,
            tr: 0,
            sz: 0,
            ps: null,
            fillColorAnim: false,
            strokeColorAnim: false,
            strokeWidthAnim: false,
            yOffset: 0,
            finalSize: 0,
            finalText: [],
            finalLineHeight: 0,
            __complete: false
          };
          this.copyData(this.currentData, this.data.d.k[0].s);
          if (!this.searchProperty()) {
            this.completeTextData(this.currentData);
          }
        }
        TextProperty.prototype.defaultBoxWidth = [0, 0];
        TextProperty.prototype.copyData = function(obj, data2) {
          for (var s2 in data2) {
            if (Object.prototype.hasOwnProperty.call(data2, s2)) {
              obj[s2] = data2[s2];
            }
          }
          return obj;
        };
        TextProperty.prototype.setCurrentData = function(data2) {
          if (!data2.__complete) {
            this.completeTextData(data2);
          }
          this.currentData = data2;
          this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth;
          this._mdf = true;
        };
        TextProperty.prototype.searchProperty = function() {
          return this.searchKeyframes();
        };
        TextProperty.prototype.searchKeyframes = function() {
          this.kf = this.data.d.k.length > 1;
          if (this.kf) {
            this.addEffect(this.getKeyframeValue.bind(this));
          }
          return this.kf;
        };
        TextProperty.prototype.addEffect = function(effectFunction) {
          this.effectsSequence.push(effectFunction);
          this.elem.addDynamicProperty(this);
        };
        TextProperty.prototype.getValue = function(_finalValue) {
          if ((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !_finalValue) {
            return;
          }
          this.currentData.t = this.data.d.k[this.keysIndex].s.t;
          var currentValue = this.currentData;
          var currentIndex = this.keysIndex;
          if (this.lock) {
            this.setCurrentData(this.currentData);
            return;
          }
          this.lock = true;
          this._mdf = false;
          var i2;
          var len = this.effectsSequence.length;
          var finalValue = _finalValue || this.data.d.k[this.keysIndex].s;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (currentIndex !== this.keysIndex) {
              finalValue = this.effectsSequence[i2](finalValue, finalValue.t);
            } else {
              finalValue = this.effectsSequence[i2](this.currentData, finalValue.t);
            }
          }
          if (currentValue !== finalValue) {
            this.setCurrentData(finalValue);
          }
          this.v = this.currentData;
          this.pv = this.v;
          this.lock = false;
          this.frameId = this.elem.globalData.frameId;
        };
        TextProperty.prototype.getKeyframeValue = function() {
          var textKeys = this.data.d.k;
          var frameNum = this.elem.comp.renderedFrame;
          var i2 = 0;
          var len = textKeys.length;
          while (i2 <= len - 1) {
            if (i2 === len - 1 || textKeys[i2 + 1].t > frameNum) {
              break;
            }
            i2 += 1;
          }
          if (this.keysIndex !== i2) {
            this.keysIndex = i2;
          }
          return this.data.d.k[this.keysIndex].s;
        };
        TextProperty.prototype.buildFinalText = function(text2) {
          var charactersArray = [];
          var i2 = 0;
          var len = text2.length;
          var charCode;
          var secondCharCode;
          var shouldCombine = false;
          var shouldCombineNext = false;
          var currentChars = "";
          while (i2 < len) {
            shouldCombine = shouldCombineNext;
            shouldCombineNext = false;
            charCode = text2.charCodeAt(i2);
            currentChars = text2.charAt(i2);
            if (FontManager.isCombinedCharacter(charCode)) {
              shouldCombine = true;
            } else if (charCode >= 55296 && charCode <= 56319) {
              if (FontManager.isRegionalFlag(text2, i2)) {
                currentChars = text2.substr(i2, 14);
              } else {
                secondCharCode = text2.charCodeAt(i2 + 1);
                if (secondCharCode >= 56320 && secondCharCode <= 57343) {
                  if (FontManager.isModifier(charCode, secondCharCode)) {
                    currentChars = text2.substr(i2, 2);
                    shouldCombine = true;
                  } else if (FontManager.isFlagEmoji(text2.substr(i2, 4))) {
                    currentChars = text2.substr(i2, 4);
                  } else {
                    currentChars = text2.substr(i2, 2);
                  }
                }
              }
            } else if (charCode > 56319) {
              secondCharCode = text2.charCodeAt(i2 + 1);
              if (FontManager.isVariationSelector(charCode)) {
                shouldCombine = true;
              }
            } else if (FontManager.isZeroWidthJoiner(charCode)) {
              shouldCombine = true;
              shouldCombineNext = true;
            }
            if (shouldCombine) {
              charactersArray[charactersArray.length - 1] += currentChars;
              shouldCombine = false;
            } else {
              charactersArray.push(currentChars);
            }
            i2 += currentChars.length;
          }
          return charactersArray;
        };
        TextProperty.prototype.completeTextData = function(documentData) {
          documentData.__complete = true;
          var fontManager = this.elem.globalData.fontManager;
          var data2 = this.data;
          var letters = [];
          var i2;
          var len;
          var newLineFlag;
          var index2 = 0;
          var val2;
          var anchorGrouping = data2.m.g;
          var currentSize = 0;
          var currentPos = 0;
          var currentLine = 0;
          var lineWidths = [];
          var lineWidth = 0;
          var maxLineWidth = 0;
          var j;
          var jLen;
          var fontData = fontManager.getFontByName(documentData.f);
          var charData;
          var cLength = 0;
          var fontProps = getFontProperties(fontData);
          documentData.fWeight = fontProps.weight;
          documentData.fStyle = fontProps.style;
          documentData.finalSize = documentData.s;
          documentData.finalText = this.buildFinalText(documentData.t);
          len = documentData.finalText.length;
          documentData.finalLineHeight = documentData.lh;
          var trackingOffset = documentData.tr / 1e3 * documentData.finalSize;
          var charCode;
          if (documentData.sz) {
            var flag = true;
            var boxWidth = documentData.sz[0];
            var boxHeight = documentData.sz[1];
            var currentHeight;
            var finalText;
            while (flag) {
              finalText = this.buildFinalText(documentData.t);
              currentHeight = 0;
              lineWidth = 0;
              len = finalText.length;
              trackingOffset = documentData.tr / 1e3 * documentData.finalSize;
              var lastSpaceIndex = -1;
              for (i2 = 0; i2 < len; i2 += 1) {
                charCode = finalText[i2].charCodeAt(0);
                newLineFlag = false;
                if (finalText[i2] === " ") {
                  lastSpaceIndex = i2;
                } else if (charCode === 13 || charCode === 3) {
                  lineWidth = 0;
                  newLineFlag = true;
                  currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
                }
                if (fontManager.chars) {
                  charData = fontManager.getCharData(finalText[i2], fontData.fStyle, fontData.fFamily);
                  cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;
                } else {
                  cLength = fontManager.measureText(finalText[i2], documentData.f, documentData.finalSize);
                }
                if (lineWidth + cLength > boxWidth && finalText[i2] !== " ") {
                  if (lastSpaceIndex === -1) {
                    len += 1;
                  } else {
                    i2 = lastSpaceIndex;
                  }
                  currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
                  finalText.splice(i2, lastSpaceIndex === i2 ? 1 : 0, "\r");
                  lastSpaceIndex = -1;
                  lineWidth = 0;
                } else {
                  lineWidth += cLength;
                  lineWidth += trackingOffset;
                }
              }
              currentHeight += fontData.ascent * documentData.finalSize / 100;
              if (this.canResize && documentData.finalSize > this.minimumFontSize && boxHeight < currentHeight) {
                documentData.finalSize -= 1;
                documentData.finalLineHeight = documentData.finalSize * documentData.lh / documentData.s;
              } else {
                documentData.finalText = finalText;
                len = documentData.finalText.length;
                flag = false;
              }
            }
          }
          lineWidth = -trackingOffset;
          cLength = 0;
          var uncollapsedSpaces = 0;
          var currentChar;
          for (i2 = 0; i2 < len; i2 += 1) {
            newLineFlag = false;
            currentChar = documentData.finalText[i2];
            charCode = currentChar.charCodeAt(0);
            if (charCode === 13 || charCode === 3) {
              uncollapsedSpaces = 0;
              lineWidths.push(lineWidth);
              maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
              lineWidth = -2 * trackingOffset;
              val2 = "";
              newLineFlag = true;
              currentLine += 1;
            } else {
              val2 = currentChar;
            }
            if (fontManager.chars) {
              charData = fontManager.getCharData(currentChar, fontData.fStyle, fontManager.getFontByName(documentData.f).fFamily);
              cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;
            } else {
              cLength = fontManager.measureText(val2, documentData.f, documentData.finalSize);
            }
            if (currentChar === " ") {
              uncollapsedSpaces += cLength + trackingOffset;
            } else {
              lineWidth += cLength + trackingOffset + uncollapsedSpaces;
              uncollapsedSpaces = 0;
            }
            letters.push({
              l: cLength,
              an: cLength,
              add: currentSize,
              n: newLineFlag,
              anIndexes: [],
              val: val2,
              line: currentLine,
              animatorJustifyOffset: 0
            });
            if (anchorGrouping == 2) {
              currentSize += cLength;
              if (val2 === "" || val2 === " " || i2 === len - 1) {
                if (val2 === "" || val2 === " ") {
                  currentSize -= cLength;
                }
                while (currentPos <= i2) {
                  letters[currentPos].an = currentSize;
                  letters[currentPos].ind = index2;
                  letters[currentPos].extra = cLength;
                  currentPos += 1;
                }
                index2 += 1;
                currentSize = 0;
              }
            } else if (anchorGrouping == 3) {
              currentSize += cLength;
              if (val2 === "" || i2 === len - 1) {
                if (val2 === "") {
                  currentSize -= cLength;
                }
                while (currentPos <= i2) {
                  letters[currentPos].an = currentSize;
                  letters[currentPos].ind = index2;
                  letters[currentPos].extra = cLength;
                  currentPos += 1;
                }
                currentSize = 0;
                index2 += 1;
              }
            } else {
              letters[index2].ind = index2;
              letters[index2].extra = 0;
              index2 += 1;
            }
          }
          documentData.l = letters;
          maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
          lineWidths.push(lineWidth);
          if (documentData.sz) {
            documentData.boxWidth = documentData.sz[0];
            documentData.justifyOffset = 0;
          } else {
            documentData.boxWidth = maxLineWidth;
            switch (documentData.j) {
              case 1:
                documentData.justifyOffset = -documentData.boxWidth;
                break;
              case 2:
                documentData.justifyOffset = -documentData.boxWidth / 2;
                break;
              default:
                documentData.justifyOffset = 0;
            }
          }
          documentData.lineWidths = lineWidths;
          var animators = data2.a;
          var animatorData;
          var letterData;
          jLen = animators.length;
          var based;
          var ind;
          var indexes = [];
          for (j = 0; j < jLen; j += 1) {
            animatorData = animators[j];
            if (animatorData.a.sc) {
              documentData.strokeColorAnim = true;
            }
            if (animatorData.a.sw) {
              documentData.strokeWidthAnim = true;
            }
            if (animatorData.a.fc || animatorData.a.fh || animatorData.a.fs || animatorData.a.fb) {
              documentData.fillColorAnim = true;
            }
            ind = 0;
            based = animatorData.s.b;
            for (i2 = 0; i2 < len; i2 += 1) {
              letterData = letters[i2];
              letterData.anIndexes[j] = ind;
              if (based == 1 && letterData.val !== "" || based == 2 && letterData.val !== "" && letterData.val !== " " || based == 3 && (letterData.n || letterData.val == " " || i2 == len - 1) || based == 4 && (letterData.n || i2 == len - 1)) {
                if (animatorData.s.rn === 1) {
                  indexes.push(ind);
                }
                ind += 1;
              }
            }
            data2.a[j].s.totalChars = ind;
            var currentInd = -1;
            var newInd;
            if (animatorData.s.rn === 1) {
              for (i2 = 0; i2 < len; i2 += 1) {
                letterData = letters[i2];
                if (currentInd != letterData.anIndexes[j]) {
                  currentInd = letterData.anIndexes[j];
                  newInd = indexes.splice(Math.floor(Math.random() * indexes.length), 1)[0];
                }
                letterData.anIndexes[j] = newInd;
              }
            }
          }
          documentData.yOffset = documentData.finalLineHeight || documentData.finalSize * 1.2;
          documentData.ls = documentData.ls || 0;
          documentData.ascent = fontData.ascent * documentData.finalSize / 100;
        };
        TextProperty.prototype.updateDocumentData = function(newData, index2) {
          index2 = index2 === void 0 ? this.keysIndex : index2;
          var dData = this.copyData({}, this.data.d.k[index2].s);
          dData = this.copyData(dData, newData);
          this.data.d.k[index2].s = dData;
          this.recalculate(index2);
          this.setCurrentData(dData);
          this.elem.addDynamicProperty(this);
        };
        TextProperty.prototype.recalculate = function(index2) {
          var dData = this.data.d.k[index2].s;
          dData.__complete = false;
          this.keysIndex = 0;
          this._isFirstFrame = true;
          this.getValue(dData);
        };
        TextProperty.prototype.canResizeFont = function(_canResize) {
          this.canResize = _canResize;
          this.recalculate(this.keysIndex);
          this.elem.addDynamicProperty(this);
        };
        TextProperty.prototype.setMinimumFontSize = function(_fontValue) {
          this.minimumFontSize = Math.floor(_fontValue) || 1;
          this.recalculate(this.keysIndex);
          this.elem.addDynamicProperty(this);
        };
        var TextSelectorProp = function() {
          var max = Math.max;
          var min = Math.min;
          var floor = Math.floor;
          function TextSelectorPropFactory(elem2, data2) {
            this._currentTextLength = -1;
            this.k = false;
            this.data = data2;
            this.elem = elem2;
            this.comp = elem2.comp;
            this.finalS = 0;
            this.finalE = 0;
            this.initDynamicPropertyContainer(elem2);
            this.s = PropertyFactory.getProp(elem2, data2.s || {
              k: 0
            }, 0, 0, this);
            if ("e" in data2) {
              this.e = PropertyFactory.getProp(elem2, data2.e, 0, 0, this);
            } else {
              this.e = {
                v: 100
              };
            }
            this.o = PropertyFactory.getProp(elem2, data2.o || {
              k: 0
            }, 0, 0, this);
            this.xe = PropertyFactory.getProp(elem2, data2.xe || {
              k: 0
            }, 0, 0, this);
            this.ne = PropertyFactory.getProp(elem2, data2.ne || {
              k: 0
            }, 0, 0, this);
            this.sm = PropertyFactory.getProp(elem2, data2.sm || {
              k: 100
            }, 0, 0, this);
            this.a = PropertyFactory.getProp(elem2, data2.a, 0, 0.01, this);
            if (!this.dynamicProperties.length) {
              this.getValue();
            }
          }
          TextSelectorPropFactory.prototype = {
            getMult: function getMult(ind) {
              if (this._currentTextLength !== this.elem.textProperty.currentData.l.length) {
                this.getValue();
              }
              var x1 = 0;
              var y1 = 0;
              var x2 = 1;
              var y2 = 1;
              if (this.ne.v > 0) {
                x1 = this.ne.v / 100;
              } else {
                y1 = -this.ne.v / 100;
              }
              if (this.xe.v > 0) {
                x2 = 1 - this.xe.v / 100;
              } else {
                y2 = 1 + this.xe.v / 100;
              }
              var easer = BezierFactory.getBezierEasing(x1, y1, x2, y2).get;
              var mult = 0;
              var s2 = this.finalS;
              var e2 = this.finalE;
              var type = this.data.sh;
              if (type === 2) {
                if (e2 === s2) {
                  mult = ind >= e2 ? 1 : 0;
                } else {
                  mult = max(0, min(0.5 / (e2 - s2) + (ind - s2) / (e2 - s2), 1));
                }
                mult = easer(mult);
              } else if (type === 3) {
                if (e2 === s2) {
                  mult = ind >= e2 ? 0 : 1;
                } else {
                  mult = 1 - max(0, min(0.5 / (e2 - s2) + (ind - s2) / (e2 - s2), 1));
                }
                mult = easer(mult);
              } else if (type === 4) {
                if (e2 === s2) {
                  mult = 0;
                } else {
                  mult = max(0, min(0.5 / (e2 - s2) + (ind - s2) / (e2 - s2), 1));
                  if (mult < 0.5) {
                    mult *= 2;
                  } else {
                    mult = 1 - 2 * (mult - 0.5);
                  }
                }
                mult = easer(mult);
              } else if (type === 5) {
                if (e2 === s2) {
                  mult = 0;
                } else {
                  var tot = e2 - s2;
                  ind = min(max(0, ind + 0.5 - s2), e2 - s2);
                  var x3 = -tot / 2 + ind;
                  var a2 = tot / 2;
                  mult = Math.sqrt(1 - x3 * x3 / (a2 * a2));
                }
                mult = easer(mult);
              } else if (type === 6) {
                if (e2 === s2) {
                  mult = 0;
                } else {
                  ind = min(max(0, ind + 0.5 - s2), e2 - s2);
                  mult = (1 + Math.cos(Math.PI + Math.PI * 2 * ind / (e2 - s2))) / 2;
                }
                mult = easer(mult);
              } else {
                if (ind >= floor(s2)) {
                  if (ind - s2 < 0) {
                    mult = max(0, min(min(e2, 1) - (s2 - ind), 1));
                  } else {
                    mult = max(0, min(e2 - ind, 1));
                  }
                }
                mult = easer(mult);
              }
              if (this.sm.v !== 100) {
                var smoothness = this.sm.v * 0.01;
                if (smoothness === 0) {
                  smoothness = 1e-8;
                }
                var threshold = 0.5 - smoothness * 0.5;
                if (mult < threshold) {
                  mult = 0;
                } else {
                  mult = (mult - threshold) / smoothness;
                  if (mult > 1) {
                    mult = 1;
                  }
                }
              }
              return mult * this.a.v;
            },
            getValue: function getValue2(newCharsFlag) {
              this.iterateDynamicProperties();
              this._mdf = newCharsFlag || this._mdf;
              this._currentTextLength = this.elem.textProperty.currentData.l.length || 0;
              if (newCharsFlag && this.data.r === 2) {
                this.e.v = this._currentTextLength;
              }
              var divisor = this.data.r === 2 ? 1 : 100 / this.data.totalChars;
              var o = this.o.v / divisor;
              var s2 = this.s.v / divisor + o;
              var e2 = this.e.v / divisor + o;
              if (s2 > e2) {
                var _s = s2;
                s2 = e2;
                e2 = _s;
              }
              this.finalS = s2;
              this.finalE = e2;
            }
          };
          extendPrototype([DynamicPropertyContainer], TextSelectorPropFactory);
          function getTextSelectorProp(elem2, data2, arr2) {
            return new TextSelectorPropFactory(elem2, data2);
          }
          return {
            getTextSelectorProp
          };
        }();
        function TextAnimatorDataProperty(elem2, animatorProps, container2) {
          var defaultData = {
            propType: false
          };
          var getProp = PropertyFactory.getProp;
          var textAnimatorAnimatables = animatorProps.a;
          this.a = {
            r: textAnimatorAnimatables.r ? getProp(elem2, textAnimatorAnimatables.r, 0, degToRads, container2) : defaultData,
            rx: textAnimatorAnimatables.rx ? getProp(elem2, textAnimatorAnimatables.rx, 0, degToRads, container2) : defaultData,
            ry: textAnimatorAnimatables.ry ? getProp(elem2, textAnimatorAnimatables.ry, 0, degToRads, container2) : defaultData,
            sk: textAnimatorAnimatables.sk ? getProp(elem2, textAnimatorAnimatables.sk, 0, degToRads, container2) : defaultData,
            sa: textAnimatorAnimatables.sa ? getProp(elem2, textAnimatorAnimatables.sa, 0, degToRads, container2) : defaultData,
            s: textAnimatorAnimatables.s ? getProp(elem2, textAnimatorAnimatables.s, 1, 0.01, container2) : defaultData,
            a: textAnimatorAnimatables.a ? getProp(elem2, textAnimatorAnimatables.a, 1, 0, container2) : defaultData,
            o: textAnimatorAnimatables.o ? getProp(elem2, textAnimatorAnimatables.o, 0, 0.01, container2) : defaultData,
            p: textAnimatorAnimatables.p ? getProp(elem2, textAnimatorAnimatables.p, 1, 0, container2) : defaultData,
            sw: textAnimatorAnimatables.sw ? getProp(elem2, textAnimatorAnimatables.sw, 0, 0, container2) : defaultData,
            sc: textAnimatorAnimatables.sc ? getProp(elem2, textAnimatorAnimatables.sc, 1, 0, container2) : defaultData,
            fc: textAnimatorAnimatables.fc ? getProp(elem2, textAnimatorAnimatables.fc, 1, 0, container2) : defaultData,
            fh: textAnimatorAnimatables.fh ? getProp(elem2, textAnimatorAnimatables.fh, 0, 0, container2) : defaultData,
            fs: textAnimatorAnimatables.fs ? getProp(elem2, textAnimatorAnimatables.fs, 0, 0.01, container2) : defaultData,
            fb: textAnimatorAnimatables.fb ? getProp(elem2, textAnimatorAnimatables.fb, 0, 0.01, container2) : defaultData,
            t: textAnimatorAnimatables.t ? getProp(elem2, textAnimatorAnimatables.t, 0, 0, container2) : defaultData
          };
          this.s = TextSelectorProp.getTextSelectorProp(elem2, animatorProps.s, container2);
          this.s.t = animatorProps.s.t;
        }
        function TextAnimatorProperty(textData, renderType, elem2) {
          this._isFirstFrame = true;
          this._hasMaskedPath = false;
          this._frameId = -1;
          this._textData = textData;
          this._renderType = renderType;
          this._elem = elem2;
          this._animatorsData = createSizedArray(this._textData.a.length);
          this._pathData = {};
          this._moreOptions = {
            alignment: {}
          };
          this.renderedLetters = [];
          this.lettersChangedFlag = false;
          this.initDynamicPropertyContainer(elem2);
        }
        TextAnimatorProperty.prototype.searchProperties = function() {
          var i2;
          var len = this._textData.a.length;
          var animatorProps;
          var getProp = PropertyFactory.getProp;
          for (i2 = 0; i2 < len; i2 += 1) {
            animatorProps = this._textData.a[i2];
            this._animatorsData[i2] = new TextAnimatorDataProperty(this._elem, animatorProps, this);
          }
          if (this._textData.p && "m" in this._textData.p) {
            this._pathData = {
              a: getProp(this._elem, this._textData.p.a, 0, 0, this),
              f: getProp(this._elem, this._textData.p.f, 0, 0, this),
              l: getProp(this._elem, this._textData.p.l, 0, 0, this),
              r: getProp(this._elem, this._textData.p.r, 0, 0, this),
              p: getProp(this._elem, this._textData.p.p, 0, 0, this),
              m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
            };
            this._hasMaskedPath = true;
          } else {
            this._hasMaskedPath = false;
          }
          this._moreOptions.alignment = getProp(this._elem, this._textData.m.a, 1, 0, this);
        };
        TextAnimatorProperty.prototype.getMeasures = function(documentData, lettersChangedFlag) {
          this.lettersChangedFlag = lettersChangedFlag;
          if (!this._mdf && !this._isFirstFrame && !lettersChangedFlag && (!this._hasMaskedPath || !this._pathData.m._mdf)) {
            return;
          }
          this._isFirstFrame = false;
          var alignment = this._moreOptions.alignment.v;
          var animators = this._animatorsData;
          var textData = this._textData;
          var matrixHelper = this.mHelper;
          var renderType = this._renderType;
          var renderedLettersCount = this.renderedLetters.length;
          var xPos;
          var yPos;
          var i2;
          var len;
          var letters = documentData.l;
          var pathInfo;
          var currentLength;
          var currentPoint;
          var segmentLength;
          var flag;
          var pointInd;
          var segmentInd;
          var prevPoint;
          var points;
          var segments;
          var partialLength;
          var totalLength;
          var perc;
          var tanAngle;
          var mask2;
          if (this._hasMaskedPath) {
            mask2 = this._pathData.m;
            if (!this._pathData.n || this._pathData._mdf) {
              var paths = mask2.v;
              if (this._pathData.r.v) {
                paths = paths.reverse();
              }
              pathInfo = {
                tLength: 0,
                segments: []
              };
              len = paths._length - 1;
              var bezierData;
              totalLength = 0;
              for (i2 = 0; i2 < len; i2 += 1) {
                bezierData = bez.buildBezierData(paths.v[i2], paths.v[i2 + 1], [paths.o[i2][0] - paths.v[i2][0], paths.o[i2][1] - paths.v[i2][1]], [paths.i[i2 + 1][0] - paths.v[i2 + 1][0], paths.i[i2 + 1][1] - paths.v[i2 + 1][1]]);
                pathInfo.tLength += bezierData.segmentLength;
                pathInfo.segments.push(bezierData);
                totalLength += bezierData.segmentLength;
              }
              i2 = len;
              if (mask2.v.c) {
                bezierData = bez.buildBezierData(paths.v[i2], paths.v[0], [paths.o[i2][0] - paths.v[i2][0], paths.o[i2][1] - paths.v[i2][1]], [paths.i[0][0] - paths.v[0][0], paths.i[0][1] - paths.v[0][1]]);
                pathInfo.tLength += bezierData.segmentLength;
                pathInfo.segments.push(bezierData);
                totalLength += bezierData.segmentLength;
              }
              this._pathData.pi = pathInfo;
            }
            pathInfo = this._pathData.pi;
            currentLength = this._pathData.f.v;
            segmentInd = 0;
            pointInd = 1;
            segmentLength = 0;
            flag = true;
            segments = pathInfo.segments;
            if (currentLength < 0 && mask2.v.c) {
              if (pathInfo.tLength < Math.abs(currentLength)) {
                currentLength = -Math.abs(currentLength) % pathInfo.tLength;
              }
              segmentInd = segments.length - 1;
              points = segments[segmentInd].points;
              pointInd = points.length - 1;
              while (currentLength < 0) {
                currentLength += points[pointInd].partialLength;
                pointInd -= 1;
                if (pointInd < 0) {
                  segmentInd -= 1;
                  points = segments[segmentInd].points;
                  pointInd = points.length - 1;
                }
              }
            }
            points = segments[segmentInd].points;
            prevPoint = points[pointInd - 1];
            currentPoint = points[pointInd];
            partialLength = currentPoint.partialLength;
          }
          len = letters.length;
          xPos = 0;
          yPos = 0;
          var yOff = documentData.finalSize * 1.2 * 0.714;
          var firstLine = true;
          var animatorProps;
          var animatorSelector;
          var j;
          var jLen;
          var letterValue;
          jLen = animators.length;
          var mult;
          var ind = -1;
          var offf;
          var xPathPos;
          var yPathPos;
          var initPathPos = currentLength;
          var initSegmentInd = segmentInd;
          var initPointInd = pointInd;
          var currentLine = -1;
          var elemOpacity;
          var sc2;
          var sw;
          var fc2;
          var k2;
          var letterSw;
          var letterSc;
          var letterFc;
          var letterM = "";
          var letterP = this.defaultPropsArray;
          var letterO;
          if (documentData.j === 2 || documentData.j === 1) {
            var animatorJustifyOffset = 0;
            var animatorFirstCharOffset = 0;
            var justifyOffsetMult = documentData.j === 2 ? -0.5 : -1;
            var lastIndex = 0;
            var isNewLine = true;
            for (i2 = 0; i2 < len; i2 += 1) {
              if (letters[i2].n) {
                if (animatorJustifyOffset) {
                  animatorJustifyOffset += animatorFirstCharOffset;
                }
                while (lastIndex < i2) {
                  letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
                  lastIndex += 1;
                }
                animatorJustifyOffset = 0;
                isNewLine = true;
              } else {
                for (j = 0; j < jLen; j += 1) {
                  animatorProps = animators[j].a;
                  if (animatorProps.t.propType) {
                    if (isNewLine && documentData.j === 2) {
                      animatorFirstCharOffset += animatorProps.t.v * justifyOffsetMult;
                    }
                    animatorSelector = animators[j].s;
                    mult = animatorSelector.getMult(letters[i2].anIndexes[j], textData.a[j].s.totalChars);
                    if (mult.length) {
                      animatorJustifyOffset += animatorProps.t.v * mult[0] * justifyOffsetMult;
                    } else {
                      animatorJustifyOffset += animatorProps.t.v * mult * justifyOffsetMult;
                    }
                  }
                }
                isNewLine = false;
              }
            }
            if (animatorJustifyOffset) {
              animatorJustifyOffset += animatorFirstCharOffset;
            }
            while (lastIndex < i2) {
              letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
              lastIndex += 1;
            }
          }
          for (i2 = 0; i2 < len; i2 += 1) {
            matrixHelper.reset();
            elemOpacity = 1;
            if (letters[i2].n) {
              xPos = 0;
              yPos += documentData.yOffset;
              yPos += firstLine ? 1 : 0;
              currentLength = initPathPos;
              firstLine = false;
              if (this._hasMaskedPath) {
                segmentInd = initSegmentInd;
                pointInd = initPointInd;
                points = segments[segmentInd].points;
                prevPoint = points[pointInd - 1];
                currentPoint = points[pointInd];
                partialLength = currentPoint.partialLength;
                segmentLength = 0;
              }
              letterM = "";
              letterFc = "";
              letterSw = "";
              letterO = "";
              letterP = this.defaultPropsArray;
            } else {
              if (this._hasMaskedPath) {
                if (currentLine !== letters[i2].line) {
                  switch (documentData.j) {
                    case 1:
                      currentLength += totalLength - documentData.lineWidths[letters[i2].line];
                      break;
                    case 2:
                      currentLength += (totalLength - documentData.lineWidths[letters[i2].line]) / 2;
                      break;
                  }
                  currentLine = letters[i2].line;
                }
                if (ind !== letters[i2].ind) {
                  if (letters[ind]) {
                    currentLength += letters[ind].extra;
                  }
                  currentLength += letters[i2].an / 2;
                  ind = letters[i2].ind;
                }
                currentLength += alignment[0] * letters[i2].an * 5e-3;
                var animatorOffset = 0;
                for (j = 0; j < jLen; j += 1) {
                  animatorProps = animators[j].a;
                  if (animatorProps.p.propType) {
                    animatorSelector = animators[j].s;
                    mult = animatorSelector.getMult(letters[i2].anIndexes[j], textData.a[j].s.totalChars);
                    if (mult.length) {
                      animatorOffset += animatorProps.p.v[0] * mult[0];
                    } else {
                      animatorOffset += animatorProps.p.v[0] * mult;
                    }
                  }
                  if (animatorProps.a.propType) {
                    animatorSelector = animators[j].s;
                    mult = animatorSelector.getMult(letters[i2].anIndexes[j], textData.a[j].s.totalChars);
                    if (mult.length) {
                      animatorOffset += animatorProps.a.v[0] * mult[0];
                    } else {
                      animatorOffset += animatorProps.a.v[0] * mult;
                    }
                  }
                }
                flag = true;
                if (this._pathData.a.v) {
                  currentLength = letters[0].an * 0.5 + (totalLength - this._pathData.f.v - letters[0].an * 0.5 - letters[letters.length - 1].an * 0.5) * ind / (len - 1);
                  currentLength += this._pathData.f.v;
                }
                while (flag) {
                  if (segmentLength + partialLength >= currentLength + animatorOffset || !points) {
                    perc = (currentLength + animatorOffset - segmentLength) / currentPoint.partialLength;
                    xPathPos = prevPoint.point[0] + (currentPoint.point[0] - prevPoint.point[0]) * perc;
                    yPathPos = prevPoint.point[1] + (currentPoint.point[1] - prevPoint.point[1]) * perc;
                    matrixHelper.translate(-alignment[0] * letters[i2].an * 5e-3, -(alignment[1] * yOff) * 0.01);
                    flag = false;
                  } else if (points) {
                    segmentLength += currentPoint.partialLength;
                    pointInd += 1;
                    if (pointInd >= points.length) {
                      pointInd = 0;
                      segmentInd += 1;
                      if (!segments[segmentInd]) {
                        if (mask2.v.c) {
                          pointInd = 0;
                          segmentInd = 0;
                          points = segments[segmentInd].points;
                        } else {
                          segmentLength -= currentPoint.partialLength;
                          points = null;
                        }
                      } else {
                        points = segments[segmentInd].points;
                      }
                    }
                    if (points) {
                      prevPoint = currentPoint;
                      currentPoint = points[pointInd];
                      partialLength = currentPoint.partialLength;
                    }
                  }
                }
                offf = letters[i2].an / 2 - letters[i2].add;
                matrixHelper.translate(-offf, 0, 0);
              } else {
                offf = letters[i2].an / 2 - letters[i2].add;
                matrixHelper.translate(-offf, 0, 0);
                matrixHelper.translate(-alignment[0] * letters[i2].an * 5e-3, -alignment[1] * yOff * 0.01, 0);
              }
              for (j = 0; j < jLen; j += 1) {
                animatorProps = animators[j].a;
                if (animatorProps.t.propType) {
                  animatorSelector = animators[j].s;
                  mult = animatorSelector.getMult(letters[i2].anIndexes[j], textData.a[j].s.totalChars);
                  if (xPos !== 0 || documentData.j !== 0) {
                    if (this._hasMaskedPath) {
                      if (mult.length) {
                        currentLength += animatorProps.t.v * mult[0];
                      } else {
                        currentLength += animatorProps.t.v * mult;
                      }
                    } else if (mult.length) {
                      xPos += animatorProps.t.v * mult[0];
                    } else {
                      xPos += animatorProps.t.v * mult;
                    }
                  }
                }
              }
              if (documentData.strokeWidthAnim) {
                sw = documentData.sw || 0;
              }
              if (documentData.strokeColorAnim) {
                if (documentData.sc) {
                  sc2 = [documentData.sc[0], documentData.sc[1], documentData.sc[2]];
                } else {
                  sc2 = [0, 0, 0];
                }
              }
              if (documentData.fillColorAnim && documentData.fc) {
                fc2 = [documentData.fc[0], documentData.fc[1], documentData.fc[2]];
              }
              for (j = 0; j < jLen; j += 1) {
                animatorProps = animators[j].a;
                if (animatorProps.a.propType) {
                  animatorSelector = animators[j].s;
                  mult = animatorSelector.getMult(letters[i2].anIndexes[j], textData.a[j].s.totalChars);
                  if (mult.length) {
                    matrixHelper.translate(-animatorProps.a.v[0] * mult[0], -animatorProps.a.v[1] * mult[1], animatorProps.a.v[2] * mult[2]);
                  } else {
                    matrixHelper.translate(-animatorProps.a.v[0] * mult, -animatorProps.a.v[1] * mult, animatorProps.a.v[2] * mult);
                  }
                }
              }
              for (j = 0; j < jLen; j += 1) {
                animatorProps = animators[j].a;
                if (animatorProps.s.propType) {
                  animatorSelector = animators[j].s;
                  mult = animatorSelector.getMult(letters[i2].anIndexes[j], textData.a[j].s.totalChars);
                  if (mult.length) {
                    matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult[0], 1 + (animatorProps.s.v[1] - 1) * mult[1], 1);
                  } else {
                    matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult, 1 + (animatorProps.s.v[1] - 1) * mult, 1);
                  }
                }
              }
              for (j = 0; j < jLen; j += 1) {
                animatorProps = animators[j].a;
                animatorSelector = animators[j].s;
                mult = animatorSelector.getMult(letters[i2].anIndexes[j], textData.a[j].s.totalChars);
                if (animatorProps.sk.propType) {
                  if (mult.length) {
                    matrixHelper.skewFromAxis(-animatorProps.sk.v * mult[0], animatorProps.sa.v * mult[1]);
                  } else {
                    matrixHelper.skewFromAxis(-animatorProps.sk.v * mult, animatorProps.sa.v * mult);
                  }
                }
                if (animatorProps.r.propType) {
                  if (mult.length) {
                    matrixHelper.rotateZ(-animatorProps.r.v * mult[2]);
                  } else {
                    matrixHelper.rotateZ(-animatorProps.r.v * mult);
                  }
                }
                if (animatorProps.ry.propType) {
                  if (mult.length) {
                    matrixHelper.rotateY(animatorProps.ry.v * mult[1]);
                  } else {
                    matrixHelper.rotateY(animatorProps.ry.v * mult);
                  }
                }
                if (animatorProps.rx.propType) {
                  if (mult.length) {
                    matrixHelper.rotateX(animatorProps.rx.v * mult[0]);
                  } else {
                    matrixHelper.rotateX(animatorProps.rx.v * mult);
                  }
                }
                if (animatorProps.o.propType) {
                  if (mult.length) {
                    elemOpacity += (animatorProps.o.v * mult[0] - elemOpacity) * mult[0];
                  } else {
                    elemOpacity += (animatorProps.o.v * mult - elemOpacity) * mult;
                  }
                }
                if (documentData.strokeWidthAnim && animatorProps.sw.propType) {
                  if (mult.length) {
                    sw += animatorProps.sw.v * mult[0];
                  } else {
                    sw += animatorProps.sw.v * mult;
                  }
                }
                if (documentData.strokeColorAnim && animatorProps.sc.propType) {
                  for (k2 = 0; k2 < 3; k2 += 1) {
                    if (mult.length) {
                      sc2[k2] += (animatorProps.sc.v[k2] - sc2[k2]) * mult[0];
                    } else {
                      sc2[k2] += (animatorProps.sc.v[k2] - sc2[k2]) * mult;
                    }
                  }
                }
                if (documentData.fillColorAnim && documentData.fc) {
                  if (animatorProps.fc.propType) {
                    for (k2 = 0; k2 < 3; k2 += 1) {
                      if (mult.length) {
                        fc2[k2] += (animatorProps.fc.v[k2] - fc2[k2]) * mult[0];
                      } else {
                        fc2[k2] += (animatorProps.fc.v[k2] - fc2[k2]) * mult;
                      }
                    }
                  }
                  if (animatorProps.fh.propType) {
                    if (mult.length) {
                      fc2 = addHueToRGB(fc2, animatorProps.fh.v * mult[0]);
                    } else {
                      fc2 = addHueToRGB(fc2, animatorProps.fh.v * mult);
                    }
                  }
                  if (animatorProps.fs.propType) {
                    if (mult.length) {
                      fc2 = addSaturationToRGB(fc2, animatorProps.fs.v * mult[0]);
                    } else {
                      fc2 = addSaturationToRGB(fc2, animatorProps.fs.v * mult);
                    }
                  }
                  if (animatorProps.fb.propType) {
                    if (mult.length) {
                      fc2 = addBrightnessToRGB(fc2, animatorProps.fb.v * mult[0]);
                    } else {
                      fc2 = addBrightnessToRGB(fc2, animatorProps.fb.v * mult);
                    }
                  }
                }
              }
              for (j = 0; j < jLen; j += 1) {
                animatorProps = animators[j].a;
                if (animatorProps.p.propType) {
                  animatorSelector = animators[j].s;
                  mult = animatorSelector.getMult(letters[i2].anIndexes[j], textData.a[j].s.totalChars);
                  if (this._hasMaskedPath) {
                    if (mult.length) {
                      matrixHelper.translate(0, animatorProps.p.v[1] * mult[0], -animatorProps.p.v[2] * mult[1]);
                    } else {
                      matrixHelper.translate(0, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
                    }
                  } else if (mult.length) {
                    matrixHelper.translate(animatorProps.p.v[0] * mult[0], animatorProps.p.v[1] * mult[1], -animatorProps.p.v[2] * mult[2]);
                  } else {
                    matrixHelper.translate(animatorProps.p.v[0] * mult, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
                  }
                }
              }
              if (documentData.strokeWidthAnim) {
                letterSw = sw < 0 ? 0 : sw;
              }
              if (documentData.strokeColorAnim) {
                letterSc = "rgb(" + Math.round(sc2[0] * 255) + "," + Math.round(sc2[1] * 255) + "," + Math.round(sc2[2] * 255) + ")";
              }
              if (documentData.fillColorAnim && documentData.fc) {
                letterFc = "rgb(" + Math.round(fc2[0] * 255) + "," + Math.round(fc2[1] * 255) + "," + Math.round(fc2[2] * 255) + ")";
              }
              if (this._hasMaskedPath) {
                matrixHelper.translate(0, -documentData.ls);
                matrixHelper.translate(0, alignment[1] * yOff * 0.01 + yPos, 0);
                if (this._pathData.p.v) {
                  tanAngle = (currentPoint.point[1] - prevPoint.point[1]) / (currentPoint.point[0] - prevPoint.point[0]);
                  var rot = Math.atan(tanAngle) * 180 / Math.PI;
                  if (currentPoint.point[0] < prevPoint.point[0]) {
                    rot += 180;
                  }
                  matrixHelper.rotate(-rot * Math.PI / 180);
                }
                matrixHelper.translate(xPathPos, yPathPos, 0);
                currentLength -= alignment[0] * letters[i2].an * 5e-3;
                if (letters[i2 + 1] && ind !== letters[i2 + 1].ind) {
                  currentLength += letters[i2].an / 2;
                  currentLength += documentData.tr * 1e-3 * documentData.finalSize;
                }
              } else {
                matrixHelper.translate(xPos, yPos, 0);
                if (documentData.ps) {
                  matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
                }
                switch (documentData.j) {
                  case 1:
                    matrixHelper.translate(letters[i2].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i2].line]), 0, 0);
                    break;
                  case 2:
                    matrixHelper.translate(letters[i2].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i2].line]) / 2, 0, 0);
                    break;
                }
                matrixHelper.translate(0, -documentData.ls);
                matrixHelper.translate(offf, 0, 0);
                matrixHelper.translate(alignment[0] * letters[i2].an * 5e-3, alignment[1] * yOff * 0.01, 0);
                xPos += letters[i2].l + documentData.tr * 1e-3 * documentData.finalSize;
              }
              if (renderType === "html") {
                letterM = matrixHelper.toCSS();
              } else if (renderType === "svg") {
                letterM = matrixHelper.to2dCSS();
              } else {
                letterP = [matrixHelper.props[0], matrixHelper.props[1], matrixHelper.props[2], matrixHelper.props[3], matrixHelper.props[4], matrixHelper.props[5], matrixHelper.props[6], matrixHelper.props[7], matrixHelper.props[8], matrixHelper.props[9], matrixHelper.props[10], matrixHelper.props[11], matrixHelper.props[12], matrixHelper.props[13], matrixHelper.props[14], matrixHelper.props[15]];
              }
              letterO = elemOpacity;
            }
            if (renderedLettersCount <= i2) {
              letterValue = new LetterProps(letterO, letterSw, letterSc, letterFc, letterM, letterP);
              this.renderedLetters.push(letterValue);
              renderedLettersCount += 1;
              this.lettersChangedFlag = true;
            } else {
              letterValue = this.renderedLetters[i2];
              this.lettersChangedFlag = letterValue.update(letterO, letterSw, letterSc, letterFc, letterM, letterP) || this.lettersChangedFlag;
            }
          }
        };
        TextAnimatorProperty.prototype.getValue = function() {
          if (this._elem.globalData.frameId === this._frameId) {
            return;
          }
          this._frameId = this._elem.globalData.frameId;
          this.iterateDynamicProperties();
        };
        TextAnimatorProperty.prototype.mHelper = new Matrix();
        TextAnimatorProperty.prototype.defaultPropsArray = [];
        extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);
        function ITextElement() {
        }
        ITextElement.prototype.initElement = function(data2, globalData2, comp2) {
          this.lettersChangedFlag = true;
          this.initFrame();
          this.initBaseData(data2, globalData2, comp2);
          this.textProperty = new TextProperty(this, data2.t, this.dynamicProperties);
          this.textAnimator = new TextAnimatorProperty(data2.t, this.renderType, this);
          this.initTransform(data2, globalData2, comp2);
          this.initHierarchy();
          this.initRenderable();
          this.initRendererElement();
          this.createContainerElements();
          this.createRenderableComponents();
          this.createContent();
          this.hide();
          this.textAnimator.searchProperties(this.dynamicProperties);
        };
        ITextElement.prototype.prepareFrame = function(num) {
          this._mdf = false;
          this.prepareRenderableFrame(num);
          this.prepareProperties(num, this.isInRange);
        };
        ITextElement.prototype.createPathShape = function(matrixHelper, shapes) {
          var j;
          var jLen = shapes.length;
          var pathNodes;
          var shapeStr = "";
          for (j = 0; j < jLen; j += 1) {
            if (shapes[j].ty === "sh") {
              pathNodes = shapes[j].ks.k;
              shapeStr += buildShapeString(pathNodes, pathNodes.i.length, true, matrixHelper);
            }
          }
          return shapeStr;
        };
        ITextElement.prototype.updateDocumentData = function(newData, index2) {
          this.textProperty.updateDocumentData(newData, index2);
        };
        ITextElement.prototype.canResizeFont = function(_canResize) {
          this.textProperty.canResizeFont(_canResize);
        };
        ITextElement.prototype.setMinimumFontSize = function(_fontSize) {
          this.textProperty.setMinimumFontSize(_fontSize);
        };
        ITextElement.prototype.applyTextPropertiesToMatrix = function(documentData, matrixHelper, lineNumber, xPos, yPos) {
          if (documentData.ps) {
            matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
          }
          matrixHelper.translate(0, -documentData.ls, 0);
          switch (documentData.j) {
            case 1:
              matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]), 0, 0);
              break;
            case 2:
              matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]) / 2, 0, 0);
              break;
          }
          matrixHelper.translate(xPos, yPos, 0);
        };
        ITextElement.prototype.buildColor = function(colorData) {
          return "rgb(" + Math.round(colorData[0] * 255) + "," + Math.round(colorData[1] * 255) + "," + Math.round(colorData[2] * 255) + ")";
        };
        ITextElement.prototype.emptyProp = new LetterProps();
        ITextElement.prototype.destroy = function() {
        };
        ITextElement.prototype.validateText = function() {
          if (this.textProperty._mdf || this.textProperty._isFirstFrame) {
            this.buildNewText();
            this.textProperty._isFirstFrame = false;
            this.textProperty._mdf = false;
          }
        };
        var emptyShapeData = {
          shapes: []
        };
        function SVGTextLottieElement(data2, globalData2, comp2) {
          this.textSpans = [];
          this.renderType = "svg";
          this.initElement(data2, globalData2, comp2);
        }
        extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement);
        SVGTextLottieElement.prototype.createContent = function() {
          if (this.data.singleShape && !this.globalData.fontManager.chars) {
            this.textContainer = createNS("text");
          }
        };
        SVGTextLottieElement.prototype.buildTextContents = function(textArray) {
          var i2 = 0;
          var len = textArray.length;
          var textContents = [];
          var currentTextContent = "";
          while (i2 < len) {
            if (textArray[i2] === String.fromCharCode(13) || textArray[i2] === String.fromCharCode(3)) {
              textContents.push(currentTextContent);
              currentTextContent = "";
            } else {
              currentTextContent += textArray[i2];
            }
            i2 += 1;
          }
          textContents.push(currentTextContent);
          return textContents;
        };
        SVGTextLottieElement.prototype.buildShapeData = function(data2, scale2) {
          if (data2.shapes && data2.shapes.length) {
            var shape = data2.shapes[0];
            if (shape.it) {
              var shapeItem = shape.it[shape.it.length - 1];
              if (shapeItem.s) {
                shapeItem.s.k[0] = scale2;
                shapeItem.s.k[1] = scale2;
              }
            }
          }
          return data2;
        };
        SVGTextLottieElement.prototype.buildNewText = function() {
          this.addDynamicProperty(this);
          var i2;
          var len;
          var documentData = this.textProperty.currentData;
          this.renderedLetters = createSizedArray(documentData ? documentData.l.length : 0);
          if (documentData.fc) {
            this.layerElement.setAttribute("fill", this.buildColor(documentData.fc));
          } else {
            this.layerElement.setAttribute("fill", "rgba(0,0,0,0)");
          }
          if (documentData.sc) {
            this.layerElement.setAttribute("stroke", this.buildColor(documentData.sc));
            this.layerElement.setAttribute("stroke-width", documentData.sw);
          }
          this.layerElement.setAttribute("font-size", documentData.finalSize);
          var fontData = this.globalData.fontManager.getFontByName(documentData.f);
          if (fontData.fClass) {
            this.layerElement.setAttribute("class", fontData.fClass);
          } else {
            this.layerElement.setAttribute("font-family", fontData.fFamily);
            var fWeight = documentData.fWeight;
            var fStyle = documentData.fStyle;
            this.layerElement.setAttribute("font-style", fStyle);
            this.layerElement.setAttribute("font-weight", fWeight);
          }
          this.layerElement.setAttribute("aria-label", documentData.t);
          var letters = documentData.l || [];
          var usesGlyphs = !!this.globalData.fontManager.chars;
          len = letters.length;
          var tSpan;
          var matrixHelper = this.mHelper;
          var shapeStr = "";
          var singleShape = this.data.singleShape;
          var xPos = 0;
          var yPos = 0;
          var firstLine = true;
          var trackingOffset = documentData.tr * 1e-3 * documentData.finalSize;
          if (singleShape && !usesGlyphs && !documentData.sz) {
            var tElement = this.textContainer;
            var justify = "start";
            switch (documentData.j) {
              case 1:
                justify = "end";
                break;
              case 2:
                justify = "middle";
                break;
              default:
                justify = "start";
                break;
            }
            tElement.setAttribute("text-anchor", justify);
            tElement.setAttribute("letter-spacing", trackingOffset);
            var textContent = this.buildTextContents(documentData.finalText);
            len = textContent.length;
            yPos = documentData.ps ? documentData.ps[1] + documentData.ascent : 0;
            for (i2 = 0; i2 < len; i2 += 1) {
              tSpan = this.textSpans[i2].span || createNS("tspan");
              tSpan.textContent = textContent[i2];
              tSpan.setAttribute("x", 0);
              tSpan.setAttribute("y", yPos);
              tSpan.style.display = "inherit";
              tElement.appendChild(tSpan);
              if (!this.textSpans[i2]) {
                this.textSpans[i2] = {
                  span: null,
                  glyph: null
                };
              }
              this.textSpans[i2].span = tSpan;
              yPos += documentData.finalLineHeight;
            }
            this.layerElement.appendChild(tElement);
          } else {
            var cachedSpansLength = this.textSpans.length;
            var charData;
            for (i2 = 0; i2 < len; i2 += 1) {
              if (!this.textSpans[i2]) {
                this.textSpans[i2] = {
                  span: null,
                  childSpan: null,
                  glyph: null
                };
              }
              if (!usesGlyphs || !singleShape || i2 === 0) {
                tSpan = cachedSpansLength > i2 ? this.textSpans[i2].span : createNS(usesGlyphs ? "g" : "text");
                if (cachedSpansLength <= i2) {
                  tSpan.setAttribute("stroke-linecap", "butt");
                  tSpan.setAttribute("stroke-linejoin", "round");
                  tSpan.setAttribute("stroke-miterlimit", "4");
                  this.textSpans[i2].span = tSpan;
                  if (usesGlyphs) {
                    var childSpan = createNS("g");
                    tSpan.appendChild(childSpan);
                    this.textSpans[i2].childSpan = childSpan;
                  }
                  this.textSpans[i2].span = tSpan;
                  this.layerElement.appendChild(tSpan);
                }
                tSpan.style.display = "inherit";
              }
              matrixHelper.reset();
              if (singleShape) {
                if (letters[i2].n) {
                  xPos = -trackingOffset;
                  yPos += documentData.yOffset;
                  yPos += firstLine ? 1 : 0;
                  firstLine = false;
                }
                this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i2].line, xPos, yPos);
                xPos += letters[i2].l || 0;
                xPos += trackingOffset;
              }
              if (usesGlyphs) {
                charData = this.globalData.fontManager.getCharData(documentData.finalText[i2], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
                var glyphElement;
                if (charData.t === 1) {
                  glyphElement = new SVGCompElement(charData.data, this.globalData, this);
                } else {
                  var data2 = emptyShapeData;
                  if (charData.data && charData.data.shapes) {
                    data2 = this.buildShapeData(charData.data, documentData.finalSize);
                  }
                  glyphElement = new SVGShapeElement(data2, this.globalData, this);
                }
                if (this.textSpans[i2].glyph) {
                  var glyph = this.textSpans[i2].glyph;
                  this.textSpans[i2].childSpan.removeChild(glyph.layerElement);
                  glyph.destroy();
                }
                this.textSpans[i2].glyph = glyphElement;
                glyphElement._debug = true;
                glyphElement.prepareFrame(0);
                glyphElement.renderFrame();
                this.textSpans[i2].childSpan.appendChild(glyphElement.layerElement);
                if (charData.t === 1) {
                  this.textSpans[i2].childSpan.setAttribute("transform", "scale(" + documentData.finalSize / 100 + "," + documentData.finalSize / 100 + ")");
                }
              } else {
                if (singleShape) {
                  tSpan.setAttribute("transform", "translate(" + matrixHelper.props[12] + "," + matrixHelper.props[13] + ")");
                }
                tSpan.textContent = letters[i2].val;
                tSpan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
              }
            }
            if (singleShape && tSpan) {
              tSpan.setAttribute("d", shapeStr);
            }
          }
          while (i2 < this.textSpans.length) {
            this.textSpans[i2].span.style.display = "none";
            i2 += 1;
          }
          this._sizeChanged = true;
        };
        SVGTextLottieElement.prototype.sourceRectAtTime = function() {
          this.prepareFrame(this.comp.renderedFrame - this.data.st);
          this.renderInnerContent();
          if (this._sizeChanged) {
            this._sizeChanged = false;
            var textBox = this.layerElement.getBBox();
            this.bbox = {
              top: textBox.y,
              left: textBox.x,
              width: textBox.width,
              height: textBox.height
            };
          }
          return this.bbox;
        };
        SVGTextLottieElement.prototype.getValue = function() {
          var i2;
          var len = this.textSpans.length;
          var glyphElement;
          this.renderedFrame = this.comp.renderedFrame;
          for (i2 = 0; i2 < len; i2 += 1) {
            glyphElement = this.textSpans[i2].glyph;
            if (glyphElement) {
              glyphElement.prepareFrame(this.comp.renderedFrame - this.data.st);
              if (glyphElement._mdf) {
                this._mdf = true;
              }
            }
          }
        };
        SVGTextLottieElement.prototype.renderInnerContent = function() {
          this.validateText();
          if (!this.data.singleShape || this._mdf) {
            this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
            if (this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) {
              this._sizeChanged = true;
              var i2;
              var len;
              var renderedLetters = this.textAnimator.renderedLetters;
              var letters = this.textProperty.currentData.l;
              len = letters.length;
              var renderedLetter;
              var textSpan;
              var glyphElement;
              for (i2 = 0; i2 < len; i2 += 1) {
                if (!letters[i2].n) {
                  renderedLetter = renderedLetters[i2];
                  textSpan = this.textSpans[i2].span;
                  glyphElement = this.textSpans[i2].glyph;
                  if (glyphElement) {
                    glyphElement.renderFrame();
                  }
                  if (renderedLetter._mdf.m) {
                    textSpan.setAttribute("transform", renderedLetter.m);
                  }
                  if (renderedLetter._mdf.o) {
                    textSpan.setAttribute("opacity", renderedLetter.o);
                  }
                  if (renderedLetter._mdf.sw) {
                    textSpan.setAttribute("stroke-width", renderedLetter.sw);
                  }
                  if (renderedLetter._mdf.sc) {
                    textSpan.setAttribute("stroke", renderedLetter.sc);
                  }
                  if (renderedLetter._mdf.fc) {
                    textSpan.setAttribute("fill", renderedLetter.fc);
                  }
                }
              }
            }
          }
        };
        function ISolidElement(data2, globalData2, comp2) {
          this.initElement(data2, globalData2, comp2);
        }
        extendPrototype([IImageElement], ISolidElement);
        ISolidElement.prototype.createContent = function() {
          var rect = createNS("rect");
          rect.setAttribute("width", this.data.sw);
          rect.setAttribute("height", this.data.sh);
          rect.setAttribute("fill", this.data.sc);
          this.layerElement.appendChild(rect);
        };
        function NullElement(data2, globalData2, comp2) {
          this.initFrame();
          this.initBaseData(data2, globalData2, comp2);
          this.initFrame();
          this.initTransform(data2, globalData2, comp2);
          this.initHierarchy();
        }
        NullElement.prototype.prepareFrame = function(num) {
          this.prepareProperties(num, true);
        };
        NullElement.prototype.renderFrame = function() {
        };
        NullElement.prototype.getBaseElement = function() {
          return null;
        };
        NullElement.prototype.destroy = function() {
        };
        NullElement.prototype.sourceRectAtTime = function() {
        };
        NullElement.prototype.hide = function() {
        };
        extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement);
        function SVGRendererBase() {
        }
        extendPrototype([BaseRenderer], SVGRendererBase);
        SVGRendererBase.prototype.createNull = function(data2) {
          return new NullElement(data2, this.globalData, this);
        };
        SVGRendererBase.prototype.createShape = function(data2) {
          return new SVGShapeElement(data2, this.globalData, this);
        };
        SVGRendererBase.prototype.createText = function(data2) {
          return new SVGTextLottieElement(data2, this.globalData, this);
        };
        SVGRendererBase.prototype.createImage = function(data2) {
          return new IImageElement(data2, this.globalData, this);
        };
        SVGRendererBase.prototype.createSolid = function(data2) {
          return new ISolidElement(data2, this.globalData, this);
        };
        SVGRendererBase.prototype.configAnimation = function(animData) {
          this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg");
          this.svgElement.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");
          if (this.renderConfig.viewBoxSize) {
            this.svgElement.setAttribute("viewBox", this.renderConfig.viewBoxSize);
          } else {
            this.svgElement.setAttribute("viewBox", "0 0 " + animData.w + " " + animData.h);
          }
          if (!this.renderConfig.viewBoxOnly) {
            this.svgElement.setAttribute("width", animData.w);
            this.svgElement.setAttribute("height", animData.h);
            this.svgElement.style.width = "100%";
            this.svgElement.style.height = "100%";
            this.svgElement.style.transform = "translate3d(0,0,0)";
            this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility;
          }
          if (this.renderConfig.width) {
            this.svgElement.setAttribute("width", this.renderConfig.width);
          }
          if (this.renderConfig.height) {
            this.svgElement.setAttribute("height", this.renderConfig.height);
          }
          if (this.renderConfig.className) {
            this.svgElement.setAttribute("class", this.renderConfig.className);
          }
          if (this.renderConfig.id) {
            this.svgElement.setAttribute("id", this.renderConfig.id);
          }
          if (this.renderConfig.focusable !== void 0) {
            this.svgElement.setAttribute("focusable", this.renderConfig.focusable);
          }
          this.svgElement.setAttribute("preserveAspectRatio", this.renderConfig.preserveAspectRatio);
          this.animationItem.wrapper.appendChild(this.svgElement);
          var defs = this.globalData.defs;
          this.setupGlobalData(animData, defs);
          this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
          this.data = animData;
          var maskElement = createNS("clipPath");
          var rect = createNS("rect");
          rect.setAttribute("width", animData.w);
          rect.setAttribute("height", animData.h);
          rect.setAttribute("x", 0);
          rect.setAttribute("y", 0);
          var maskId = createElementID();
          maskElement.setAttribute("id", maskId);
          maskElement.appendChild(rect);
          this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + maskId + ")");
          defs.appendChild(maskElement);
          this.layers = animData.layers;
          this.elements = createSizedArray(animData.layers.length);
        };
        SVGRendererBase.prototype.destroy = function() {
          if (this.animationItem.wrapper) {
            this.animationItem.wrapper.innerText = "";
          }
          this.layerElement = null;
          this.globalData.defs = null;
          var i2;
          var len = this.layers ? this.layers.length : 0;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (this.elements[i2] && this.elements[i2].destroy) {
              this.elements[i2].destroy();
            }
          }
          this.elements.length = 0;
          this.destroyed = true;
          this.animationItem = null;
        };
        SVGRendererBase.prototype.updateContainerSize = function() {
        };
        SVGRendererBase.prototype.findIndexByInd = function(ind) {
          var i2 = 0;
          var len = this.layers.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (this.layers[i2].ind === ind) {
              return i2;
            }
          }
          return -1;
        };
        SVGRendererBase.prototype.buildItem = function(pos) {
          var elements = this.elements;
          if (elements[pos] || this.layers[pos].ty === 99) {
            return;
          }
          elements[pos] = true;
          var element = this.createItem(this.layers[pos]);
          elements[pos] = element;
          if (getExpressionsPlugin()) {
            if (this.layers[pos].ty === 0) {
              this.globalData.projectInterface.registerComposition(element);
            }
            element.initExpressions();
          }
          this.appendElementInPos(element, pos);
          if (this.layers[pos].tt) {
            var elementIndex = "tp" in this.layers[pos] ? this.findIndexByInd(this.layers[pos].tp) : pos - 1;
            if (elementIndex === -1) {
              return;
            }
            if (!this.elements[elementIndex] || this.elements[elementIndex] === true) {
              this.buildItem(elementIndex);
              this.addPendingElement(element);
            } else {
              var matteElement = elements[elementIndex];
              var matteMask = matteElement.getMatte(this.layers[pos].tt);
              element.setMatte(matteMask);
            }
          }
        };
        SVGRendererBase.prototype.checkPendingElements = function() {
          while (this.pendingElements.length) {
            var element = this.pendingElements.pop();
            element.checkParenting();
            if (element.data.tt) {
              var i2 = 0;
              var len = this.elements.length;
              while (i2 < len) {
                if (this.elements[i2] === element) {
                  var elementIndex = "tp" in element.data ? this.findIndexByInd(element.data.tp) : i2 - 1;
                  var matteElement = this.elements[elementIndex];
                  var matteMask = matteElement.getMatte(this.layers[i2].tt);
                  element.setMatte(matteMask);
                  break;
                }
                i2 += 1;
              }
            }
          }
        };
        SVGRendererBase.prototype.renderFrame = function(num) {
          if (this.renderedFrame === num || this.destroyed) {
            return;
          }
          if (num === null) {
            num = this.renderedFrame;
          } else {
            this.renderedFrame = num;
          }
          this.globalData.frameNum = num;
          this.globalData.frameId += 1;
          this.globalData.projectInterface.currentFrame = num;
          this.globalData._mdf = false;
          var i2;
          var len = this.layers.length;
          if (!this.completeLayers) {
            this.checkLayers(num);
          }
          for (i2 = len - 1; i2 >= 0; i2 -= 1) {
            if (this.completeLayers || this.elements[i2]) {
              this.elements[i2].prepareFrame(num - this.layers[i2].st);
            }
          }
          if (this.globalData._mdf) {
            for (i2 = 0; i2 < len; i2 += 1) {
              if (this.completeLayers || this.elements[i2]) {
                this.elements[i2].renderFrame();
              }
            }
          }
        };
        SVGRendererBase.prototype.appendElementInPos = function(element, pos) {
          var newElement = element.getBaseElement();
          if (!newElement) {
            return;
          }
          var i2 = 0;
          var nextElement;
          while (i2 < pos) {
            if (this.elements[i2] && this.elements[i2] !== true && this.elements[i2].getBaseElement()) {
              nextElement = this.elements[i2].getBaseElement();
            }
            i2 += 1;
          }
          if (nextElement) {
            this.layerElement.insertBefore(newElement, nextElement);
          } else {
            this.layerElement.appendChild(newElement);
          }
        };
        SVGRendererBase.prototype.hide = function() {
          this.layerElement.style.display = "none";
        };
        SVGRendererBase.prototype.show = function() {
          this.layerElement.style.display = "block";
        };
        function ICompElement() {
        }
        extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement);
        ICompElement.prototype.initElement = function(data2, globalData2, comp2) {
          this.initFrame();
          this.initBaseData(data2, globalData2, comp2);
          this.initTransform(data2, globalData2, comp2);
          this.initRenderable();
          this.initHierarchy();
          this.initRendererElement();
          this.createContainerElements();
          this.createRenderableComponents();
          if (this.data.xt || !globalData2.progressiveLoad) {
            this.buildAllItems();
          }
          this.hide();
        };
        ICompElement.prototype.prepareFrame = function(num) {
          this._mdf = false;
          this.prepareRenderableFrame(num);
          this.prepareProperties(num, this.isInRange);
          if (!this.isInRange && !this.data.xt) {
            return;
          }
          if (!this.tm._placeholder) {
            var timeRemapped = this.tm.v;
            if (timeRemapped === this.data.op) {
              timeRemapped = this.data.op - 1;
            }
            this.renderedFrame = timeRemapped;
          } else {
            this.renderedFrame = num / this.data.sr;
          }
          var i2;
          var len = this.elements.length;
          if (!this.completeLayers) {
            this.checkLayers(this.renderedFrame);
          }
          for (i2 = len - 1; i2 >= 0; i2 -= 1) {
            if (this.completeLayers || this.elements[i2]) {
              this.elements[i2].prepareFrame(this.renderedFrame - this.layers[i2].st);
              if (this.elements[i2]._mdf) {
                this._mdf = true;
              }
            }
          }
        };
        ICompElement.prototype.renderInnerContent = function() {
          var i2;
          var len = this.layers.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (this.completeLayers || this.elements[i2]) {
              this.elements[i2].renderFrame();
            }
          }
        };
        ICompElement.prototype.setElements = function(elems) {
          this.elements = elems;
        };
        ICompElement.prototype.getElements = function() {
          return this.elements;
        };
        ICompElement.prototype.destroyElements = function() {
          var i2;
          var len = this.layers.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (this.elements[i2]) {
              this.elements[i2].destroy();
            }
          }
        };
        ICompElement.prototype.destroy = function() {
          this.destroyElements();
          this.destroyBaseElement();
        };
        function SVGCompElement(data2, globalData2, comp2) {
          this.layers = data2.layers;
          this.supports3d = true;
          this.completeLayers = false;
          this.pendingElements = [];
          this.elements = this.layers ? createSizedArray(this.layers.length) : [];
          this.initElement(data2, globalData2, comp2);
          this.tm = data2.tm ? PropertyFactory.getProp(this, data2.tm, 0, globalData2.frameRate, this) : {
            _placeholder: true
          };
        }
        extendPrototype([SVGRendererBase, ICompElement, SVGBaseElement], SVGCompElement);
        SVGCompElement.prototype.createComp = function(data2) {
          return new SVGCompElement(data2, this.globalData, this);
        };
        function SVGRenderer(animationItem, config) {
          this.animationItem = animationItem;
          this.layers = null;
          this.renderedFrame = -1;
          this.svgElement = createNS("svg");
          var ariaLabel = "";
          if (config && config.title) {
            var titleElement = createNS("title");
            var titleId = createElementID();
            titleElement.setAttribute("id", titleId);
            titleElement.textContent = config.title;
            this.svgElement.appendChild(titleElement);
            ariaLabel += titleId;
          }
          if (config && config.description) {
            var descElement = createNS("desc");
            var descId = createElementID();
            descElement.setAttribute("id", descId);
            descElement.textContent = config.description;
            this.svgElement.appendChild(descElement);
            ariaLabel += " " + descId;
          }
          if (ariaLabel) {
            this.svgElement.setAttribute("aria-labelledby", ariaLabel);
          }
          var defs = createNS("defs");
          this.svgElement.appendChild(defs);
          var maskElement = createNS("g");
          this.svgElement.appendChild(maskElement);
          this.layerElement = maskElement;
          this.renderConfig = {
            preserveAspectRatio: config && config.preserveAspectRatio || "xMidYMid meet",
            imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || "xMidYMid slice",
            contentVisibility: config && config.contentVisibility || "visible",
            progressiveLoad: config && config.progressiveLoad || false,
            hideOnTransparent: !(config && config.hideOnTransparent === false),
            viewBoxOnly: config && config.viewBoxOnly || false,
            viewBoxSize: config && config.viewBoxSize || false,
            className: config && config.className || "",
            id: config && config.id || "",
            focusable: config && config.focusable,
            filterSize: {
              width: config && config.filterSize && config.filterSize.width || "100%",
              height: config && config.filterSize && config.filterSize.height || "100%",
              x: config && config.filterSize && config.filterSize.x || "0%",
              y: config && config.filterSize && config.filterSize.y || "0%"
            },
            width: config && config.width,
            height: config && config.height,
            runExpressions: !config || config.runExpressions === void 0 || config.runExpressions
          };
          this.globalData = {
            _mdf: false,
            frameNum: -1,
            defs,
            renderConfig: this.renderConfig
          };
          this.elements = [];
          this.pendingElements = [];
          this.destroyed = false;
          this.rendererType = "svg";
        }
        extendPrototype([SVGRendererBase], SVGRenderer);
        SVGRenderer.prototype.createComp = function(data2) {
          return new SVGCompElement(data2, this.globalData, this);
        };
        function ShapeTransformManager() {
          this.sequences = {};
          this.sequenceList = [];
          this.transform_key_count = 0;
        }
        ShapeTransformManager.prototype = {
          addTransformSequence: function addTransformSequence(transforms) {
            var i2;
            var len = transforms.length;
            var key2 = "_";
            for (i2 = 0; i2 < len; i2 += 1) {
              key2 += transforms[i2].transform.key + "_";
            }
            var sequence = this.sequences[key2];
            if (!sequence) {
              sequence = {
                transforms: [].concat(transforms),
                finalTransform: new Matrix(),
                _mdf: false
              };
              this.sequences[key2] = sequence;
              this.sequenceList.push(sequence);
            }
            return sequence;
          },
          processSequence: function processSequence(sequence, isFirstFrame) {
            var i2 = 0;
            var len = sequence.transforms.length;
            var _mdf = isFirstFrame;
            while (i2 < len && !isFirstFrame) {
              if (sequence.transforms[i2].transform.mProps._mdf) {
                _mdf = true;
                break;
              }
              i2 += 1;
            }
            if (_mdf) {
              sequence.finalTransform.reset();
              for (i2 = len - 1; i2 >= 0; i2 -= 1) {
                sequence.finalTransform.multiply(sequence.transforms[i2].transform.mProps.v);
              }
            }
            sequence._mdf = _mdf;
          },
          processSequences: function processSequences(isFirstFrame) {
            var i2;
            var len = this.sequenceList.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              this.processSequence(this.sequenceList[i2], isFirstFrame);
            }
          },
          getNewKey: function getNewKey() {
            this.transform_key_count += 1;
            return "_" + this.transform_key_count;
          }
        };
        var lumaLoader = function lumaLoader2() {
          var id2 = "__lottie_element_luma_buffer";
          var lumaBuffer = null;
          var lumaBufferCtx = null;
          var svg = null;
          function createLumaSvgFilter() {
            var _svg = createNS("svg");
            var fil = createNS("filter");
            var matrix = createNS("feColorMatrix");
            fil.setAttribute("id", id2);
            matrix.setAttribute("type", "matrix");
            matrix.setAttribute("color-interpolation-filters", "sRGB");
            matrix.setAttribute("values", "0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0");
            fil.appendChild(matrix);
            _svg.appendChild(fil);
            _svg.setAttribute("id", id2 + "_svg");
            if (featureSupport.svgLumaHidden) {
              _svg.style.display = "none";
            }
            return _svg;
          }
          function loadLuma() {
            if (!lumaBuffer) {
              svg = createLumaSvgFilter();
              document.body.appendChild(svg);
              lumaBuffer = createTag("canvas");
              lumaBufferCtx = lumaBuffer.getContext("2d");
              lumaBufferCtx.filter = "url(#" + id2 + ")";
              lumaBufferCtx.fillStyle = "rgba(0,0,0,0)";
              lumaBufferCtx.fillRect(0, 0, 1, 1);
            }
          }
          function getLuma(canvas) {
            if (!lumaBuffer) {
              loadLuma();
            }
            lumaBuffer.width = canvas.width;
            lumaBuffer.height = canvas.height;
            lumaBufferCtx.filter = "url(#" + id2 + ")";
            return lumaBuffer;
          }
          return {
            load: loadLuma,
            get: getLuma
          };
        };
        function createCanvas(width2, height2) {
          if (featureSupport.offscreenCanvas) {
            return new OffscreenCanvas(width2, height2);
          }
          var canvas = createTag("canvas");
          canvas.width = width2;
          canvas.height = height2;
          return canvas;
        }
        var assetLoader = function() {
          return {
            loadLumaCanvas: lumaLoader.load,
            getLumaCanvas: lumaLoader.get,
            createCanvas
          };
        }();
        var registeredEffects = {};
        function CVEffects(elem2) {
          var i2;
          var len = elem2.data.ef ? elem2.data.ef.length : 0;
          this.filters = [];
          var filterManager;
          for (i2 = 0; i2 < len; i2 += 1) {
            filterManager = null;
            var type = elem2.data.ef[i2].ty;
            if (registeredEffects[type]) {
              var Effect = registeredEffects[type].effect;
              filterManager = new Effect(elem2.effectsManager.effectElements[i2], elem2);
            }
            if (filterManager) {
              this.filters.push(filterManager);
            }
          }
          if (this.filters.length) {
            elem2.addRenderableComponent(this);
          }
        }
        CVEffects.prototype.renderFrame = function(_isFirstFrame) {
          var i2;
          var len = this.filters.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            this.filters[i2].renderFrame(_isFirstFrame);
          }
        };
        CVEffects.prototype.getEffects = function(type) {
          var i2;
          var len = this.filters.length;
          var effects = [];
          for (i2 = 0; i2 < len; i2 += 1) {
            if (this.filters[i2].type === type) {
              effects.push(this.filters[i2]);
            }
          }
          return effects;
        };
        function registerEffect(id2, effect2) {
          registeredEffects[id2] = {
            effect: effect2
          };
        }
        function CVMaskElement(data2, element) {
          this.data = data2;
          this.element = element;
          this.masksProperties = this.data.masksProperties || [];
          this.viewData = createSizedArray(this.masksProperties.length);
          var i2;
          var len = this.masksProperties.length;
          var hasMasks = false;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (this.masksProperties[i2].mode !== "n") {
              hasMasks = true;
            }
            this.viewData[i2] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[i2], 3);
          }
          this.hasMasks = hasMasks;
          if (hasMasks) {
            this.element.addRenderableComponent(this);
          }
        }
        CVMaskElement.prototype.renderFrame = function() {
          if (!this.hasMasks) {
            return;
          }
          var transform2 = this.element.finalTransform.mat;
          var ctx = this.element.canvasContext;
          var i2;
          var len = this.masksProperties.length;
          var pt;
          var pts;
          var data2;
          ctx.beginPath();
          for (i2 = 0; i2 < len; i2 += 1) {
            if (this.masksProperties[i2].mode !== "n") {
              if (this.masksProperties[i2].inv) {
                ctx.moveTo(0, 0);
                ctx.lineTo(this.element.globalData.compSize.w, 0);
                ctx.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h);
                ctx.lineTo(0, this.element.globalData.compSize.h);
                ctx.lineTo(0, 0);
              }
              data2 = this.viewData[i2].v;
              pt = transform2.applyToPointArray(data2.v[0][0], data2.v[0][1], 0);
              ctx.moveTo(pt[0], pt[1]);
              var j;
              var jLen = data2._length;
              for (j = 1; j < jLen; j += 1) {
                pts = transform2.applyToTriplePoints(data2.o[j - 1], data2.i[j], data2.v[j]);
                ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
              }
              pts = transform2.applyToTriplePoints(data2.o[j - 1], data2.i[0], data2.v[0]);
              ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
            }
          }
          this.element.globalData.renderer.save(true);
          ctx.clip();
        };
        CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty;
        CVMaskElement.prototype.destroy = function() {
          this.element = null;
        };
        function CVBaseElement() {
        }
        var operationsMap = {
          1: "source-in",
          2: "source-out",
          3: "source-in",
          4: "source-out"
        };
        CVBaseElement.prototype = {
          createElements: function createElements() {
          },
          initRendererElement: function initRendererElement() {
          },
          createContainerElements: function createContainerElements() {
            if (this.data.tt >= 1) {
              this.buffers = [];
              var canvasContext = this.globalData.canvasContext;
              var bufferCanvas = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);
              this.buffers.push(bufferCanvas);
              var bufferCanvas2 = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);
              this.buffers.push(bufferCanvas2);
              if (this.data.tt >= 3 && !document._isProxy) {
                assetLoader.loadLumaCanvas();
              }
            }
            this.canvasContext = this.globalData.canvasContext;
            this.transformCanvas = this.globalData.transformCanvas;
            this.renderableEffectsManager = new CVEffects(this);
            this.searchEffectTransforms();
          },
          createContent: function createContent() {
          },
          setBlendMode: function setBlendMode() {
            var globalData2 = this.globalData;
            if (globalData2.blendMode !== this.data.bm) {
              globalData2.blendMode = this.data.bm;
              var blendModeValue = getBlendMode(this.data.bm);
              globalData2.canvasContext.globalCompositeOperation = blendModeValue;
            }
          },
          createRenderableComponents: function createRenderableComponents() {
            this.maskManager = new CVMaskElement(this.data, this);
            this.transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
          },
          hideElement: function hideElement() {
            if (!this.hidden && (!this.isInRange || this.isTransparent)) {
              this.hidden = true;
            }
          },
          showElement: function showElement() {
            if (this.isInRange && !this.isTransparent) {
              this.hidden = false;
              this._isFirstFrame = true;
              this.maskManager._isFirstFrame = true;
            }
          },
          clearCanvas: function clearCanvas(canvasContext) {
            canvasContext.clearRect(this.transformCanvas.tx, this.transformCanvas.ty, this.transformCanvas.w * this.transformCanvas.sx, this.transformCanvas.h * this.transformCanvas.sy);
          },
          prepareLayer: function prepareLayer() {
            if (this.data.tt >= 1) {
              var buffer = this.buffers[0];
              var bufferCtx = buffer.getContext("2d");
              this.clearCanvas(bufferCtx);
              bufferCtx.drawImage(this.canvasContext.canvas, 0, 0);
              this.currentTransform = this.canvasContext.getTransform();
              this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
              this.clearCanvas(this.canvasContext);
              this.canvasContext.setTransform(this.currentTransform);
            }
          },
          exitLayer: function exitLayer() {
            if (this.data.tt >= 1) {
              var buffer = this.buffers[1];
              var bufferCtx = buffer.getContext("2d");
              this.clearCanvas(bufferCtx);
              bufferCtx.drawImage(this.canvasContext.canvas, 0, 0);
              this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
              this.clearCanvas(this.canvasContext);
              this.canvasContext.setTransform(this.currentTransform);
              var mask2 = this.comp.getElementById("tp" in this.data ? this.data.tp : this.data.ind - 1);
              mask2.renderFrame(true);
              this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);
              if (this.data.tt >= 3 && !document._isProxy) {
                var lumaBuffer = assetLoader.getLumaCanvas(this.canvasContext.canvas);
                var lumaBufferCtx = lumaBuffer.getContext("2d");
                lumaBufferCtx.drawImage(this.canvasContext.canvas, 0, 0);
                this.clearCanvas(this.canvasContext);
                this.canvasContext.drawImage(lumaBuffer, 0, 0);
              }
              this.canvasContext.globalCompositeOperation = operationsMap[this.data.tt];
              this.canvasContext.drawImage(buffer, 0, 0);
              this.canvasContext.globalCompositeOperation = "destination-over";
              this.canvasContext.drawImage(this.buffers[0], 0, 0);
              this.canvasContext.setTransform(this.currentTransform);
              this.canvasContext.globalCompositeOperation = "source-over";
            }
          },
          renderFrame: function renderFrame(forceRender) {
            if (this.hidden || this.data.hd) {
              return;
            }
            if (this.data.td === 1 && !forceRender) {
              return;
            }
            this.renderTransform();
            this.renderRenderable();
            this.renderLocalTransform();
            this.setBlendMode();
            var forceRealStack = this.data.ty === 0;
            this.prepareLayer();
            this.globalData.renderer.save(forceRealStack);
            this.globalData.renderer.ctxTransform(this.finalTransform.localMat.props);
            this.globalData.renderer.ctxOpacity(this.finalTransform.localOpacity);
            this.renderInnerContent();
            this.globalData.renderer.restore(forceRealStack);
            this.exitLayer();
            if (this.maskManager.hasMasks) {
              this.globalData.renderer.restore(true);
            }
            if (this._isFirstFrame) {
              this._isFirstFrame = false;
            }
          },
          destroy: function destroy() {
            this.canvasContext = null;
            this.data = null;
            this.globalData = null;
            this.maskManager.destroy();
          },
          mHelper: new Matrix()
        };
        CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement;
        CVBaseElement.prototype.show = CVBaseElement.prototype.showElement;
        function CVShapeData(element, data2, styles, transformsManager) {
          this.styledShapes = [];
          this.tr = [0, 0, 0, 0, 0, 0];
          var ty = 4;
          if (data2.ty === "rc") {
            ty = 5;
          } else if (data2.ty === "el") {
            ty = 6;
          } else if (data2.ty === "sr") {
            ty = 7;
          }
          this.sh = ShapePropertyFactory.getShapeProp(element, data2, ty, element);
          var i2;
          var len = styles.length;
          var styledShape;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (!styles[i2].closed) {
              styledShape = {
                transforms: transformsManager.addTransformSequence(styles[i2].transforms),
                trNodes: []
              };
              this.styledShapes.push(styledShape);
              styles[i2].elements.push(styledShape);
            }
          }
        }
        CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated;
        function CVShapeElement(data2, globalData2, comp2) {
          this.shapes = [];
          this.shapesData = data2.shapes;
          this.stylesList = [];
          this.itemsData = [];
          this.prevViewData = [];
          this.shapeModifiers = [];
          this.processedElements = [];
          this.transformsManager = new ShapeTransformManager();
          this.initElement(data2, globalData2, comp2);
        }
        extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement);
        CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement;
        CVShapeElement.prototype.transformHelper = {
          opacity: 1,
          _opMdf: false
        };
        CVShapeElement.prototype.dashResetter = [];
        CVShapeElement.prototype.createContent = function() {
          this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
        };
        CVShapeElement.prototype.createStyleElement = function(data2, transforms) {
          var styleElem = {
            data: data2,
            type: data2.ty,
            preTransforms: this.transformsManager.addTransformSequence(transforms),
            transforms: [],
            elements: [],
            closed: data2.hd === true
          };
          var elementData = {};
          if (data2.ty === "fl" || data2.ty === "st") {
            elementData.c = PropertyFactory.getProp(this, data2.c, 1, 255, this);
            if (!elementData.c.k) {
              styleElem.co = "rgb(" + bmFloor(elementData.c.v[0]) + "," + bmFloor(elementData.c.v[1]) + "," + bmFloor(elementData.c.v[2]) + ")";
            }
          } else if (data2.ty === "gf" || data2.ty === "gs") {
            elementData.s = PropertyFactory.getProp(this, data2.s, 1, null, this);
            elementData.e = PropertyFactory.getProp(this, data2.e, 1, null, this);
            elementData.h = PropertyFactory.getProp(this, data2.h || {
              k: 0
            }, 0, 0.01, this);
            elementData.a = PropertyFactory.getProp(this, data2.a || {
              k: 0
            }, 0, degToRads, this);
            elementData.g = new GradientProperty(this, data2.g, this);
          }
          elementData.o = PropertyFactory.getProp(this, data2.o, 0, 0.01, this);
          if (data2.ty === "st" || data2.ty === "gs") {
            styleElem.lc = lineCapEnum[data2.lc || 2];
            styleElem.lj = lineJoinEnum[data2.lj || 2];
            if (data2.lj == 1) {
              styleElem.ml = data2.ml;
            }
            elementData.w = PropertyFactory.getProp(this, data2.w, 0, null, this);
            if (!elementData.w.k) {
              styleElem.wi = elementData.w.v;
            }
            if (data2.d) {
              var d = new DashProperty(this, data2.d, "canvas", this);
              elementData.d = d;
              if (!elementData.d.k) {
                styleElem.da = elementData.d.dashArray;
                styleElem["do"] = elementData.d.dashoffset[0];
              }
            }
          } else {
            styleElem.r = data2.r === 2 ? "evenodd" : "nonzero";
          }
          this.stylesList.push(styleElem);
          elementData.style = styleElem;
          return elementData;
        };
        CVShapeElement.prototype.createGroupElement = function() {
          var elementData = {
            it: [],
            prevViewData: []
          };
          return elementData;
        };
        CVShapeElement.prototype.createTransformElement = function(data2) {
          var elementData = {
            transform: {
              opacity: 1,
              _opMdf: false,
              key: this.transformsManager.getNewKey(),
              op: PropertyFactory.getProp(this, data2.o, 0, 0.01, this),
              mProps: TransformPropertyFactory.getTransformProperty(this, data2, this)
            }
          };
          return elementData;
        };
        CVShapeElement.prototype.createShapeElement = function(data2) {
          var elementData = new CVShapeData(this, data2, this.stylesList, this.transformsManager);
          this.shapes.push(elementData);
          this.addShapeToModifiers(elementData);
          return elementData;
        };
        CVShapeElement.prototype.reloadShapes = function() {
          this._isFirstFrame = true;
          var i2;
          var len = this.itemsData.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            this.prevViewData[i2] = this.itemsData[i2];
          }
          this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
          len = this.dynamicProperties.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            this.dynamicProperties[i2].getValue();
          }
          this.renderModifiers();
          this.transformsManager.processSequences(this._isFirstFrame);
        };
        CVShapeElement.prototype.addTransformToStyleList = function(transform2) {
          var i2;
          var len = this.stylesList.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (!this.stylesList[i2].closed) {
              this.stylesList[i2].transforms.push(transform2);
            }
          }
        };
        CVShapeElement.prototype.removeTransformFromStyleList = function() {
          var i2;
          var len = this.stylesList.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (!this.stylesList[i2].closed) {
              this.stylesList[i2].transforms.pop();
            }
          }
        };
        CVShapeElement.prototype.closeStyles = function(styles) {
          var i2;
          var len = styles.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            styles[i2].closed = true;
          }
        };
        CVShapeElement.prototype.searchShapes = function(arr2, itemsData, prevViewData, shouldRender, transforms) {
          var i2;
          var len = arr2.length - 1;
          var j;
          var jLen;
          var ownStyles = [];
          var ownModifiers = [];
          var processedPos;
          var modifier;
          var currentTransform;
          var ownTransforms = [].concat(transforms);
          for (i2 = len; i2 >= 0; i2 -= 1) {
            processedPos = this.searchProcessedElement(arr2[i2]);
            if (!processedPos) {
              arr2[i2]._shouldRender = shouldRender;
            } else {
              itemsData[i2] = prevViewData[processedPos - 1];
            }
            if (arr2[i2].ty === "fl" || arr2[i2].ty === "st" || arr2[i2].ty === "gf" || arr2[i2].ty === "gs") {
              if (!processedPos) {
                itemsData[i2] = this.createStyleElement(arr2[i2], ownTransforms);
              } else {
                itemsData[i2].style.closed = false;
              }
              ownStyles.push(itemsData[i2].style);
            } else if (arr2[i2].ty === "gr") {
              if (!processedPos) {
                itemsData[i2] = this.createGroupElement(arr2[i2]);
              } else {
                jLen = itemsData[i2].it.length;
                for (j = 0; j < jLen; j += 1) {
                  itemsData[i2].prevViewData[j] = itemsData[i2].it[j];
                }
              }
              this.searchShapes(arr2[i2].it, itemsData[i2].it, itemsData[i2].prevViewData, shouldRender, ownTransforms);
            } else if (arr2[i2].ty === "tr") {
              if (!processedPos) {
                currentTransform = this.createTransformElement(arr2[i2]);
                itemsData[i2] = currentTransform;
              }
              ownTransforms.push(itemsData[i2]);
              this.addTransformToStyleList(itemsData[i2]);
            } else if (arr2[i2].ty === "sh" || arr2[i2].ty === "rc" || arr2[i2].ty === "el" || arr2[i2].ty === "sr") {
              if (!processedPos) {
                itemsData[i2] = this.createShapeElement(arr2[i2]);
              }
            } else if (arr2[i2].ty === "tm" || arr2[i2].ty === "rd" || arr2[i2].ty === "pb" || arr2[i2].ty === "zz" || arr2[i2].ty === "op") {
              if (!processedPos) {
                modifier = ShapeModifiers.getModifier(arr2[i2].ty);
                modifier.init(this, arr2[i2]);
                itemsData[i2] = modifier;
                this.shapeModifiers.push(modifier);
              } else {
                modifier = itemsData[i2];
                modifier.closed = false;
              }
              ownModifiers.push(modifier);
            } else if (arr2[i2].ty === "rp") {
              if (!processedPos) {
                modifier = ShapeModifiers.getModifier(arr2[i2].ty);
                itemsData[i2] = modifier;
                modifier.init(this, arr2, i2, itemsData);
                this.shapeModifiers.push(modifier);
                shouldRender = false;
              } else {
                modifier = itemsData[i2];
                modifier.closed = true;
              }
              ownModifiers.push(modifier);
            }
            this.addProcessedElement(arr2[i2], i2 + 1);
          }
          this.removeTransformFromStyleList();
          this.closeStyles(ownStyles);
          len = ownModifiers.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            ownModifiers[i2].closed = true;
          }
        };
        CVShapeElement.prototype.renderInnerContent = function() {
          this.transformHelper.opacity = 1;
          this.transformHelper._opMdf = false;
          this.renderModifiers();
          this.transformsManager.processSequences(this._isFirstFrame);
          this.renderShape(this.transformHelper, this.shapesData, this.itemsData, true);
        };
        CVShapeElement.prototype.renderShapeTransform = function(parentTransform, groupTransform) {
          if (parentTransform._opMdf || groupTransform.op._mdf || this._isFirstFrame) {
            groupTransform.opacity = parentTransform.opacity;
            groupTransform.opacity *= groupTransform.op.v;
            groupTransform._opMdf = true;
          }
        };
        CVShapeElement.prototype.drawLayer = function() {
          var i2;
          var len = this.stylesList.length;
          var j;
          var jLen;
          var k2;
          var kLen;
          var elems;
          var nodes;
          var renderer = this.globalData.renderer;
          var ctx = this.globalData.canvasContext;
          var type;
          var currentStyle;
          for (i2 = 0; i2 < len; i2 += 1) {
            currentStyle = this.stylesList[i2];
            type = currentStyle.type;
            if (!((type === "st" || type === "gs") && currentStyle.wi === 0 || !currentStyle.data._shouldRender || currentStyle.coOp === 0 || this.globalData.currentGlobalAlpha === 0)) {
              renderer.save();
              elems = currentStyle.elements;
              if (type === "st" || type === "gs") {
                renderer.ctxStrokeStyle(type === "st" ? currentStyle.co : currentStyle.grd);
                renderer.ctxLineWidth(currentStyle.wi);
                renderer.ctxLineCap(currentStyle.lc);
                renderer.ctxLineJoin(currentStyle.lj);
                renderer.ctxMiterLimit(currentStyle.ml || 0);
              } else {
                renderer.ctxFillStyle(type === "fl" ? currentStyle.co : currentStyle.grd);
              }
              renderer.ctxOpacity(currentStyle.coOp);
              if (type !== "st" && type !== "gs") {
                ctx.beginPath();
              }
              renderer.ctxTransform(currentStyle.preTransforms.finalTransform.props);
              jLen = elems.length;
              for (j = 0; j < jLen; j += 1) {
                if (type === "st" || type === "gs") {
                  ctx.beginPath();
                  if (currentStyle.da) {
                    ctx.setLineDash(currentStyle.da);
                    ctx.lineDashOffset = currentStyle["do"];
                  }
                }
                nodes = elems[j].trNodes;
                kLen = nodes.length;
                for (k2 = 0; k2 < kLen; k2 += 1) {
                  if (nodes[k2].t === "m") {
                    ctx.moveTo(nodes[k2].p[0], nodes[k2].p[1]);
                  } else if (nodes[k2].t === "c") {
                    ctx.bezierCurveTo(nodes[k2].pts[0], nodes[k2].pts[1], nodes[k2].pts[2], nodes[k2].pts[3], nodes[k2].pts[4], nodes[k2].pts[5]);
                  } else {
                    ctx.closePath();
                  }
                }
                if (type === "st" || type === "gs") {
                  renderer.ctxStroke();
                  if (currentStyle.da) {
                    ctx.setLineDash(this.dashResetter);
                  }
                }
              }
              if (type !== "st" && type !== "gs") {
                this.globalData.renderer.ctxFill(currentStyle.r);
              }
              renderer.restore();
            }
          }
        };
        CVShapeElement.prototype.renderShape = function(parentTransform, items, data2, isMain) {
          var i2;
          var len = items.length - 1;
          var groupTransform;
          groupTransform = parentTransform;
          for (i2 = len; i2 >= 0; i2 -= 1) {
            if (items[i2].ty === "tr") {
              groupTransform = data2[i2].transform;
              this.renderShapeTransform(parentTransform, groupTransform);
            } else if (items[i2].ty === "sh" || items[i2].ty === "el" || items[i2].ty === "rc" || items[i2].ty === "sr") {
              this.renderPath(items[i2], data2[i2]);
            } else if (items[i2].ty === "fl") {
              this.renderFill(items[i2], data2[i2], groupTransform);
            } else if (items[i2].ty === "st") {
              this.renderStroke(items[i2], data2[i2], groupTransform);
            } else if (items[i2].ty === "gf" || items[i2].ty === "gs") {
              this.renderGradientFill(items[i2], data2[i2], groupTransform);
            } else if (items[i2].ty === "gr") {
              this.renderShape(groupTransform, items[i2].it, data2[i2].it);
            } else if (items[i2].ty === "tm")
              ;
          }
          if (isMain) {
            this.drawLayer();
          }
        };
        CVShapeElement.prototype.renderStyledShape = function(styledShape, shape) {
          if (this._isFirstFrame || shape._mdf || styledShape.transforms._mdf) {
            var shapeNodes = styledShape.trNodes;
            var paths = shape.paths;
            var i2;
            var len;
            var j;
            var jLen = paths._length;
            shapeNodes.length = 0;
            var groupTransformMat = styledShape.transforms.finalTransform;
            for (j = 0; j < jLen; j += 1) {
              var pathNodes = paths.shapes[j];
              if (pathNodes && pathNodes.v) {
                len = pathNodes._length;
                for (i2 = 1; i2 < len; i2 += 1) {
                  if (i2 === 1) {
                    shapeNodes.push({
                      t: "m",
                      p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
                    });
                  }
                  shapeNodes.push({
                    t: "c",
                    pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i2 - 1], pathNodes.i[i2], pathNodes.v[i2])
                  });
                }
                if (len === 1) {
                  shapeNodes.push({
                    t: "m",
                    p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
                  });
                }
                if (pathNodes.c && len) {
                  shapeNodes.push({
                    t: "c",
                    pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i2 - 1], pathNodes.i[0], pathNodes.v[0])
                  });
                  shapeNodes.push({
                    t: "z"
                  });
                }
              }
            }
            styledShape.trNodes = shapeNodes;
          }
        };
        CVShapeElement.prototype.renderPath = function(pathData, itemData) {
          if (pathData.hd !== true && pathData._shouldRender) {
            var i2;
            var len = itemData.styledShapes.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              this.renderStyledShape(itemData.styledShapes[i2], itemData.sh);
            }
          }
        };
        CVShapeElement.prototype.renderFill = function(styleData, itemData, groupTransform) {
          var styleElem = itemData.style;
          if (itemData.c._mdf || this._isFirstFrame) {
            styleElem.co = "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")";
          }
          if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
            styleElem.coOp = itemData.o.v * groupTransform.opacity;
          }
        };
        CVShapeElement.prototype.renderGradientFill = function(styleData, itemData, groupTransform) {
          var styleElem = itemData.style;
          var grd;
          if (!styleElem.grd || itemData.g._mdf || itemData.s._mdf || itemData.e._mdf || styleData.t !== 1 && (itemData.h._mdf || itemData.a._mdf)) {
            var ctx = this.globalData.canvasContext;
            var pt1 = itemData.s.v;
            var pt2 = itemData.e.v;
            if (styleData.t === 1) {
              grd = ctx.createLinearGradient(pt1[0], pt1[1], pt2[0], pt2[1]);
            } else {
              var rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
              var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
              var percent = itemData.h.v;
              if (percent >= 1) {
                percent = 0.99;
              } else if (percent <= -1) {
                percent = -0.99;
              }
              var dist = rad * percent;
              var x2 = Math.cos(ang + itemData.a.v) * dist + pt1[0];
              var y2 = Math.sin(ang + itemData.a.v) * dist + pt1[1];
              grd = ctx.createRadialGradient(x2, y2, 0, pt1[0], pt1[1], rad);
            }
            var i2;
            var len = styleData.g.p;
            var cValues = itemData.g.c;
            var opacity = 1;
            for (i2 = 0; i2 < len; i2 += 1) {
              if (itemData.g._hasOpacity && itemData.g._collapsable) {
                opacity = itemData.g.o[i2 * 2 + 1];
              }
              grd.addColorStop(cValues[i2 * 4] / 100, "rgba(" + cValues[i2 * 4 + 1] + "," + cValues[i2 * 4 + 2] + "," + cValues[i2 * 4 + 3] + "," + opacity + ")");
            }
            styleElem.grd = grd;
          }
          styleElem.coOp = itemData.o.v * groupTransform.opacity;
        };
        CVShapeElement.prototype.renderStroke = function(styleData, itemData, groupTransform) {
          var styleElem = itemData.style;
          var d = itemData.d;
          if (d && (d._mdf || this._isFirstFrame)) {
            styleElem.da = d.dashArray;
            styleElem["do"] = d.dashoffset[0];
          }
          if (itemData.c._mdf || this._isFirstFrame) {
            styleElem.co = "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")";
          }
          if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
            styleElem.coOp = itemData.o.v * groupTransform.opacity;
          }
          if (itemData.w._mdf || this._isFirstFrame) {
            styleElem.wi = itemData.w.v;
          }
        };
        CVShapeElement.prototype.destroy = function() {
          this.shapesData = null;
          this.globalData = null;
          this.canvasContext = null;
          this.stylesList.length = 0;
          this.itemsData.length = 0;
        };
        function CVTextElement(data2, globalData2, comp2) {
          this.textSpans = [];
          this.yOffset = 0;
          this.fillColorAnim = false;
          this.strokeColorAnim = false;
          this.strokeWidthAnim = false;
          this.stroke = false;
          this.fill = false;
          this.justifyOffset = 0;
          this.currentRender = null;
          this.renderType = "canvas";
          this.values = {
            fill: "rgba(0,0,0,0)",
            stroke: "rgba(0,0,0,0)",
            sWidth: 0,
            fValue: ""
          };
          this.initElement(data2, globalData2, comp2);
        }
        extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement);
        CVTextElement.prototype.tHelper = createTag("canvas").getContext("2d");
        CVTextElement.prototype.buildNewText = function() {
          var documentData = this.textProperty.currentData;
          this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
          var hasFill = false;
          if (documentData.fc) {
            hasFill = true;
            this.values.fill = this.buildColor(documentData.fc);
          } else {
            this.values.fill = "rgba(0,0,0,0)";
          }
          this.fill = hasFill;
          var hasStroke = false;
          if (documentData.sc) {
            hasStroke = true;
            this.values.stroke = this.buildColor(documentData.sc);
            this.values.sWidth = documentData.sw;
          }
          var fontData = this.globalData.fontManager.getFontByName(documentData.f);
          var i2;
          var len;
          var letters = documentData.l;
          var matrixHelper = this.mHelper;
          this.stroke = hasStroke;
          this.values.fValue = documentData.finalSize + "px " + this.globalData.fontManager.getFontByName(documentData.f).fFamily;
          len = documentData.finalText.length;
          var charData;
          var shapeData;
          var k2;
          var kLen;
          var shapes;
          var j;
          var jLen;
          var pathNodes;
          var commands;
          var pathArr;
          var singleShape = this.data.singleShape;
          var trackingOffset = documentData.tr * 1e-3 * documentData.finalSize;
          var xPos = 0;
          var yPos = 0;
          var firstLine = true;
          var cnt = 0;
          for (i2 = 0; i2 < len; i2 += 1) {
            charData = this.globalData.fontManager.getCharData(documentData.finalText[i2], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
            shapeData = charData && charData.data || {};
            matrixHelper.reset();
            if (singleShape && letters[i2].n) {
              xPos = -trackingOffset;
              yPos += documentData.yOffset;
              yPos += firstLine ? 1 : 0;
              firstLine = false;
            }
            shapes = shapeData.shapes ? shapeData.shapes[0].it : [];
            jLen = shapes.length;
            matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
            if (singleShape) {
              this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i2].line, xPos, yPos);
            }
            commands = createSizedArray(jLen - 1);
            var commandsCounter = 0;
            for (j = 0; j < jLen; j += 1) {
              if (shapes[j].ty === "sh") {
                kLen = shapes[j].ks.k.i.length;
                pathNodes = shapes[j].ks.k;
                pathArr = [];
                for (k2 = 1; k2 < kLen; k2 += 1) {
                  if (k2 === 1) {
                    pathArr.push(matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
                  }
                  pathArr.push(matrixHelper.applyToX(pathNodes.o[k2 - 1][0], pathNodes.o[k2 - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k2 - 1][0], pathNodes.o[k2 - 1][1], 0), matrixHelper.applyToX(pathNodes.i[k2][0], pathNodes.i[k2][1], 0), matrixHelper.applyToY(pathNodes.i[k2][0], pathNodes.i[k2][1], 0), matrixHelper.applyToX(pathNodes.v[k2][0], pathNodes.v[k2][1], 0), matrixHelper.applyToY(pathNodes.v[k2][0], pathNodes.v[k2][1], 0));
                }
                pathArr.push(matrixHelper.applyToX(pathNodes.o[k2 - 1][0], pathNodes.o[k2 - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k2 - 1][0], pathNodes.o[k2 - 1][1], 0), matrixHelper.applyToX(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToY(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
                commands[commandsCounter] = pathArr;
                commandsCounter += 1;
              }
            }
            if (singleShape) {
              xPos += letters[i2].l;
              xPos += trackingOffset;
            }
            if (this.textSpans[cnt]) {
              this.textSpans[cnt].elem = commands;
            } else {
              this.textSpans[cnt] = {
                elem: commands
              };
            }
            cnt += 1;
          }
        };
        CVTextElement.prototype.renderInnerContent = function() {
          this.validateText();
          var ctx = this.canvasContext;
          ctx.font = this.values.fValue;
          this.globalData.renderer.ctxLineCap("butt");
          this.globalData.renderer.ctxLineJoin("miter");
          this.globalData.renderer.ctxMiterLimit(4);
          if (!this.data.singleShape) {
            this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
          }
          var i2;
          var len;
          var j;
          var jLen;
          var k2;
          var kLen;
          var renderedLetters = this.textAnimator.renderedLetters;
          var letters = this.textProperty.currentData.l;
          len = letters.length;
          var renderedLetter;
          var lastFill = null;
          var lastStroke = null;
          var lastStrokeW = null;
          var commands;
          var pathArr;
          var renderer = this.globalData.renderer;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (!letters[i2].n) {
              renderedLetter = renderedLetters[i2];
              if (renderedLetter) {
                renderer.save();
                renderer.ctxTransform(renderedLetter.p);
                renderer.ctxOpacity(renderedLetter.o);
              }
              if (this.fill) {
                if (renderedLetter && renderedLetter.fc) {
                  if (lastFill !== renderedLetter.fc) {
                    renderer.ctxFillStyle(renderedLetter.fc);
                    lastFill = renderedLetter.fc;
                  }
                } else if (lastFill !== this.values.fill) {
                  lastFill = this.values.fill;
                  renderer.ctxFillStyle(this.values.fill);
                }
                commands = this.textSpans[i2].elem;
                jLen = commands.length;
                this.globalData.canvasContext.beginPath();
                for (j = 0; j < jLen; j += 1) {
                  pathArr = commands[j];
                  kLen = pathArr.length;
                  this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
                  for (k2 = 2; k2 < kLen; k2 += 6) {
                    this.globalData.canvasContext.bezierCurveTo(pathArr[k2], pathArr[k2 + 1], pathArr[k2 + 2], pathArr[k2 + 3], pathArr[k2 + 4], pathArr[k2 + 5]);
                  }
                }
                this.globalData.canvasContext.closePath();
                renderer.ctxFill();
              }
              if (this.stroke) {
                if (renderedLetter && renderedLetter.sw) {
                  if (lastStrokeW !== renderedLetter.sw) {
                    lastStrokeW = renderedLetter.sw;
                    renderer.ctxLineWidth(renderedLetter.sw);
                  }
                } else if (lastStrokeW !== this.values.sWidth) {
                  lastStrokeW = this.values.sWidth;
                  renderer.ctxLineWidth(this.values.sWidth);
                }
                if (renderedLetter && renderedLetter.sc) {
                  if (lastStroke !== renderedLetter.sc) {
                    lastStroke = renderedLetter.sc;
                    renderer.ctxStrokeStyle(renderedLetter.sc);
                  }
                } else if (lastStroke !== this.values.stroke) {
                  lastStroke = this.values.stroke;
                  renderer.ctxStrokeStyle(this.values.stroke);
                }
                commands = this.textSpans[i2].elem;
                jLen = commands.length;
                this.globalData.canvasContext.beginPath();
                for (j = 0; j < jLen; j += 1) {
                  pathArr = commands[j];
                  kLen = pathArr.length;
                  this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
                  for (k2 = 2; k2 < kLen; k2 += 6) {
                    this.globalData.canvasContext.bezierCurveTo(pathArr[k2], pathArr[k2 + 1], pathArr[k2 + 2], pathArr[k2 + 3], pathArr[k2 + 4], pathArr[k2 + 5]);
                  }
                }
                this.globalData.canvasContext.closePath();
                renderer.ctxStroke();
              }
              if (renderedLetter) {
                this.globalData.renderer.restore();
              }
            }
          }
        };
        function CVImageElement(data2, globalData2, comp2) {
          this.assetData = globalData2.getAssetData(data2.refId);
          this.img = globalData2.imageLoader.getAsset(this.assetData);
          this.initElement(data2, globalData2, comp2);
        }
        extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement);
        CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement;
        CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;
        CVImageElement.prototype.createContent = function() {
          if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
            var canvas = createTag("canvas");
            canvas.width = this.assetData.w;
            canvas.height = this.assetData.h;
            var ctx = canvas.getContext("2d");
            var imgW = this.img.width;
            var imgH = this.img.height;
            var imgRel = imgW / imgH;
            var canvasRel = this.assetData.w / this.assetData.h;
            var widthCrop;
            var heightCrop;
            var par = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;
            if (imgRel > canvasRel && par === "xMidYMid slice" || imgRel < canvasRel && par !== "xMidYMid slice") {
              heightCrop = imgH;
              widthCrop = heightCrop * canvasRel;
            } else {
              widthCrop = imgW;
              heightCrop = widthCrop / canvasRel;
            }
            ctx.drawImage(this.img, (imgW - widthCrop) / 2, (imgH - heightCrop) / 2, widthCrop, heightCrop, 0, 0, this.assetData.w, this.assetData.h);
            this.img = canvas;
          }
        };
        CVImageElement.prototype.renderInnerContent = function() {
          this.canvasContext.drawImage(this.img, 0, 0);
        };
        CVImageElement.prototype.destroy = function() {
          this.img = null;
        };
        function CVSolidElement(data2, globalData2, comp2) {
          this.initElement(data2, globalData2, comp2);
        }
        extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement);
        CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement;
        CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;
        CVSolidElement.prototype.renderInnerContent = function() {
          this.globalData.renderer.ctxFillStyle(this.data.sc);
          this.globalData.renderer.ctxFillRect(0, 0, this.data.sw, this.data.sh);
        };
        function CanvasRendererBase() {
        }
        extendPrototype([BaseRenderer], CanvasRendererBase);
        CanvasRendererBase.prototype.createShape = function(data2) {
          return new CVShapeElement(data2, this.globalData, this);
        };
        CanvasRendererBase.prototype.createText = function(data2) {
          return new CVTextElement(data2, this.globalData, this);
        };
        CanvasRendererBase.prototype.createImage = function(data2) {
          return new CVImageElement(data2, this.globalData, this);
        };
        CanvasRendererBase.prototype.createSolid = function(data2) {
          return new CVSolidElement(data2, this.globalData, this);
        };
        CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;
        CanvasRendererBase.prototype.ctxTransform = function(props) {
          if (props[0] === 1 && props[1] === 0 && props[4] === 0 && props[5] === 1 && props[12] === 0 && props[13] === 0) {
            return;
          }
          this.canvasContext.transform(props[0], props[1], props[4], props[5], props[12], props[13]);
        };
        CanvasRendererBase.prototype.ctxOpacity = function(op2) {
          this.canvasContext.globalAlpha *= op2 < 0 ? 0 : op2;
        };
        CanvasRendererBase.prototype.ctxFillStyle = function(value2) {
          this.canvasContext.fillStyle = value2;
        };
        CanvasRendererBase.prototype.ctxStrokeStyle = function(value2) {
          this.canvasContext.strokeStyle = value2;
        };
        CanvasRendererBase.prototype.ctxLineWidth = function(value2) {
          this.canvasContext.lineWidth = value2;
        };
        CanvasRendererBase.prototype.ctxLineCap = function(value2) {
          this.canvasContext.lineCap = value2;
        };
        CanvasRendererBase.prototype.ctxLineJoin = function(value2) {
          this.canvasContext.lineJoin = value2;
        };
        CanvasRendererBase.prototype.ctxMiterLimit = function(value2) {
          this.canvasContext.miterLimit = value2;
        };
        CanvasRendererBase.prototype.ctxFill = function(rule) {
          this.canvasContext.fill(rule);
        };
        CanvasRendererBase.prototype.ctxFillRect = function(x2, y2, w2, h2) {
          this.canvasContext.fillRect(x2, y2, w2, h2);
        };
        CanvasRendererBase.prototype.ctxStroke = function() {
          this.canvasContext.stroke();
        };
        CanvasRendererBase.prototype.reset = function() {
          if (!this.renderConfig.clearCanvas) {
            this.canvasContext.restore();
            return;
          }
          this.contextData.reset();
        };
        CanvasRendererBase.prototype.save = function() {
          this.canvasContext.save();
        };
        CanvasRendererBase.prototype.restore = function(actionFlag) {
          if (!this.renderConfig.clearCanvas) {
            this.canvasContext.restore();
            return;
          }
          if (actionFlag) {
            this.globalData.blendMode = "source-over";
          }
          this.contextData.restore(actionFlag);
        };
        CanvasRendererBase.prototype.configAnimation = function(animData) {
          if (this.animationItem.wrapper) {
            this.animationItem.container = createTag("canvas");
            var containerStyle = this.animationItem.container.style;
            containerStyle.width = "100%";
            containerStyle.height = "100%";
            var origin = "0px 0px 0px";
            containerStyle.transformOrigin = origin;
            containerStyle.mozTransformOrigin = origin;
            containerStyle.webkitTransformOrigin = origin;
            containerStyle["-webkit-transform"] = origin;
            containerStyle.contentVisibility = this.renderConfig.contentVisibility;
            this.animationItem.wrapper.appendChild(this.animationItem.container);
            this.canvasContext = this.animationItem.container.getContext("2d");
            if (this.renderConfig.className) {
              this.animationItem.container.setAttribute("class", this.renderConfig.className);
            }
            if (this.renderConfig.id) {
              this.animationItem.container.setAttribute("id", this.renderConfig.id);
            }
          } else {
            this.canvasContext = this.renderConfig.context;
          }
          this.contextData.setContext(this.canvasContext);
          this.data = animData;
          this.layers = animData.layers;
          this.transformCanvas = {
            w: animData.w,
            h: animData.h,
            sx: 0,
            sy: 0,
            tx: 0,
            ty: 0
          };
          this.setupGlobalData(animData, document.body);
          this.globalData.canvasContext = this.canvasContext;
          this.globalData.renderer = this;
          this.globalData.isDashed = false;
          this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
          this.globalData.transformCanvas = this.transformCanvas;
          this.elements = createSizedArray(animData.layers.length);
          this.updateContainerSize();
        };
        CanvasRendererBase.prototype.updateContainerSize = function(width2, height2) {
          this.reset();
          var elementWidth;
          var elementHeight;
          if (width2) {
            elementWidth = width2;
            elementHeight = height2;
            this.canvasContext.canvas.width = elementWidth;
            this.canvasContext.canvas.height = elementHeight;
          } else {
            if (this.animationItem.wrapper && this.animationItem.container) {
              elementWidth = this.animationItem.wrapper.offsetWidth;
              elementHeight = this.animationItem.wrapper.offsetHeight;
            } else {
              elementWidth = this.canvasContext.canvas.width;
              elementHeight = this.canvasContext.canvas.height;
            }
            this.canvasContext.canvas.width = elementWidth * this.renderConfig.dpr;
            this.canvasContext.canvas.height = elementHeight * this.renderConfig.dpr;
          }
          var elementRel;
          var animationRel;
          if (this.renderConfig.preserveAspectRatio.indexOf("meet") !== -1 || this.renderConfig.preserveAspectRatio.indexOf("slice") !== -1) {
            var par = this.renderConfig.preserveAspectRatio.split(" ");
            var fillType = par[1] || "meet";
            var pos = par[0] || "xMidYMid";
            var xPos = pos.substr(0, 4);
            var yPos = pos.substr(4);
            elementRel = elementWidth / elementHeight;
            animationRel = this.transformCanvas.w / this.transformCanvas.h;
            if (animationRel > elementRel && fillType === "meet" || animationRel < elementRel && fillType === "slice") {
              this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
              this.transformCanvas.sy = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
            } else {
              this.transformCanvas.sx = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
              this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
            }
            if (xPos === "xMid" && (animationRel < elementRel && fillType === "meet" || animationRel > elementRel && fillType === "slice")) {
              this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) / 2 * this.renderConfig.dpr;
            } else if (xPos === "xMax" && (animationRel < elementRel && fillType === "meet" || animationRel > elementRel && fillType === "slice")) {
              this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) * this.renderConfig.dpr;
            } else {
              this.transformCanvas.tx = 0;
            }
            if (yPos === "YMid" && (animationRel > elementRel && fillType === "meet" || animationRel < elementRel && fillType === "slice")) {
              this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) / 2 * this.renderConfig.dpr;
            } else if (yPos === "YMax" && (animationRel > elementRel && fillType === "meet" || animationRel < elementRel && fillType === "slice")) {
              this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) * this.renderConfig.dpr;
            } else {
              this.transformCanvas.ty = 0;
            }
          } else if (this.renderConfig.preserveAspectRatio === "none") {
            this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
            this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
            this.transformCanvas.tx = 0;
            this.transformCanvas.ty = 0;
          } else {
            this.transformCanvas.sx = this.renderConfig.dpr;
            this.transformCanvas.sy = this.renderConfig.dpr;
            this.transformCanvas.tx = 0;
            this.transformCanvas.ty = 0;
          }
          this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1];
          this.ctxTransform(this.transformCanvas.props);
          this.canvasContext.beginPath();
          this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
          this.canvasContext.closePath();
          this.canvasContext.clip();
          this.renderFrame(this.renderedFrame, true);
        };
        CanvasRendererBase.prototype.destroy = function() {
          if (this.renderConfig.clearCanvas && this.animationItem.wrapper) {
            this.animationItem.wrapper.innerText = "";
          }
          var i2;
          var len = this.layers ? this.layers.length : 0;
          for (i2 = len - 1; i2 >= 0; i2 -= 1) {
            if (this.elements[i2] && this.elements[i2].destroy) {
              this.elements[i2].destroy();
            }
          }
          this.elements.length = 0;
          this.globalData.canvasContext = null;
          this.animationItem.container = null;
          this.destroyed = true;
        };
        CanvasRendererBase.prototype.renderFrame = function(num, forceRender) {
          if (this.renderedFrame === num && this.renderConfig.clearCanvas === true && !forceRender || this.destroyed || num === -1) {
            return;
          }
          this.renderedFrame = num;
          this.globalData.frameNum = num - this.animationItem._isFirstFrame;
          this.globalData.frameId += 1;
          this.globalData._mdf = !this.renderConfig.clearCanvas || forceRender;
          this.globalData.projectInterface.currentFrame = num;
          var i2;
          var len = this.layers.length;
          if (!this.completeLayers) {
            this.checkLayers(num);
          }
          for (i2 = len - 1; i2 >= 0; i2 -= 1) {
            if (this.completeLayers || this.elements[i2]) {
              this.elements[i2].prepareFrame(num - this.layers[i2].st);
            }
          }
          if (this.globalData._mdf) {
            if (this.renderConfig.clearCanvas === true) {
              this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
            } else {
              this.save();
            }
            for (i2 = len - 1; i2 >= 0; i2 -= 1) {
              if (this.completeLayers || this.elements[i2]) {
                this.elements[i2].renderFrame();
              }
            }
            if (this.renderConfig.clearCanvas !== true) {
              this.restore();
            }
          }
        };
        CanvasRendererBase.prototype.buildItem = function(pos) {
          var elements = this.elements;
          if (elements[pos] || this.layers[pos].ty === 99) {
            return;
          }
          var element = this.createItem(this.layers[pos], this, this.globalData);
          elements[pos] = element;
          element.initExpressions();
        };
        CanvasRendererBase.prototype.checkPendingElements = function() {
          while (this.pendingElements.length) {
            var element = this.pendingElements.pop();
            element.checkParenting();
          }
        };
        CanvasRendererBase.prototype.hide = function() {
          this.animationItem.container.style.display = "none";
        };
        CanvasRendererBase.prototype.show = function() {
          this.animationItem.container.style.display = "block";
        };
        function CanvasContext() {
          this.opacity = -1;
          this.transform = createTypedArray("float32", 16);
          this.fillStyle = "";
          this.strokeStyle = "";
          this.lineWidth = "";
          this.lineCap = "";
          this.lineJoin = "";
          this.miterLimit = "";
          this.id = Math.random();
        }
        function CVContextData() {
          this.stack = [];
          this.cArrPos = 0;
          this.cTr = new Matrix();
          var i2;
          var len = 15;
          for (i2 = 0; i2 < len; i2 += 1) {
            var canvasContext = new CanvasContext();
            this.stack[i2] = canvasContext;
          }
          this._length = len;
          this.nativeContext = null;
          this.transformMat = new Matrix();
          this.currentOpacity = 1;
          this.currentFillStyle = "";
          this.appliedFillStyle = "";
          this.currentStrokeStyle = "";
          this.appliedStrokeStyle = "";
          this.currentLineWidth = "";
          this.appliedLineWidth = "";
          this.currentLineCap = "";
          this.appliedLineCap = "";
          this.currentLineJoin = "";
          this.appliedLineJoin = "";
          this.appliedMiterLimit = "";
          this.currentMiterLimit = "";
        }
        CVContextData.prototype.duplicate = function() {
          var newLength = this._length * 2;
          var i2 = 0;
          for (i2 = this._length; i2 < newLength; i2 += 1) {
            this.stack[i2] = new CanvasContext();
          }
          this._length = newLength;
        };
        CVContextData.prototype.reset = function() {
          this.cArrPos = 0;
          this.cTr.reset();
          this.stack[this.cArrPos].opacity = 1;
        };
        CVContextData.prototype.restore = function(forceRestore) {
          this.cArrPos -= 1;
          var currentContext = this.stack[this.cArrPos];
          var transform2 = currentContext.transform;
          var i2;
          var arr2 = this.cTr.props;
          for (i2 = 0; i2 < 16; i2 += 1) {
            arr2[i2] = transform2[i2];
          }
          if (forceRestore) {
            this.nativeContext.restore();
            var prevStack = this.stack[this.cArrPos + 1];
            this.appliedFillStyle = prevStack.fillStyle;
            this.appliedStrokeStyle = prevStack.strokeStyle;
            this.appliedLineWidth = prevStack.lineWidth;
            this.appliedLineCap = prevStack.lineCap;
            this.appliedLineJoin = prevStack.lineJoin;
            this.appliedMiterLimit = prevStack.miterLimit;
          }
          this.nativeContext.setTransform(transform2[0], transform2[1], transform2[4], transform2[5], transform2[12], transform2[13]);
          if (forceRestore || currentContext.opacity !== -1 && this.currentOpacity !== currentContext.opacity) {
            this.nativeContext.globalAlpha = currentContext.opacity;
            this.currentOpacity = currentContext.opacity;
          }
          this.currentFillStyle = currentContext.fillStyle;
          this.currentStrokeStyle = currentContext.strokeStyle;
          this.currentLineWidth = currentContext.lineWidth;
          this.currentLineCap = currentContext.lineCap;
          this.currentLineJoin = currentContext.lineJoin;
          this.currentMiterLimit = currentContext.miterLimit;
        };
        CVContextData.prototype.save = function(saveOnNativeFlag) {
          if (saveOnNativeFlag) {
            this.nativeContext.save();
          }
          var props = this.cTr.props;
          if (this._length <= this.cArrPos) {
            this.duplicate();
          }
          var currentStack = this.stack[this.cArrPos];
          var i2;
          for (i2 = 0; i2 < 16; i2 += 1) {
            currentStack.transform[i2] = props[i2];
          }
          this.cArrPos += 1;
          var newStack = this.stack[this.cArrPos];
          newStack.opacity = currentStack.opacity;
          newStack.fillStyle = currentStack.fillStyle;
          newStack.strokeStyle = currentStack.strokeStyle;
          newStack.lineWidth = currentStack.lineWidth;
          newStack.lineCap = currentStack.lineCap;
          newStack.lineJoin = currentStack.lineJoin;
          newStack.miterLimit = currentStack.miterLimit;
        };
        CVContextData.prototype.setOpacity = function(value2) {
          this.stack[this.cArrPos].opacity = value2;
        };
        CVContextData.prototype.setContext = function(value2) {
          this.nativeContext = value2;
        };
        CVContextData.prototype.fillStyle = function(value2) {
          if (this.stack[this.cArrPos].fillStyle !== value2) {
            this.currentFillStyle = value2;
            this.stack[this.cArrPos].fillStyle = value2;
          }
        };
        CVContextData.prototype.strokeStyle = function(value2) {
          if (this.stack[this.cArrPos].strokeStyle !== value2) {
            this.currentStrokeStyle = value2;
            this.stack[this.cArrPos].strokeStyle = value2;
          }
        };
        CVContextData.prototype.lineWidth = function(value2) {
          if (this.stack[this.cArrPos].lineWidth !== value2) {
            this.currentLineWidth = value2;
            this.stack[this.cArrPos].lineWidth = value2;
          }
        };
        CVContextData.prototype.lineCap = function(value2) {
          if (this.stack[this.cArrPos].lineCap !== value2) {
            this.currentLineCap = value2;
            this.stack[this.cArrPos].lineCap = value2;
          }
        };
        CVContextData.prototype.lineJoin = function(value2) {
          if (this.stack[this.cArrPos].lineJoin !== value2) {
            this.currentLineJoin = value2;
            this.stack[this.cArrPos].lineJoin = value2;
          }
        };
        CVContextData.prototype.miterLimit = function(value2) {
          if (this.stack[this.cArrPos].miterLimit !== value2) {
            this.currentMiterLimit = value2;
            this.stack[this.cArrPos].miterLimit = value2;
          }
        };
        CVContextData.prototype.transform = function(props) {
          this.transformMat.cloneFromProps(props);
          var currentTransform = this.cTr;
          this.transformMat.multiply(currentTransform);
          currentTransform.cloneFromProps(this.transformMat.props);
          var trProps = currentTransform.props;
          this.nativeContext.setTransform(trProps[0], trProps[1], trProps[4], trProps[5], trProps[12], trProps[13]);
        };
        CVContextData.prototype.opacity = function(op2) {
          var currentOpacity = this.stack[this.cArrPos].opacity;
          currentOpacity *= op2 < 0 ? 0 : op2;
          if (this.stack[this.cArrPos].opacity !== currentOpacity) {
            if (this.currentOpacity !== op2) {
              this.nativeContext.globalAlpha = op2;
              this.currentOpacity = op2;
            }
            this.stack[this.cArrPos].opacity = currentOpacity;
          }
        };
        CVContextData.prototype.fill = function(rule) {
          if (this.appliedFillStyle !== this.currentFillStyle) {
            this.appliedFillStyle = this.currentFillStyle;
            this.nativeContext.fillStyle = this.appliedFillStyle;
          }
          this.nativeContext.fill(rule);
        };
        CVContextData.prototype.fillRect = function(x2, y2, w2, h2) {
          if (this.appliedFillStyle !== this.currentFillStyle) {
            this.appliedFillStyle = this.currentFillStyle;
            this.nativeContext.fillStyle = this.appliedFillStyle;
          }
          this.nativeContext.fillRect(x2, y2, w2, h2);
        };
        CVContextData.prototype.stroke = function() {
          if (this.appliedStrokeStyle !== this.currentStrokeStyle) {
            this.appliedStrokeStyle = this.currentStrokeStyle;
            this.nativeContext.strokeStyle = this.appliedStrokeStyle;
          }
          if (this.appliedLineWidth !== this.currentLineWidth) {
            this.appliedLineWidth = this.currentLineWidth;
            this.nativeContext.lineWidth = this.appliedLineWidth;
          }
          if (this.appliedLineCap !== this.currentLineCap) {
            this.appliedLineCap = this.currentLineCap;
            this.nativeContext.lineCap = this.appliedLineCap;
          }
          if (this.appliedLineJoin !== this.currentLineJoin) {
            this.appliedLineJoin = this.currentLineJoin;
            this.nativeContext.lineJoin = this.appliedLineJoin;
          }
          if (this.appliedMiterLimit !== this.currentMiterLimit) {
            this.appliedMiterLimit = this.currentMiterLimit;
            this.nativeContext.miterLimit = this.appliedMiterLimit;
          }
          this.nativeContext.stroke();
        };
        function CVCompElement(data2, globalData2, comp2) {
          this.completeLayers = false;
          this.layers = data2.layers;
          this.pendingElements = [];
          this.elements = createSizedArray(this.layers.length);
          this.initElement(data2, globalData2, comp2);
          this.tm = data2.tm ? PropertyFactory.getProp(this, data2.tm, 0, globalData2.frameRate, this) : {
            _placeholder: true
          };
        }
        extendPrototype([CanvasRendererBase, ICompElement, CVBaseElement], CVCompElement);
        CVCompElement.prototype.renderInnerContent = function() {
          var ctx = this.canvasContext;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(this.data.w, 0);
          ctx.lineTo(this.data.w, this.data.h);
          ctx.lineTo(0, this.data.h);
          ctx.lineTo(0, 0);
          ctx.clip();
          var i2;
          var len = this.layers.length;
          for (i2 = len - 1; i2 >= 0; i2 -= 1) {
            if (this.completeLayers || this.elements[i2]) {
              this.elements[i2].renderFrame();
            }
          }
        };
        CVCompElement.prototype.destroy = function() {
          var i2;
          var len = this.layers.length;
          for (i2 = len - 1; i2 >= 0; i2 -= 1) {
            if (this.elements[i2]) {
              this.elements[i2].destroy();
            }
          }
          this.layers = null;
          this.elements = null;
        };
        CVCompElement.prototype.createComp = function(data2) {
          return new CVCompElement(data2, this.globalData, this);
        };
        function CanvasRenderer(animationItem, config) {
          this.animationItem = animationItem;
          this.renderConfig = {
            clearCanvas: config && config.clearCanvas !== void 0 ? config.clearCanvas : true,
            context: config && config.context || null,
            progressiveLoad: config && config.progressiveLoad || false,
            preserveAspectRatio: config && config.preserveAspectRatio || "xMidYMid meet",
            imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || "xMidYMid slice",
            contentVisibility: config && config.contentVisibility || "visible",
            className: config && config.className || "",
            id: config && config.id || "",
            runExpressions: !config || config.runExpressions === void 0 || config.runExpressions
          };
          this.renderConfig.dpr = config && config.dpr || 1;
          if (this.animationItem.wrapper) {
            this.renderConfig.dpr = config && config.dpr || window.devicePixelRatio || 1;
          }
          this.renderedFrame = -1;
          this.globalData = {
            frameNum: -1,
            _mdf: false,
            renderConfig: this.renderConfig,
            currentGlobalAlpha: -1
          };
          this.contextData = new CVContextData();
          this.elements = [];
          this.pendingElements = [];
          this.transformMat = new Matrix();
          this.completeLayers = false;
          this.rendererType = "canvas";
          if (this.renderConfig.clearCanvas) {
            this.ctxTransform = this.contextData.transform.bind(this.contextData);
            this.ctxOpacity = this.contextData.opacity.bind(this.contextData);
            this.ctxFillStyle = this.contextData.fillStyle.bind(this.contextData);
            this.ctxStrokeStyle = this.contextData.strokeStyle.bind(this.contextData);
            this.ctxLineWidth = this.contextData.lineWidth.bind(this.contextData);
            this.ctxLineCap = this.contextData.lineCap.bind(this.contextData);
            this.ctxLineJoin = this.contextData.lineJoin.bind(this.contextData);
            this.ctxMiterLimit = this.contextData.miterLimit.bind(this.contextData);
            this.ctxFill = this.contextData.fill.bind(this.contextData);
            this.ctxFillRect = this.contextData.fillRect.bind(this.contextData);
            this.ctxStroke = this.contextData.stroke.bind(this.contextData);
            this.save = this.contextData.save.bind(this.contextData);
          }
        }
        extendPrototype([CanvasRendererBase], CanvasRenderer);
        CanvasRenderer.prototype.createComp = function(data2) {
          return new CVCompElement(data2, this.globalData, this);
        };
        function HBaseElement() {
        }
        HBaseElement.prototype = {
          checkBlendMode: function checkBlendMode() {
          },
          initRendererElement: function initRendererElement() {
            this.baseElement = createTag(this.data.tg || "div");
            if (this.data.hasMask) {
              this.svgElement = createNS("svg");
              this.layerElement = createNS("g");
              this.maskedElement = this.layerElement;
              this.svgElement.appendChild(this.layerElement);
              this.baseElement.appendChild(this.svgElement);
            } else {
              this.layerElement = this.baseElement;
            }
            styleDiv(this.baseElement);
          },
          createContainerElements: function createContainerElements() {
            this.renderableEffectsManager = new CVEffects(this);
            this.transformedElement = this.baseElement;
            this.maskedElement = this.layerElement;
            if (this.data.ln) {
              this.layerElement.setAttribute("id", this.data.ln);
            }
            if (this.data.cl) {
              this.layerElement.setAttribute("class", this.data.cl);
            }
            if (this.data.bm !== 0) {
              this.setBlendMode();
            }
          },
          renderElement: function renderElement() {
            var transformedElementStyle = this.transformedElement ? this.transformedElement.style : {};
            if (this.finalTransform._matMdf) {
              var matrixValue = this.finalTransform.mat.toCSS();
              transformedElementStyle.transform = matrixValue;
              transformedElementStyle.webkitTransform = matrixValue;
            }
            if (this.finalTransform._opMdf) {
              transformedElementStyle.opacity = this.finalTransform.mProp.o.v;
            }
          },
          renderFrame: function renderFrame() {
            if (this.data.hd || this.hidden) {
              return;
            }
            this.renderTransform();
            this.renderRenderable();
            this.renderElement();
            this.renderInnerContent();
            if (this._isFirstFrame) {
              this._isFirstFrame = false;
            }
          },
          destroy: function destroy() {
            this.layerElement = null;
            this.transformedElement = null;
            if (this.matteElement) {
              this.matteElement = null;
            }
            if (this.maskManager) {
              this.maskManager.destroy();
              this.maskManager = null;
            }
          },
          createRenderableComponents: function createRenderableComponents() {
            this.maskManager = new MaskElement(this.data, this, this.globalData);
          },
          addEffects: function addEffects() {
          },
          setMatte: function setMatte() {
          }
        };
        HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement;
        HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy;
        HBaseElement.prototype.buildElementParenting = BaseRenderer.prototype.buildElementParenting;
        function HSolidElement(data2, globalData2, comp2) {
          this.initElement(data2, globalData2, comp2);
        }
        extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement);
        HSolidElement.prototype.createContent = function() {
          var rect;
          if (this.data.hasMask) {
            rect = createNS("rect");
            rect.setAttribute("width", this.data.sw);
            rect.setAttribute("height", this.data.sh);
            rect.setAttribute("fill", this.data.sc);
            this.svgElement.setAttribute("width", this.data.sw);
            this.svgElement.setAttribute("height", this.data.sh);
          } else {
            rect = createTag("div");
            rect.style.width = this.data.sw + "px";
            rect.style.height = this.data.sh + "px";
            rect.style.backgroundColor = this.data.sc;
          }
          this.layerElement.appendChild(rect);
        };
        function HShapeElement(data2, globalData2, comp2) {
          this.shapes = [];
          this.shapesData = data2.shapes;
          this.stylesList = [];
          this.shapeModifiers = [];
          this.itemsData = [];
          this.processedElements = [];
          this.animatedContents = [];
          this.shapesContainer = createNS("g");
          this.initElement(data2, globalData2, comp2);
          this.prevViewData = [];
          this.currentBBox = {
            x: 999999,
            y: -999999,
            h: 0,
            w: 0
          };
        }
        extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement);
        HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent;
        HShapeElement.prototype.createContent = function() {
          var cont;
          this.baseElement.style.fontSize = 0;
          if (this.data.hasMask) {
            this.layerElement.appendChild(this.shapesContainer);
            cont = this.svgElement;
          } else {
            cont = createNS("svg");
            var size = this.comp.data ? this.comp.data : this.globalData.compSize;
            cont.setAttribute("width", size.w);
            cont.setAttribute("height", size.h);
            cont.appendChild(this.shapesContainer);
            this.layerElement.appendChild(cont);
          }
          this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], true);
          this.filterUniqueShapes();
          this.shapeCont = cont;
        };
        HShapeElement.prototype.getTransformedPoint = function(transformers, point) {
          var i2;
          var len = transformers.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            point = transformers[i2].mProps.v.applyToPointArray(point[0], point[1], 0);
          }
          return point;
        };
        HShapeElement.prototype.calculateShapeBoundingBox = function(item, boundingBox) {
          var shape = item.sh.v;
          var transformers = item.transformers;
          var i2;
          var len = shape._length;
          var vPoint;
          var oPoint;
          var nextIPoint;
          var nextVPoint;
          if (len <= 1) {
            return;
          }
          for (i2 = 0; i2 < len - 1; i2 += 1) {
            vPoint = this.getTransformedPoint(transformers, shape.v[i2]);
            oPoint = this.getTransformedPoint(transformers, shape.o[i2]);
            nextIPoint = this.getTransformedPoint(transformers, shape.i[i2 + 1]);
            nextVPoint = this.getTransformedPoint(transformers, shape.v[i2 + 1]);
            this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
          }
          if (shape.c) {
            vPoint = this.getTransformedPoint(transformers, shape.v[i2]);
            oPoint = this.getTransformedPoint(transformers, shape.o[i2]);
            nextIPoint = this.getTransformedPoint(transformers, shape.i[0]);
            nextVPoint = this.getTransformedPoint(transformers, shape.v[0]);
            this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
          }
        };
        HShapeElement.prototype.checkBounds = function(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox) {
          this.getBoundsOfCurve(vPoint, oPoint, nextIPoint, nextVPoint);
          var bounds = this.shapeBoundingBox;
          boundingBox.x = bmMin(bounds.left, boundingBox.x);
          boundingBox.xMax = bmMax(bounds.right, boundingBox.xMax);
          boundingBox.y = bmMin(bounds.top, boundingBox.y);
          boundingBox.yMax = bmMax(bounds.bottom, boundingBox.yMax);
        };
        HShapeElement.prototype.shapeBoundingBox = {
          left: 0,
          right: 0,
          top: 0,
          bottom: 0
        };
        HShapeElement.prototype.tempBoundingBox = {
          x: 0,
          xMax: 0,
          y: 0,
          yMax: 0,
          width: 0,
          height: 0
        };
        HShapeElement.prototype.getBoundsOfCurve = function(p0, p1, p2, p3) {
          var bounds = [[p0[0], p3[0]], [p0[1], p3[1]]];
          for (var a2, b, c2, t2, b2ac, t1, t22, i2 = 0; i2 < 2; ++i2) {
            b = 6 * p0[i2] - 12 * p1[i2] + 6 * p2[i2];
            a2 = -3 * p0[i2] + 9 * p1[i2] - 9 * p2[i2] + 3 * p3[i2];
            c2 = 3 * p1[i2] - 3 * p0[i2];
            b |= 0;
            a2 |= 0;
            c2 |= 0;
            if (a2 === 0 && b === 0)
              ;
            else if (a2 === 0) {
              t2 = -c2 / b;
              if (t2 > 0 && t2 < 1) {
                bounds[i2].push(this.calculateF(t2, p0, p1, p2, p3, i2));
              }
            } else {
              b2ac = b * b - 4 * c2 * a2;
              if (b2ac >= 0) {
                t1 = (-b + bmSqrt(b2ac)) / (2 * a2);
                if (t1 > 0 && t1 < 1)
                  bounds[i2].push(this.calculateF(t1, p0, p1, p2, p3, i2));
                t22 = (-b - bmSqrt(b2ac)) / (2 * a2);
                if (t22 > 0 && t22 < 1)
                  bounds[i2].push(this.calculateF(t22, p0, p1, p2, p3, i2));
              }
            }
          }
          this.shapeBoundingBox.left = bmMin.apply(null, bounds[0]);
          this.shapeBoundingBox.top = bmMin.apply(null, bounds[1]);
          this.shapeBoundingBox.right = bmMax.apply(null, bounds[0]);
          this.shapeBoundingBox.bottom = bmMax.apply(null, bounds[1]);
        };
        HShapeElement.prototype.calculateF = function(t2, p0, p1, p2, p3, i2) {
          return bmPow(1 - t2, 3) * p0[i2] + 3 * bmPow(1 - t2, 2) * t2 * p1[i2] + 3 * (1 - t2) * bmPow(t2, 2) * p2[i2] + bmPow(t2, 3) * p3[i2];
        };
        HShapeElement.prototype.calculateBoundingBox = function(itemsData, boundingBox) {
          var i2;
          var len = itemsData.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (itemsData[i2] && itemsData[i2].sh) {
              this.calculateShapeBoundingBox(itemsData[i2], boundingBox);
            } else if (itemsData[i2] && itemsData[i2].it) {
              this.calculateBoundingBox(itemsData[i2].it, boundingBox);
            } else if (itemsData[i2] && itemsData[i2].style && itemsData[i2].w) {
              this.expandStrokeBoundingBox(itemsData[i2].w, boundingBox);
            }
          }
        };
        HShapeElement.prototype.expandStrokeBoundingBox = function(widthProperty, boundingBox) {
          var width2 = 0;
          if (widthProperty.keyframes) {
            for (var i2 = 0; i2 < widthProperty.keyframes.length; i2 += 1) {
              var kfw = widthProperty.keyframes[i2].s;
              if (kfw > width2) {
                width2 = kfw;
              }
            }
            width2 *= widthProperty.mult;
          } else {
            width2 = widthProperty.v * widthProperty.mult;
          }
          boundingBox.x -= width2;
          boundingBox.xMax += width2;
          boundingBox.y -= width2;
          boundingBox.yMax += width2;
        };
        HShapeElement.prototype.currentBoxContains = function(box) {
          return this.currentBBox.x <= box.x && this.currentBBox.y <= box.y && this.currentBBox.width + this.currentBBox.x >= box.x + box.width && this.currentBBox.height + this.currentBBox.y >= box.y + box.height;
        };
        HShapeElement.prototype.renderInnerContent = function() {
          this._renderShapeFrame();
          if (!this.hidden && (this._isFirstFrame || this._mdf)) {
            var tempBoundingBox = this.tempBoundingBox;
            var max = 999999;
            tempBoundingBox.x = max;
            tempBoundingBox.xMax = -max;
            tempBoundingBox.y = max;
            tempBoundingBox.yMax = -max;
            this.calculateBoundingBox(this.itemsData, tempBoundingBox);
            tempBoundingBox.width = tempBoundingBox.xMax < tempBoundingBox.x ? 0 : tempBoundingBox.xMax - tempBoundingBox.x;
            tempBoundingBox.height = tempBoundingBox.yMax < tempBoundingBox.y ? 0 : tempBoundingBox.yMax - tempBoundingBox.y;
            if (this.currentBoxContains(tempBoundingBox)) {
              return;
            }
            var changed = false;
            if (this.currentBBox.w !== tempBoundingBox.width) {
              this.currentBBox.w = tempBoundingBox.width;
              this.shapeCont.setAttribute("width", tempBoundingBox.width);
              changed = true;
            }
            if (this.currentBBox.h !== tempBoundingBox.height) {
              this.currentBBox.h = tempBoundingBox.height;
              this.shapeCont.setAttribute("height", tempBoundingBox.height);
              changed = true;
            }
            if (changed || this.currentBBox.x !== tempBoundingBox.x || this.currentBBox.y !== tempBoundingBox.y) {
              this.currentBBox.w = tempBoundingBox.width;
              this.currentBBox.h = tempBoundingBox.height;
              this.currentBBox.x = tempBoundingBox.x;
              this.currentBBox.y = tempBoundingBox.y;
              this.shapeCont.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h);
              var shapeStyle = this.shapeCont.style;
              var shapeTransform = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
              shapeStyle.transform = shapeTransform;
              shapeStyle.webkitTransform = shapeTransform;
            }
          }
        };
        function HTextElement(data2, globalData2, comp2) {
          this.textSpans = [];
          this.textPaths = [];
          this.currentBBox = {
            x: 999999,
            y: -999999,
            h: 0,
            w: 0
          };
          this.renderType = "svg";
          this.isMasked = false;
          this.initElement(data2, globalData2, comp2);
        }
        extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement);
        HTextElement.prototype.createContent = function() {
          this.isMasked = this.checkMasks();
          if (this.isMasked) {
            this.renderType = "svg";
            this.compW = this.comp.data.w;
            this.compH = this.comp.data.h;
            this.svgElement.setAttribute("width", this.compW);
            this.svgElement.setAttribute("height", this.compH);
            var g2 = createNS("g");
            this.maskedElement.appendChild(g2);
            this.innerElem = g2;
          } else {
            this.renderType = "html";
            this.innerElem = this.layerElement;
          }
          this.checkParenting();
        };
        HTextElement.prototype.buildNewText = function() {
          var documentData = this.textProperty.currentData;
          this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
          var innerElemStyle = this.innerElem.style;
          var textColor = documentData.fc ? this.buildColor(documentData.fc) : "rgba(0,0,0,0)";
          innerElemStyle.fill = textColor;
          innerElemStyle.color = textColor;
          if (documentData.sc) {
            innerElemStyle.stroke = this.buildColor(documentData.sc);
            innerElemStyle.strokeWidth = documentData.sw + "px";
          }
          var fontData = this.globalData.fontManager.getFontByName(documentData.f);
          if (!this.globalData.fontManager.chars) {
            innerElemStyle.fontSize = documentData.finalSize + "px";
            innerElemStyle.lineHeight = documentData.finalSize + "px";
            if (fontData.fClass) {
              this.innerElem.className = fontData.fClass;
            } else {
              innerElemStyle.fontFamily = fontData.fFamily;
              var fWeight = documentData.fWeight;
              var fStyle = documentData.fStyle;
              innerElemStyle.fontStyle = fStyle;
              innerElemStyle.fontWeight = fWeight;
            }
          }
          var i2;
          var len;
          var letters = documentData.l;
          len = letters.length;
          var tSpan;
          var tParent;
          var tCont;
          var matrixHelper = this.mHelper;
          var shapes;
          var shapeStr = "";
          var cnt = 0;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (this.globalData.fontManager.chars) {
              if (!this.textPaths[cnt]) {
                tSpan = createNS("path");
                tSpan.setAttribute("stroke-linecap", lineCapEnum[1]);
                tSpan.setAttribute("stroke-linejoin", lineJoinEnum[2]);
                tSpan.setAttribute("stroke-miterlimit", "4");
              } else {
                tSpan = this.textPaths[cnt];
              }
              if (!this.isMasked) {
                if (this.textSpans[cnt]) {
                  tParent = this.textSpans[cnt];
                  tCont = tParent.children[0];
                } else {
                  tParent = createTag("div");
                  tParent.style.lineHeight = 0;
                  tCont = createNS("svg");
                  tCont.appendChild(tSpan);
                  styleDiv(tParent);
                }
              }
            } else if (!this.isMasked) {
              if (this.textSpans[cnt]) {
                tParent = this.textSpans[cnt];
                tSpan = this.textPaths[cnt];
              } else {
                tParent = createTag("span");
                styleDiv(tParent);
                tSpan = createTag("span");
                styleDiv(tSpan);
                tParent.appendChild(tSpan);
              }
            } else {
              tSpan = this.textPaths[cnt] ? this.textPaths[cnt] : createNS("text");
            }
            if (this.globalData.fontManager.chars) {
              var charData = this.globalData.fontManager.getCharData(documentData.finalText[i2], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
              var shapeData;
              if (charData) {
                shapeData = charData.data;
              } else {
                shapeData = null;
              }
              matrixHelper.reset();
              if (shapeData && shapeData.shapes && shapeData.shapes.length) {
                shapes = shapeData.shapes[0].it;
                matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
                shapeStr = this.createPathShape(matrixHelper, shapes);
                tSpan.setAttribute("d", shapeStr);
              }
              if (!this.isMasked) {
                this.innerElem.appendChild(tParent);
                if (shapeData && shapeData.shapes) {
                  document.body.appendChild(tCont);
                  var boundingBox = tCont.getBBox();
                  tCont.setAttribute("width", boundingBox.width + 2);
                  tCont.setAttribute("height", boundingBox.height + 2);
                  tCont.setAttribute("viewBox", boundingBox.x - 1 + " " + (boundingBox.y - 1) + " " + (boundingBox.width + 2) + " " + (boundingBox.height + 2));
                  var tContStyle = tCont.style;
                  var tContTranslation = "translate(" + (boundingBox.x - 1) + "px," + (boundingBox.y - 1) + "px)";
                  tContStyle.transform = tContTranslation;
                  tContStyle.webkitTransform = tContTranslation;
                  letters[i2].yOffset = boundingBox.y - 1;
                } else {
                  tCont.setAttribute("width", 1);
                  tCont.setAttribute("height", 1);
                }
                tParent.appendChild(tCont);
              } else {
                this.innerElem.appendChild(tSpan);
              }
            } else {
              tSpan.textContent = letters[i2].val;
              tSpan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
              if (!this.isMasked) {
                this.innerElem.appendChild(tParent);
                var tStyle = tSpan.style;
                var tSpanTranslation = "translate3d(0," + -documentData.finalSize / 1.2 + "px,0)";
                tStyle.transform = tSpanTranslation;
                tStyle.webkitTransform = tSpanTranslation;
              } else {
                this.innerElem.appendChild(tSpan);
              }
            }
            if (!this.isMasked) {
              this.textSpans[cnt] = tParent;
            } else {
              this.textSpans[cnt] = tSpan;
            }
            this.textSpans[cnt].style.display = "block";
            this.textPaths[cnt] = tSpan;
            cnt += 1;
          }
          while (cnt < this.textSpans.length) {
            this.textSpans[cnt].style.display = "none";
            cnt += 1;
          }
        };
        HTextElement.prototype.renderInnerContent = function() {
          this.validateText();
          var svgStyle;
          if (this.data.singleShape) {
            if (!this._isFirstFrame && !this.lettersChangedFlag) {
              return;
            }
            if (this.isMasked && this.finalTransform._matMdf) {
              this.svgElement.setAttribute("viewBox", -this.finalTransform.mProp.p.v[0] + " " + -this.finalTransform.mProp.p.v[1] + " " + this.compW + " " + this.compH);
              svgStyle = this.svgElement.style;
              var translation2 = "translate(" + -this.finalTransform.mProp.p.v[0] + "px," + -this.finalTransform.mProp.p.v[1] + "px)";
              svgStyle.transform = translation2;
              svgStyle.webkitTransform = translation2;
            }
          }
          this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
          if (!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag) {
            return;
          }
          var i2;
          var len;
          var count = 0;
          var renderedLetters = this.textAnimator.renderedLetters;
          var letters = this.textProperty.currentData.l;
          len = letters.length;
          var renderedLetter;
          var textSpan;
          var textPath;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (letters[i2].n) {
              count += 1;
            } else {
              textSpan = this.textSpans[i2];
              textPath = this.textPaths[i2];
              renderedLetter = renderedLetters[count];
              count += 1;
              if (renderedLetter._mdf.m) {
                if (!this.isMasked) {
                  textSpan.style.webkitTransform = renderedLetter.m;
                  textSpan.style.transform = renderedLetter.m;
                } else {
                  textSpan.setAttribute("transform", renderedLetter.m);
                }
              }
              textSpan.style.opacity = renderedLetter.o;
              if (renderedLetter.sw && renderedLetter._mdf.sw) {
                textPath.setAttribute("stroke-width", renderedLetter.sw);
              }
              if (renderedLetter.sc && renderedLetter._mdf.sc) {
                textPath.setAttribute("stroke", renderedLetter.sc);
              }
              if (renderedLetter.fc && renderedLetter._mdf.fc) {
                textPath.setAttribute("fill", renderedLetter.fc);
                textPath.style.color = renderedLetter.fc;
              }
            }
          }
          if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {
            var boundingBox = this.innerElem.getBBox();
            if (this.currentBBox.w !== boundingBox.width) {
              this.currentBBox.w = boundingBox.width;
              this.svgElement.setAttribute("width", boundingBox.width);
            }
            if (this.currentBBox.h !== boundingBox.height) {
              this.currentBBox.h = boundingBox.height;
              this.svgElement.setAttribute("height", boundingBox.height);
            }
            var margin = 1;
            if (this.currentBBox.w !== boundingBox.width + margin * 2 || this.currentBBox.h !== boundingBox.height + margin * 2 || this.currentBBox.x !== boundingBox.x - margin || this.currentBBox.y !== boundingBox.y - margin) {
              this.currentBBox.w = boundingBox.width + margin * 2;
              this.currentBBox.h = boundingBox.height + margin * 2;
              this.currentBBox.x = boundingBox.x - margin;
              this.currentBBox.y = boundingBox.y - margin;
              this.svgElement.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h);
              svgStyle = this.svgElement.style;
              var svgTransform = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
              svgStyle.transform = svgTransform;
              svgStyle.webkitTransform = svgTransform;
            }
          }
        };
        function HCameraElement(data2, globalData2, comp2) {
          this.initFrame();
          this.initBaseData(data2, globalData2, comp2);
          this.initHierarchy();
          var getProp = PropertyFactory.getProp;
          this.pe = getProp(this, data2.pe, 0, 0, this);
          if (data2.ks.p.s) {
            this.px = getProp(this, data2.ks.p.x, 1, 0, this);
            this.py = getProp(this, data2.ks.p.y, 1, 0, this);
            this.pz = getProp(this, data2.ks.p.z, 1, 0, this);
          } else {
            this.p = getProp(this, data2.ks.p, 1, 0, this);
          }
          if (data2.ks.a) {
            this.a = getProp(this, data2.ks.a, 1, 0, this);
          }
          if (data2.ks.or.k.length && data2.ks.or.k[0].to) {
            var i2;
            var len = data2.ks.or.k.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              data2.ks.or.k[i2].to = null;
              data2.ks.or.k[i2].ti = null;
            }
          }
          this.or = getProp(this, data2.ks.or, 1, degToRads, this);
          this.or.sh = true;
          this.rx = getProp(this, data2.ks.rx, 0, degToRads, this);
          this.ry = getProp(this, data2.ks.ry, 0, degToRads, this);
          this.rz = getProp(this, data2.ks.rz, 0, degToRads, this);
          this.mat = new Matrix();
          this._prevMat = new Matrix();
          this._isFirstFrame = true;
          this.finalTransform = {
            mProp: this
          };
        }
        extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement);
        HCameraElement.prototype.setup = function() {
          var i2;
          var len = this.comp.threeDElements.length;
          var comp2;
          var perspectiveStyle;
          var containerStyle;
          for (i2 = 0; i2 < len; i2 += 1) {
            comp2 = this.comp.threeDElements[i2];
            if (comp2.type === "3d") {
              perspectiveStyle = comp2.perspectiveElem.style;
              containerStyle = comp2.container.style;
              var perspective = this.pe.v + "px";
              var origin = "0px 0px 0px";
              var matrix = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
              perspectiveStyle.perspective = perspective;
              perspectiveStyle.webkitPerspective = perspective;
              containerStyle.transformOrigin = origin;
              containerStyle.mozTransformOrigin = origin;
              containerStyle.webkitTransformOrigin = origin;
              perspectiveStyle.transform = matrix;
              perspectiveStyle.webkitTransform = matrix;
            }
          }
        };
        HCameraElement.prototype.createElements = function() {
        };
        HCameraElement.prototype.hide = function() {
        };
        HCameraElement.prototype.renderFrame = function() {
          var _mdf = this._isFirstFrame;
          var i2;
          var len;
          if (this.hierarchy) {
            len = this.hierarchy.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              _mdf = this.hierarchy[i2].finalTransform.mProp._mdf || _mdf;
            }
          }
          if (_mdf || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {
            this.mat.reset();
            if (this.hierarchy) {
              len = this.hierarchy.length - 1;
              for (i2 = len; i2 >= 0; i2 -= 1) {
                var mTransf = this.hierarchy[i2].finalTransform.mProp;
                this.mat.translate(-mTransf.p.v[0], -mTransf.p.v[1], mTransf.p.v[2]);
                this.mat.rotateX(-mTransf.or.v[0]).rotateY(-mTransf.or.v[1]).rotateZ(mTransf.or.v[2]);
                this.mat.rotateX(-mTransf.rx.v).rotateY(-mTransf.ry.v).rotateZ(mTransf.rz.v);
                this.mat.scale(1 / mTransf.s.v[0], 1 / mTransf.s.v[1], 1 / mTransf.s.v[2]);
                this.mat.translate(mTransf.a.v[0], mTransf.a.v[1], mTransf.a.v[2]);
              }
            }
            if (this.p) {
              this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]);
            } else {
              this.mat.translate(-this.px.v, -this.py.v, this.pz.v);
            }
            if (this.a) {
              var diffVector;
              if (this.p) {
                diffVector = [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]];
              } else {
                diffVector = [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]];
              }
              var mag = Math.sqrt(Math.pow(diffVector[0], 2) + Math.pow(diffVector[1], 2) + Math.pow(diffVector[2], 2));
              var lookDir = [diffVector[0] / mag, diffVector[1] / mag, diffVector[2] / mag];
              var lookLengthOnXZ = Math.sqrt(lookDir[2] * lookDir[2] + lookDir[0] * lookDir[0]);
              var mRotationX = Math.atan2(lookDir[1], lookLengthOnXZ);
              var mRotationY = Math.atan2(lookDir[0], -lookDir[2]);
              this.mat.rotateY(mRotationY).rotateX(-mRotationX);
            }
            this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v);
            this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]);
            this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0);
            this.mat.translate(0, 0, this.pe.v);
            var hasMatrixChanged = !this._prevMat.equals(this.mat);
            if ((hasMatrixChanged || this.pe._mdf) && this.comp.threeDElements) {
              len = this.comp.threeDElements.length;
              var comp2;
              var perspectiveStyle;
              var containerStyle;
              for (i2 = 0; i2 < len; i2 += 1) {
                comp2 = this.comp.threeDElements[i2];
                if (comp2.type === "3d") {
                  if (hasMatrixChanged) {
                    var matValue = this.mat.toCSS();
                    containerStyle = comp2.container.style;
                    containerStyle.transform = matValue;
                    containerStyle.webkitTransform = matValue;
                  }
                  if (this.pe._mdf) {
                    perspectiveStyle = comp2.perspectiveElem.style;
                    perspectiveStyle.perspective = this.pe.v + "px";
                    perspectiveStyle.webkitPerspective = this.pe.v + "px";
                  }
                }
              }
              this.mat.clone(this._prevMat);
            }
          }
          this._isFirstFrame = false;
        };
        HCameraElement.prototype.prepareFrame = function(num) {
          this.prepareProperties(num, true);
        };
        HCameraElement.prototype.destroy = function() {
        };
        HCameraElement.prototype.getBaseElement = function() {
          return null;
        };
        function HImageElement(data2, globalData2, comp2) {
          this.assetData = globalData2.getAssetData(data2.refId);
          this.initElement(data2, globalData2, comp2);
        }
        extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement);
        HImageElement.prototype.createContent = function() {
          var assetPath = this.globalData.getAssetsPath(this.assetData);
          var img = new Image();
          if (this.data.hasMask) {
            this.imageElem = createNS("image");
            this.imageElem.setAttribute("width", this.assetData.w + "px");
            this.imageElem.setAttribute("height", this.assetData.h + "px");
            this.imageElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", assetPath);
            this.layerElement.appendChild(this.imageElem);
            this.baseElement.setAttribute("width", this.assetData.w);
            this.baseElement.setAttribute("height", this.assetData.h);
          } else {
            this.layerElement.appendChild(img);
          }
          img.crossOrigin = "anonymous";
          img.src = assetPath;
          if (this.data.ln) {
            this.baseElement.setAttribute("id", this.data.ln);
          }
        };
        function HybridRendererBase(animationItem, config) {
          this.animationItem = animationItem;
          this.layers = null;
          this.renderedFrame = -1;
          this.renderConfig = {
            className: config && config.className || "",
            imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || "xMidYMid slice",
            hideOnTransparent: !(config && config.hideOnTransparent === false),
            filterSize: {
              width: config && config.filterSize && config.filterSize.width || "400%",
              height: config && config.filterSize && config.filterSize.height || "400%",
              x: config && config.filterSize && config.filterSize.x || "-100%",
              y: config && config.filterSize && config.filterSize.y || "-100%"
            }
          };
          this.globalData = {
            _mdf: false,
            frameNum: -1,
            renderConfig: this.renderConfig
          };
          this.pendingElements = [];
          this.elements = [];
          this.threeDElements = [];
          this.destroyed = false;
          this.camera = null;
          this.supports3d = true;
          this.rendererType = "html";
        }
        extendPrototype([BaseRenderer], HybridRendererBase);
        HybridRendererBase.prototype.buildItem = SVGRenderer.prototype.buildItem;
        HybridRendererBase.prototype.checkPendingElements = function() {
          while (this.pendingElements.length) {
            var element = this.pendingElements.pop();
            element.checkParenting();
          }
        };
        HybridRendererBase.prototype.appendElementInPos = function(element, pos) {
          var newDOMElement = element.getBaseElement();
          if (!newDOMElement) {
            return;
          }
          var layer = this.layers[pos];
          if (!layer.ddd || !this.supports3d) {
            if (this.threeDElements) {
              this.addTo3dContainer(newDOMElement, pos);
            } else {
              var i2 = 0;
              var nextDOMElement;
              var nextLayer;
              var tmpDOMElement;
              while (i2 < pos) {
                if (this.elements[i2] && this.elements[i2] !== true && this.elements[i2].getBaseElement) {
                  nextLayer = this.elements[i2];
                  tmpDOMElement = this.layers[i2].ddd ? this.getThreeDContainerByPos(i2) : nextLayer.getBaseElement();
                  nextDOMElement = tmpDOMElement || nextDOMElement;
                }
                i2 += 1;
              }
              if (nextDOMElement) {
                if (!layer.ddd || !this.supports3d) {
                  this.layerElement.insertBefore(newDOMElement, nextDOMElement);
                }
              } else if (!layer.ddd || !this.supports3d) {
                this.layerElement.appendChild(newDOMElement);
              }
            }
          } else {
            this.addTo3dContainer(newDOMElement, pos);
          }
        };
        HybridRendererBase.prototype.createShape = function(data2) {
          if (!this.supports3d) {
            return new SVGShapeElement(data2, this.globalData, this);
          }
          return new HShapeElement(data2, this.globalData, this);
        };
        HybridRendererBase.prototype.createText = function(data2) {
          if (!this.supports3d) {
            return new SVGTextLottieElement(data2, this.globalData, this);
          }
          return new HTextElement(data2, this.globalData, this);
        };
        HybridRendererBase.prototype.createCamera = function(data2) {
          this.camera = new HCameraElement(data2, this.globalData, this);
          return this.camera;
        };
        HybridRendererBase.prototype.createImage = function(data2) {
          if (!this.supports3d) {
            return new IImageElement(data2, this.globalData, this);
          }
          return new HImageElement(data2, this.globalData, this);
        };
        HybridRendererBase.prototype.createSolid = function(data2) {
          if (!this.supports3d) {
            return new ISolidElement(data2, this.globalData, this);
          }
          return new HSolidElement(data2, this.globalData, this);
        };
        HybridRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;
        HybridRendererBase.prototype.getThreeDContainerByPos = function(pos) {
          var i2 = 0;
          var len = this.threeDElements.length;
          while (i2 < len) {
            if (this.threeDElements[i2].startPos <= pos && this.threeDElements[i2].endPos >= pos) {
              return this.threeDElements[i2].perspectiveElem;
            }
            i2 += 1;
          }
          return null;
        };
        HybridRendererBase.prototype.createThreeDContainer = function(pos, type) {
          var perspectiveElem = createTag("div");
          var style;
          var containerStyle;
          styleDiv(perspectiveElem);
          var container2 = createTag("div");
          styleDiv(container2);
          if (type === "3d") {
            style = perspectiveElem.style;
            style.width = this.globalData.compSize.w + "px";
            style.height = this.globalData.compSize.h + "px";
            var center = "50% 50%";
            style.webkitTransformOrigin = center;
            style.mozTransformOrigin = center;
            style.transformOrigin = center;
            containerStyle = container2.style;
            var matrix = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
            containerStyle.transform = matrix;
            containerStyle.webkitTransform = matrix;
          }
          perspectiveElem.appendChild(container2);
          var threeDContainerData = {
            container: container2,
            perspectiveElem,
            startPos: pos,
            endPos: pos,
            type
          };
          this.threeDElements.push(threeDContainerData);
          return threeDContainerData;
        };
        HybridRendererBase.prototype.build3dContainers = function() {
          var i2;
          var len = this.layers.length;
          var lastThreeDContainerData;
          var currentContainer = "";
          for (i2 = 0; i2 < len; i2 += 1) {
            if (this.layers[i2].ddd && this.layers[i2].ty !== 3) {
              if (currentContainer !== "3d") {
                currentContainer = "3d";
                lastThreeDContainerData = this.createThreeDContainer(i2, "3d");
              }
              lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i2);
            } else {
              if (currentContainer !== "2d") {
                currentContainer = "2d";
                lastThreeDContainerData = this.createThreeDContainer(i2, "2d");
              }
              lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i2);
            }
          }
          len = this.threeDElements.length;
          for (i2 = len - 1; i2 >= 0; i2 -= 1) {
            this.resizerElem.appendChild(this.threeDElements[i2].perspectiveElem);
          }
        };
        HybridRendererBase.prototype.addTo3dContainer = function(elem2, pos) {
          var i2 = 0;
          var len = this.threeDElements.length;
          while (i2 < len) {
            if (pos <= this.threeDElements[i2].endPos) {
              var j = this.threeDElements[i2].startPos;
              var nextElement;
              while (j < pos) {
                if (this.elements[j] && this.elements[j].getBaseElement) {
                  nextElement = this.elements[j].getBaseElement();
                }
                j += 1;
              }
              if (nextElement) {
                this.threeDElements[i2].container.insertBefore(elem2, nextElement);
              } else {
                this.threeDElements[i2].container.appendChild(elem2);
              }
              break;
            }
            i2 += 1;
          }
        };
        HybridRendererBase.prototype.configAnimation = function(animData) {
          var resizerElem = createTag("div");
          var wrapper2 = this.animationItem.wrapper;
          var style = resizerElem.style;
          style.width = animData.w + "px";
          style.height = animData.h + "px";
          this.resizerElem = resizerElem;
          styleDiv(resizerElem);
          style.transformStyle = "flat";
          style.mozTransformStyle = "flat";
          style.webkitTransformStyle = "flat";
          if (this.renderConfig.className) {
            resizerElem.setAttribute("class", this.renderConfig.className);
          }
          wrapper2.appendChild(resizerElem);
          style.overflow = "hidden";
          var svg = createNS("svg");
          svg.setAttribute("width", "1");
          svg.setAttribute("height", "1");
          styleDiv(svg);
          this.resizerElem.appendChild(svg);
          var defs = createNS("defs");
          svg.appendChild(defs);
          this.data = animData;
          this.setupGlobalData(animData, svg);
          this.globalData.defs = defs;
          this.layers = animData.layers;
          this.layerElement = this.resizerElem;
          this.build3dContainers();
          this.updateContainerSize();
        };
        HybridRendererBase.prototype.destroy = function() {
          if (this.animationItem.wrapper) {
            this.animationItem.wrapper.innerText = "";
          }
          this.animationItem.container = null;
          this.globalData.defs = null;
          var i2;
          var len = this.layers ? this.layers.length : 0;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (this.elements[i2] && this.elements[i2].destroy) {
              this.elements[i2].destroy();
            }
          }
          this.elements.length = 0;
          this.destroyed = true;
          this.animationItem = null;
        };
        HybridRendererBase.prototype.updateContainerSize = function() {
          var elementWidth = this.animationItem.wrapper.offsetWidth;
          var elementHeight = this.animationItem.wrapper.offsetHeight;
          var elementRel = elementWidth / elementHeight;
          var animationRel = this.globalData.compSize.w / this.globalData.compSize.h;
          var sx;
          var sy;
          var tx;
          var ty;
          if (animationRel > elementRel) {
            sx = elementWidth / this.globalData.compSize.w;
            sy = elementWidth / this.globalData.compSize.w;
            tx = 0;
            ty = (elementHeight - this.globalData.compSize.h * (elementWidth / this.globalData.compSize.w)) / 2;
          } else {
            sx = elementHeight / this.globalData.compSize.h;
            sy = elementHeight / this.globalData.compSize.h;
            tx = (elementWidth - this.globalData.compSize.w * (elementHeight / this.globalData.compSize.h)) / 2;
            ty = 0;
          }
          var style = this.resizerElem.style;
          style.webkitTransform = "matrix3d(" + sx + ",0,0,0,0," + sy + ",0,0,0,0,1,0," + tx + "," + ty + ",0,1)";
          style.transform = style.webkitTransform;
        };
        HybridRendererBase.prototype.renderFrame = SVGRenderer.prototype.renderFrame;
        HybridRendererBase.prototype.hide = function() {
          this.resizerElem.style.display = "none";
        };
        HybridRendererBase.prototype.show = function() {
          this.resizerElem.style.display = "block";
        };
        HybridRendererBase.prototype.initItems = function() {
          this.buildAllItems();
          if (this.camera) {
            this.camera.setup();
          } else {
            var cWidth = this.globalData.compSize.w;
            var cHeight = this.globalData.compSize.h;
            var i2;
            var len = this.threeDElements.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              var style = this.threeDElements[i2].perspectiveElem.style;
              style.webkitPerspective = Math.sqrt(Math.pow(cWidth, 2) + Math.pow(cHeight, 2)) + "px";
              style.perspective = style.webkitPerspective;
            }
          }
        };
        HybridRendererBase.prototype.searchExtraCompositions = function(assets2) {
          var i2;
          var len = assets2.length;
          var floatingContainer = createTag("div");
          for (i2 = 0; i2 < len; i2 += 1) {
            if (assets2[i2].xt) {
              var comp2 = this.createComp(assets2[i2], floatingContainer, this.globalData.comp, null);
              comp2.initExpressions();
              this.globalData.projectInterface.registerComposition(comp2);
            }
          }
        };
        function HCompElement(data2, globalData2, comp2) {
          this.layers = data2.layers;
          this.supports3d = !data2.hasMask;
          this.completeLayers = false;
          this.pendingElements = [];
          this.elements = this.layers ? createSizedArray(this.layers.length) : [];
          this.initElement(data2, globalData2, comp2);
          this.tm = data2.tm ? PropertyFactory.getProp(this, data2.tm, 0, globalData2.frameRate, this) : {
            _placeholder: true
          };
        }
        extendPrototype([HybridRendererBase, ICompElement, HBaseElement], HCompElement);
        HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements;
        HCompElement.prototype.createContainerElements = function() {
          this._createBaseContainerElements();
          if (this.data.hasMask) {
            this.svgElement.setAttribute("width", this.data.w);
            this.svgElement.setAttribute("height", this.data.h);
            this.transformedElement = this.baseElement;
          } else {
            this.transformedElement = this.layerElement;
          }
        };
        HCompElement.prototype.addTo3dContainer = function(elem2, pos) {
          var j = 0;
          var nextElement;
          while (j < pos) {
            if (this.elements[j] && this.elements[j].getBaseElement) {
              nextElement = this.elements[j].getBaseElement();
            }
            j += 1;
          }
          if (nextElement) {
            this.layerElement.insertBefore(elem2, nextElement);
          } else {
            this.layerElement.appendChild(elem2);
          }
        };
        HCompElement.prototype.createComp = function(data2) {
          if (!this.supports3d) {
            return new SVGCompElement(data2, this.globalData, this);
          }
          return new HCompElement(data2, this.globalData, this);
        };
        function HybridRenderer(animationItem, config) {
          this.animationItem = animationItem;
          this.layers = null;
          this.renderedFrame = -1;
          this.renderConfig = {
            className: config && config.className || "",
            imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || "xMidYMid slice",
            hideOnTransparent: !(config && config.hideOnTransparent === false),
            filterSize: {
              width: config && config.filterSize && config.filterSize.width || "400%",
              height: config && config.filterSize && config.filterSize.height || "400%",
              x: config && config.filterSize && config.filterSize.x || "-100%",
              y: config && config.filterSize && config.filterSize.y || "-100%"
            },
            runExpressions: !config || config.runExpressions === void 0 || config.runExpressions
          };
          this.globalData = {
            _mdf: false,
            frameNum: -1,
            renderConfig: this.renderConfig
          };
          this.pendingElements = [];
          this.elements = [];
          this.threeDElements = [];
          this.destroyed = false;
          this.camera = null;
          this.supports3d = true;
          this.rendererType = "html";
        }
        extendPrototype([HybridRendererBase], HybridRenderer);
        HybridRenderer.prototype.createComp = function(data2) {
          if (!this.supports3d) {
            return new SVGCompElement(data2, this.globalData, this);
          }
          return new HCompElement(data2, this.globalData, this);
        };
        var CompExpressionInterface = /* @__PURE__ */ function() {
          return function(comp2) {
            function _thisLayerFunction(name2) {
              var i2 = 0;
              var len = comp2.layers.length;
              while (i2 < len) {
                if (comp2.layers[i2].nm === name2 || comp2.layers[i2].ind === name2) {
                  return comp2.elements[i2].layerInterface;
                }
                i2 += 1;
              }
              return null;
            }
            Object.defineProperty(_thisLayerFunction, "_name", {
              value: comp2.data.nm
            });
            _thisLayerFunction.layer = _thisLayerFunction;
            _thisLayerFunction.pixelAspect = 1;
            _thisLayerFunction.height = comp2.data.h || comp2.globalData.compSize.h;
            _thisLayerFunction.width = comp2.data.w || comp2.globalData.compSize.w;
            _thisLayerFunction.pixelAspect = 1;
            _thisLayerFunction.frameDuration = 1 / comp2.globalData.frameRate;
            _thisLayerFunction.displayStartTime = 0;
            _thisLayerFunction.numLayers = comp2.layers.length;
            return _thisLayerFunction;
          };
        }();
        function _typeof$2(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof$2 = function _typeof2(obj2) {
              return typeof obj2;
            };
          } else {
            _typeof$2 = function _typeof2(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return _typeof$2(obj);
        }
        function seedRandom(pool, math) {
          var global2 = this, width2 = 256, chunks = 6, digits = 52, rngname = "random", startdenom = math.pow(width2, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask2 = width2 - 1, nodecrypto;
          function seedrandom(seed, options, callback) {
            var key2 = [];
            options = options === true ? {
              entropy: true
            } : options || {};
            var shortseed = mixkey(flatten(options.entropy ? [seed, tostring(pool)] : seed === null ? autoseed() : seed, 3), key2);
            var arc4 = new ARC4(key2);
            var prng = function prng2() {
              var n2 = arc4.g(chunks), d = startdenom, x2 = 0;
              while (n2 < significance) {
                n2 = (n2 + x2) * width2;
                d *= width2;
                x2 = arc4.g(1);
              }
              while (n2 >= overflow) {
                n2 /= 2;
                d /= 2;
                x2 >>>= 1;
              }
              return (n2 + x2) / d;
            };
            prng.int32 = function() {
              return arc4.g(4) | 0;
            };
            prng.quick = function() {
              return arc4.g(4) / 4294967296;
            };
            prng["double"] = prng;
            mixkey(tostring(arc4.S), pool);
            return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
              if (state) {
                if (state.S) {
                  copy2(state, arc4);
                }
                prng2.state = function() {
                  return copy2(arc4, {});
                };
              }
              if (is_math_call) {
                math[rngname] = prng2;
                return seed2;
              } else
                return prng2;
            })(prng, shortseed, "global" in options ? options.global : this == math, options.state);
          }
          math["seed" + rngname] = seedrandom;
          function ARC4(key2) {
            var t2, keylen = key2.length, me2 = this, i2 = 0, j = me2.i = me2.j = 0, s2 = me2.S = [];
            if (!keylen) {
              key2 = [keylen++];
            }
            while (i2 < width2) {
              s2[i2] = i2++;
            }
            for (i2 = 0; i2 < width2; i2++) {
              s2[i2] = s2[j = mask2 & j + key2[i2 % keylen] + (t2 = s2[i2])];
              s2[j] = t2;
            }
            me2.g = function(count) {
              var t3, r2 = 0, i3 = me2.i, j2 = me2.j, s3 = me2.S;
              while (count--) {
                t3 = s3[i3 = mask2 & i3 + 1];
                r2 = r2 * width2 + s3[mask2 & (s3[i3] = s3[j2 = mask2 & j2 + t3]) + (s3[j2] = t3)];
              }
              me2.i = i3;
              me2.j = j2;
              return r2;
            };
          }
          function copy2(f2, t2) {
            t2.i = f2.i;
            t2.j = f2.j;
            t2.S = f2.S.slice();
            return t2;
          }
          function flatten(obj, depth) {
            var result = [], typ = _typeof$2(obj), prop;
            if (depth && typ == "object") {
              for (prop in obj) {
                try {
                  result.push(flatten(obj[prop], depth - 1));
                } catch (e2) {
                }
              }
            }
            return result.length ? result : typ == "string" ? obj : obj + "\0";
          }
          function mixkey(seed, key2) {
            var stringseed = seed + "", smear, j = 0;
            while (j < stringseed.length) {
              key2[mask2 & j] = mask2 & (smear ^= key2[mask2 & j] * 19) + stringseed.charCodeAt(j++);
            }
            return tostring(key2);
          }
          function autoseed() {
            try {
              if (nodecrypto)
                ;
              var out = new Uint8Array(width2);
              (global2.crypto || global2.msCrypto).getRandomValues(out);
              return tostring(out);
            } catch (e2) {
              var browser = global2.navigator, plugins2 = browser && browser.plugins;
              return [+/* @__PURE__ */ new Date(), global2, plugins2, global2.screen, tostring(pool)];
            }
          }
          function tostring(a2) {
            return String.fromCharCode.apply(0, a2);
          }
          mixkey(math.random(), pool);
        }
        function initialize$2(BMMath2) {
          seedRandom([], BMMath2);
        }
        var propTypes = {
          SHAPE: "shape"
        };
        function _typeof$1(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof$1 = function _typeof2(obj2) {
              return typeof obj2;
            };
          } else {
            _typeof$1 = function _typeof2(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return _typeof$1(obj);
        }
        var ExpressionManager = function() {
          var ob = {};
          var Math = BMMath;
          var window = null;
          var document = null;
          var XMLHttpRequest = null;
          var fetch = null;
          var frames = null;
          var _lottieGlobal = {};
          initialize$2(BMMath);
          function resetFrame() {
            _lottieGlobal = {};
          }
          function $bm_isInstanceOfArray(arr2) {
            return arr2.constructor === Array || arr2.constructor === Float32Array;
          }
          function isNumerable(tOfV, v2) {
            return tOfV === "number" || v2 instanceof Number || tOfV === "boolean" || tOfV === "string";
          }
          function $bm_neg(a2) {
            var tOfA = _typeof$1(a2);
            if (tOfA === "number" || a2 instanceof Number || tOfA === "boolean") {
              return -a2;
            }
            if ($bm_isInstanceOfArray(a2)) {
              var i2;
              var lenA = a2.length;
              var retArr = [];
              for (i2 = 0; i2 < lenA; i2 += 1) {
                retArr[i2] = -a2[i2];
              }
              return retArr;
            }
            if (a2.propType) {
              return a2.v;
            }
            return -a2;
          }
          var easeInBez = BezierFactory.getBezierEasing(0.333, 0, 0.833, 0.833, "easeIn").get;
          var easeOutBez = BezierFactory.getBezierEasing(0.167, 0.167, 0.667, 1, "easeOut").get;
          var easeInOutBez = BezierFactory.getBezierEasing(0.33, 0, 0.667, 1, "easeInOut").get;
          function sum(a2, b) {
            var tOfA = _typeof$1(a2);
            var tOfB = _typeof$1(b);
            if (isNumerable(tOfA, a2) && isNumerable(tOfB, b) || tOfA === "string" || tOfB === "string") {
              return a2 + b;
            }
            if ($bm_isInstanceOfArray(a2) && isNumerable(tOfB, b)) {
              a2 = a2.slice(0);
              a2[0] += b;
              return a2;
            }
            if (isNumerable(tOfA, a2) && $bm_isInstanceOfArray(b)) {
              b = b.slice(0);
              b[0] = a2 + b[0];
              return b;
            }
            if ($bm_isInstanceOfArray(a2) && $bm_isInstanceOfArray(b)) {
              var i2 = 0;
              var lenA = a2.length;
              var lenB = b.length;
              var retArr = [];
              while (i2 < lenA || i2 < lenB) {
                if ((typeof a2[i2] === "number" || a2[i2] instanceof Number) && (typeof b[i2] === "number" || b[i2] instanceof Number)) {
                  retArr[i2] = a2[i2] + b[i2];
                } else {
                  retArr[i2] = b[i2] === void 0 ? a2[i2] : a2[i2] || b[i2];
                }
                i2 += 1;
              }
              return retArr;
            }
            return 0;
          }
          var add = sum;
          function sub(a2, b) {
            var tOfA = _typeof$1(a2);
            var tOfB = _typeof$1(b);
            if (isNumerable(tOfA, a2) && isNumerable(tOfB, b)) {
              if (tOfA === "string") {
                a2 = parseInt(a2, 10);
              }
              if (tOfB === "string") {
                b = parseInt(b, 10);
              }
              return a2 - b;
            }
            if ($bm_isInstanceOfArray(a2) && isNumerable(tOfB, b)) {
              a2 = a2.slice(0);
              a2[0] -= b;
              return a2;
            }
            if (isNumerable(tOfA, a2) && $bm_isInstanceOfArray(b)) {
              b = b.slice(0);
              b[0] = a2 - b[0];
              return b;
            }
            if ($bm_isInstanceOfArray(a2) && $bm_isInstanceOfArray(b)) {
              var i2 = 0;
              var lenA = a2.length;
              var lenB = b.length;
              var retArr = [];
              while (i2 < lenA || i2 < lenB) {
                if ((typeof a2[i2] === "number" || a2[i2] instanceof Number) && (typeof b[i2] === "number" || b[i2] instanceof Number)) {
                  retArr[i2] = a2[i2] - b[i2];
                } else {
                  retArr[i2] = b[i2] === void 0 ? a2[i2] : a2[i2] || b[i2];
                }
                i2 += 1;
              }
              return retArr;
            }
            return 0;
          }
          function mul(a2, b) {
            var tOfA = _typeof$1(a2);
            var tOfB = _typeof$1(b);
            var arr2;
            if (isNumerable(tOfA, a2) && isNumerable(tOfB, b)) {
              return a2 * b;
            }
            var i2;
            var len;
            if ($bm_isInstanceOfArray(a2) && isNumerable(tOfB, b)) {
              len = a2.length;
              arr2 = createTypedArray("float32", len);
              for (i2 = 0; i2 < len; i2 += 1) {
                arr2[i2] = a2[i2] * b;
              }
              return arr2;
            }
            if (isNumerable(tOfA, a2) && $bm_isInstanceOfArray(b)) {
              len = b.length;
              arr2 = createTypedArray("float32", len);
              for (i2 = 0; i2 < len; i2 += 1) {
                arr2[i2] = a2 * b[i2];
              }
              return arr2;
            }
            return 0;
          }
          function div(a2, b) {
            var tOfA = _typeof$1(a2);
            var tOfB = _typeof$1(b);
            var arr2;
            if (isNumerable(tOfA, a2) && isNumerable(tOfB, b)) {
              return a2 / b;
            }
            var i2;
            var len;
            if ($bm_isInstanceOfArray(a2) && isNumerable(tOfB, b)) {
              len = a2.length;
              arr2 = createTypedArray("float32", len);
              for (i2 = 0; i2 < len; i2 += 1) {
                arr2[i2] = a2[i2] / b;
              }
              return arr2;
            }
            if (isNumerable(tOfA, a2) && $bm_isInstanceOfArray(b)) {
              len = b.length;
              arr2 = createTypedArray("float32", len);
              for (i2 = 0; i2 < len; i2 += 1) {
                arr2[i2] = a2 / b[i2];
              }
              return arr2;
            }
            return 0;
          }
          function mod(a2, b) {
            if (typeof a2 === "string") {
              a2 = parseInt(a2, 10);
            }
            if (typeof b === "string") {
              b = parseInt(b, 10);
            }
            return a2 % b;
          }
          var $bm_sum = sum;
          var $bm_sub = sub;
          var $bm_mul = mul;
          var $bm_div = div;
          var $bm_mod = mod;
          function clamp(num, min, max) {
            if (min > max) {
              var mm = max;
              max = min;
              min = mm;
            }
            return Math.min(Math.max(num, min), max);
          }
          function radiansToDegrees(val2) {
            return val2 / degToRads;
          }
          var radians_to_degrees = radiansToDegrees;
          function degreesToRadians(val2) {
            return val2 * degToRads;
          }
          var degrees_to_radians = radiansToDegrees;
          var helperLengthArray = [0, 0, 0, 0, 0, 0];
          function length(arr1, arr2) {
            if (typeof arr1 === "number" || arr1 instanceof Number) {
              arr2 = arr2 || 0;
              return Math.abs(arr1 - arr2);
            }
            if (!arr2) {
              arr2 = helperLengthArray;
            }
            var i2;
            var len = Math.min(arr1.length, arr2.length);
            var addedLength = 0;
            for (i2 = 0; i2 < len; i2 += 1) {
              addedLength += Math.pow(arr2[i2] - arr1[i2], 2);
            }
            return Math.sqrt(addedLength);
          }
          function normalize(vec) {
            return div(vec, length(vec));
          }
          function rgbToHsl(val2) {
            var r2 = val2[0];
            var g2 = val2[1];
            var b = val2[2];
            var max = Math.max(r2, g2, b);
            var min = Math.min(r2, g2, b);
            var h2;
            var s2;
            var l2 = (max + min) / 2;
            if (max === min) {
              h2 = 0;
              s2 = 0;
            } else {
              var d = max - min;
              s2 = l2 > 0.5 ? d / (2 - max - min) : d / (max + min);
              switch (max) {
                case r2:
                  h2 = (g2 - b) / d + (g2 < b ? 6 : 0);
                  break;
                case g2:
                  h2 = (b - r2) / d + 2;
                  break;
                case b:
                  h2 = (r2 - g2) / d + 4;
                  break;
              }
              h2 /= 6;
            }
            return [h2, s2, l2, val2[3]];
          }
          function hue2rgb(p2, q2, t2) {
            if (t2 < 0)
              t2 += 1;
            if (t2 > 1)
              t2 -= 1;
            if (t2 < 1 / 6)
              return p2 + (q2 - p2) * 6 * t2;
            if (t2 < 1 / 2)
              return q2;
            if (t2 < 2 / 3)
              return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
            return p2;
          }
          function hslToRgb(val2) {
            var h2 = val2[0];
            var s2 = val2[1];
            var l2 = val2[2];
            var r2;
            var g2;
            var b;
            if (s2 === 0) {
              r2 = l2;
              b = l2;
              g2 = l2;
            } else {
              var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
              var p2 = 2 * l2 - q2;
              r2 = hue2rgb(p2, q2, h2 + 1 / 3);
              g2 = hue2rgb(p2, q2, h2);
              b = hue2rgb(p2, q2, h2 - 1 / 3);
            }
            return [r2, g2, b, val2[3]];
          }
          function linear(t2, tMin, tMax, value1, value2) {
            if (value1 === void 0 || value2 === void 0) {
              value1 = tMin;
              value2 = tMax;
              tMin = 0;
              tMax = 1;
            }
            if (tMax < tMin) {
              var _tMin = tMax;
              tMax = tMin;
              tMin = _tMin;
            }
            if (t2 <= tMin) {
              return value1;
            }
            if (t2 >= tMax) {
              return value2;
            }
            var perc = tMax === tMin ? 0 : (t2 - tMin) / (tMax - tMin);
            if (!value1.length) {
              return value1 + (value2 - value1) * perc;
            }
            var i2;
            var len = value1.length;
            var arr2 = createTypedArray("float32", len);
            for (i2 = 0; i2 < len; i2 += 1) {
              arr2[i2] = value1[i2] + (value2[i2] - value1[i2]) * perc;
            }
            return arr2;
          }
          function random(min, max) {
            if (max === void 0) {
              if (min === void 0) {
                min = 0;
                max = 1;
              } else {
                max = min;
                min = void 0;
              }
            }
            if (max.length) {
              var i2;
              var len = max.length;
              if (!min) {
                min = createTypedArray("float32", len);
              }
              var arr2 = createTypedArray("float32", len);
              var rnd = BMMath.random();
              for (i2 = 0; i2 < len; i2 += 1) {
                arr2[i2] = min[i2] + rnd * (max[i2] - min[i2]);
              }
              return arr2;
            }
            if (min === void 0) {
              min = 0;
            }
            var rndm = BMMath.random();
            return min + rndm * (max - min);
          }
          function createPath(points, inTangents, outTangents, closed) {
            var i2;
            var len = points.length;
            var path2 = shapePool.newElement();
            path2.setPathData(!!closed, len);
            var arrPlaceholder = [0, 0];
            var inVertexPoint;
            var outVertexPoint;
            for (i2 = 0; i2 < len; i2 += 1) {
              inVertexPoint = inTangents && inTangents[i2] ? inTangents[i2] : arrPlaceholder;
              outVertexPoint = outTangents && outTangents[i2] ? outTangents[i2] : arrPlaceholder;
              path2.setTripleAt(points[i2][0], points[i2][1], outVertexPoint[0] + points[i2][0], outVertexPoint[1] + points[i2][1], inVertexPoint[0] + points[i2][0], inVertexPoint[1] + points[i2][1], i2, true);
            }
            return path2;
          }
          function initiateExpression(elem, data, property) {
            function noOp(_value) {
              return _value;
            }
            if (!elem.globalData.renderConfig.runExpressions) {
              return noOp;
            }
            var val = data.x;
            var needsVelocity = /velocity(?![\w\d])/.test(val);
            var _needsRandom = val.indexOf("random") !== -1;
            var elemType = elem.data.ty;
            var transform;
            var $bm_transform;
            var content;
            var effect;
            var thisProperty = property;
            thisProperty.valueAtTime = thisProperty.getValueAtTime;
            Object.defineProperty(thisProperty, "value", {
              get: function get2() {
                return thisProperty.v;
              }
            });
            elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate;
            elem.comp.displayStartTime = 0;
            var inPoint = elem.data.ip / elem.comp.globalData.frameRate;
            var outPoint = elem.data.op / elem.comp.globalData.frameRate;
            var width = elem.data.sw ? elem.data.sw : 0;
            var height = elem.data.sh ? elem.data.sh : 0;
            var name = elem.data.nm;
            var loopIn;
            var loop_in;
            var loopOut;
            var loop_out;
            var smooth;
            var toWorld;
            var fromWorld;
            var fromComp;
            var toComp;
            var fromCompToSurface;
            var position;
            var rotation;
            var anchorPoint;
            var scale;
            var thisLayer;
            var thisComp;
            var mask;
            var valueAtTime;
            var velocityAtTime;
            var scoped_bm_rt;
            var expression_function = eval("[function _expression_function(){" + val + ";scoped_bm_rt=$bm_rt}]")[0];
            var numKeys = property.kf ? data.k.length : 0;
            var active = !this.data || this.data.hd !== true;
            var wiggle = function wiggle2(freq, amp) {
              var iWiggle;
              var j;
              var lenWiggle = this.pv.length ? this.pv.length : 1;
              var addedAmps = createTypedArray("float32", lenWiggle);
              freq = 5;
              var iterations = Math.floor(time * freq);
              iWiggle = 0;
              j = 0;
              while (iWiggle < iterations) {
                for (j = 0; j < lenWiggle; j += 1) {
                  addedAmps[j] += -amp + amp * 2 * BMMath.random();
                }
                iWiggle += 1;
              }
              var periods = time * freq;
              var perc = periods - Math.floor(periods);
              var arr2 = createTypedArray("float32", lenWiggle);
              if (lenWiggle > 1) {
                for (j = 0; j < lenWiggle; j += 1) {
                  arr2[j] = this.pv[j] + addedAmps[j] + (-amp + amp * 2 * BMMath.random()) * perc;
                }
                return arr2;
              }
              return this.pv + addedAmps[0] + (-amp + amp * 2 * BMMath.random()) * perc;
            }.bind(this);
            if (thisProperty.loopIn) {
              loopIn = thisProperty.loopIn.bind(thisProperty);
              loop_in = loopIn;
            }
            if (thisProperty.loopOut) {
              loopOut = thisProperty.loopOut.bind(thisProperty);
              loop_out = loopOut;
            }
            if (thisProperty.smooth) {
              smooth = thisProperty.smooth.bind(thisProperty);
            }
            function loopInDuration(type, duration) {
              return loopIn(type, duration, true);
            }
            function loopOutDuration(type, duration) {
              return loopOut(type, duration, true);
            }
            if (this.getValueAtTime) {
              valueAtTime = this.getValueAtTime.bind(this);
            }
            if (this.getVelocityAtTime) {
              velocityAtTime = this.getVelocityAtTime.bind(this);
            }
            var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);
            function lookAt(elem1, elem2) {
              var fVec = [elem2[0] - elem1[0], elem2[1] - elem1[1], elem2[2] - elem1[2]];
              var pitch = Math.atan2(fVec[0], Math.sqrt(fVec[1] * fVec[1] + fVec[2] * fVec[2])) / degToRads;
              var yaw = -Math.atan2(fVec[1], fVec[2]) / degToRads;
              return [yaw, pitch, 0];
            }
            function easeOut(t2, tMin, tMax, val1, val2) {
              return applyEase(easeOutBez, t2, tMin, tMax, val1, val2);
            }
            function easeIn(t2, tMin, tMax, val1, val2) {
              return applyEase(easeInBez, t2, tMin, tMax, val1, val2);
            }
            function ease(t2, tMin, tMax, val1, val2) {
              return applyEase(easeInOutBez, t2, tMin, tMax, val1, val2);
            }
            function applyEase(fn, t2, tMin, tMax, val1, val2) {
              if (val1 === void 0) {
                val1 = tMin;
                val2 = tMax;
              } else {
                t2 = (t2 - tMin) / (tMax - tMin);
              }
              if (t2 > 1) {
                t2 = 1;
              } else if (t2 < 0) {
                t2 = 0;
              }
              var mult = fn(t2);
              if ($bm_isInstanceOfArray(val1)) {
                var iKey;
                var lenKey = val1.length;
                var arr2 = createTypedArray("float32", lenKey);
                for (iKey = 0; iKey < lenKey; iKey += 1) {
                  arr2[iKey] = (val2[iKey] - val1[iKey]) * mult + val1[iKey];
                }
                return arr2;
              }
              return (val2 - val1) * mult + val1;
            }
            function nearestKey(time2) {
              var iKey;
              var lenKey = data.k.length;
              var index2;
              var keyTime;
              if (!data.k.length || typeof data.k[0] === "number") {
                index2 = 0;
                keyTime = 0;
              } else {
                index2 = -1;
                time2 *= elem.comp.globalData.frameRate;
                if (time2 < data.k[0].t) {
                  index2 = 1;
                  keyTime = data.k[0].t;
                } else {
                  for (iKey = 0; iKey < lenKey - 1; iKey += 1) {
                    if (time2 === data.k[iKey].t) {
                      index2 = iKey + 1;
                      keyTime = data.k[iKey].t;
                      break;
                    } else if (time2 > data.k[iKey].t && time2 < data.k[iKey + 1].t) {
                      if (time2 - data.k[iKey].t > data.k[iKey + 1].t - time2) {
                        index2 = iKey + 2;
                        keyTime = data.k[iKey + 1].t;
                      } else {
                        index2 = iKey + 1;
                        keyTime = data.k[iKey].t;
                      }
                      break;
                    }
                  }
                  if (index2 === -1) {
                    index2 = iKey + 1;
                    keyTime = data.k[iKey].t;
                  }
                }
              }
              var obKey = {};
              obKey.index = index2;
              obKey.time = keyTime / elem.comp.globalData.frameRate;
              return obKey;
            }
            function key(ind) {
              var obKey;
              var iKey;
              var lenKey;
              if (!data.k.length || typeof data.k[0] === "number") {
                throw new Error("The property has no keyframe at index " + ind);
              }
              ind -= 1;
              obKey = {
                time: data.k[ind].t / elem.comp.globalData.frameRate,
                value: []
              };
              var arr2 = Object.prototype.hasOwnProperty.call(data.k[ind], "s") ? data.k[ind].s : data.k[ind - 1].e;
              lenKey = arr2.length;
              for (iKey = 0; iKey < lenKey; iKey += 1) {
                obKey[iKey] = arr2[iKey];
                obKey.value[iKey] = arr2[iKey];
              }
              return obKey;
            }
            function framesToTime(fr2, fps) {
              if (!fps) {
                fps = elem.comp.globalData.frameRate;
              }
              return fr2 / fps;
            }
            function timeToFrames(t2, fps) {
              if (!t2 && t2 !== 0) {
                t2 = time;
              }
              if (!fps) {
                fps = elem.comp.globalData.frameRate;
              }
              return t2 * fps;
            }
            function seedRandom(seed) {
              BMMath.seedrandom(randSeed + seed);
            }
            function sourceRectAtTime() {
              return elem.sourceRectAtTime();
            }
            function substring(init2, end) {
              if (typeof value === "string") {
                if (end === void 0) {
                  return value.substring(init2);
                }
                return value.substring(init2, end);
              }
              return "";
            }
            function substr(init2, end) {
              if (typeof value === "string") {
                if (end === void 0) {
                  return value.substr(init2);
                }
                return value.substr(init2, end);
              }
              return "";
            }
            function posterizeTime(framesPerSecond) {
              time = framesPerSecond === 0 ? 0 : Math.floor(time * framesPerSecond) / framesPerSecond;
              value = valueAtTime(time);
            }
            var time;
            var velocity;
            var value;
            var text;
            var textIndex;
            var textTotal;
            var selectorValue;
            var index = elem.data.ind;
            var hasParent = !!(elem.hierarchy && elem.hierarchy.length);
            var parent;
            var randSeed = Math.floor(Math.random() * 1e6);
            var globalData = elem.globalData;
            function executeExpression(_value) {
              value = _value;
              if (this.frameExpressionId === elem.globalData.frameId && this.propType !== "textSelector") {
                return value;
              }
              if (this.propType === "textSelector") {
                textIndex = this.textIndex;
                textTotal = this.textTotal;
                selectorValue = this.selectorValue;
              }
              if (!thisLayer) {
                text = elem.layerInterface.text;
                thisLayer = elem.layerInterface;
                thisComp = elem.comp.compInterface;
                toWorld = thisLayer.toWorld.bind(thisLayer);
                fromWorld = thisLayer.fromWorld.bind(thisLayer);
                fromComp = thisLayer.fromComp.bind(thisLayer);
                toComp = thisLayer.toComp.bind(thisLayer);
                mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null;
                fromCompToSurface = fromComp;
              }
              if (!transform) {
                transform = elem.layerInterface("ADBE Transform Group");
                $bm_transform = transform;
                if (transform) {
                  anchorPoint = transform.anchorPoint;
                }
              }
              if (elemType === 4 && !content) {
                content = thisLayer("ADBE Root Vectors Group");
              }
              if (!effect) {
                effect = thisLayer(4);
              }
              hasParent = !!(elem.hierarchy && elem.hierarchy.length);
              if (hasParent && !parent) {
                parent = elem.hierarchy[0].layerInterface;
              }
              time = this.comp.renderedFrame / this.comp.globalData.frameRate;
              if (_needsRandom) {
                seedRandom(randSeed + time);
              }
              if (needsVelocity) {
                velocity = velocityAtTime(time);
              }
              expression_function();
              this.frameExpressionId = elem.globalData.frameId;
              scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE ? scoped_bm_rt.v : scoped_bm_rt;
              return scoped_bm_rt;
            }
            executeExpression.__preventDeadCodeRemoval = [$bm_transform, anchorPoint, time, velocity, inPoint, outPoint, width, height, name, loop_in, loop_out, smooth, toComp, fromCompToSurface, toWorld, fromWorld, mask, position, rotation, scale, thisComp, numKeys, active, wiggle, loopInDuration, loopOutDuration, comp, lookAt, easeOut, easeIn, ease, nearestKey, key, text, textIndex, textTotal, selectorValue, framesToTime, timeToFrames, sourceRectAtTime, substring, substr, posterizeTime, index, globalData];
            return executeExpression;
          }
          ob.initiateExpression = initiateExpression;
          ob.__preventDeadCodeRemoval = [window, document, XMLHttpRequest, fetch, frames, $bm_neg, add, $bm_sum, $bm_sub, $bm_mul, $bm_div, $bm_mod, clamp, radians_to_degrees, degreesToRadians, degrees_to_radians, normalize, rgbToHsl, hslToRgb, linear, random, createPath, _lottieGlobal];
          ob.resetFrame = resetFrame;
          return ob;
        }();
        var Expressions = function() {
          var ob2 = {};
          ob2.initExpressions = initExpressions;
          ob2.resetFrame = ExpressionManager.resetFrame;
          function initExpressions(animation) {
            var stackCount = 0;
            var registers = [];
            function pushExpression() {
              stackCount += 1;
            }
            function popExpression() {
              stackCount -= 1;
              if (stackCount === 0) {
                releaseInstances();
              }
            }
            function registerExpressionProperty(expression) {
              if (registers.indexOf(expression) === -1) {
                registers.push(expression);
              }
            }
            function releaseInstances() {
              var i2;
              var len = registers.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                registers[i2].release();
              }
              registers.length = 0;
            }
            animation.renderer.compInterface = CompExpressionInterface(animation.renderer);
            animation.renderer.globalData.projectInterface.registerComposition(animation.renderer);
            animation.renderer.globalData.pushExpression = pushExpression;
            animation.renderer.globalData.popExpression = popExpression;
            animation.renderer.globalData.registerExpressionProperty = registerExpressionProperty;
          }
          return ob2;
        }();
        var MaskManagerInterface = function() {
          function MaskInterface(mask2, data2) {
            this._mask = mask2;
            this._data = data2;
          }
          Object.defineProperty(MaskInterface.prototype, "maskPath", {
            get: function get2() {
              if (this._mask.prop.k) {
                this._mask.prop.getValue();
              }
              return this._mask.prop;
            }
          });
          Object.defineProperty(MaskInterface.prototype, "maskOpacity", {
            get: function get2() {
              if (this._mask.op.k) {
                this._mask.op.getValue();
              }
              return this._mask.op.v * 100;
            }
          });
          var MaskManager = function MaskManager2(maskManager) {
            var _masksInterfaces = createSizedArray(maskManager.viewData.length);
            var i2;
            var len = maskManager.viewData.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              _masksInterfaces[i2] = new MaskInterface(maskManager.viewData[i2], maskManager.masksProperties[i2]);
            }
            var maskFunction = function maskFunction2(name2) {
              i2 = 0;
              while (i2 < len) {
                if (maskManager.masksProperties[i2].nm === name2) {
                  return _masksInterfaces[i2];
                }
                i2 += 1;
              }
              return null;
            };
            return maskFunction;
          };
          return MaskManager;
        }();
        var ExpressionPropertyInterface = /* @__PURE__ */ function() {
          var defaultUnidimensionalValue = {
            pv: 0,
            v: 0,
            mult: 1
          };
          var defaultMultidimensionalValue = {
            pv: [0, 0, 0],
            v: [0, 0, 0],
            mult: 1
          };
          function completeProperty(expressionValue, property2, type) {
            Object.defineProperty(expressionValue, "velocity", {
              get: function get2() {
                return property2.getVelocityAtTime(property2.comp.currentFrame);
              }
            });
            expressionValue.numKeys = property2.keyframes ? property2.keyframes.length : 0;
            expressionValue.key = function(pos) {
              if (!expressionValue.numKeys) {
                return 0;
              }
              var value2 = "";
              if ("s" in property2.keyframes[pos - 1]) {
                value2 = property2.keyframes[pos - 1].s;
              } else if ("e" in property2.keyframes[pos - 2]) {
                value2 = property2.keyframes[pos - 2].e;
              } else {
                value2 = property2.keyframes[pos - 2].s;
              }
              var valueProp = type === "unidimensional" ? new Number(value2) : Object.assign({}, value2);
              valueProp.time = property2.keyframes[pos - 1].t / property2.elem.comp.globalData.frameRate;
              valueProp.value = type === "unidimensional" ? value2[0] : value2;
              return valueProp;
            };
            expressionValue.valueAtTime = property2.getValueAtTime;
            expressionValue.speedAtTime = property2.getSpeedAtTime;
            expressionValue.velocityAtTime = property2.getVelocityAtTime;
            expressionValue.propertyGroup = property2.propertyGroup;
          }
          function UnidimensionalPropertyInterface(property2) {
            if (!property2 || !("pv" in property2)) {
              property2 = defaultUnidimensionalValue;
            }
            var mult = 1 / property2.mult;
            var val2 = property2.pv * mult;
            var expressionValue = new Number(val2);
            expressionValue.value = val2;
            completeProperty(expressionValue, property2, "unidimensional");
            return function() {
              if (property2.k) {
                property2.getValue();
              }
              val2 = property2.v * mult;
              if (expressionValue.value !== val2) {
                expressionValue = new Number(val2);
                expressionValue.value = val2;
                completeProperty(expressionValue, property2, "unidimensional");
              }
              return expressionValue;
            };
          }
          function MultidimensionalPropertyInterface(property2) {
            if (!property2 || !("pv" in property2)) {
              property2 = defaultMultidimensionalValue;
            }
            var mult = 1 / property2.mult;
            var len = property2.data && property2.data.l || property2.pv.length;
            var expressionValue = createTypedArray("float32", len);
            var arrValue = createTypedArray("float32", len);
            expressionValue.value = arrValue;
            completeProperty(expressionValue, property2, "multidimensional");
            return function() {
              if (property2.k) {
                property2.getValue();
              }
              for (var i2 = 0; i2 < len; i2 += 1) {
                arrValue[i2] = property2.v[i2] * mult;
                expressionValue[i2] = arrValue[i2];
              }
              return expressionValue;
            };
          }
          function defaultGetter() {
            return defaultUnidimensionalValue;
          }
          return function(property2) {
            if (!property2) {
              return defaultGetter;
            }
            if (property2.propType === "unidimensional") {
              return UnidimensionalPropertyInterface(property2);
            }
            return MultidimensionalPropertyInterface(property2);
          };
        }();
        var TransformExpressionInterface = /* @__PURE__ */ function() {
          return function(transform2) {
            function _thisFunction(name2) {
              switch (name2) {
                case "scale":
                case "Scale":
                case "ADBE Scale":
                case 6:
                  return _thisFunction.scale;
                case "rotation":
                case "Rotation":
                case "ADBE Rotation":
                case "ADBE Rotate Z":
                case 10:
                  return _thisFunction.rotation;
                case "ADBE Rotate X":
                  return _thisFunction.xRotation;
                case "ADBE Rotate Y":
                  return _thisFunction.yRotation;
                case "position":
                case "Position":
                case "ADBE Position":
                case 2:
                  return _thisFunction.position;
                case "ADBE Position_0":
                  return _thisFunction.xPosition;
                case "ADBE Position_1":
                  return _thisFunction.yPosition;
                case "ADBE Position_2":
                  return _thisFunction.zPosition;
                case "anchorPoint":
                case "AnchorPoint":
                case "Anchor Point":
                case "ADBE AnchorPoint":
                case 1:
                  return _thisFunction.anchorPoint;
                case "opacity":
                case "Opacity":
                case 11:
                  return _thisFunction.opacity;
                default:
                  return null;
              }
            }
            Object.defineProperty(_thisFunction, "rotation", {
              get: ExpressionPropertyInterface(transform2.r || transform2.rz)
            });
            Object.defineProperty(_thisFunction, "zRotation", {
              get: ExpressionPropertyInterface(transform2.rz || transform2.r)
            });
            Object.defineProperty(_thisFunction, "xRotation", {
              get: ExpressionPropertyInterface(transform2.rx)
            });
            Object.defineProperty(_thisFunction, "yRotation", {
              get: ExpressionPropertyInterface(transform2.ry)
            });
            Object.defineProperty(_thisFunction, "scale", {
              get: ExpressionPropertyInterface(transform2.s)
            });
            var _px;
            var _py;
            var _pz;
            var _transformFactory;
            if (transform2.p) {
              _transformFactory = ExpressionPropertyInterface(transform2.p);
            } else {
              _px = ExpressionPropertyInterface(transform2.px);
              _py = ExpressionPropertyInterface(transform2.py);
              if (transform2.pz) {
                _pz = ExpressionPropertyInterface(transform2.pz);
              }
            }
            Object.defineProperty(_thisFunction, "position", {
              get: function get2() {
                if (transform2.p) {
                  return _transformFactory();
                }
                return [_px(), _py(), _pz ? _pz() : 0];
              }
            });
            Object.defineProperty(_thisFunction, "xPosition", {
              get: ExpressionPropertyInterface(transform2.px)
            });
            Object.defineProperty(_thisFunction, "yPosition", {
              get: ExpressionPropertyInterface(transform2.py)
            });
            Object.defineProperty(_thisFunction, "zPosition", {
              get: ExpressionPropertyInterface(transform2.pz)
            });
            Object.defineProperty(_thisFunction, "anchorPoint", {
              get: ExpressionPropertyInterface(transform2.a)
            });
            Object.defineProperty(_thisFunction, "opacity", {
              get: ExpressionPropertyInterface(transform2.o)
            });
            Object.defineProperty(_thisFunction, "skew", {
              get: ExpressionPropertyInterface(transform2.sk)
            });
            Object.defineProperty(_thisFunction, "skewAxis", {
              get: ExpressionPropertyInterface(transform2.sa)
            });
            Object.defineProperty(_thisFunction, "orientation", {
              get: ExpressionPropertyInterface(transform2.or)
            });
            return _thisFunction;
          };
        }();
        var LayerExpressionInterface = /* @__PURE__ */ function() {
          function getMatrix(time2) {
            var toWorldMat = new Matrix();
            if (time2 !== void 0) {
              var propMatrix = this._elem.finalTransform.mProp.getValueAtTime(time2);
              propMatrix.clone(toWorldMat);
            } else {
              var transformMat = this._elem.finalTransform.mProp;
              transformMat.applyToMatrix(toWorldMat);
            }
            return toWorldMat;
          }
          function toWorldVec(arr2, time2) {
            var toWorldMat = this.getMatrix(time2);
            toWorldMat.props[12] = 0;
            toWorldMat.props[13] = 0;
            toWorldMat.props[14] = 0;
            return this.applyPoint(toWorldMat, arr2);
          }
          function toWorld2(arr2, time2) {
            var toWorldMat = this.getMatrix(time2);
            return this.applyPoint(toWorldMat, arr2);
          }
          function fromWorldVec(arr2, time2) {
            var toWorldMat = this.getMatrix(time2);
            toWorldMat.props[12] = 0;
            toWorldMat.props[13] = 0;
            toWorldMat.props[14] = 0;
            return this.invertPoint(toWorldMat, arr2);
          }
          function fromWorld2(arr2, time2) {
            var toWorldMat = this.getMatrix(time2);
            return this.invertPoint(toWorldMat, arr2);
          }
          function applyPoint(matrix, arr2) {
            if (this._elem.hierarchy && this._elem.hierarchy.length) {
              var i2;
              var len = this._elem.hierarchy.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                this._elem.hierarchy[i2].finalTransform.mProp.applyToMatrix(matrix);
              }
            }
            return matrix.applyToPointArray(arr2[0], arr2[1], arr2[2] || 0);
          }
          function invertPoint(matrix, arr2) {
            if (this._elem.hierarchy && this._elem.hierarchy.length) {
              var i2;
              var len = this._elem.hierarchy.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                this._elem.hierarchy[i2].finalTransform.mProp.applyToMatrix(matrix);
              }
            }
            return matrix.inversePoint(arr2);
          }
          function fromComp2(arr2) {
            var toWorldMat = new Matrix();
            toWorldMat.reset();
            this._elem.finalTransform.mProp.applyToMatrix(toWorldMat);
            if (this._elem.hierarchy && this._elem.hierarchy.length) {
              var i2;
              var len = this._elem.hierarchy.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                this._elem.hierarchy[i2].finalTransform.mProp.applyToMatrix(toWorldMat);
              }
              return toWorldMat.inversePoint(arr2);
            }
            return toWorldMat.inversePoint(arr2);
          }
          function sampleImage() {
            return [1, 1, 1, 1];
          }
          return function(elem2) {
            var transformInterface;
            function _registerMaskInterface(maskManager) {
              _thisLayerFunction.mask = new MaskManagerInterface(maskManager, elem2);
            }
            function _registerEffectsInterface(effects) {
              _thisLayerFunction.effect = effects;
            }
            function _thisLayerFunction(name2) {
              switch (name2) {
                case "ADBE Root Vectors Group":
                case "Contents":
                case 2:
                  return _thisLayerFunction.shapeInterface;
                case 1:
                case 6:
                case "Transform":
                case "transform":
                case "ADBE Transform Group":
                  return transformInterface;
                case 4:
                case "ADBE Effect Parade":
                case "effects":
                case "Effects":
                  return _thisLayerFunction.effect;
                case "ADBE Text Properties":
                  return _thisLayerFunction.textInterface;
                default:
                  return null;
              }
            }
            _thisLayerFunction.getMatrix = getMatrix;
            _thisLayerFunction.invertPoint = invertPoint;
            _thisLayerFunction.applyPoint = applyPoint;
            _thisLayerFunction.toWorld = toWorld2;
            _thisLayerFunction.toWorldVec = toWorldVec;
            _thisLayerFunction.fromWorld = fromWorld2;
            _thisLayerFunction.fromWorldVec = fromWorldVec;
            _thisLayerFunction.toComp = toWorld2;
            _thisLayerFunction.fromComp = fromComp2;
            _thisLayerFunction.sampleImage = sampleImage;
            _thisLayerFunction.sourceRectAtTime = elem2.sourceRectAtTime.bind(elem2);
            _thisLayerFunction._elem = elem2;
            transformInterface = TransformExpressionInterface(elem2.finalTransform.mProp);
            var anchorPointDescriptor = getDescriptor(transformInterface, "anchorPoint");
            Object.defineProperties(_thisLayerFunction, {
              hasParent: {
                get: function get2() {
                  return elem2.hierarchy.length;
                }
              },
              parent: {
                get: function get2() {
                  return elem2.hierarchy[0].layerInterface;
                }
              },
              rotation: getDescriptor(transformInterface, "rotation"),
              scale: getDescriptor(transformInterface, "scale"),
              position: getDescriptor(transformInterface, "position"),
              opacity: getDescriptor(transformInterface, "opacity"),
              anchorPoint: anchorPointDescriptor,
              anchor_point: anchorPointDescriptor,
              transform: {
                get: function get2() {
                  return transformInterface;
                }
              },
              active: {
                get: function get2() {
                  return elem2.isInRange;
                }
              }
            });
            _thisLayerFunction.startTime = elem2.data.st;
            _thisLayerFunction.index = elem2.data.ind;
            _thisLayerFunction.source = elem2.data.refId;
            _thisLayerFunction.height = elem2.data.ty === 0 ? elem2.data.h : 100;
            _thisLayerFunction.width = elem2.data.ty === 0 ? elem2.data.w : 100;
            _thisLayerFunction.inPoint = elem2.data.ip / elem2.comp.globalData.frameRate;
            _thisLayerFunction.outPoint = elem2.data.op / elem2.comp.globalData.frameRate;
            _thisLayerFunction._name = elem2.data.nm;
            _thisLayerFunction.registerMaskInterface = _registerMaskInterface;
            _thisLayerFunction.registerEffectsInterface = _registerEffectsInterface;
            return _thisLayerFunction;
          };
        }();
        var propertyGroupFactory = /* @__PURE__ */ function() {
          return function(interfaceFunction, parentPropertyGroup) {
            return function(val2) {
              val2 = val2 === void 0 ? 1 : val2;
              if (val2 <= 0) {
                return interfaceFunction;
              }
              return parentPropertyGroup(val2 - 1);
            };
          };
        }();
        var PropertyInterface = /* @__PURE__ */ function() {
          return function(propertyName, propertyGroup) {
            var interfaceFunction = {
              _name: propertyName
            };
            function _propertyGroup(val2) {
              val2 = val2 === void 0 ? 1 : val2;
              if (val2 <= 0) {
                return interfaceFunction;
              }
              return propertyGroup(val2 - 1);
            }
            return _propertyGroup;
          };
        }();
        var EffectsExpressionInterface = /* @__PURE__ */ function() {
          var ob2 = {
            createEffectsInterface
          };
          function createEffectsInterface(elem2, propertyGroup) {
            if (elem2.effectsManager) {
              var effectElements = [];
              var effectsData = elem2.data.ef;
              var i2;
              var len = elem2.effectsManager.effectElements.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                effectElements.push(createGroupInterface(effectsData[i2], elem2.effectsManager.effectElements[i2], propertyGroup, elem2));
              }
              var effects = elem2.data.ef || [];
              var groupInterface = function groupInterface2(name2) {
                i2 = 0;
                len = effects.length;
                while (i2 < len) {
                  if (name2 === effects[i2].nm || name2 === effects[i2].mn || name2 === effects[i2].ix) {
                    return effectElements[i2];
                  }
                  i2 += 1;
                }
                return null;
              };
              Object.defineProperty(groupInterface, "numProperties", {
                get: function get2() {
                  return effects.length;
                }
              });
              return groupInterface;
            }
            return null;
          }
          function createGroupInterface(data2, elements, propertyGroup, elem2) {
            function groupInterface(name2) {
              var effects = data2.ef;
              var i3 = 0;
              var len2 = effects.length;
              while (i3 < len2) {
                if (name2 === effects[i3].nm || name2 === effects[i3].mn || name2 === effects[i3].ix) {
                  if (effects[i3].ty === 5) {
                    return effectElements[i3];
                  }
                  return effectElements[i3]();
                }
                i3 += 1;
              }
              throw new Error();
            }
            var _propertyGroup = propertyGroupFactory(groupInterface, propertyGroup);
            var effectElements = [];
            var i2;
            var len = data2.ef.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              if (data2.ef[i2].ty === 5) {
                effectElements.push(createGroupInterface(data2.ef[i2], elements.effectElements[i2], elements.effectElements[i2].propertyGroup, elem2));
              } else {
                effectElements.push(createValueInterface(elements.effectElements[i2], data2.ef[i2].ty, elem2, _propertyGroup));
              }
            }
            if (data2.mn === "ADBE Color Control") {
              Object.defineProperty(groupInterface, "color", {
                get: function get2() {
                  return effectElements[0]();
                }
              });
            }
            Object.defineProperties(groupInterface, {
              numProperties: {
                get: function get2() {
                  return data2.np;
                }
              },
              _name: {
                value: data2.nm
              },
              propertyGroup: {
                value: _propertyGroup
              }
            });
            groupInterface.enabled = data2.en !== 0;
            groupInterface.active = groupInterface.enabled;
            return groupInterface;
          }
          function createValueInterface(element, type, elem2, propertyGroup) {
            var expressionProperty = ExpressionPropertyInterface(element.p);
            function interfaceFunction() {
              if (type === 10) {
                return elem2.comp.compInterface(element.p.v);
              }
              return expressionProperty();
            }
            if (element.p.setGroupProperty) {
              element.p.setGroupProperty(PropertyInterface("", propertyGroup));
            }
            return interfaceFunction;
          }
          return ob2;
        }();
        var ShapePathInterface = /* @__PURE__ */ function() {
          return function pathInterfaceFactory(shape, view, propertyGroup) {
            var prop = view.sh;
            function interfaceFunction(val2) {
              if (val2 === "Shape" || val2 === "shape" || val2 === "Path" || val2 === "path" || val2 === "ADBE Vector Shape" || val2 === 2) {
                return interfaceFunction.path;
              }
              return null;
            }
            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            prop.setGroupProperty(PropertyInterface("Path", _propertyGroup));
            Object.defineProperties(interfaceFunction, {
              path: {
                get: function get2() {
                  if (prop.k) {
                    prop.getValue();
                  }
                  return prop;
                }
              },
              shape: {
                get: function get2() {
                  if (prop.k) {
                    prop.getValue();
                  }
                  return prop;
                }
              },
              _name: {
                value: shape.nm
              },
              ix: {
                value: shape.ix
              },
              propertyIndex: {
                value: shape.ix
              },
              mn: {
                value: shape.mn
              },
              propertyGroup: {
                value: propertyGroup
              }
            });
            return interfaceFunction;
          };
        }();
        var ShapeExpressionInterface = /* @__PURE__ */ function() {
          function iterateElements(shapes, view, propertyGroup) {
            var arr2 = [];
            var i2;
            var len = shapes ? shapes.length : 0;
            for (i2 = 0; i2 < len; i2 += 1) {
              if (shapes[i2].ty === "gr") {
                arr2.push(groupInterfaceFactory(shapes[i2], view[i2], propertyGroup));
              } else if (shapes[i2].ty === "fl") {
                arr2.push(fillInterfaceFactory(shapes[i2], view[i2], propertyGroup));
              } else if (shapes[i2].ty === "st") {
                arr2.push(strokeInterfaceFactory(shapes[i2], view[i2], propertyGroup));
              } else if (shapes[i2].ty === "tm") {
                arr2.push(trimInterfaceFactory(shapes[i2], view[i2], propertyGroup));
              } else if (shapes[i2].ty === "tr")
                ;
              else if (shapes[i2].ty === "el") {
                arr2.push(ellipseInterfaceFactory(shapes[i2], view[i2], propertyGroup));
              } else if (shapes[i2].ty === "sr") {
                arr2.push(starInterfaceFactory(shapes[i2], view[i2], propertyGroup));
              } else if (shapes[i2].ty === "sh") {
                arr2.push(ShapePathInterface(shapes[i2], view[i2], propertyGroup));
              } else if (shapes[i2].ty === "rc") {
                arr2.push(rectInterfaceFactory(shapes[i2], view[i2], propertyGroup));
              } else if (shapes[i2].ty === "rd") {
                arr2.push(roundedInterfaceFactory(shapes[i2], view[i2], propertyGroup));
              } else if (shapes[i2].ty === "rp") {
                arr2.push(repeaterInterfaceFactory(shapes[i2], view[i2], propertyGroup));
              } else if (shapes[i2].ty === "gf") {
                arr2.push(gradientFillInterfaceFactory(shapes[i2], view[i2], propertyGroup));
              } else {
                arr2.push(defaultInterfaceFactory(shapes[i2], view[i2]));
              }
            }
            return arr2;
          }
          function contentsInterfaceFactory(shape, view, propertyGroup) {
            var interfaces2;
            var interfaceFunction = function _interfaceFunction(value2) {
              var i2 = 0;
              var len = interfaces2.length;
              while (i2 < len) {
                if (interfaces2[i2]._name === value2 || interfaces2[i2].mn === value2 || interfaces2[i2].propertyIndex === value2 || interfaces2[i2].ix === value2 || interfaces2[i2].ind === value2) {
                  return interfaces2[i2];
                }
                i2 += 1;
              }
              if (typeof value2 === "number") {
                return interfaces2[value2 - 1];
              }
              return null;
            };
            interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            interfaces2 = iterateElements(shape.it, view.it, interfaceFunction.propertyGroup);
            interfaceFunction.numProperties = interfaces2.length;
            var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
            interfaceFunction.transform = transformInterface;
            interfaceFunction.propertyIndex = shape.cix;
            interfaceFunction._name = shape.nm;
            return interfaceFunction;
          }
          function groupInterfaceFactory(shape, view, propertyGroup) {
            var interfaceFunction = function _interfaceFunction(value2) {
              switch (value2) {
                case "ADBE Vectors Group":
                case "Contents":
                case 2:
                  return interfaceFunction.content;
                default:
                  return interfaceFunction.transform;
              }
            };
            interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            var content2 = contentsInterfaceFactory(shape, view, interfaceFunction.propertyGroup);
            var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
            interfaceFunction.content = content2;
            interfaceFunction.transform = transformInterface;
            Object.defineProperty(interfaceFunction, "_name", {
              get: function get2() {
                return shape.nm;
              }
            });
            interfaceFunction.numProperties = shape.np;
            interfaceFunction.propertyIndex = shape.ix;
            interfaceFunction.nm = shape.nm;
            interfaceFunction.mn = shape.mn;
            return interfaceFunction;
          }
          function fillInterfaceFactory(shape, view, propertyGroup) {
            function interfaceFunction(val2) {
              if (val2 === "Color" || val2 === "color") {
                return interfaceFunction.color;
              }
              if (val2 === "Opacity" || val2 === "opacity") {
                return interfaceFunction.opacity;
              }
              return null;
            }
            Object.defineProperties(interfaceFunction, {
              color: {
                get: ExpressionPropertyInterface(view.c)
              },
              opacity: {
                get: ExpressionPropertyInterface(view.o)
              },
              _name: {
                value: shape.nm
              },
              mn: {
                value: shape.mn
              }
            });
            view.c.setGroupProperty(PropertyInterface("Color", propertyGroup));
            view.o.setGroupProperty(PropertyInterface("Opacity", propertyGroup));
            return interfaceFunction;
          }
          function gradientFillInterfaceFactory(shape, view, propertyGroup) {
            function interfaceFunction(val2) {
              if (val2 === "Start Point" || val2 === "start point") {
                return interfaceFunction.startPoint;
              }
              if (val2 === "End Point" || val2 === "end point") {
                return interfaceFunction.endPoint;
              }
              if (val2 === "Opacity" || val2 === "opacity") {
                return interfaceFunction.opacity;
              }
              return null;
            }
            Object.defineProperties(interfaceFunction, {
              startPoint: {
                get: ExpressionPropertyInterface(view.s)
              },
              endPoint: {
                get: ExpressionPropertyInterface(view.e)
              },
              opacity: {
                get: ExpressionPropertyInterface(view.o)
              },
              type: {
                get: function get2() {
                  return "a";
                }
              },
              _name: {
                value: shape.nm
              },
              mn: {
                value: shape.mn
              }
            });
            view.s.setGroupProperty(PropertyInterface("Start Point", propertyGroup));
            view.e.setGroupProperty(PropertyInterface("End Point", propertyGroup));
            view.o.setGroupProperty(PropertyInterface("Opacity", propertyGroup));
            return interfaceFunction;
          }
          function defaultInterfaceFactory() {
            function interfaceFunction() {
              return null;
            }
            return interfaceFunction;
          }
          function strokeInterfaceFactory(shape, view, propertyGroup) {
            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            var _dashPropertyGroup = propertyGroupFactory(dashOb, _propertyGroup);
            function addPropertyToDashOb(i3) {
              Object.defineProperty(dashOb, shape.d[i3].nm, {
                get: ExpressionPropertyInterface(view.d.dataProps[i3].p)
              });
            }
            var i2;
            var len = shape.d ? shape.d.length : 0;
            var dashOb = {};
            for (i2 = 0; i2 < len; i2 += 1) {
              addPropertyToDashOb(i2);
              view.d.dataProps[i2].p.setGroupProperty(_dashPropertyGroup);
            }
            function interfaceFunction(val2) {
              if (val2 === "Color" || val2 === "color") {
                return interfaceFunction.color;
              }
              if (val2 === "Opacity" || val2 === "opacity") {
                return interfaceFunction.opacity;
              }
              if (val2 === "Stroke Width" || val2 === "stroke width") {
                return interfaceFunction.strokeWidth;
              }
              return null;
            }
            Object.defineProperties(interfaceFunction, {
              color: {
                get: ExpressionPropertyInterface(view.c)
              },
              opacity: {
                get: ExpressionPropertyInterface(view.o)
              },
              strokeWidth: {
                get: ExpressionPropertyInterface(view.w)
              },
              dash: {
                get: function get2() {
                  return dashOb;
                }
              },
              _name: {
                value: shape.nm
              },
              mn: {
                value: shape.mn
              }
            });
            view.c.setGroupProperty(PropertyInterface("Color", _propertyGroup));
            view.o.setGroupProperty(PropertyInterface("Opacity", _propertyGroup));
            view.w.setGroupProperty(PropertyInterface("Stroke Width", _propertyGroup));
            return interfaceFunction;
          }
          function trimInterfaceFactory(shape, view, propertyGroup) {
            function interfaceFunction(val2) {
              if (val2 === shape.e.ix || val2 === "End" || val2 === "end") {
                return interfaceFunction.end;
              }
              if (val2 === shape.s.ix) {
                return interfaceFunction.start;
              }
              if (val2 === shape.o.ix) {
                return interfaceFunction.offset;
              }
              return null;
            }
            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            interfaceFunction.propertyIndex = shape.ix;
            view.s.setGroupProperty(PropertyInterface("Start", _propertyGroup));
            view.e.setGroupProperty(PropertyInterface("End", _propertyGroup));
            view.o.setGroupProperty(PropertyInterface("Offset", _propertyGroup));
            interfaceFunction.propertyIndex = shape.ix;
            interfaceFunction.propertyGroup = propertyGroup;
            Object.defineProperties(interfaceFunction, {
              start: {
                get: ExpressionPropertyInterface(view.s)
              },
              end: {
                get: ExpressionPropertyInterface(view.e)
              },
              offset: {
                get: ExpressionPropertyInterface(view.o)
              },
              _name: {
                value: shape.nm
              }
            });
            interfaceFunction.mn = shape.mn;
            return interfaceFunction;
          }
          function transformInterfaceFactory(shape, view, propertyGroup) {
            function interfaceFunction(value2) {
              if (shape.a.ix === value2 || value2 === "Anchor Point") {
                return interfaceFunction.anchorPoint;
              }
              if (shape.o.ix === value2 || value2 === "Opacity") {
                return interfaceFunction.opacity;
              }
              if (shape.p.ix === value2 || value2 === "Position") {
                return interfaceFunction.position;
              }
              if (shape.r.ix === value2 || value2 === "Rotation" || value2 === "ADBE Vector Rotation") {
                return interfaceFunction.rotation;
              }
              if (shape.s.ix === value2 || value2 === "Scale") {
                return interfaceFunction.scale;
              }
              if (shape.sk && shape.sk.ix === value2 || value2 === "Skew") {
                return interfaceFunction.skew;
              }
              if (shape.sa && shape.sa.ix === value2 || value2 === "Skew Axis") {
                return interfaceFunction.skewAxis;
              }
              return null;
            }
            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            view.transform.mProps.o.setGroupProperty(PropertyInterface("Opacity", _propertyGroup));
            view.transform.mProps.p.setGroupProperty(PropertyInterface("Position", _propertyGroup));
            view.transform.mProps.a.setGroupProperty(PropertyInterface("Anchor Point", _propertyGroup));
            view.transform.mProps.s.setGroupProperty(PropertyInterface("Scale", _propertyGroup));
            view.transform.mProps.r.setGroupProperty(PropertyInterface("Rotation", _propertyGroup));
            if (view.transform.mProps.sk) {
              view.transform.mProps.sk.setGroupProperty(PropertyInterface("Skew", _propertyGroup));
              view.transform.mProps.sa.setGroupProperty(PropertyInterface("Skew Angle", _propertyGroup));
            }
            view.transform.op.setGroupProperty(PropertyInterface("Opacity", _propertyGroup));
            Object.defineProperties(interfaceFunction, {
              opacity: {
                get: ExpressionPropertyInterface(view.transform.mProps.o)
              },
              position: {
                get: ExpressionPropertyInterface(view.transform.mProps.p)
              },
              anchorPoint: {
                get: ExpressionPropertyInterface(view.transform.mProps.a)
              },
              scale: {
                get: ExpressionPropertyInterface(view.transform.mProps.s)
              },
              rotation: {
                get: ExpressionPropertyInterface(view.transform.mProps.r)
              },
              skew: {
                get: ExpressionPropertyInterface(view.transform.mProps.sk)
              },
              skewAxis: {
                get: ExpressionPropertyInterface(view.transform.mProps.sa)
              },
              _name: {
                value: shape.nm
              }
            });
            interfaceFunction.ty = "tr";
            interfaceFunction.mn = shape.mn;
            interfaceFunction.propertyGroup = propertyGroup;
            return interfaceFunction;
          }
          function ellipseInterfaceFactory(shape, view, propertyGroup) {
            function interfaceFunction(value2) {
              if (shape.p.ix === value2) {
                return interfaceFunction.position;
              }
              if (shape.s.ix === value2) {
                return interfaceFunction.size;
              }
              return null;
            }
            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            interfaceFunction.propertyIndex = shape.ix;
            var prop = view.sh.ty === "tm" ? view.sh.prop : view.sh;
            prop.s.setGroupProperty(PropertyInterface("Size", _propertyGroup));
            prop.p.setGroupProperty(PropertyInterface("Position", _propertyGroup));
            Object.defineProperties(interfaceFunction, {
              size: {
                get: ExpressionPropertyInterface(prop.s)
              },
              position: {
                get: ExpressionPropertyInterface(prop.p)
              },
              _name: {
                value: shape.nm
              }
            });
            interfaceFunction.mn = shape.mn;
            return interfaceFunction;
          }
          function starInterfaceFactory(shape, view, propertyGroup) {
            function interfaceFunction(value2) {
              if (shape.p.ix === value2) {
                return interfaceFunction.position;
              }
              if (shape.r.ix === value2) {
                return interfaceFunction.rotation;
              }
              if (shape.pt.ix === value2) {
                return interfaceFunction.points;
              }
              if (shape.or.ix === value2 || value2 === "ADBE Vector Star Outer Radius") {
                return interfaceFunction.outerRadius;
              }
              if (shape.os.ix === value2) {
                return interfaceFunction.outerRoundness;
              }
              if (shape.ir && (shape.ir.ix === value2 || value2 === "ADBE Vector Star Inner Radius")) {
                return interfaceFunction.innerRadius;
              }
              if (shape.is && shape.is.ix === value2) {
                return interfaceFunction.innerRoundness;
              }
              return null;
            }
            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            var prop = view.sh.ty === "tm" ? view.sh.prop : view.sh;
            interfaceFunction.propertyIndex = shape.ix;
            prop.or.setGroupProperty(PropertyInterface("Outer Radius", _propertyGroup));
            prop.os.setGroupProperty(PropertyInterface("Outer Roundness", _propertyGroup));
            prop.pt.setGroupProperty(PropertyInterface("Points", _propertyGroup));
            prop.p.setGroupProperty(PropertyInterface("Position", _propertyGroup));
            prop.r.setGroupProperty(PropertyInterface("Rotation", _propertyGroup));
            if (shape.ir) {
              prop.ir.setGroupProperty(PropertyInterface("Inner Radius", _propertyGroup));
              prop.is.setGroupProperty(PropertyInterface("Inner Roundness", _propertyGroup));
            }
            Object.defineProperties(interfaceFunction, {
              position: {
                get: ExpressionPropertyInterface(prop.p)
              },
              rotation: {
                get: ExpressionPropertyInterface(prop.r)
              },
              points: {
                get: ExpressionPropertyInterface(prop.pt)
              },
              outerRadius: {
                get: ExpressionPropertyInterface(prop.or)
              },
              outerRoundness: {
                get: ExpressionPropertyInterface(prop.os)
              },
              innerRadius: {
                get: ExpressionPropertyInterface(prop.ir)
              },
              innerRoundness: {
                get: ExpressionPropertyInterface(prop.is)
              },
              _name: {
                value: shape.nm
              }
            });
            interfaceFunction.mn = shape.mn;
            return interfaceFunction;
          }
          function rectInterfaceFactory(shape, view, propertyGroup) {
            function interfaceFunction(value2) {
              if (shape.p.ix === value2) {
                return interfaceFunction.position;
              }
              if (shape.r.ix === value2) {
                return interfaceFunction.roundness;
              }
              if (shape.s.ix === value2 || value2 === "Size" || value2 === "ADBE Vector Rect Size") {
                return interfaceFunction.size;
              }
              return null;
            }
            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            var prop = view.sh.ty === "tm" ? view.sh.prop : view.sh;
            interfaceFunction.propertyIndex = shape.ix;
            prop.p.setGroupProperty(PropertyInterface("Position", _propertyGroup));
            prop.s.setGroupProperty(PropertyInterface("Size", _propertyGroup));
            prop.r.setGroupProperty(PropertyInterface("Rotation", _propertyGroup));
            Object.defineProperties(interfaceFunction, {
              position: {
                get: ExpressionPropertyInterface(prop.p)
              },
              roundness: {
                get: ExpressionPropertyInterface(prop.r)
              },
              size: {
                get: ExpressionPropertyInterface(prop.s)
              },
              _name: {
                value: shape.nm
              }
            });
            interfaceFunction.mn = shape.mn;
            return interfaceFunction;
          }
          function roundedInterfaceFactory(shape, view, propertyGroup) {
            function interfaceFunction(value2) {
              if (shape.r.ix === value2 || value2 === "Round Corners 1") {
                return interfaceFunction.radius;
              }
              return null;
            }
            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            var prop = view;
            interfaceFunction.propertyIndex = shape.ix;
            prop.rd.setGroupProperty(PropertyInterface("Radius", _propertyGroup));
            Object.defineProperties(interfaceFunction, {
              radius: {
                get: ExpressionPropertyInterface(prop.rd)
              },
              _name: {
                value: shape.nm
              }
            });
            interfaceFunction.mn = shape.mn;
            return interfaceFunction;
          }
          function repeaterInterfaceFactory(shape, view, propertyGroup) {
            function interfaceFunction(value2) {
              if (shape.c.ix === value2 || value2 === "Copies") {
                return interfaceFunction.copies;
              }
              if (shape.o.ix === value2 || value2 === "Offset") {
                return interfaceFunction.offset;
              }
              return null;
            }
            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
            var prop = view;
            interfaceFunction.propertyIndex = shape.ix;
            prop.c.setGroupProperty(PropertyInterface("Copies", _propertyGroup));
            prop.o.setGroupProperty(PropertyInterface("Offset", _propertyGroup));
            Object.defineProperties(interfaceFunction, {
              copies: {
                get: ExpressionPropertyInterface(prop.c)
              },
              offset: {
                get: ExpressionPropertyInterface(prop.o)
              },
              _name: {
                value: shape.nm
              }
            });
            interfaceFunction.mn = shape.mn;
            return interfaceFunction;
          }
          return function(shapes, view, propertyGroup) {
            var interfaces2;
            function _interfaceFunction(value2) {
              if (typeof value2 === "number") {
                value2 = value2 === void 0 ? 1 : value2;
                if (value2 === 0) {
                  return propertyGroup;
                }
                return interfaces2[value2 - 1];
              }
              var i2 = 0;
              var len = interfaces2.length;
              while (i2 < len) {
                if (interfaces2[i2]._name === value2) {
                  return interfaces2[i2];
                }
                i2 += 1;
              }
              return null;
            }
            function parentGroupWrapper() {
              return propertyGroup;
            }
            _interfaceFunction.propertyGroup = propertyGroupFactory(_interfaceFunction, parentGroupWrapper);
            interfaces2 = iterateElements(shapes, view, _interfaceFunction.propertyGroup);
            _interfaceFunction.numProperties = interfaces2.length;
            _interfaceFunction._name = "Contents";
            return _interfaceFunction;
          };
        }();
        var TextExpressionInterface = /* @__PURE__ */ function() {
          return function(elem2) {
            var _sourceText;
            function _thisLayerFunction(name2) {
              switch (name2) {
                case "ADBE Text Document":
                  return _thisLayerFunction.sourceText;
                default:
                  return null;
              }
            }
            Object.defineProperty(_thisLayerFunction, "sourceText", {
              get: function get2() {
                elem2.textProperty.getValue();
                var stringValue = elem2.textProperty.currentData.t;
                if (!_sourceText || stringValue !== _sourceText.value) {
                  _sourceText = new String(stringValue);
                  _sourceText.value = stringValue || new String(stringValue);
                  Object.defineProperty(_sourceText, "style", {
                    get: function get3() {
                      return {
                        fillColor: elem2.textProperty.currentData.fc
                      };
                    }
                  });
                }
                return _sourceText;
              }
            });
            return _thisLayerFunction;
          };
        }();
        function _typeof(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof = function _typeof2(obj2) {
              return typeof obj2;
            };
          } else {
            _typeof = function _typeof2(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return _typeof(obj);
        }
        var FootageInterface = /* @__PURE__ */ function() {
          var outlineInterfaceFactory = function outlineInterfaceFactory2(elem2) {
            var currentPropertyName = "";
            var currentProperty = elem2.getFootageData();
            function init2() {
              currentPropertyName = "";
              currentProperty = elem2.getFootageData();
              return searchProperty;
            }
            function searchProperty(value2) {
              if (currentProperty[value2]) {
                currentPropertyName = value2;
                currentProperty = currentProperty[value2];
                if (_typeof(currentProperty) === "object") {
                  return searchProperty;
                }
                return currentProperty;
              }
              var propertyNameIndex = value2.indexOf(currentPropertyName);
              if (propertyNameIndex !== -1) {
                var index2 = parseInt(value2.substr(propertyNameIndex + currentPropertyName.length), 10);
                currentProperty = currentProperty[index2];
                if (_typeof(currentProperty) === "object") {
                  return searchProperty;
                }
                return currentProperty;
              }
              return "";
            }
            return init2;
          };
          var dataInterfaceFactory = function dataInterfaceFactory2(elem2) {
            function interfaceFunction(value2) {
              if (value2 === "Outline") {
                return interfaceFunction.outlineInterface();
              }
              return null;
            }
            interfaceFunction._name = "Outline";
            interfaceFunction.outlineInterface = outlineInterfaceFactory(elem2);
            return interfaceFunction;
          };
          return function(elem2) {
            function _interfaceFunction(value2) {
              if (value2 === "Data") {
                return _interfaceFunction.dataInterface;
              }
              return null;
            }
            _interfaceFunction._name = "Data";
            _interfaceFunction.dataInterface = dataInterfaceFactory(elem2);
            return _interfaceFunction;
          };
        }();
        var interfaces = {
          layer: LayerExpressionInterface,
          effects: EffectsExpressionInterface,
          comp: CompExpressionInterface,
          shape: ShapeExpressionInterface,
          text: TextExpressionInterface,
          footage: FootageInterface
        };
        function getInterface(type) {
          return interfaces[type] || null;
        }
        var expressionHelpers = /* @__PURE__ */ function() {
          function searchExpressions(elem2, data2, prop) {
            if (data2.x) {
              prop.k = true;
              prop.x = true;
              prop.initiateExpression = ExpressionManager.initiateExpression;
              prop.effectsSequence.push(prop.initiateExpression(elem2, data2, prop).bind(prop));
            }
          }
          function getValueAtTime(frameNum) {
            frameNum *= this.elem.globalData.frameRate;
            frameNum -= this.offsetTime;
            if (frameNum !== this._cachingAtTime.lastFrame) {
              this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < frameNum ? this._cachingAtTime.lastIndex : 0;
              this._cachingAtTime.value = this.interpolateValue(frameNum, this._cachingAtTime);
              this._cachingAtTime.lastFrame = frameNum;
            }
            return this._cachingAtTime.value;
          }
          function getSpeedAtTime(frameNum) {
            var delta = -0.01;
            var v1 = this.getValueAtTime(frameNum);
            var v2 = this.getValueAtTime(frameNum + delta);
            var speed = 0;
            if (v1.length) {
              var i2;
              for (i2 = 0; i2 < v1.length; i2 += 1) {
                speed += Math.pow(v2[i2] - v1[i2], 2);
              }
              speed = Math.sqrt(speed) * 100;
            } else {
              speed = 0;
            }
            return speed;
          }
          function getVelocityAtTime(frameNum) {
            if (this.vel !== void 0) {
              return this.vel;
            }
            var delta = -1e-3;
            var v1 = this.getValueAtTime(frameNum);
            var v2 = this.getValueAtTime(frameNum + delta);
            var velocity2;
            if (v1.length) {
              velocity2 = createTypedArray("float32", v1.length);
              var i2;
              for (i2 = 0; i2 < v1.length; i2 += 1) {
                velocity2[i2] = (v2[i2] - v1[i2]) / delta;
              }
            } else {
              velocity2 = (v2 - v1) / delta;
            }
            return velocity2;
          }
          function getStaticValueAtTime() {
            return this.pv;
          }
          function setGroupProperty(propertyGroup) {
            this.propertyGroup = propertyGroup;
          }
          return {
            searchExpressions,
            getSpeedAtTime,
            getVelocityAtTime,
            getValueAtTime,
            getStaticValueAtTime,
            setGroupProperty
          };
        }();
        function addPropertyDecorator() {
          function loopOut2(type, duration, durationFlag) {
            if (!this.k || !this.keyframes) {
              return this.pv;
            }
            type = type ? type.toLowerCase() : "";
            var currentFrame = this.comp.renderedFrame;
            var keyframes = this.keyframes;
            var lastKeyFrame = keyframes[keyframes.length - 1].t;
            if (currentFrame <= lastKeyFrame) {
              return this.pv;
            }
            var cycleDuration;
            var firstKeyFrame;
            if (!durationFlag) {
              if (!duration || duration > keyframes.length - 1) {
                duration = keyframes.length - 1;
              }
              firstKeyFrame = keyframes[keyframes.length - 1 - duration].t;
              cycleDuration = lastKeyFrame - firstKeyFrame;
            } else {
              if (!duration) {
                cycleDuration = Math.max(0, lastKeyFrame - this.elem.data.ip);
              } else {
                cycleDuration = Math.abs(lastKeyFrame - this.elem.comp.globalData.frameRate * duration);
              }
              firstKeyFrame = lastKeyFrame - cycleDuration;
            }
            var i2;
            var len;
            var ret;
            if (type === "pingpong") {
              var iterations = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);
              if (iterations % 2 !== 0) {
                return this.getValueAtTime((cycleDuration - (currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
              }
            } else if (type === "offset") {
              var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
              var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
              var current2 = this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
              var repeats = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);
              if (this.pv.length) {
                ret = new Array(initV.length);
                len = ret.length;
                for (i2 = 0; i2 < len; i2 += 1) {
                  ret[i2] = (endV[i2] - initV[i2]) * repeats + current2[i2];
                }
                return ret;
              }
              return (endV - initV) * repeats + current2;
            } else if (type === "continue") {
              var lastValue = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
              var nextLastValue = this.getValueAtTime((lastKeyFrame - 1e-3) / this.comp.globalData.frameRate, 0);
              if (this.pv.length) {
                ret = new Array(lastValue.length);
                len = ret.length;
                for (i2 = 0; i2 < len; i2 += 1) {
                  ret[i2] = lastValue[i2] + (lastValue[i2] - nextLastValue[i2]) * ((currentFrame - lastKeyFrame) / this.comp.globalData.frameRate) / 5e-4;
                }
                return ret;
              }
              return lastValue + (lastValue - nextLastValue) * ((currentFrame - lastKeyFrame) / 1e-3);
            }
            return this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
          }
          function loopIn2(type, duration, durationFlag) {
            if (!this.k) {
              return this.pv;
            }
            type = type ? type.toLowerCase() : "";
            var currentFrame = this.comp.renderedFrame;
            var keyframes = this.keyframes;
            var firstKeyFrame = keyframes[0].t;
            if (currentFrame >= firstKeyFrame) {
              return this.pv;
            }
            var cycleDuration;
            var lastKeyFrame;
            if (!durationFlag) {
              if (!duration || duration > keyframes.length - 1) {
                duration = keyframes.length - 1;
              }
              lastKeyFrame = keyframes[duration].t;
              cycleDuration = lastKeyFrame - firstKeyFrame;
            } else {
              if (!duration) {
                cycleDuration = Math.max(0, this.elem.data.op - firstKeyFrame);
              } else {
                cycleDuration = Math.abs(this.elem.comp.globalData.frameRate * duration);
              }
              lastKeyFrame = firstKeyFrame + cycleDuration;
            }
            var i2;
            var len;
            var ret;
            if (type === "pingpong") {
              var iterations = Math.floor((firstKeyFrame - currentFrame) / cycleDuration);
              if (iterations % 2 === 0) {
                return this.getValueAtTime(((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
              }
            } else if (type === "offset") {
              var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
              var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
              var current2 = this.getValueAtTime((cycleDuration - (firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
              var repeats = Math.floor((firstKeyFrame - currentFrame) / cycleDuration) + 1;
              if (this.pv.length) {
                ret = new Array(initV.length);
                len = ret.length;
                for (i2 = 0; i2 < len; i2 += 1) {
                  ret[i2] = current2[i2] - (endV[i2] - initV[i2]) * repeats;
                }
                return ret;
              }
              return current2 - (endV - initV) * repeats;
            } else if (type === "continue") {
              var firstValue = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
              var nextFirstValue = this.getValueAtTime((firstKeyFrame + 1e-3) / this.comp.globalData.frameRate, 0);
              if (this.pv.length) {
                ret = new Array(firstValue.length);
                len = ret.length;
                for (i2 = 0; i2 < len; i2 += 1) {
                  ret[i2] = firstValue[i2] + (firstValue[i2] - nextFirstValue[i2]) * (firstKeyFrame - currentFrame) / 1e-3;
                }
                return ret;
              }
              return firstValue + (firstValue - nextFirstValue) * (firstKeyFrame - currentFrame) / 1e-3;
            }
            return this.getValueAtTime((cycleDuration - ((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame)) / this.comp.globalData.frameRate, 0);
          }
          function smooth2(width2, samples) {
            if (!this.k) {
              return this.pv;
            }
            width2 = (width2 || 0.4) * 0.5;
            samples = Math.floor(samples || 5);
            if (samples <= 1) {
              return this.pv;
            }
            var currentTime = this.comp.renderedFrame / this.comp.globalData.frameRate;
            var initFrame2 = currentTime - width2;
            var endFrame = currentTime + width2;
            var sampleFrequency = samples > 1 ? (endFrame - initFrame2) / (samples - 1) : 1;
            var i2 = 0;
            var j = 0;
            var value2;
            if (this.pv.length) {
              value2 = createTypedArray("float32", this.pv.length);
            } else {
              value2 = 0;
            }
            var sampleValue;
            while (i2 < samples) {
              sampleValue = this.getValueAtTime(initFrame2 + i2 * sampleFrequency);
              if (this.pv.length) {
                for (j = 0; j < this.pv.length; j += 1) {
                  value2[j] += sampleValue[j];
                }
              } else {
                value2 += sampleValue;
              }
              i2 += 1;
            }
            if (this.pv.length) {
              for (j = 0; j < this.pv.length; j += 1) {
                value2[j] /= samples;
              }
            } else {
              value2 /= samples;
            }
            return value2;
          }
          function getTransformValueAtTime(time2) {
            if (!this._transformCachingAtTime) {
              this._transformCachingAtTime = {
                v: new Matrix()
              };
            }
            var matrix = this._transformCachingAtTime.v;
            matrix.cloneFromProps(this.pre.props);
            if (this.appliedTransformations < 1) {
              var anchor = this.a.getValueAtTime(time2);
              matrix.translate(-anchor[0] * this.a.mult, -anchor[1] * this.a.mult, anchor[2] * this.a.mult);
            }
            if (this.appliedTransformations < 2) {
              var scale2 = this.s.getValueAtTime(time2);
              matrix.scale(scale2[0] * this.s.mult, scale2[1] * this.s.mult, scale2[2] * this.s.mult);
            }
            if (this.sk && this.appliedTransformations < 3) {
              var skew = this.sk.getValueAtTime(time2);
              var skewAxis = this.sa.getValueAtTime(time2);
              matrix.skewFromAxis(-skew * this.sk.mult, skewAxis * this.sa.mult);
            }
            if (this.r && this.appliedTransformations < 4) {
              var rotation2 = this.r.getValueAtTime(time2);
              matrix.rotate(-rotation2 * this.r.mult);
            } else if (!this.r && this.appliedTransformations < 4) {
              var rotationZ = this.rz.getValueAtTime(time2);
              var rotationY = this.ry.getValueAtTime(time2);
              var rotationX = this.rx.getValueAtTime(time2);
              var orientation = this.or.getValueAtTime(time2);
              matrix.rotateZ(-rotationZ * this.rz.mult).rotateY(rotationY * this.ry.mult).rotateX(rotationX * this.rx.mult).rotateZ(-orientation[2] * this.or.mult).rotateY(orientation[1] * this.or.mult).rotateX(orientation[0] * this.or.mult);
            }
            if (this.data.p && this.data.p.s) {
              var positionX = this.px.getValueAtTime(time2);
              var positionY = this.py.getValueAtTime(time2);
              if (this.data.p.z) {
                var positionZ = this.pz.getValueAtTime(time2);
                matrix.translate(positionX * this.px.mult, positionY * this.py.mult, -positionZ * this.pz.mult);
              } else {
                matrix.translate(positionX * this.px.mult, positionY * this.py.mult, 0);
              }
            } else {
              var position2 = this.p.getValueAtTime(time2);
              matrix.translate(position2[0] * this.p.mult, position2[1] * this.p.mult, -position2[2] * this.p.mult);
            }
            return matrix;
          }
          function getTransformStaticValueAtTime() {
            return this.v.clone(new Matrix());
          }
          var getTransformProperty = TransformPropertyFactory.getTransformProperty;
          TransformPropertyFactory.getTransformProperty = function(elem2, data2, container2) {
            var prop = getTransformProperty(elem2, data2, container2);
            if (prop.dynamicProperties.length) {
              prop.getValueAtTime = getTransformValueAtTime.bind(prop);
            } else {
              prop.getValueAtTime = getTransformStaticValueAtTime.bind(prop);
            }
            prop.setGroupProperty = expressionHelpers.setGroupProperty;
            return prop;
          };
          var propertyGetProp = PropertyFactory.getProp;
          PropertyFactory.getProp = function(elem2, data2, type, mult, container2) {
            var prop = propertyGetProp(elem2, data2, type, mult, container2);
            if (prop.kf) {
              prop.getValueAtTime = expressionHelpers.getValueAtTime.bind(prop);
            } else {
              prop.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(prop);
            }
            prop.setGroupProperty = expressionHelpers.setGroupProperty;
            prop.loopOut = loopOut2;
            prop.loopIn = loopIn2;
            prop.smooth = smooth2;
            prop.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(prop);
            prop.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(prop);
            prop.numKeys = data2.a === 1 ? data2.k.length : 0;
            prop.propertyIndex = data2.ix;
            var value2 = 0;
            if (type !== 0) {
              value2 = createTypedArray("float32", data2.a === 1 ? data2.k[0].s.length : data2.k.length);
            }
            prop._cachingAtTime = {
              lastFrame: initialDefaultFrame,
              lastIndex: 0,
              value: value2
            };
            expressionHelpers.searchExpressions(elem2, data2, prop);
            if (prop.k) {
              container2.addDynamicProperty(prop);
            }
            return prop;
          };
          function getShapeValueAtTime(frameNum) {
            if (!this._cachingAtTime) {
              this._cachingAtTime = {
                shapeValue: shapePool.clone(this.pv),
                lastIndex: 0,
                lastTime: initialDefaultFrame
              };
            }
            frameNum *= this.elem.globalData.frameRate;
            frameNum -= this.offsetTime;
            if (frameNum !== this._cachingAtTime.lastTime) {
              this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < frameNum ? this._caching.lastIndex : 0;
              this._cachingAtTime.lastTime = frameNum;
              this.interpolateShape(frameNum, this._cachingAtTime.shapeValue, this._cachingAtTime);
            }
            return this._cachingAtTime.shapeValue;
          }
          var ShapePropertyConstructorFunction = ShapePropertyFactory.getConstructorFunction();
          var KeyframedShapePropertyConstructorFunction = ShapePropertyFactory.getKeyframedConstructorFunction();
          function ShapeExpressions() {
          }
          ShapeExpressions.prototype = {
            vertices: function vertices(prop, time2) {
              if (this.k) {
                this.getValue();
              }
              var shapePath = this.v;
              if (time2 !== void 0) {
                shapePath = this.getValueAtTime(time2, 0);
              }
              var i2;
              var len = shapePath._length;
              var vertices2 = shapePath[prop];
              var points = shapePath.v;
              var arr2 = createSizedArray(len);
              for (i2 = 0; i2 < len; i2 += 1) {
                if (prop === "i" || prop === "o") {
                  arr2[i2] = [vertices2[i2][0] - points[i2][0], vertices2[i2][1] - points[i2][1]];
                } else {
                  arr2[i2] = [vertices2[i2][0], vertices2[i2][1]];
                }
              }
              return arr2;
            },
            points: function points(time2) {
              return this.vertices("v", time2);
            },
            inTangents: function inTangents(time2) {
              return this.vertices("i", time2);
            },
            outTangents: function outTangents(time2) {
              return this.vertices("o", time2);
            },
            isClosed: function isClosed() {
              return this.v.c;
            },
            pointOnPath: function pointOnPath(perc, time2) {
              var shapePath = this.v;
              if (time2 !== void 0) {
                shapePath = this.getValueAtTime(time2, 0);
              }
              if (!this._segmentsLength) {
                this._segmentsLength = bez.getSegmentsLength(shapePath);
              }
              var segmentsLength = this._segmentsLength;
              var lengths = segmentsLength.lengths;
              var lengthPos = segmentsLength.totalLength * perc;
              var i2 = 0;
              var len = lengths.length;
              var accumulatedLength = 0;
              var pt;
              while (i2 < len) {
                if (accumulatedLength + lengths[i2].addedLength > lengthPos) {
                  var initIndex = i2;
                  var endIndex = shapePath.c && i2 === len - 1 ? 0 : i2 + 1;
                  var segmentPerc = (lengthPos - accumulatedLength) / lengths[i2].addedLength;
                  pt = bez.getPointInSegment(shapePath.v[initIndex], shapePath.v[endIndex], shapePath.o[initIndex], shapePath.i[endIndex], segmentPerc, lengths[i2]);
                  break;
                } else {
                  accumulatedLength += lengths[i2].addedLength;
                }
                i2 += 1;
              }
              if (!pt) {
                pt = shapePath.c ? [shapePath.v[0][0], shapePath.v[0][1]] : [shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1]];
              }
              return pt;
            },
            vectorOnPath: function vectorOnPath(perc, time2, vectorType) {
              if (perc == 1) {
                perc = this.v.c;
              } else if (perc == 0) {
                perc = 0.999;
              }
              var pt1 = this.pointOnPath(perc, time2);
              var pt2 = this.pointOnPath(perc + 1e-3, time2);
              var xLength = pt2[0] - pt1[0];
              var yLength = pt2[1] - pt1[1];
              var magnitude = Math.sqrt(Math.pow(xLength, 2) + Math.pow(yLength, 2));
              if (magnitude === 0) {
                return [0, 0];
              }
              var unitVector = vectorType === "tangent" ? [xLength / magnitude, yLength / magnitude] : [-yLength / magnitude, xLength / magnitude];
              return unitVector;
            },
            tangentOnPath: function tangentOnPath(perc, time2) {
              return this.vectorOnPath(perc, time2, "tangent");
            },
            normalOnPath: function normalOnPath(perc, time2) {
              return this.vectorOnPath(perc, time2, "normal");
            },
            setGroupProperty: expressionHelpers.setGroupProperty,
            getValueAtTime: expressionHelpers.getStaticValueAtTime
          };
          extendPrototype([ShapeExpressions], ShapePropertyConstructorFunction);
          extendPrototype([ShapeExpressions], KeyframedShapePropertyConstructorFunction);
          KeyframedShapePropertyConstructorFunction.prototype.getValueAtTime = getShapeValueAtTime;
          KeyframedShapePropertyConstructorFunction.prototype.initiateExpression = ExpressionManager.initiateExpression;
          var propertyGetShapeProp = ShapePropertyFactory.getShapeProp;
          ShapePropertyFactory.getShapeProp = function(elem2, data2, type, arr2, trims) {
            var prop = propertyGetShapeProp(elem2, data2, type, arr2, trims);
            prop.propertyIndex = data2.ix;
            prop.lock = false;
            if (type === 3) {
              expressionHelpers.searchExpressions(elem2, data2.pt, prop);
            } else if (type === 4) {
              expressionHelpers.searchExpressions(elem2, data2.ks, prop);
            }
            if (prop.k) {
              elem2.addDynamicProperty(prop);
            }
            return prop;
          };
        }
        function initialize$1() {
          addPropertyDecorator();
        }
        function addDecorator() {
          function searchExpressions() {
            if (this.data.d.x) {
              this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this);
              this.addEffect(this.getExpressionValue.bind(this));
              return true;
            }
            return null;
          }
          TextProperty.prototype.getExpressionValue = function(currentValue, text2) {
            var newValue = this.calculateExpression(text2);
            if (currentValue.t !== newValue) {
              var newData = {};
              this.copyData(newData, currentValue);
              newData.t = newValue.toString();
              newData.__complete = false;
              return newData;
            }
            return currentValue;
          };
          TextProperty.prototype.searchProperty = function() {
            var isKeyframed = this.searchKeyframes();
            var hasExpressions = this.searchExpressions();
            this.kf = isKeyframed || hasExpressions;
            return this.kf;
          };
          TextProperty.prototype.searchExpressions = searchExpressions;
        }
        function initialize() {
          addDecorator();
        }
        function SVGComposableEffect() {
        }
        SVGComposableEffect.prototype = {
          createMergeNode: function createMergeNode(resultId, ins) {
            var feMerge = createNS("feMerge");
            feMerge.setAttribute("result", resultId);
            var feMergeNode;
            var i2;
            for (i2 = 0; i2 < ins.length; i2 += 1) {
              feMergeNode = createNS("feMergeNode");
              feMergeNode.setAttribute("in", ins[i2]);
              feMerge.appendChild(feMergeNode);
              feMerge.appendChild(feMergeNode);
            }
            return feMerge;
          }
        };
        var linearFilterValue = "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0";
        function SVGTintFilter(filter, filterManager, elem2, id2, source) {
          this.filterManager = filterManager;
          var feColorMatrix = createNS("feColorMatrix");
          feColorMatrix.setAttribute("type", "matrix");
          feColorMatrix.setAttribute("color-interpolation-filters", "linearRGB");
          feColorMatrix.setAttribute("values", linearFilterValue + " 1 0");
          this.linearFilter = feColorMatrix;
          feColorMatrix.setAttribute("result", id2 + "_tint_1");
          filter.appendChild(feColorMatrix);
          feColorMatrix = createNS("feColorMatrix");
          feColorMatrix.setAttribute("type", "matrix");
          feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
          feColorMatrix.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0");
          feColorMatrix.setAttribute("result", id2 + "_tint_2");
          filter.appendChild(feColorMatrix);
          this.matrixFilter = feColorMatrix;
          var feMerge = this.createMergeNode(id2, [source, id2 + "_tint_1", id2 + "_tint_2"]);
          filter.appendChild(feMerge);
        }
        extendPrototype([SVGComposableEffect], SVGTintFilter);
        SVGTintFilter.prototype.renderFrame = function(forceRender) {
          if (forceRender || this.filterManager._mdf) {
            var colorBlack = this.filterManager.effectElements[0].p.v;
            var colorWhite = this.filterManager.effectElements[1].p.v;
            var opacity = this.filterManager.effectElements[2].p.v / 100;
            this.linearFilter.setAttribute("values", linearFilterValue + " " + opacity + " 0");
            this.matrixFilter.setAttribute("values", colorWhite[0] - colorBlack[0] + " 0 0 0 " + colorBlack[0] + " " + (colorWhite[1] - colorBlack[1]) + " 0 0 0 " + colorBlack[1] + " " + (colorWhite[2] - colorBlack[2]) + " 0 0 0 " + colorBlack[2] + " 0 0 0 1 0");
          }
        };
        function SVGFillFilter(filter, filterManager, elem2, id2) {
          this.filterManager = filterManager;
          var feColorMatrix = createNS("feColorMatrix");
          feColorMatrix.setAttribute("type", "matrix");
          feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
          feColorMatrix.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0");
          feColorMatrix.setAttribute("result", id2);
          filter.appendChild(feColorMatrix);
          this.matrixFilter = feColorMatrix;
        }
        SVGFillFilter.prototype.renderFrame = function(forceRender) {
          if (forceRender || this.filterManager._mdf) {
            var color2 = this.filterManager.effectElements[2].p.v;
            var opacity = this.filterManager.effectElements[6].p.v;
            this.matrixFilter.setAttribute("values", "0 0 0 0 " + color2[0] + " 0 0 0 0 " + color2[1] + " 0 0 0 0 " + color2[2] + " 0 0 0 " + opacity + " 0");
          }
        };
        function SVGStrokeEffect(fil, filterManager, elem2) {
          this.initialized = false;
          this.filterManager = filterManager;
          this.elem = elem2;
          this.paths = [];
        }
        SVGStrokeEffect.prototype.initialize = function() {
          var elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
          var path2;
          var groupPath;
          var i2;
          var len;
          if (this.filterManager.effectElements[1].p.v === 1) {
            len = this.elem.maskManager.masksProperties.length;
            i2 = 0;
          } else {
            i2 = this.filterManager.effectElements[0].p.v - 1;
            len = i2 + 1;
          }
          groupPath = createNS("g");
          groupPath.setAttribute("fill", "none");
          groupPath.setAttribute("stroke-linecap", "round");
          groupPath.setAttribute("stroke-dashoffset", 1);
          for (i2; i2 < len; i2 += 1) {
            path2 = createNS("path");
            groupPath.appendChild(path2);
            this.paths.push({
              p: path2,
              m: i2
            });
          }
          if (this.filterManager.effectElements[10].p.v === 3) {
            var mask2 = createNS("mask");
            var id2 = createElementID();
            mask2.setAttribute("id", id2);
            mask2.setAttribute("mask-type", "alpha");
            mask2.appendChild(groupPath);
            this.elem.globalData.defs.appendChild(mask2);
            var g2 = createNS("g");
            g2.setAttribute("mask", "url(" + getLocationHref() + "#" + id2 + ")");
            while (elemChildren[0]) {
              g2.appendChild(elemChildren[0]);
            }
            this.elem.layerElement.appendChild(g2);
            this.masker = mask2;
            groupPath.setAttribute("stroke", "#fff");
          } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
            if (this.filterManager.effectElements[10].p.v === 2) {
              elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
              while (elemChildren.length) {
                this.elem.layerElement.removeChild(elemChildren[0]);
              }
            }
            this.elem.layerElement.appendChild(groupPath);
            this.elem.layerElement.removeAttribute("mask");
            groupPath.setAttribute("stroke", "#fff");
          }
          this.initialized = true;
          this.pathMasker = groupPath;
        };
        SVGStrokeEffect.prototype.renderFrame = function(forceRender) {
          if (!this.initialized) {
            this.initialize();
          }
          var i2;
          var len = this.paths.length;
          var mask2;
          var path2;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (this.paths[i2].m !== -1) {
              mask2 = this.elem.maskManager.viewData[this.paths[i2].m];
              path2 = this.paths[i2].p;
              if (forceRender || this.filterManager._mdf || mask2.prop._mdf) {
                path2.setAttribute("d", mask2.lastPath);
              }
              if (forceRender || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || mask2.prop._mdf) {
                var dasharrayValue;
                if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {
                  var s2 = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
                  var e2 = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
                  var l2 = path2.getTotalLength();
                  dasharrayValue = "0 0 0 " + l2 * s2 + " ";
                  var lineLength = l2 * (e2 - s2);
                  var segment = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
                  var units = Math.floor(lineLength / segment);
                  var j;
                  for (j = 0; j < units; j += 1) {
                    dasharrayValue += "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01 + " ";
                  }
                  dasharrayValue += "0 " + l2 * 10 + " 0 0";
                } else {
                  dasharrayValue = "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
                }
                path2.setAttribute("stroke-dasharray", dasharrayValue);
              }
            }
          }
          if (forceRender || this.filterManager.effectElements[4].p._mdf) {
            this.pathMasker.setAttribute("stroke-width", this.filterManager.effectElements[4].p.v * 2);
          }
          if (forceRender || this.filterManager.effectElements[6].p._mdf) {
            this.pathMasker.setAttribute("opacity", this.filterManager.effectElements[6].p.v);
          }
          if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
            if (forceRender || this.filterManager.effectElements[3].p._mdf) {
              var color2 = this.filterManager.effectElements[3].p.v;
              this.pathMasker.setAttribute("stroke", "rgb(" + bmFloor(color2[0] * 255) + "," + bmFloor(color2[1] * 255) + "," + bmFloor(color2[2] * 255) + ")");
            }
          }
        };
        function SVGTritoneFilter(filter, filterManager, elem2, id2) {
          this.filterManager = filterManager;
          var feColorMatrix = createNS("feColorMatrix");
          feColorMatrix.setAttribute("type", "matrix");
          feColorMatrix.setAttribute("color-interpolation-filters", "linearRGB");
          feColorMatrix.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0");
          filter.appendChild(feColorMatrix);
          var feComponentTransfer = createNS("feComponentTransfer");
          feComponentTransfer.setAttribute("color-interpolation-filters", "sRGB");
          feComponentTransfer.setAttribute("result", id2);
          this.matrixFilter = feComponentTransfer;
          var feFuncR = createNS("feFuncR");
          feFuncR.setAttribute("type", "table");
          feComponentTransfer.appendChild(feFuncR);
          this.feFuncR = feFuncR;
          var feFuncG = createNS("feFuncG");
          feFuncG.setAttribute("type", "table");
          feComponentTransfer.appendChild(feFuncG);
          this.feFuncG = feFuncG;
          var feFuncB = createNS("feFuncB");
          feFuncB.setAttribute("type", "table");
          feComponentTransfer.appendChild(feFuncB);
          this.feFuncB = feFuncB;
          filter.appendChild(feComponentTransfer);
        }
        SVGTritoneFilter.prototype.renderFrame = function(forceRender) {
          if (forceRender || this.filterManager._mdf) {
            var color1 = this.filterManager.effectElements[0].p.v;
            var color2 = this.filterManager.effectElements[1].p.v;
            var color3 = this.filterManager.effectElements[2].p.v;
            var tableR = color3[0] + " " + color2[0] + " " + color1[0];
            var tableG = color3[1] + " " + color2[1] + " " + color1[1];
            var tableB = color3[2] + " " + color2[2] + " " + color1[2];
            this.feFuncR.setAttribute("tableValues", tableR);
            this.feFuncG.setAttribute("tableValues", tableG);
            this.feFuncB.setAttribute("tableValues", tableB);
          }
        };
        function SVGProLevelsFilter(filter, filterManager, elem2, id2) {
          this.filterManager = filterManager;
          var effectElements = this.filterManager.effectElements;
          var feComponentTransfer = createNS("feComponentTransfer");
          if (effectElements[10].p.k || effectElements[10].p.v !== 0 || effectElements[11].p.k || effectElements[11].p.v !== 1 || effectElements[12].p.k || effectElements[12].p.v !== 1 || effectElements[13].p.k || effectElements[13].p.v !== 0 || effectElements[14].p.k || effectElements[14].p.v !== 1) {
            this.feFuncR = this.createFeFunc("feFuncR", feComponentTransfer);
          }
          if (effectElements[17].p.k || effectElements[17].p.v !== 0 || effectElements[18].p.k || effectElements[18].p.v !== 1 || effectElements[19].p.k || effectElements[19].p.v !== 1 || effectElements[20].p.k || effectElements[20].p.v !== 0 || effectElements[21].p.k || effectElements[21].p.v !== 1) {
            this.feFuncG = this.createFeFunc("feFuncG", feComponentTransfer);
          }
          if (effectElements[24].p.k || effectElements[24].p.v !== 0 || effectElements[25].p.k || effectElements[25].p.v !== 1 || effectElements[26].p.k || effectElements[26].p.v !== 1 || effectElements[27].p.k || effectElements[27].p.v !== 0 || effectElements[28].p.k || effectElements[28].p.v !== 1) {
            this.feFuncB = this.createFeFunc("feFuncB", feComponentTransfer);
          }
          if (effectElements[31].p.k || effectElements[31].p.v !== 0 || effectElements[32].p.k || effectElements[32].p.v !== 1 || effectElements[33].p.k || effectElements[33].p.v !== 1 || effectElements[34].p.k || effectElements[34].p.v !== 0 || effectElements[35].p.k || effectElements[35].p.v !== 1) {
            this.feFuncA = this.createFeFunc("feFuncA", feComponentTransfer);
          }
          if (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) {
            feComponentTransfer.setAttribute("color-interpolation-filters", "sRGB");
            filter.appendChild(feComponentTransfer);
          }
          if (effectElements[3].p.k || effectElements[3].p.v !== 0 || effectElements[4].p.k || effectElements[4].p.v !== 1 || effectElements[5].p.k || effectElements[5].p.v !== 1 || effectElements[6].p.k || effectElements[6].p.v !== 0 || effectElements[7].p.k || effectElements[7].p.v !== 1) {
            feComponentTransfer = createNS("feComponentTransfer");
            feComponentTransfer.setAttribute("color-interpolation-filters", "sRGB");
            feComponentTransfer.setAttribute("result", id2);
            filter.appendChild(feComponentTransfer);
            this.feFuncRComposed = this.createFeFunc("feFuncR", feComponentTransfer);
            this.feFuncGComposed = this.createFeFunc("feFuncG", feComponentTransfer);
            this.feFuncBComposed = this.createFeFunc("feFuncB", feComponentTransfer);
          }
        }
        SVGProLevelsFilter.prototype.createFeFunc = function(type, feComponentTransfer) {
          var feFunc = createNS(type);
          feFunc.setAttribute("type", "table");
          feComponentTransfer.appendChild(feFunc);
          return feFunc;
        };
        SVGProLevelsFilter.prototype.getTableValue = function(inputBlack, inputWhite, gamma, outputBlack, outputWhite) {
          var cnt = 0;
          var segments = 256;
          var perc;
          var min = Math.min(inputBlack, inputWhite);
          var max = Math.max(inputBlack, inputWhite);
          var table = Array.call(null, {
            length: segments
          });
          var colorValue;
          var pos = 0;
          var outputDelta = outputWhite - outputBlack;
          var inputDelta = inputWhite - inputBlack;
          while (cnt <= 256) {
            perc = cnt / 256;
            if (perc <= min) {
              colorValue = inputDelta < 0 ? outputWhite : outputBlack;
            } else if (perc >= max) {
              colorValue = inputDelta < 0 ? outputBlack : outputWhite;
            } else {
              colorValue = outputBlack + outputDelta * Math.pow((perc - inputBlack) / inputDelta, 1 / gamma);
            }
            table[pos] = colorValue;
            pos += 1;
            cnt += 256 / (segments - 1);
          }
          return table.join(" ");
        };
        SVGProLevelsFilter.prototype.renderFrame = function(forceRender) {
          if (forceRender || this.filterManager._mdf) {
            var val2;
            var effectElements = this.filterManager.effectElements;
            if (this.feFuncRComposed && (forceRender || effectElements[3].p._mdf || effectElements[4].p._mdf || effectElements[5].p._mdf || effectElements[6].p._mdf || effectElements[7].p._mdf)) {
              val2 = this.getTableValue(effectElements[3].p.v, effectElements[4].p.v, effectElements[5].p.v, effectElements[6].p.v, effectElements[7].p.v);
              this.feFuncRComposed.setAttribute("tableValues", val2);
              this.feFuncGComposed.setAttribute("tableValues", val2);
              this.feFuncBComposed.setAttribute("tableValues", val2);
            }
            if (this.feFuncR && (forceRender || effectElements[10].p._mdf || effectElements[11].p._mdf || effectElements[12].p._mdf || effectElements[13].p._mdf || effectElements[14].p._mdf)) {
              val2 = this.getTableValue(effectElements[10].p.v, effectElements[11].p.v, effectElements[12].p.v, effectElements[13].p.v, effectElements[14].p.v);
              this.feFuncR.setAttribute("tableValues", val2);
            }
            if (this.feFuncG && (forceRender || effectElements[17].p._mdf || effectElements[18].p._mdf || effectElements[19].p._mdf || effectElements[20].p._mdf || effectElements[21].p._mdf)) {
              val2 = this.getTableValue(effectElements[17].p.v, effectElements[18].p.v, effectElements[19].p.v, effectElements[20].p.v, effectElements[21].p.v);
              this.feFuncG.setAttribute("tableValues", val2);
            }
            if (this.feFuncB && (forceRender || effectElements[24].p._mdf || effectElements[25].p._mdf || effectElements[26].p._mdf || effectElements[27].p._mdf || effectElements[28].p._mdf)) {
              val2 = this.getTableValue(effectElements[24].p.v, effectElements[25].p.v, effectElements[26].p.v, effectElements[27].p.v, effectElements[28].p.v);
              this.feFuncB.setAttribute("tableValues", val2);
            }
            if (this.feFuncA && (forceRender || effectElements[31].p._mdf || effectElements[32].p._mdf || effectElements[33].p._mdf || effectElements[34].p._mdf || effectElements[35].p._mdf)) {
              val2 = this.getTableValue(effectElements[31].p.v, effectElements[32].p.v, effectElements[33].p.v, effectElements[34].p.v, effectElements[35].p.v);
              this.feFuncA.setAttribute("tableValues", val2);
            }
          }
        };
        function SVGDropShadowEffect(filter, filterManager, elem2, id2, source) {
          var globalFilterSize = filterManager.container.globalData.renderConfig.filterSize;
          var filterSize = filterManager.data.fs || globalFilterSize;
          filter.setAttribute("x", filterSize.x || globalFilterSize.x);
          filter.setAttribute("y", filterSize.y || globalFilterSize.y);
          filter.setAttribute("width", filterSize.width || globalFilterSize.width);
          filter.setAttribute("height", filterSize.height || globalFilterSize.height);
          this.filterManager = filterManager;
          var feGaussianBlur = createNS("feGaussianBlur");
          feGaussianBlur.setAttribute("in", "SourceAlpha");
          feGaussianBlur.setAttribute("result", id2 + "_drop_shadow_1");
          feGaussianBlur.setAttribute("stdDeviation", "0");
          this.feGaussianBlur = feGaussianBlur;
          filter.appendChild(feGaussianBlur);
          var feOffset = createNS("feOffset");
          feOffset.setAttribute("dx", "25");
          feOffset.setAttribute("dy", "0");
          feOffset.setAttribute("in", id2 + "_drop_shadow_1");
          feOffset.setAttribute("result", id2 + "_drop_shadow_2");
          this.feOffset = feOffset;
          filter.appendChild(feOffset);
          var feFlood = createNS("feFlood");
          feFlood.setAttribute("flood-color", "#00ff00");
          feFlood.setAttribute("flood-opacity", "1");
          feFlood.setAttribute("result", id2 + "_drop_shadow_3");
          this.feFlood = feFlood;
          filter.appendChild(feFlood);
          var feComposite = createNS("feComposite");
          feComposite.setAttribute("in", id2 + "_drop_shadow_3");
          feComposite.setAttribute("in2", id2 + "_drop_shadow_2");
          feComposite.setAttribute("operator", "in");
          feComposite.setAttribute("result", id2 + "_drop_shadow_4");
          filter.appendChild(feComposite);
          var feMerge = this.createMergeNode(id2, [id2 + "_drop_shadow_4", source]);
          filter.appendChild(feMerge);
        }
        extendPrototype([SVGComposableEffect], SVGDropShadowEffect);
        SVGDropShadowEffect.prototype.renderFrame = function(forceRender) {
          if (forceRender || this.filterManager._mdf) {
            if (forceRender || this.filterManager.effectElements[4].p._mdf) {
              this.feGaussianBlur.setAttribute("stdDeviation", this.filterManager.effectElements[4].p.v / 4);
            }
            if (forceRender || this.filterManager.effectElements[0].p._mdf) {
              var col = this.filterManager.effectElements[0].p.v;
              this.feFlood.setAttribute("flood-color", rgbToHex(Math.round(col[0] * 255), Math.round(col[1] * 255), Math.round(col[2] * 255)));
            }
            if (forceRender || this.filterManager.effectElements[1].p._mdf) {
              this.feFlood.setAttribute("flood-opacity", this.filterManager.effectElements[1].p.v / 255);
            }
            if (forceRender || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
              var distance = this.filterManager.effectElements[3].p.v;
              var angle = (this.filterManager.effectElements[2].p.v - 90) * degToRads;
              var x2 = distance * Math.cos(angle);
              var y2 = distance * Math.sin(angle);
              this.feOffset.setAttribute("dx", x2);
              this.feOffset.setAttribute("dy", y2);
            }
          }
        };
        var _svgMatteSymbols = [];
        function SVGMatte3Effect(filterElem, filterManager, elem2) {
          this.initialized = false;
          this.filterManager = filterManager;
          this.filterElem = filterElem;
          this.elem = elem2;
          elem2.matteElement = createNS("g");
          elem2.matteElement.appendChild(elem2.layerElement);
          elem2.matteElement.appendChild(elem2.transformedElement);
          elem2.baseElement = elem2.matteElement;
        }
        SVGMatte3Effect.prototype.findSymbol = function(mask2) {
          var i2 = 0;
          var len = _svgMatteSymbols.length;
          while (i2 < len) {
            if (_svgMatteSymbols[i2] === mask2) {
              return _svgMatteSymbols[i2];
            }
            i2 += 1;
          }
          return null;
        };
        SVGMatte3Effect.prototype.replaceInParent = function(mask2, symbolId) {
          var parentNode = mask2.layerElement.parentNode;
          if (!parentNode) {
            return;
          }
          var children = parentNode.children;
          var i2 = 0;
          var len = children.length;
          while (i2 < len) {
            if (children[i2] === mask2.layerElement) {
              break;
            }
            i2 += 1;
          }
          var nextChild;
          if (i2 <= len - 2) {
            nextChild = children[i2 + 1];
          }
          var useElem = createNS("use");
          useElem.setAttribute("href", "#" + symbolId);
          if (nextChild) {
            parentNode.insertBefore(useElem, nextChild);
          } else {
            parentNode.appendChild(useElem);
          }
        };
        SVGMatte3Effect.prototype.setElementAsMask = function(elem2, mask2) {
          if (!this.findSymbol(mask2)) {
            var symbolId = createElementID();
            var masker = createNS("mask");
            masker.setAttribute("id", mask2.layerId);
            masker.setAttribute("mask-type", "alpha");
            _svgMatteSymbols.push(mask2);
            var defs = elem2.globalData.defs;
            defs.appendChild(masker);
            var symbol = createNS("symbol");
            symbol.setAttribute("id", symbolId);
            this.replaceInParent(mask2, symbolId);
            symbol.appendChild(mask2.layerElement);
            defs.appendChild(symbol);
            var useElem = createNS("use");
            useElem.setAttribute("href", "#" + symbolId);
            masker.appendChild(useElem);
            mask2.data.hd = false;
            mask2.show();
          }
          elem2.setMatte(mask2.layerId);
        };
        SVGMatte3Effect.prototype.initialize = function() {
          var ind = this.filterManager.effectElements[0].p.v;
          var elements = this.elem.comp.elements;
          var i2 = 0;
          var len = elements.length;
          while (i2 < len) {
            if (elements[i2] && elements[i2].data.ind === ind) {
              this.setElementAsMask(this.elem, elements[i2]);
            }
            i2 += 1;
          }
          this.initialized = true;
        };
        SVGMatte3Effect.prototype.renderFrame = function() {
          if (!this.initialized) {
            this.initialize();
          }
        };
        function SVGGaussianBlurEffect(filter, filterManager, elem2, id2) {
          filter.setAttribute("x", "-100%");
          filter.setAttribute("y", "-100%");
          filter.setAttribute("width", "300%");
          filter.setAttribute("height", "300%");
          this.filterManager = filterManager;
          var feGaussianBlur = createNS("feGaussianBlur");
          feGaussianBlur.setAttribute("result", id2);
          filter.appendChild(feGaussianBlur);
          this.feGaussianBlur = feGaussianBlur;
        }
        SVGGaussianBlurEffect.prototype.renderFrame = function(forceRender) {
          if (forceRender || this.filterManager._mdf) {
            var kBlurrinessToSigma = 0.3;
            var sigma = this.filterManager.effectElements[0].p.v * kBlurrinessToSigma;
            var dimensions = this.filterManager.effectElements[1].p.v;
            var sigmaX = dimensions == 3 ? 0 : sigma;
            var sigmaY = dimensions == 2 ? 0 : sigma;
            this.feGaussianBlur.setAttribute("stdDeviation", sigmaX + " " + sigmaY);
            var edgeMode = this.filterManager.effectElements[2].p.v == 1 ? "wrap" : "duplicate";
            this.feGaussianBlur.setAttribute("edgeMode", edgeMode);
          }
        };
        function TransformEffect() {
        }
        TransformEffect.prototype.init = function(effectsManager) {
          this.effectsManager = effectsManager;
          this.type = effectTypes.TRANSFORM_EFFECT;
          this.matrix = new Matrix();
          this.opacity = -1;
          this._mdf = false;
          this._opMdf = false;
        };
        TransformEffect.prototype.renderFrame = function(forceFrame) {
          this._opMdf = false;
          this._mdf = false;
          if (forceFrame || this.effectsManager._mdf) {
            var effectElements = this.effectsManager.effectElements;
            var anchor = effectElements[0].p.v;
            var position2 = effectElements[1].p.v;
            var isUniformScale = effectElements[2].p.v === 1;
            var scaleHeight = effectElements[3].p.v;
            var scaleWidth = isUniformScale ? scaleHeight : effectElements[4].p.v;
            var skew = effectElements[5].p.v;
            var skewAxis = effectElements[6].p.v;
            var rotation2 = effectElements[7].p.v;
            this.matrix.reset();
            this.matrix.translate(-anchor[0], -anchor[1], anchor[2]);
            this.matrix.scale(scaleWidth * 0.01, scaleHeight * 0.01, 1);
            this.matrix.rotate(-rotation2 * degToRads);
            this.matrix.skewFromAxis(-skew * degToRads, (skewAxis + 90) * degToRads);
            this.matrix.translate(position2[0], position2[1], 0);
            this._mdf = true;
            if (this.opacity !== effectElements[8].p.v) {
              this.opacity = effectElements[8].p.v;
              this._opMdf = true;
            }
          }
        };
        function SVGTransformEffect(_, filterManager) {
          this.init(filterManager);
        }
        extendPrototype([TransformEffect], SVGTransformEffect);
        function CVTransformEffect(effectsManager) {
          this.init(effectsManager);
        }
        extendPrototype([TransformEffect], CVTransformEffect);
        registerRenderer("canvas", CanvasRenderer);
        registerRenderer("html", HybridRenderer);
        registerRenderer("svg", SVGRenderer);
        ShapeModifiers.registerModifier("tm", TrimModifier);
        ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier);
        ShapeModifiers.registerModifier("rp", RepeaterModifier);
        ShapeModifiers.registerModifier("rd", RoundCornersModifier);
        ShapeModifiers.registerModifier("zz", ZigZagModifier);
        ShapeModifiers.registerModifier("op", OffsetPathModifier);
        setExpressionsPlugin(Expressions);
        setExpressionInterfaces(getInterface);
        initialize$1();
        initialize();
        registerEffect$1(20, SVGTintFilter, true);
        registerEffect$1(21, SVGFillFilter, true);
        registerEffect$1(22, SVGStrokeEffect, false);
        registerEffect$1(23, SVGTritoneFilter, true);
        registerEffect$1(24, SVGProLevelsFilter, true);
        registerEffect$1(25, SVGDropShadowEffect, true);
        registerEffect$1(28, SVGMatte3Effect, false);
        registerEffect$1(29, SVGGaussianBlurEffect, true);
        registerEffect$1(35, SVGTransformEffect, false);
        registerEffect(35, CVTransformEffect);
        return lottie;
      });
    })(lottie$1, lottie$1.exports);
    var lottieExports = lottie$1.exports;
    const lottie = /* @__PURE__ */ getDefaultExportFromCjs(lottieExports);
    function _iterableToArrayLimit(arr2, i2) {
      var _i = null == arr2 ? null : "undefined" != typeof Symbol && arr2[Symbol.iterator] || arr2["@@iterator"];
      if (null != _i) {
        var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
        try {
          if (_x = (_i = _i.call(arr2)).next, 0 === i2)
            ;
          else
            for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i2); _n = true)
              ;
        } catch (err) {
          _d = true, _e = err;
        } finally {
          try {
            if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r))
              return;
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
    }
    function ownKeys(object, enumerableOnly) {
      var keys2 = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread2(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? ownKeys(Object(source), true).forEach(function(key2) {
          _defineProperty(target, key2, source[key2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key2) {
          Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
        });
      }
      return target;
    }
    function _defineProperty(obj, key2, value2) {
      key2 = _toPropertyKey(key2);
      if (key2 in obj) {
        Object.defineProperty(obj, key2, {
          value: value2,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key2] = value2;
      }
      return obj;
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key2, i2;
      for (i2 = 0; i2 < sourceKeys.length; i2++) {
        key2 = sourceKeys[i2];
        if (excluded.indexOf(key2) >= 0)
          continue;
        target[key2] = source[key2];
      }
      return target;
    }
    function _objectWithoutProperties(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose(source, excluded);
      var key2, i2;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
          key2 = sourceSymbolKeys[i2];
          if (excluded.indexOf(key2) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key2))
            continue;
          target[key2] = source[key2];
        }
      }
      return target;
    }
    function _slicedToArray(arr2, i2) {
      return _arrayWithHoles(arr2) || _iterableToArrayLimit(arr2, i2) || _unsupportedIterableToArray(arr2, i2) || _nonIterableRest();
    }
    function _arrayWithHoles(arr2) {
      if (Array.isArray(arr2))
        return arr2;
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr2, len) {
      if (len == null || len > arr2.length)
        len = arr2.length;
      for (var i2 = 0, arr22 = new Array(len); i2 < len; i2++)
        arr22[i2] = arr2[i2];
      return arr22;
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function _toPropertyKey(arg) {
      var key2 = _toPrimitive(arg, "string");
      return typeof key2 === "symbol" ? key2 : String(key2);
    }
    var _excluded$1 = ["animationData", "loop", "autoplay", "initialSegment", "onComplete", "onLoopComplete", "onEnterFrame", "onSegmentStart", "onConfigReady", "onDataReady", "onDataFailed", "onLoadedImages", "onDOMLoaded", "onDestroy", "lottieRef", "renderer", "name", "assetsPath", "rendererSettings"];
    var useLottie = function useLottie2(props, style) {
      var animationData = props.animationData, loop = props.loop, autoplay = props.autoplay, initialSegment = props.initialSegment, onComplete = props.onComplete, onLoopComplete = props.onLoopComplete, onEnterFrame = props.onEnterFrame, onSegmentStart = props.onSegmentStart, onConfigReady = props.onConfigReady, onDataReady = props.onDataReady, onDataFailed = props.onDataFailed, onLoadedImages = props.onLoadedImages, onDOMLoaded = props.onDOMLoaded, onDestroy = props.onDestroy;
      props.lottieRef;
      props.renderer;
      props.name;
      props.assetsPath;
      props.rendererSettings;
      var rest = _objectWithoutProperties(props, _excluded$1);
      var _useState = reactExports.useState(false), _useState2 = _slicedToArray(_useState, 2), animationLoaded = _useState2[0], setAnimationLoaded = _useState2[1];
      var animationInstanceRef = reactExports.useRef();
      var animationContainer = reactExports.useRef(null);
      var play = function play2() {
        var _a;
        (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.play();
      };
      var stop = function stop2() {
        var _a;
        (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.stop();
      };
      var pause = function pause2() {
        var _a;
        (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.pause();
      };
      var setSpeed = function setSpeed2(speed) {
        var _a;
        (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.setSpeed(speed);
      };
      var goToAndPlay = function goToAndPlay2(value2, isFrame) {
        var _a;
        (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.goToAndPlay(value2, isFrame);
      };
      var goToAndStop = function goToAndStop2(value2, isFrame) {
        var _a;
        (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.goToAndStop(value2, isFrame);
      };
      var setDirection = function setDirection2(direction) {
        var _a;
        (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.setDirection(direction);
      };
      var playSegments = function playSegments2(segments, forceFlag) {
        var _a;
        (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.playSegments(segments, forceFlag);
      };
      var setSubframe = function setSubframe2(useSubFrames) {
        var _a;
        (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.setSubframe(useSubFrames);
      };
      var getDuration = function getDuration2(inFrames) {
        var _a;
        return (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.getDuration(inFrames);
      };
      var destroy = function destroy2() {
        var _a;
        (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.destroy();
        animationInstanceRef.current = void 0;
      };
      var loadAnimation2 = function loadAnimation3() {
        var forcedConfigs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var _a;
        if (!animationContainer.current) {
          return;
        }
        (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.destroy();
        var config = _objectSpread2(_objectSpread2(_objectSpread2({}, props), forcedConfigs), {}, {
          container: animationContainer.current
        });
        animationInstanceRef.current = lottie.loadAnimation(config);
        setAnimationLoaded(!!animationInstanceRef.current);
        return function() {
          var _a2;
          (_a2 = animationInstanceRef.current) === null || _a2 === void 0 ? void 0 : _a2.destroy();
          animationInstanceRef.current = void 0;
        };
      };
      reactExports.useEffect(function() {
        var onUnmount = loadAnimation2();
        return function() {
          return onUnmount === null || onUnmount === void 0 ? void 0 : onUnmount();
        };
      }, [animationData, loop]);
      reactExports.useEffect(function() {
        if (!animationInstanceRef.current) {
          return;
        }
        animationInstanceRef.current.autoplay = !!autoplay;
      }, [autoplay]);
      reactExports.useEffect(function() {
        if (!animationInstanceRef.current) {
          return;
        }
        if (!initialSegment) {
          animationInstanceRef.current.resetSegments(true);
          return;
        }
        if (!Array.isArray(initialSegment) || !initialSegment.length) {
          return;
        }
        if (animationInstanceRef.current.currentRawFrame < initialSegment[0] || animationInstanceRef.current.currentRawFrame > initialSegment[1]) {
          animationInstanceRef.current.currentRawFrame = initialSegment[0];
        }
        animationInstanceRef.current.setSegment(initialSegment[0], initialSegment[1]);
      }, [initialSegment]);
      reactExports.useEffect(function() {
        var partialListeners = [{
          name: "complete",
          handler: onComplete
        }, {
          name: "loopComplete",
          handler: onLoopComplete
        }, {
          name: "enterFrame",
          handler: onEnterFrame
        }, {
          name: "segmentStart",
          handler: onSegmentStart
        }, {
          name: "config_ready",
          handler: onConfigReady
        }, {
          name: "data_ready",
          handler: onDataReady
        }, {
          name: "data_failed",
          handler: onDataFailed
        }, {
          name: "loaded_images",
          handler: onLoadedImages
        }, {
          name: "DOMLoaded",
          handler: onDOMLoaded
        }, {
          name: "destroy",
          handler: onDestroy
        }];
        var listeners = partialListeners.filter(function(listener) {
          return listener.handler != null;
        });
        if (!listeners.length) {
          return;
        }
        var deregisterList = listeners.map(
          /**
           * Handle the process of adding an event listener
           * @param {Listener} listener
           * @return {Function} Function that deregister the listener
           */
          function(listener) {
            var _a;
            (_a = animationInstanceRef.current) === null || _a === void 0 ? void 0 : _a.addEventListener(listener.name, listener.handler);
            return function() {
              var _a2;
              (_a2 = animationInstanceRef.current) === null || _a2 === void 0 ? void 0 : _a2.removeEventListener(listener.name, listener.handler);
            };
          }
        );
        return function() {
          deregisterList.forEach(function(deregister) {
            return deregister();
          });
        };
      }, [onComplete, onLoopComplete, onEnterFrame, onSegmentStart, onConfigReady, onDataReady, onDataFailed, onLoadedImages, onDOMLoaded, onDestroy]);
      var View = /* @__PURE__ */ React$1.createElement("div", _objectSpread2({
        style,
        ref: animationContainer
      }, rest));
      return {
        View,
        play,
        stop,
        pause,
        setSpeed,
        goToAndStop,
        goToAndPlay,
        setDirection,
        playSegments,
        setSubframe,
        getDuration,
        destroy,
        animationContainerRef: animationContainer,
        animationLoaded,
        animationItem: animationInstanceRef.current
      };
    };
    function getContainerVisibility(container2) {
      var _container$getBoundin = container2.getBoundingClientRect(), top = _container$getBoundin.top, height2 = _container$getBoundin.height;
      var current2 = window.innerHeight - top;
      var max = window.innerHeight + height2;
      return current2 / max;
    }
    function getContainerCursorPosition(container2, cursorX, cursorY) {
      var _container$getBoundin2 = container2.getBoundingClientRect(), top = _container$getBoundin2.top, left = _container$getBoundin2.left, width2 = _container$getBoundin2.width, height2 = _container$getBoundin2.height;
      var x2 = (cursorX - left) / width2;
      var y2 = (cursorY - top) / height2;
      return {
        x: x2,
        y: y2
      };
    }
    var useInitInteractivity = function useInitInteractivity2(_ref) {
      var wrapperRef = _ref.wrapperRef, animationItem = _ref.animationItem, mode = _ref.mode, actions2 = _ref.actions;
      reactExports.useEffect(function() {
        var wrapper2 = wrapperRef.current;
        if (!wrapper2 || !animationItem || !actions2.length) {
          return;
        }
        animationItem.stop();
        var scrollModeHandler = function scrollModeHandler2() {
          var assignedSegment = null;
          var scrollHandler = function scrollHandler2() {
            var currentPercent = getContainerVisibility(wrapper2);
            var action = actions2.find(function(_ref2) {
              var visibility = _ref2.visibility;
              return visibility && currentPercent >= visibility[0] && currentPercent <= visibility[1];
            });
            if (!action) {
              return;
            }
            if (action.type === "seek" && action.visibility && action.frames.length === 2) {
              var frameToGo = action.frames[0] + Math.ceil((currentPercent - action.visibility[0]) / (action.visibility[1] - action.visibility[0]) * action.frames[1]);
              //! goToAndStop must be relative to the start of the current segment
              animationItem.goToAndStop(frameToGo - animationItem.firstFrame - 1, true);
            }
            if (action.type === "loop") {
              if (assignedSegment === null) {
                animationItem.playSegments(action.frames, true);
                assignedSegment = action.frames;
              } else {
                if (assignedSegment !== action.frames) {
                  animationItem.playSegments(action.frames, true);
                  assignedSegment = action.frames;
                } else if (animationItem.isPaused) {
                  animationItem.playSegments(action.frames, true);
                  assignedSegment = action.frames;
                }
              }
            }
            if (action.type === "play" && animationItem.isPaused) {
              animationItem.resetSegments(true);
              animationItem.play();
            }
            if (action.type === "stop") {
              animationItem.goToAndStop(action.frames[0] - animationItem.firstFrame - 1, true);
            }
          };
          document.addEventListener("scroll", scrollHandler);
          return function() {
            document.removeEventListener("scroll", scrollHandler);
          };
        };
        var cursorModeHandler = function cursorModeHandler2() {
          var handleCursor = function handleCursor2(_x, _y) {
            var x2 = _x;
            var y2 = _y;
            if (x2 !== -1 && y2 !== -1) {
              var pos = getContainerCursorPosition(wrapper2, x2, y2);
              x2 = pos.x;
              y2 = pos.y;
            }
            var action = actions2.find(function(_ref3) {
              var position2 = _ref3.position;
              if (position2 && Array.isArray(position2.x) && Array.isArray(position2.y)) {
                return x2 >= position2.x[0] && x2 <= position2.x[1] && y2 >= position2.y[0] && y2 <= position2.y[1];
              }
              if (position2 && !Number.isNaN(position2.x) && !Number.isNaN(position2.y)) {
                return x2 === position2.x && y2 === position2.y;
              }
              return false;
            });
            if (!action) {
              return;
            }
            if (action.type === "seek" && action.position && Array.isArray(action.position.x) && Array.isArray(action.position.y) && action.frames.length === 2) {
              var xPercent = (x2 - action.position.x[0]) / (action.position.x[1] - action.position.x[0]);
              var yPercent = (y2 - action.position.y[0]) / (action.position.y[1] - action.position.y[0]);
              animationItem.playSegments(action.frames, true);
              animationItem.goToAndStop(Math.ceil((xPercent + yPercent) / 2 * (action.frames[1] - action.frames[0])), true);
            }
            if (action.type === "loop") {
              animationItem.playSegments(action.frames, true);
            }
            if (action.type === "play") {
              if (animationItem.isPaused) {
                animationItem.resetSegments(false);
              }
              animationItem.playSegments(action.frames);
            }
            if (action.type === "stop") {
              animationItem.goToAndStop(action.frames[0], true);
            }
          };
          var mouseMoveHandler = function mouseMoveHandler2(ev) {
            handleCursor(ev.clientX, ev.clientY);
          };
          var mouseOutHandler = function mouseOutHandler2() {
            handleCursor(-1, -1);
          };
          wrapper2.addEventListener("mousemove", mouseMoveHandler);
          wrapper2.addEventListener("mouseout", mouseOutHandler);
          return function() {
            wrapper2.removeEventListener("mousemove", mouseMoveHandler);
            wrapper2.removeEventListener("mouseout", mouseOutHandler);
          };
        };
        switch (mode) {
          case "scroll":
            return scrollModeHandler();
          case "cursor":
            return cursorModeHandler();
        }
      }, [mode, animationItem]);
    };
    var useLottieInteractivity = function useLottieInteractivity2(_ref4) {
      var actions2 = _ref4.actions, mode = _ref4.mode, lottieObj = _ref4.lottieObj;
      var animationItem = lottieObj.animationItem, View = lottieObj.View, animationContainerRef = lottieObj.animationContainerRef;
      useInitInteractivity({
        actions: actions2,
        animationItem,
        mode,
        wrapperRef: animationContainerRef
      });
      return View;
    };
    var _excluded = ["style", "interactivity"];
    var Lottie = function Lottie2(props) {
      var _a, _b, _c;
      var style = props.style, interactivity = props.interactivity, lottieProps = _objectWithoutProperties(props, _excluded);
      var _useLottie = useLottie(lottieProps, style), View = _useLottie.View, play = _useLottie.play, stop = _useLottie.stop, pause = _useLottie.pause, setSpeed = _useLottie.setSpeed, goToAndStop = _useLottie.goToAndStop, goToAndPlay = _useLottie.goToAndPlay, setDirection = _useLottie.setDirection, playSegments = _useLottie.playSegments, setSubframe = _useLottie.setSubframe, getDuration = _useLottie.getDuration, destroy = _useLottie.destroy, animationContainerRef = _useLottie.animationContainerRef, animationLoaded = _useLottie.animationLoaded, animationItem = _useLottie.animationItem;
      reactExports.useEffect(function() {
        if (props.lottieRef) {
          props.lottieRef.current = {
            play,
            stop,
            pause,
            setSpeed,
            goToAndPlay,
            goToAndStop,
            setDirection,
            playSegments,
            setSubframe,
            getDuration,
            destroy,
            animationContainerRef,
            animationLoaded,
            animationItem
          };
        }
      }, [(_a = props.lottieRef) === null || _a === void 0 ? void 0 : _a.current]);
      return useLottieInteractivity({
        lottieObj: {
          View,
          play,
          stop,
          pause,
          setSpeed,
          goToAndStop,
          goToAndPlay,
          setDirection,
          playSegments,
          setSubframe,
          getDuration,
          destroy,
          animationContainerRef,
          animationLoaded,
          animationItem
        },
        actions: (_b = interactivity === null || interactivity === void 0 ? void 0 : interactivity.actions) !== null && _b !== void 0 ? _b : [],
        mode: (_c = interactivity === null || interactivity === void 0 ? void 0 : interactivity.mode) !== null && _c !== void 0 ? _c : "scroll"
      });
    };
    const v$1 = "4.8.0";
    const meta$1 = {
      g: "LottieFiles AE 3.5.6",
      a: "",
      k: "",
      d: "",
      tc: ""
    };
    const fr$1 = 60;
    const ip$1 = 0;
    const op$1 = 120;
    const w$1 = 714;
    const h$1 = 678;
    const nm$1 = "Pre-comp 1";
    const ddd$1 = 0;
    const assets$1 = [
      {
        id: "comp_0",
        layers: [
          {
            ddd: 0,
            ind: 1,
            ty: 4,
            nm: "centro",
            sr: 1,
            ks: {
              o: {
                a: 0,
                k: 100,
                ix: 11
              },
              r: {
                a: 0,
                k: 0,
                ix: 10
              },
              p: {
                a: 1,
                k: [
                  {
                    i: {
                      x: 0.214,
                      y: 1
                    },
                    o: {
                      x: 0.462,
                      y: 0
                    },
                    t: 0,
                    s: [
                      450,
                      907,
                      0
                    ],
                    to: [
                      0,
                      0,
                      0
                    ],
                    ti: [
                      0,
                      0,
                      0
                    ]
                  },
                  {
                    t: 30,
                    s: [
                      450,
                      1513,
                      0
                    ]
                  }
                ],
                ix: 2
              },
              a: {
                a: 0,
                k: [
                  -348,
                  -169,
                  0
                ],
                ix: 1
              },
              s: {
                a: 0,
                k: [
                  100,
                  100,
                  100
                ],
                ix: 6
              }
            },
            ao: 0,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ind: 0,
                    ty: "sh",
                    ix: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [
                            0,
                            0
                          ],
                          [
                            0,
                            0
                          ]
                        ],
                        o: [
                          [
                            0,
                            0
                          ],
                          [
                            0,
                            0
                          ]
                        ],
                        v: [
                          [
                            -348,
                            -420
                          ],
                          [
                            -348,
                            -30
                          ]
                        ],
                        c: false
                      },
                      ix: 2
                    },
                    nm: "Path 1",
                    mn: "ADBE Vector Shape - Group",
                    hd: false
                  },
                  {
                    ty: "st",
                    c: {
                      a: 0,
                      k: [
                        0.854901960784,
                        0.858823529412,
                        0.882352941176,
                        1
                      ],
                      ix: 3
                    },
                    o: {
                      a: 0,
                      k: 100,
                      ix: 4
                    },
                    w: {
                      a: 0,
                      k: 77,
                      ix: 5
                    },
                    lc: 2,
                    lj: 1,
                    ml: 4,
                    bm: 0,
                    nm: "Stroke 1",
                    mn: "ADBE Vector Graphic - Stroke",
                    hd: false
                  },
                  {
                    ty: "tr",
                    p: {
                      a: 0,
                      k: [
                        -348,
                        -164
                      ],
                      ix: 2
                    },
                    a: {
                      a: 0,
                      k: [
                        -348,
                        -156
                      ],
                      ix: 1
                    },
                    s: {
                      a: 0,
                      k: [
                        100,
                        100
                      ],
                      ix: 3
                    },
                    r: {
                      a: 0,
                      k: 0,
                      ix: 6
                    },
                    o: {
                      a: 0,
                      k: 100,
                      ix: 7
                    },
                    sk: {
                      a: 0,
                      k: 0,
                      ix: 4
                    },
                    sa: {
                      a: 0,
                      k: 0,
                      ix: 5
                    },
                    nm: "Transform"
                  }
                ],
                nm: "Shape 1",
                np: 3,
                cix: 2,
                bm: 0,
                ix: 1,
                mn: "ADBE Vector Group",
                hd: false
              }
            ],
            ip: 0,
            op: 120,
            st: 0,
            bm: 0
          },
          {
            ddd: 0,
            ind: 2,
            ty: 4,
            nm: "esquerdo",
            parent: 1,
            sr: 1,
            ks: {
              o: {
                a: 0,
                k: 100,
                ix: 11
              },
              r: {
                a: 1,
                k: [
                  {
                    i: {
                      x: [
                        0.298
                      ],
                      y: [
                        1
                      ]
                    },
                    o: {
                      x: [
                        0.448
                      ],
                      y: [
                        0
                      ]
                    },
                    t: 6,
                    s: [
                      43.5
                    ]
                  },
                  {
                    t: 36,
                    s: [
                      -1
                    ]
                  }
                ],
                ix: 10
              },
              p: {
                a: 0,
                k: [
                  -348.39,
                  -36.55,
                  0
                ],
                ix: 2
              },
              a: {
                a: 0,
                k: [
                  -2,
                  84,
                  0
                ],
                ix: 1
              },
              s: {
                a: 0,
                k: [
                  100,
                  100,
                  100
                ],
                ix: 6
              }
            },
            ao: 0,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ind: 0,
                    ty: "sh",
                    ix: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [
                            0,
                            0
                          ],
                          [
                            0,
                            0
                          ]
                        ],
                        o: [
                          [
                            0,
                            0
                          ],
                          [
                            0,
                            0
                          ]
                        ],
                        v: [
                          [
                            -178,
                            -102
                          ],
                          [
                            -2,
                            84
                          ]
                        ],
                        c: false
                      },
                      ix: 2
                    },
                    nm: "Path 1",
                    mn: "ADBE Vector Shape - Group",
                    hd: false
                  },
                  {
                    ty: "st",
                    c: {
                      a: 0,
                      k: [
                        0.854901960784,
                        0.858823529412,
                        0.882352941176,
                        1
                      ],
                      ix: 3
                    },
                    o: {
                      a: 0,
                      k: 100,
                      ix: 4
                    },
                    w: {
                      a: 0,
                      k: 77,
                      ix: 5
                    },
                    lc: 2,
                    lj: 1,
                    ml: 4,
                    bm: 0,
                    nm: "Stroke 1",
                    mn: "ADBE Vector Graphic - Stroke",
                    hd: false
                  },
                  {
                    ty: "tr",
                    p: {
                      a: 0,
                      k: [
                        0,
                        0
                      ],
                      ix: 2
                    },
                    a: {
                      a: 0,
                      k: [
                        0,
                        0
                      ],
                      ix: 1
                    },
                    s: {
                      a: 0,
                      k: [
                        100,
                        100
                      ],
                      ix: 3
                    },
                    r: {
                      a: 0,
                      k: 0,
                      ix: 6
                    },
                    o: {
                      a: 0,
                      k: 100,
                      ix: 7
                    },
                    sk: {
                      a: 0,
                      k: 0,
                      ix: 4
                    },
                    sa: {
                      a: 0,
                      k: 0,
                      ix: 5
                    },
                    nm: "Transform"
                  }
                ],
                nm: "Shape 1",
                np: 3,
                cix: 2,
                bm: 0,
                ix: 1,
                mn: "ADBE Vector Group",
                hd: false
              },
              {
                ty: "tm",
                s: {
                  a: 0,
                  k: 8,
                  ix: 1
                },
                e: {
                  a: 0,
                  k: 100,
                  ix: 2
                },
                o: {
                  a: 0,
                  k: 0,
                  ix: 3
                },
                m: 1,
                ix: 2,
                nm: "Trim Paths 1",
                mn: "ADBE Vector Filter - Trim",
                hd: false
              }
            ],
            ip: 0,
            op: 120,
            st: 0,
            bm: 0
          },
          {
            ddd: 0,
            ind: 3,
            ty: 4,
            nm: "direito",
            parent: 1,
            sr: 1,
            ks: {
              o: {
                a: 0,
                k: 100,
                ix: 11
              },
              r: {
                a: 1,
                k: [
                  {
                    i: {
                      x: [
                        0.265
                      ],
                      y: [
                        1
                      ]
                    },
                    o: {
                      x: [
                        0.53
                      ],
                      y: [
                        0
                      ]
                    },
                    t: 6,
                    s: [
                      -43.5
                    ]
                  },
                  {
                    t: 36,
                    s: [
                      1
                    ]
                  }
                ],
                ix: 10
              },
              p: {
                a: 0,
                k: [
                  -348.39,
                  -36.55,
                  0
                ],
                ix: 2
              },
              a: {
                a: 0,
                k: [
                  -2,
                  84,
                  0
                ],
                ix: 1
              },
              s: {
                a: 0,
                k: [
                  -100,
                  100,
                  100
                ],
                ix: 6
              }
            },
            ao: 0,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ind: 0,
                    ty: "sh",
                    ix: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [
                            0,
                            0
                          ],
                          [
                            0,
                            0
                          ]
                        ],
                        o: [
                          [
                            0,
                            0
                          ],
                          [
                            0,
                            0
                          ]
                        ],
                        v: [
                          [
                            -178,
                            -102
                          ],
                          [
                            -2,
                            84
                          ]
                        ],
                        c: false
                      },
                      ix: 2
                    },
                    nm: "Path 1",
                    mn: "ADBE Vector Shape - Group",
                    hd: false
                  },
                  {
                    ty: "tm",
                    s: {
                      a: 0,
                      k: 8,
                      ix: 1
                    },
                    e: {
                      a: 0,
                      k: 100,
                      ix: 2
                    },
                    o: {
                      a: 0,
                      k: 0,
                      ix: 3
                    },
                    m: 1,
                    ix: 2,
                    nm: "Trim Paths 1",
                    mn: "ADBE Vector Filter - Trim",
                    hd: false
                  },
                  {
                    ty: "st",
                    c: {
                      a: 0,
                      k: [
                        0.854901960784,
                        0.858823529412,
                        0.882352941176,
                        1
                      ],
                      ix: 3
                    },
                    o: {
                      a: 0,
                      k: 100,
                      ix: 4
                    },
                    w: {
                      a: 0,
                      k: 77,
                      ix: 5
                    },
                    lc: 2,
                    lj: 1,
                    ml: 4,
                    bm: 0,
                    nm: "Stroke 1",
                    mn: "ADBE Vector Graphic - Stroke",
                    hd: false
                  },
                  {
                    ty: "tr",
                    p: {
                      a: 0,
                      k: [
                        0,
                        0
                      ],
                      ix: 2
                    },
                    a: {
                      a: 0,
                      k: [
                        0,
                        0
                      ],
                      ix: 1
                    },
                    s: {
                      a: 0,
                      k: [
                        100,
                        100
                      ],
                      ix: 3
                    },
                    r: {
                      a: 0,
                      k: 0,
                      ix: 6
                    },
                    o: {
                      a: 0,
                      k: 100,
                      ix: 7
                    },
                    sk: {
                      a: 0,
                      k: 0,
                      ix: 4
                    },
                    sa: {
                      a: 0,
                      k: 0,
                      ix: 5
                    },
                    nm: "Transform"
                  }
                ],
                nm: "Shape 1",
                np: 4,
                cix: 2,
                bm: 0,
                ix: 1,
                mn: "ADBE Vector Group",
                hd: false
              }
            ],
            ip: 0,
            op: 120,
            st: 0,
            bm: 0
          }
        ]
      },
      {
        id: "comp_1",
        layers: [
          {
            ddd: 0,
            ind: 1,
            ty: 4,
            nm: "centro",
            sr: 1,
            ks: {
              o: {
                a: 0,
                k: 100,
                ix: 11
              },
              r: {
                a: 0,
                k: 0,
                ix: 10
              },
              p: {
                a: 1,
                k: [
                  {
                    i: {
                      x: 0.569,
                      y: 1
                    },
                    o: {
                      x: 0.809,
                      y: 0
                    },
                    t: 0,
                    s: [
                      450,
                      391,
                      0
                    ],
                    to: [
                      0,
                      0,
                      0
                    ],
                    ti: [
                      0,
                      0,
                      0
                    ]
                  },
                  {
                    t: 30,
                    s: [
                      450,
                      997,
                      0
                    ]
                  }
                ],
                ix: 2
              },
              a: {
                a: 0,
                k: [
                  -348,
                  -169,
                  0
                ],
                ix: 1
              },
              s: {
                a: 0,
                k: [
                  100,
                  100,
                  100
                ],
                ix: 6
              }
            },
            ao: 0,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ind: 0,
                    ty: "sh",
                    ix: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [
                            0,
                            0
                          ],
                          [
                            0,
                            0
                          ]
                        ],
                        o: [
                          [
                            0,
                            0
                          ],
                          [
                            0,
                            0
                          ]
                        ],
                        v: [
                          [
                            -348,
                            -420
                          ],
                          [
                            -348,
                            -30
                          ]
                        ],
                        c: false
                      },
                      ix: 2
                    },
                    nm: "Path 1",
                    mn: "ADBE Vector Shape - Group",
                    hd: false
                  },
                  {
                    ty: "st",
                    c: {
                      a: 0,
                      k: [
                        0.854901960784,
                        0.858823529412,
                        0.882352941176,
                        1
                      ],
                      ix: 3
                    },
                    o: {
                      a: 0,
                      k: 100,
                      ix: 4
                    },
                    w: {
                      a: 0,
                      k: 77,
                      ix: 5
                    },
                    lc: 2,
                    lj: 1,
                    ml: 4,
                    bm: 0,
                    nm: "Stroke 1",
                    mn: "ADBE Vector Graphic - Stroke",
                    hd: false
                  },
                  {
                    ty: "tr",
                    p: {
                      a: 0,
                      k: [
                        -348,
                        -164
                      ],
                      ix: 2
                    },
                    a: {
                      a: 0,
                      k: [
                        -348,
                        -156
                      ],
                      ix: 1
                    },
                    s: {
                      a: 0,
                      k: [
                        100,
                        100
                      ],
                      ix: 3
                    },
                    r: {
                      a: 0,
                      k: 0,
                      ix: 6
                    },
                    o: {
                      a: 0,
                      k: 100,
                      ix: 7
                    },
                    sk: {
                      a: 0,
                      k: 0,
                      ix: 4
                    },
                    sa: {
                      a: 0,
                      k: 0,
                      ix: 5
                    },
                    nm: "Transform"
                  }
                ],
                nm: "Shape 1",
                np: 3,
                cix: 2,
                bm: 0,
                ix: 1,
                mn: "ADBE Vector Group",
                hd: false
              }
            ],
            ip: 0,
            op: 120,
            st: 0,
            bm: 0
          },
          {
            ddd: 0,
            ind: 2,
            ty: 4,
            nm: "esquerdo",
            parent: 1,
            sr: 1,
            ks: {
              o: {
                a: 0,
                k: 100,
                ix: 11
              },
              r: {
                a: 1,
                k: [
                  {
                    i: {
                      x: [
                        0.552
                      ],
                      y: [
                        1
                      ]
                    },
                    o: {
                      x: [
                        0.702
                      ],
                      y: [
                        0
                      ]
                    },
                    t: 0,
                    s: [
                      -1
                    ]
                  },
                  {
                    t: 30,
                    s: [
                      43.5
                    ]
                  }
                ],
                ix: 10
              },
              p: {
                a: 0,
                k: [
                  -348.39,
                  -36.55,
                  0
                ],
                ix: 2
              },
              a: {
                a: 0,
                k: [
                  -2,
                  84,
                  0
                ],
                ix: 1
              },
              s: {
                a: 0,
                k: [
                  100,
                  100,
                  100
                ],
                ix: 6
              }
            },
            ao: 0,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ind: 0,
                    ty: "sh",
                    ix: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [
                            0,
                            0
                          ],
                          [
                            0,
                            0
                          ]
                        ],
                        o: [
                          [
                            0,
                            0
                          ],
                          [
                            0,
                            0
                          ]
                        ],
                        v: [
                          [
                            -178,
                            -102
                          ],
                          [
                            -2,
                            84
                          ]
                        ],
                        c: false
                      },
                      ix: 2
                    },
                    nm: "Path 1",
                    mn: "ADBE Vector Shape - Group",
                    hd: false
                  },
                  {
                    ty: "st",
                    c: {
                      a: 0,
                      k: [
                        0.854901960784,
                        0.858823529412,
                        0.882352941176,
                        1
                      ],
                      ix: 3
                    },
                    o: {
                      a: 0,
                      k: 100,
                      ix: 4
                    },
                    w: {
                      a: 0,
                      k: 77,
                      ix: 5
                    },
                    lc: 2,
                    lj: 1,
                    ml: 4,
                    bm: 0,
                    nm: "Stroke 1",
                    mn: "ADBE Vector Graphic - Stroke",
                    hd: false
                  },
                  {
                    ty: "tr",
                    p: {
                      a: 0,
                      k: [
                        0,
                        0
                      ],
                      ix: 2
                    },
                    a: {
                      a: 0,
                      k: [
                        0,
                        0
                      ],
                      ix: 1
                    },
                    s: {
                      a: 0,
                      k: [
                        100,
                        100
                      ],
                      ix: 3
                    },
                    r: {
                      a: 0,
                      k: 0,
                      ix: 6
                    },
                    o: {
                      a: 0,
                      k: 100,
                      ix: 7
                    },
                    sk: {
                      a: 0,
                      k: 0,
                      ix: 4
                    },
                    sa: {
                      a: 0,
                      k: 0,
                      ix: 5
                    },
                    nm: "Transform"
                  }
                ],
                nm: "Shape 1",
                np: 3,
                cix: 2,
                bm: 0,
                ix: 1,
                mn: "ADBE Vector Group",
                hd: false
              },
              {
                ty: "tm",
                s: {
                  a: 0,
                  k: 8,
                  ix: 1
                },
                e: {
                  a: 0,
                  k: 100,
                  ix: 2
                },
                o: {
                  a: 0,
                  k: 0,
                  ix: 3
                },
                m: 1,
                ix: 2,
                nm: "Trim Paths 1",
                mn: "ADBE Vector Filter - Trim",
                hd: false
              }
            ],
            ip: 0,
            op: 120,
            st: 0,
            bm: 0
          },
          {
            ddd: 0,
            ind: 3,
            ty: 4,
            nm: "direito",
            parent: 1,
            sr: 1,
            ks: {
              o: {
                a: 0,
                k: 100,
                ix: 11
              },
              r: {
                a: 1,
                k: [
                  {
                    i: {
                      x: [
                        0.47
                      ],
                      y: [
                        1
                      ]
                    },
                    o: {
                      x: [
                        0.735
                      ],
                      y: [
                        0
                      ]
                    },
                    t: 0,
                    s: [
                      1
                    ]
                  },
                  {
                    t: 30,
                    s: [
                      -43.5
                    ]
                  }
                ],
                ix: 10
              },
              p: {
                a: 0,
                k: [
                  -348.39,
                  -36.55,
                  0
                ],
                ix: 2
              },
              a: {
                a: 0,
                k: [
                  -2,
                  84,
                  0
                ],
                ix: 1
              },
              s: {
                a: 0,
                k: [
                  -100,
                  100,
                  100
                ],
                ix: 6
              }
            },
            ao: 0,
            shapes: [
              {
                ty: "gr",
                it: [
                  {
                    ind: 0,
                    ty: "sh",
                    ix: 1,
                    ks: {
                      a: 0,
                      k: {
                        i: [
                          [
                            0,
                            0
                          ],
                          [
                            0,
                            0
                          ]
                        ],
                        o: [
                          [
                            0,
                            0
                          ],
                          [
                            0,
                            0
                          ]
                        ],
                        v: [
                          [
                            -178,
                            -102
                          ],
                          [
                            -2,
                            84
                          ]
                        ],
                        c: false
                      },
                      ix: 2
                    },
                    nm: "Path 1",
                    mn: "ADBE Vector Shape - Group",
                    hd: false
                  },
                  {
                    ty: "tm",
                    s: {
                      a: 0,
                      k: 8,
                      ix: 1
                    },
                    e: {
                      a: 0,
                      k: 100,
                      ix: 2
                    },
                    o: {
                      a: 0,
                      k: 0,
                      ix: 3
                    },
                    m: 1,
                    ix: 2,
                    nm: "Trim Paths 1",
                    mn: "ADBE Vector Filter - Trim",
                    hd: false
                  },
                  {
                    ty: "st",
                    c: {
                      a: 0,
                      k: [
                        0.854901960784,
                        0.858823529412,
                        0.882352941176,
                        1
                      ],
                      ix: 3
                    },
                    o: {
                      a: 0,
                      k: 100,
                      ix: 4
                    },
                    w: {
                      a: 0,
                      k: 77,
                      ix: 5
                    },
                    lc: 2,
                    lj: 1,
                    ml: 4,
                    bm: 0,
                    nm: "Stroke 1",
                    mn: "ADBE Vector Graphic - Stroke",
                    hd: false
                  },
                  {
                    ty: "tr",
                    p: {
                      a: 0,
                      k: [
                        0,
                        0
                      ],
                      ix: 2
                    },
                    a: {
                      a: 0,
                      k: [
                        0,
                        0
                      ],
                      ix: 1
                    },
                    s: {
                      a: 0,
                      k: [
                        100,
                        100
                      ],
                      ix: 3
                    },
                    r: {
                      a: 0,
                      k: 0,
                      ix: 6
                    },
                    o: {
                      a: 0,
                      k: 100,
                      ix: 7
                    },
                    sk: {
                      a: 0,
                      k: 0,
                      ix: 4
                    },
                    sa: {
                      a: 0,
                      k: 0,
                      ix: 5
                    },
                    nm: "Transform"
                  }
                ],
                nm: "Shape 1",
                np: 4,
                cix: 2,
                bm: 0,
                ix: 1,
                mn: "ADBE Vector Group",
                hd: false
              }
            ],
            ip: 0,
            op: 120,
            st: 0,
            bm: 0
          }
        ]
      }
    ];
    const layers$1 = [
      {
        ddd: 0,
        ind: 1,
        ty: 0,
        nm: "seta 2",
        refId: "comp_0",
        sr: 1,
        ks: {
          o: {
            a: 0,
            k: 100,
            ix: 11
          },
          r: {
            a: 0,
            k: 0,
            ix: 10
          },
          p: {
            a: 0,
            k: [
              357,
              -247,
              0
            ],
            ix: 2
          },
          a: {
            a: 0,
            k: [
              450,
              960,
              0
            ],
            ix: 1
          },
          s: {
            a: 0,
            k: [
              100,
              100,
              100
            ],
            ix: 6
          }
        },
        ao: 0,
        w: 900,
        h: 1920,
        ip: 30,
        op: 120,
        st: 30,
        bm: 0
      },
      {
        ddd: 0,
        ind: 2,
        ty: 0,
        nm: "seta",
        refId: "comp_1",
        sr: 1,
        ks: {
          o: {
            a: 0,
            k: 100,
            ix: 11
          },
          r: {
            a: 0,
            k: 0,
            ix: 10
          },
          p: {
            a: 0,
            k: [
              357,
              258,
              0
            ],
            ix: 2
          },
          a: {
            a: 0,
            k: [
              450,
              345,
              0
            ],
            ix: 1
          },
          s: {
            a: 0,
            k: [
              100,
              100,
              100
            ],
            ix: 6
          }
        },
        ao: 0,
        w: 900,
        h: 690,
        ip: 0,
        op: 120,
        st: 0,
        bm: 0
      },
      {
        ddd: 0,
        ind: 3,
        ty: 4,
        nm: "base Outlines",
        sr: 1,
        ks: {
          o: {
            a: 0,
            k: 100,
            ix: 11
          },
          r: {
            a: 0,
            k: 0,
            ix: 10
          },
          p: {
            a: 0,
            k: [
              357,
              548.713,
              0
            ],
            ix: 2
          },
          a: {
            a: 0,
            k: [
              357.81,
              129.934,
              0
            ],
            ix: 1
          },
          s: {
            a: 0,
            k: [
              100,
              100,
              100
            ],
            ix: 6
          }
        },
        ao: 0,
        shapes: [
          {
            ty: "gr",
            it: [
              {
                ind: 0,
                ty: "sh",
                ix: 1,
                ks: {
                  a: 0,
                  k: {
                    i: [
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        50.043
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        -21.158,
                        0
                      ],
                      [
                        0,
                        -21.447
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        -7.049,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        7.149
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        -21.158,
                        0
                      ],
                      [
                        0,
                        -21.447
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        49.368,
                        0
                      ]
                    ],
                    o: [
                      [
                        -49.369,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        -21.447
                      ],
                      [
                        21.158,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        7.145
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        7.053,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        -21.447
                      ],
                      [
                        21.158,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        50.043
                      ],
                      [
                        0,
                        0
                      ]
                    ],
                    v: [
                      [
                        -268.169,
                        129.445
                      ],
                      [
                        -357.559,
                        38.834
                      ],
                      [
                        -357.559,
                        -90.61
                      ],
                      [
                        -319.249,
                        -129.445
                      ],
                      [
                        -280.939,
                        -90.61
                      ],
                      [
                        -280.939,
                        38.834
                      ],
                      [
                        -268.169,
                        51.778
                      ],
                      [
                        268.169,
                        51.778
                      ],
                      [
                        280.939,
                        38.834
                      ],
                      [
                        280.939,
                        -90.61
                      ],
                      [
                        319.249,
                        -129.445
                      ],
                      [
                        357.559,
                        -90.61
                      ],
                      [
                        357.559,
                        38.834
                      ],
                      [
                        268.169,
                        129.445
                      ]
                    ],
                    c: true
                  },
                  ix: 2
                },
                nm: "Path 1",
                mn: "ADBE Vector Shape - Group",
                hd: false
              },
              {
                ty: "fl",
                c: {
                  a: 0,
                  k: [
                    0.865977448108,
                    0.86824388691,
                    0.890449075138,
                    1
                  ],
                  ix: 4
                },
                o: {
                  a: 0,
                  k: 100,
                  ix: 5
                },
                r: 1,
                bm: 0,
                nm: "Fill 1",
                mn: "ADBE Vector Graphic - Fill",
                hd: false
              },
              {
                ty: "tr",
                p: {
                  a: 0,
                  k: [
                    357.809,
                    129.695
                  ],
                  ix: 2
                },
                a: {
                  a: 0,
                  k: [
                    0,
                    0
                  ],
                  ix: 1
                },
                s: {
                  a: 0,
                  k: [
                    100,
                    100
                  ],
                  ix: 3
                },
                r: {
                  a: 0,
                  k: 0,
                  ix: 6
                },
                o: {
                  a: 0,
                  k: 100,
                  ix: 7
                },
                sk: {
                  a: 0,
                  k: 0,
                  ix: 4
                },
                sa: {
                  a: 0,
                  k: 0,
                  ix: 5
                },
                nm: "Transform"
              }
            ],
            nm: "Group 1",
            np: 2,
            cix: 2,
            bm: 0,
            ix: 1,
            mn: "ADBE Vector Group",
            hd: false
          }
        ],
        ip: 0,
        op: 120,
        st: 0,
        bm: 0
      }
    ];
    const markers$1 = [];
    const downloadingAnimation = {
      v: v$1,
      meta: meta$1,
      fr: fr$1,
      ip: ip$1,
      op: op$1,
      w: w$1,
      h: h$1,
      nm: nm$1,
      ddd: ddd$1,
      assets: assets$1,
      layers: layers$1,
      markers: markers$1
    };
    function DownloadIcon({ isDownloading }) {
      const lottieRef = reactExports.useRef(null);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Lottie,
        {
          lottieRef,
          animationData: downloadingAnimation,
          loop: isDownloading,
          autoplay: isDownloading,
          style: { width: 16 }
        }
      );
    }
    const routes = [
      {
        path: "/",
        nameKey: "home",
        render: () => /* @__PURE__ */ jsxRuntimeExports.jsx(HomeIcon, {})
      },
      {
        path: "/catalogue",
        nameKey: "catalogue",
        render: () => /* @__PURE__ */ jsxRuntimeExports.jsx(AppsIcon, {})
      },
      {
        path: "/downloads",
        nameKey: "downloads",
        render: (isDownloading) => /* @__PURE__ */ jsxRuntimeExports.jsx(DownloadIcon, { isDownloading })
      },
      {
        path: "/settings",
        nameKey: "settings",
        render: () => /* @__PURE__ */ jsxRuntimeExports.jsx(GearIcon, {})
      }
    ];
    var sidebar$l = createRuntimeFn({ defaultClassName: "_6m0cgi0", variantClassNames: { resizing: { true: "_6m0cgi1" } }, defaultVariants: {}, compoundVariants: [] });
    var content$4 = createRuntimeFn({ defaultClassName: "_6m0cgi2", variantClassNames: { macos: { true: "_6m0cgi3" } }, defaultVariants: {}, compoundVariants: [] });
    var handle = "_6m0cgi4";
    var menu = "_6m0cgi5";
    var menuItem = createRuntimeFn({ defaultClassName: "_6m0cgi6", variantClassNames: { active: { true: "_6m0cgi7" }, muted: { true: "_6m0cgi8" } }, defaultVariants: {}, compoundVariants: [] });
    var menuItemButton = "_6m0cgi9";
    var menuItemButtonLabel = "_6m0cgia";
    var gameIcon = "_6m0cgib";
    var sectionTitle = "_6m0cgic";
    var section = "_6m0cgid";
    var profileButton = "_4k4aej0";
    var profileButtonContent = "_4k4aej1";
    var profileAvatar$1 = "_4k4aej2";
    var profileButtonInformation = "_4k4aej3";
    var profileButtonTitle = "_4k4aej5";
    function SidebarProfile() {
      const navigate = useNavigate();
      const { t: t2 } = useTranslation("sidebar");
      const { userDetails, profileBackground: profileBackground2 } = useUserDetails();
      const { gameRunning } = useAppSelector((state) => state.gameRunning);
      const handleButtonClick = () => {
        if (userDetails === null) {
          window.electron.openAuthWindow();
          return;
        }
        navigate(`/user/${userDetails.id}`);
      };
      const profileButtonBackground = reactExports.useMemo(() => {
        if (profileBackground2)
          return profileBackground2;
        return void 0;
      }, [profileBackground2]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          type: "button",
          className: profileButton,
          style: { background: profileButtonBackground },
          onClick: handleButtonClick,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: profileButtonContent, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: profileAvatar$1, children: userDetails?.profileImageUrl ? /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                className: profileAvatar$1,
                src: userDetails.profileImageUrl,
                alt: userDetails.displayName
              }
            ) : /* @__PURE__ */ jsxRuntimeExports.jsx(PersonIcon, {}) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: profileButtonInformation, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: profileButtonTitle, children: userDetails ? userDetails.displayName : t2("sign_in") }),
              userDetails && gameRunning && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: gameRunning.title }) })
            ] }),
            userDetails && gameRunning && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                alt: gameRunning.title,
                width: 24,
                style: { borderRadius: 4 },
                src: gameRunning.iconUrl
              }
            )
          ] })
        }
      );
    }
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var Symbol$1 = root.Symbol;
    var objectProto$b = Object.prototype;
    var hasOwnProperty$8 = objectProto$b.hasOwnProperty;
    var nativeObjectToString$1 = objectProto$b.toString;
    var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
    function getRawTag(value2) {
      var isOwn = hasOwnProperty$8.call(value2, symToStringTag$1), tag = value2[symToStringTag$1];
      try {
        value2[symToStringTag$1] = void 0;
        var unmasked = true;
      } catch (e2) {
      }
      var result = nativeObjectToString$1.call(value2);
      if (unmasked) {
        if (isOwn) {
          value2[symToStringTag$1] = tag;
        } else {
          delete value2[symToStringTag$1];
        }
      }
      return result;
    }
    var objectProto$a = Object.prototype;
    var nativeObjectToString = objectProto$a.toString;
    function objectToString(value2) {
      return nativeObjectToString.call(value2);
    }
    var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
    function baseGetTag(value2) {
      if (value2 == null) {
        return value2 === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value2) ? getRawTag(value2) : objectToString(value2);
    }
    function isObjectLike(value2) {
      return value2 != null && typeof value2 == "object";
    }
    var symbolTag$1 = "[object Symbol]";
    function isSymbol(value2) {
      return typeof value2 == "symbol" || isObjectLike(value2) && baseGetTag(value2) == symbolTag$1;
    }
    function arrayMap(array, iteratee) {
      var index2 = -1, length2 = array == null ? 0 : array.length, result = Array(length2);
      while (++index2 < length2) {
        result[index2] = iteratee(array[index2], index2, array);
      }
      return result;
    }
    var isArray = Array.isArray;
    var INFINITY$1 = 1 / 0;
    var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
    function baseToString(value2) {
      if (typeof value2 == "string") {
        return value2;
      }
      if (isArray(value2)) {
        return arrayMap(value2, baseToString) + "";
      }
      if (isSymbol(value2)) {
        return symbolToString ? symbolToString.call(value2) : "";
      }
      var result = value2 + "";
      return result == "0" && 1 / value2 == -INFINITY$1 ? "-0" : result;
    }
    function isObject(value2) {
      var type = typeof value2;
      return value2 != null && (type == "object" || type == "function");
    }
    function identity(value2) {
      return value2;
    }
    var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
    function isFunction(value2) {
      if (!isObject(value2)) {
        return false;
      }
      var tag = baseGetTag(value2);
      return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    var funcProto$1 = Function.prototype;
    var funcToString$1 = funcProto$1.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString$1.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype, objectProto$9 = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty$7).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value2) {
      if (!isObject(value2) || isMasked(value2)) {
        return false;
      }
      var pattern = isFunction(value2) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value2));
    }
    function getValue(object, key2) {
      return object == null ? void 0 : object[key2];
    }
    function getNative(object, key2) {
      var value2 = getValue(object, key2);
      return baseIsNative(value2) ? value2 : void 0;
    }
    var WeakMap$1 = getNative(root, "WeakMap");
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    function constant(value2) {
      return function() {
        return value2;
      };
    }
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e2) {
      }
    }();
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    var setToString = shortOut(baseSetToString);
    var MAX_SAFE_INTEGER$1 = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value2, length2) {
      var type = typeof value2;
      length2 = length2 == null ? MAX_SAFE_INTEGER$1 : length2;
      return !!length2 && (type == "number" || type != "symbol" && reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length2);
    }
    function eq(value2, other) {
      return value2 === other || value2 !== value2 && other !== other;
    }
    var nativeMax = Math.max;
    function overRest(func, start, transform2) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index2 = -1, length2 = nativeMax(args.length - start, 0), array = Array(length2);
        while (++index2 < length2) {
          array[index2] = args[start + index2];
        }
        index2 = -1;
        var otherArgs = Array(start + 1);
        while (++index2 < start) {
          otherArgs[index2] = args[index2];
        }
        otherArgs[start] = transform2(array);
        return apply(func, this, otherArgs);
      };
    }
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value2) {
      return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER;
    }
    function isArrayLike(value2) {
      return value2 != null && isLength(value2.length) && !isFunction(value2);
    }
    function isIterateeCall(value2, index2, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index2;
      if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
        return eq(object[index2], value2);
      }
      return false;
    }
    var objectProto$8 = Object.prototype;
    function isPrototype(value2) {
      var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$8;
      return value2 === proto;
    }
    function baseTimes(n2, iteratee) {
      var index2 = -1, result = Array(n2);
      while (++index2 < n2) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    var argsTag$2 = "[object Arguments]";
    function baseIsArguments(value2) {
      return isObjectLike(value2) && baseGetTag(value2) == argsTag$2;
    }
    var objectProto$7 = Object.prototype;
    var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
    var propertyIsEnumerable$1 = objectProto$7.propertyIsEnumerable;
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value2) {
      return isObjectLike(value2) && hasOwnProperty$6.call(value2, "callee") && !propertyIsEnumerable$1.call(value2, "callee");
    };
    function stubFalse() {
      return false;
    }
    var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
    var Buffer = moduleExports$1 ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", weakMapTag$1 = "[object WeakMap]";
    var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag$1] = false;
    function baseIsTypedArray(value2) {
      return isObjectLike(value2) && isLength(value2.length) && !!typedArrayTags[baseGetTag(value2)];
    }
    function baseUnary(func) {
      return function(value2) {
        return func(value2);
      };
    }
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e2) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    var objectProto$6 = Object.prototype;
    var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
    function arrayLikeKeys(value2, inherited) {
      var isArr = isArray(value2), isArg = !isArr && isArguments(value2), isBuff = !isArr && !isArg && isBuffer(value2), isType = !isArr && !isArg && !isBuff && isTypedArray(value2), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value2.length, String) : [], length2 = result.length;
      for (var key2 in value2) {
        if (hasOwnProperty$5.call(value2, key2) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key2 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key2 == "offset" || key2 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || // Skip index properties.
        isIndex(key2, length2)))) {
          result.push(key2);
        }
      }
      return result;
    }
    function overArg(func, transform2) {
      return function(arg) {
        return func(transform2(arg));
      };
    }
    var nativeKeys = overArg(Object.keys, Object);
    var objectProto$5 = Object.prototype;
    var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key2 in Object(object)) {
        if (hasOwnProperty$4.call(object, key2) && key2 != "constructor") {
          result.push(key2);
        }
      }
      return result;
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
    function isKey(value2, object) {
      if (isArray(value2)) {
        return false;
      }
      var type = typeof value2;
      if (type == "number" || type == "symbol" || type == "boolean" || value2 == null || isSymbol(value2)) {
        return true;
      }
      return reIsPlainProp.test(value2) || !reIsDeepProp.test(value2) || object != null && value2 in Object(object);
    }
    var nativeCreate = getNative(Object, "create");
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key2) {
      var result = this.has(key2) && delete this.__data__[key2];
      this.size -= result ? 1 : 0;
      return result;
    }
    var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
    var objectProto$4 = Object.prototype;
    var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
    function hashGet(key2) {
      var data2 = this.__data__;
      if (nativeCreate) {
        var result = data2[key2];
        return result === HASH_UNDEFINED$2 ? void 0 : result;
      }
      return hasOwnProperty$3.call(data2, key2) ? data2[key2] : void 0;
    }
    var objectProto$3 = Object.prototype;
    var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
    function hashHas(key2) {
      var data2 = this.__data__;
      return nativeCreate ? data2[key2] !== void 0 : hasOwnProperty$2.call(data2, key2);
    }
    var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
    function hashSet(key2, value2) {
      var data2 = this.__data__;
      this.size += this.has(key2) ? 0 : 1;
      data2[key2] = nativeCreate && value2 === void 0 ? HASH_UNDEFINED$1 : value2;
      return this;
    }
    function Hash(entries) {
      var index2 = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length2) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function assocIndexOf(array, key2) {
      var length2 = array.length;
      while (length2--) {
        if (eq(array[length2][0], key2)) {
          return length2;
        }
      }
      return -1;
    }
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key2) {
      var data2 = this.__data__, index2 = assocIndexOf(data2, key2);
      if (index2 < 0) {
        return false;
      }
      var lastIndex = data2.length - 1;
      if (index2 == lastIndex) {
        data2.pop();
      } else {
        splice.call(data2, index2, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key2) {
      var data2 = this.__data__, index2 = assocIndexOf(data2, key2);
      return index2 < 0 ? void 0 : data2[index2][1];
    }
    function listCacheHas(key2) {
      return assocIndexOf(this.__data__, key2) > -1;
    }
    function listCacheSet(key2, value2) {
      var data2 = this.__data__, index2 = assocIndexOf(data2, key2);
      if (index2 < 0) {
        ++this.size;
        data2.push([key2, value2]);
      } else {
        data2[index2][1] = value2;
      }
      return this;
    }
    function ListCache(entries) {
      var index2 = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length2) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    var Map$1 = getNative(root, "Map");
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map$1 || ListCache)(),
        "string": new Hash()
      };
    }
    function isKeyable(value2) {
      var type = typeof value2;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value2 !== "__proto__" : value2 === null;
    }
    function getMapData(map, key2) {
      var data2 = map.__data__;
      return isKeyable(key2) ? data2[typeof key2 == "string" ? "string" : "hash"] : data2.map;
    }
    function mapCacheDelete(key2) {
      var result = getMapData(this, key2)["delete"](key2);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key2) {
      return getMapData(this, key2).get(key2);
    }
    function mapCacheHas(key2) {
      return getMapData(this, key2).has(key2);
    }
    function mapCacheSet(key2, value2) {
      var data2 = getMapData(this, key2), size = data2.size;
      data2.set(key2, value2);
      this.size += data2.size == size ? 0 : 1;
      return this;
    }
    function MapCache(entries) {
      var index2 = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length2) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key2 = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key2)) {
          return cache.get(key2);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key2, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key2) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key2;
      });
      var cache = result.cache;
      return result;
    }
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46) {
        result.push("");
      }
      string.replace(rePropName, function(match2, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match2);
      });
      return result;
    });
    function toString(value2) {
      return value2 == null ? "" : baseToString(value2);
    }
    function castPath(value2, object) {
      if (isArray(value2)) {
        return value2;
      }
      return isKey(value2, object) ? [value2] : stringToPath(toString(value2));
    }
    var INFINITY = 1 / 0;
    function toKey(value2) {
      if (typeof value2 == "string" || isSymbol(value2)) {
        return value2;
      }
      var result = value2 + "";
      return result == "0" && 1 / value2 == -INFINITY ? "-0" : result;
    }
    function baseGet(object, path2) {
      path2 = castPath(path2, object);
      var index2 = 0, length2 = path2.length;
      while (object != null && index2 < length2) {
        object = object[toKey(path2[index2++])];
      }
      return index2 && index2 == length2 ? object : void 0;
    }
    function get(object, path2, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path2);
      return result === void 0 ? defaultValue : result;
    }
    function arrayPush(array, values) {
      var index2 = -1, length2 = values.length, offset = array.length;
      while (++index2 < length2) {
        array[offset + index2] = values[index2];
      }
      return array;
    }
    var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
    function isFlattenable(value2) {
      return isArray(value2) || isArguments(value2) || !!(spreadableSymbol && value2 && value2[spreadableSymbol]);
    }
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index2 = -1, length2 = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index2 < length2) {
        var value2 = array[index2];
        if (predicate(value2)) {
          {
            arrayPush(result, value2);
          }
        } else {
          result[result.length] = value2;
        }
      }
      return result;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key2) {
      var data2 = this.__data__, result = data2["delete"](key2);
      this.size = data2.size;
      return result;
    }
    function stackGet(key2) {
      return this.__data__.get(key2);
    }
    function stackHas(key2) {
      return this.__data__.has(key2);
    }
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key2, value2) {
      var data2 = this.__data__;
      if (data2 instanceof ListCache) {
        var pairs = data2.__data__;
        if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key2, value2]);
          this.size = ++data2.size;
          return this;
        }
        data2 = this.__data__ = new MapCache(pairs);
      }
      data2.set(key2, value2);
      this.size = data2.size;
      return this;
    }
    function Stack(entries) {
      var data2 = this.__data__ = new ListCache(entries);
      this.size = data2.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayFilter(array, predicate) {
      var index2 = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index2 < length2) {
        var value2 = array[index2];
        if (predicate(value2, index2, array)) {
          result[resIndex++] = value2;
        }
      }
      return result;
    }
    function stubArray() {
      return [];
    }
    var objectProto$2 = Object.prototype;
    var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    var DataView = getNative(root, "DataView");
    var Promise$1 = getNative(root, "Promise");
    var Set$1 = getNative(root, "Set");
    var mapTag$1 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$1 = "[object Set]", weakMapTag = "[object WeakMap]";
    var dataViewTag$1 = "[object DataView]";
    var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$1 || Map$1 && getTag(new Map$1()) != mapTag$1 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$1 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag) {
      getTag = function(value2) {
        var result = baseGetTag(value2), Ctor = result == objectTag$1 ? value2.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag$1;
            case mapCtorString:
              return mapTag$1;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag$1;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    var Uint8Array$1 = root.Uint8Array;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value2) {
      this.__data__.set(value2, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value2) {
      return this.__data__.has(value2);
    }
    function SetCache(values) {
      var index2 = -1, length2 = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index2 < length2) {
        this.add(values[index2]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function arraySome(array, predicate) {
      var index2 = -1, length2 = array == null ? 0 : array.length;
      while (++index2 < length2) {
        if (predicate(array[index2], index2, array)) {
          return true;
        }
      }
      return false;
    }
    function cacheHas(cache, key2) {
      return cache.has(key2);
    }
    var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index2 < arrLength) {
        var arrValue = array[index2], othValue = other[index2];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function mapToArray(map) {
      var index2 = -1, result = Array(map.size);
      map.forEach(function(value2, key2) {
        result[++index2] = [key2, value2];
      });
      return result;
    }
    function setToArray(set2) {
      var index2 = -1, result = Array(set2.size);
      set2.forEach(function(value2) {
        result[++index2] = value2;
      });
      return result;
    }
    var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
    var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
    var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert2 = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
          convert2 || (convert2 = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG$2;
          stack.set(object, other);
          var result = equalArrays(convert2(object), convert2(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    var COMPARE_PARTIAL_FLAG$3 = 1;
    var objectProto$1 = Object.prototype;
    var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index2 = objLength;
      while (index2--) {
        var key2 = objProps[index2];
        if (!(isPartial ? key2 in other : hasOwnProperty$1.call(other, key2))) {
          return false;
        }
      }
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index2 < objLength) {
        key2 = objProps[index2];
        var objValue = object[key2], othValue = other[key2];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key2, other, object, stack) : customizer(objValue, othValue, key2, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key2 == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    var COMPARE_PARTIAL_FLAG$2 = 1;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    function baseIsEqual(value2, other, bitmask, customizer, stack) {
      if (value2 === other) {
        return true;
      }
      if (value2 == null || other == null || !isObjectLike(value2) && !isObjectLike(other)) {
        return value2 !== value2 && other !== other;
      }
      return baseIsEqualDeep(value2, other, bitmask, customizer, baseIsEqual, stack);
    }
    var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
    function baseIsMatch(object, source, matchData, customizer) {
      var index2 = matchData.length, length2 = index2;
      if (object == null) {
        return !length2;
      }
      object = Object(object);
      while (index2--) {
        var data2 = matchData[index2];
        if (data2[2] ? data2[1] !== object[data2[0]] : !(data2[0] in object)) {
          return false;
        }
      }
      while (++index2 < length2) {
        data2 = matchData[index2];
        var key2 = data2[0], objValue = object[key2], srcValue = data2[1];
        if (data2[2]) {
          if (objValue === void 0 && !(key2 in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          var result;
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    function isStrictComparable(value2) {
      return value2 === value2 && !isObject(value2);
    }
    function getMatchData(object) {
      var result = keys(object), length2 = result.length;
      while (length2--) {
        var key2 = result[length2], value2 = object[key2];
        result[length2] = [key2, value2, isStrictComparable(value2)];
      }
      return result;
    }
    function matchesStrictComparable(key2, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key2] === srcValue && (srcValue !== void 0 || key2 in Object(object));
      };
    }
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    function baseHasIn(object, key2) {
      return object != null && key2 in Object(object);
    }
    function hasPath(object, path2, hasFunc) {
      path2 = castPath(path2, object);
      var index2 = -1, length2 = path2.length, result = false;
      while (++index2 < length2) {
        var key2 = toKey(path2[index2]);
        if (!(result = object != null && hasFunc(object, key2))) {
          break;
        }
        object = object[key2];
      }
      if (result || ++index2 != length2) {
        return result;
      }
      length2 = object == null ? 0 : object.length;
      return !!length2 && isLength(length2) && isIndex(key2, length2) && (isArray(object) || isArguments(object));
    }
    function hasIn(object, path2) {
      return object != null && hasPath(object, path2, baseHasIn);
    }
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    function baseMatchesProperty(path2, srcValue) {
      if (isKey(path2) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path2), srcValue);
      }
      return function(object) {
        var objValue = get(object, path2);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }
    function baseProperty(key2) {
      return function(object) {
        return object == null ? void 0 : object[key2];
      };
    }
    function basePropertyDeep(path2) {
      return function(object) {
        return baseGet(object, path2);
      };
    }
    function property(path2) {
      return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
    }
    function baseIteratee(value2) {
      if (typeof value2 == "function") {
        return value2;
      }
      if (value2 == null) {
        return identity;
      }
      if (typeof value2 == "object") {
        return isArray(value2) ? baseMatchesProperty(value2[0], value2[1]) : baseMatches(value2);
      }
      return property(value2);
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index2 = -1, iterable = Object(object), props = keysFunc(object), length2 = props.length;
        while (length2--) {
          var key2 = props[++index2];
          if (iteratee(iterable[key2], key2, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    var baseFor = createBaseFor();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length2 = collection.length, index2 = -1, iterable = Object(collection);
        while (++index2 < length2) {
          if (iteratee(iterable[index2], index2, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    var baseEach = createBaseEach(baseForOwn);
    function baseMap(collection, iteratee) {
      var index2 = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
      baseEach(collection, function(value2, key2, collection2) {
        result[++index2] = iteratee(value2, key2, collection2);
      });
      return result;
    }
    function baseSortBy(array, comparer) {
      var length2 = array.length;
      array.sort(comparer);
      while (length2--) {
        array[length2] = array[length2].value;
      }
      return array;
    }
    function compareAscending(value2, other) {
      if (value2 !== other) {
        var valIsDefined = value2 !== void 0, valIsNull = value2 === null, valIsReflexive = value2 === value2, valIsSymbol = isSymbol(value2);
        var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
        if (!othIsNull && !othIsSymbol && !valIsSymbol && value2 > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
          return 1;
        }
        if (!valIsNull && !valIsSymbol && !othIsSymbol && value2 < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }
    function compareMultiple(object, other, orders) {
      var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length2 = objCriteria.length, ordersLength = orders.length;
      while (++index2 < length2) {
        var result = compareAscending(objCriteria[index2], othCriteria[index2]);
        if (result) {
          if (index2 >= ordersLength) {
            return result;
          }
          var order = orders[index2];
          return result * (order == "desc" ? -1 : 1);
        }
      }
      return object.index - other.index;
    }
    function baseOrderBy(collection, iteratees, orders) {
      if (iteratees.length) {
        iteratees = arrayMap(iteratees, function(iteratee) {
          if (isArray(iteratee)) {
            return function(value2) {
              return baseGet(value2, iteratee.length === 1 ? iteratee[0] : iteratee);
            };
          }
          return iteratee;
        });
      } else {
        iteratees = [identity];
      }
      var index2 = -1;
      iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
      var result = baseMap(collection, function(value2, key2, collection2) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value2);
        });
        return { "criteria": criteria, "index": ++index2, "value": value2 };
      });
      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }
    function orderBy(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      orders = orders;
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseOrderBy(collection, iteratees, orders);
    }
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length2 = iteratees.length;
      if (length2 > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length2 > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees), []);
    });
    const SIDEBAR_MIN_WIDTH = 200;
    const SIDEBAR_INITIAL_WIDTH = 250;
    const SIDEBAR_MAX_WIDTH = 450;
    const initialSidebarWidth = window.localStorage.getItem("sidebarWidth");
    function Sidebar$1() {
      const { t: t2 } = useTranslation("sidebar");
      const { library, updateLibrary } = useLibrary();
      const navigate = useNavigate();
      const [filteredLibrary, setFilteredLibrary] = reactExports.useState([]);
      const [isResizing, setIsResizing] = reactExports.useState(false);
      const [sidebarWidth, setSidebarWidth] = reactExports.useState(
        initialSidebarWidth ? Number(initialSidebarWidth) : SIDEBAR_INITIAL_WIDTH
      );
      const location = useLocation();
      const sortedLibrary = reactExports.useMemo(() => {
        return sortBy(library, (game) => game.title);
      }, [library]);
      const { lastPacket, progress: progress2 } = useDownload();
      const { showWarningToast } = useToast();
      reactExports.useEffect(() => {
        updateLibrary();
      }, [lastPacket?.game.id, updateLibrary]);
      const isDownloading = sortedLibrary.some(
        (game) => game.status === "active" && game.progress !== 1
      );
      const sidebarRef = reactExports.useRef(null);
      const cursorPos = reactExports.useRef({ x: 0 });
      const sidebarInitialWidth = reactExports.useRef(0);
      const handleMouseDown = (event) => {
        setIsResizing(true);
        cursorPos.current.x = event.screenX;
        sidebarInitialWidth.current = sidebarRef.current?.clientWidth || SIDEBAR_INITIAL_WIDTH;
      };
      const handleFilter = (event) => {
        setFilteredLibrary(
          sortedLibrary.filter(
            (game) => game.title.toLowerCase().includes(event.target.value.toLocaleLowerCase())
          )
        );
      };
      reactExports.useEffect(() => {
        setFilteredLibrary(sortedLibrary);
      }, [sortedLibrary]);
      reactExports.useEffect(() => {
        window.onmousemove = (event) => {
          if (isResizing) {
            const cursorXDelta = event.screenX - cursorPos.current.x;
            const newWidth = Math.max(
              SIDEBAR_MIN_WIDTH,
              Math.min(
                sidebarInitialWidth.current + cursorXDelta,
                SIDEBAR_MAX_WIDTH
              )
            );
            setSidebarWidth(newWidth);
            window.localStorage.setItem("sidebarWidth", String(newWidth));
          }
        };
        window.onmouseup = () => {
          if (isResizing)
            setIsResizing(false);
        };
        return () => {
          window.onmouseup = null;
          window.onmousemove = null;
        };
      }, [isResizing]);
      const getGameTitle = (game) => {
        if (lastPacket?.game.id === game.id) {
          return t2("downloading", {
            title: game.title,
            percentage: progress2
          });
        }
        if (game.downloadQueue !== null) {
          return t2("queued", { title: game.title });
        }
        if (game.status === "paused")
          return t2("paused", { title: game.title });
        return game.title;
      };
      const handleSidebarItemClick = (path2) => {
        if (path2 !== location.pathname) {
          navigate(path2);
        }
      };
      const handleSidebarGameClick = (event, game) => {
        const path2 = buildGameDetailsPath(game);
        if (path2 !== location.pathname) {
          navigate(path2);
        }
        if (event.detail == 2) {
          if (game.executablePath) {
            window.electron.openGame(game.id, game.executablePath);
          } else {
            showWarningToast(t2("game_has_no_executable"));
          }
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "aside",
        {
          ref: sidebarRef,
          className: sidebar$l({ resizing: isResizing }),
          style: {
            width: sidebarWidth,
            minWidth: sidebarWidth,
            maxWidth: sidebarWidth
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(SidebarProfile, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                className: content$4({
                  macos: window.electron.platform === "darwin"
                }),
                children: [
                  window.electron.platform === "darwin" && /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: "NoFinder" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: section, children: /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: menu, children: routes.map(({ nameKey, path: path2, render }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "li",
                    {
                      className: menuItem({
                        active: location.pathname === path2
                      }),
                      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                        "button",
                        {
                          type: "button",
                          className: menuItemButton,
                          onClick: () => handleSidebarItemClick(path2),
                          children: [
                            render(isDownloading),
                            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2(nameKey) })
                          ]
                        }
                      )
                    },
                    nameKey
                  )) }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: section, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("small", { className: sectionTitle, children: t2("my_library") }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      TextField,
                      {
                        placeholder: t2("filter"),
                        onChange: handleFilter,
                        theme: "dark"
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: menu, children: filteredLibrary.map((game) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "li",
                      {
                        className: menuItem({
                          active: location.pathname === `/game/${game.shop}/${game.objectID}`,
                          muted: game.status === "removed"
                        }),
                        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                          "button",
                          {
                            type: "button",
                            className: menuItemButton,
                            onClick: (event) => handleSidebarGameClick(event, game),
                            children: [
                              game.iconUrl ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                                "img",
                                {
                                  className: gameIcon,
                                  src: game.iconUrl,
                                  alt: game.title
                                }
                              ) : /* @__PURE__ */ jsxRuntimeExports.jsx(SvgSteamLogo, { className: gameIcon }),
                              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: menuItemButtonLabel, children: getGameTitle(game) })
                            ]
                          }
                        )
                      },
                      game.id
                    )) })
                  ] })
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                className: handle,
                onMouseDown: handleMouseDown
              }
            )
          ]
        }
      ) });
    }
    var textFieldContainer = "e3mva90";
    var textField = createRuntimeFn({ defaultClassName: "e3mva91", variantClassNames: { focused: { true: "e3mva92", false: "e3mva93" }, theme: { primary: "e3mva94", dark: "e3mva95" }, state: { error: "e3mva96" } }, defaultVariants: {}, compoundVariants: [] });
    var textFieldInput = createRuntimeFn({ defaultClassName: "e3mva97", variantClassNames: { readOnly: { true: "e3mva98" } }, defaultVariants: {}, compoundVariants: [] });
    var togglePasswordButton = "e3mva99";
    var textFieldWrapper = "e3mva9a";
    function TextField({
      theme = "primary",
      label: label2,
      hint,
      textFieldProps,
      containerProps,
      rightContent = null,
      state,
      ...props
    }) {
      const id2 = reactExports.useId();
      const [isPasswordVisible, setIsPasswordVisible] = reactExports.useState(false);
      const [isFocused, setIsFocused] = reactExports.useState(false);
      const { t: t2 } = useTranslation("forms");
      const showPasswordToggleButton = props.type === "password";
      const inputType = reactExports.useMemo(() => {
        if (props.type === "password" && isPasswordVisible)
          return "text";
        return props.type ?? "text";
      }, [props.type, isPasswordVisible]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: textFieldContainer, ...containerProps, children: [
        label2 && /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: id2, children: label2 }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: textFieldWrapper, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: textField({ focused: isFocused, theme, state }),
              ...textFieldProps,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    id: id2,
                    className: textFieldInput({ readOnly: props.readOnly }),
                    onFocus: () => setIsFocused(true),
                    onBlur: () => setIsFocused(false),
                    ...props,
                    type: inputType
                  }
                ),
                showPasswordToggleButton && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    className: togglePasswordButton,
                    onClick: () => setIsPasswordVisible(!isPasswordVisible),
                    "aria-label": t2("toggle_password_visibility"),
                    children: isPasswordVisible ? /* @__PURE__ */ jsxRuntimeExports.jsx(EyeClosedIcon, { size: 16 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(EyeIcon, { size: 16 })
                  }
                )
              ]
            }
          ),
          rightContent
        ] }),
        hint && /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: hint })
      ] });
    }
    var checkboxField = "mhmb7b0";
    var checkbox = "mhmb7b1";
    var checkboxInput = "mhmb7b2";
    var checkboxLabel = "mhmb7b3";
    function CheckboxField({ label: label2, ...props }) {
      const id2 = reactExports.useId();
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: checkboxField, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: checkbox, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              id: id2,
              type: "checkbox",
              className: checkboxInput,
              ...props
            }
          ),
          props.checked && /* @__PURE__ */ jsxRuntimeExports.jsx(CheckIcon, {})
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: id2, className: checkboxLabel, children: label2 })
      ] });
    }
    var select = createRuntimeFn({ defaultClassName: "_10ks0ap0", variantClassNames: { focused: { true: "_10ks0ap1", false: "_10ks0ap2" }, theme: { primary: "_10ks0ap3", dark: "_10ks0ap4" } }, defaultVariants: {}, compoundVariants: [] });
    var option = "_10ks0ap5";
    var label = "_10ks0ap6";
    function SelectField({
      value: value2,
      label: label$1,
      options = [{ key: "-", value: value2?.toString() || "-", label: "-" }],
      theme = "primary",
      onChange
    }) {
      const [isFocused, setIsFocused] = reactExports.useState(false);
      const id2 = reactExports.useId();
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: 1 }, children: [
        label$1 && /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: id2, className: label, children: label$1 }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: select({ focused: isFocused, theme }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "select",
          {
            id: id2,
            value: value2,
            className: option,
            onFocus: () => setIsFocused(true),
            onBlur: () => setIsFocused(false),
            onChange,
            children: options.map((option2) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: option2.value, children: option2.label }, option2.key))
          }
        ) })
      ] });
    }
    var toast = createRuntimeFn({ defaultClassName: "_14foxft2", variantClassNames: { closing: { true: "_14foxft3", false: "_14foxft4" } }, defaultVariants: {}, compoundVariants: [] });
    var toastContent = "_14foxft5";
    var progress = "_14foxft6";
    var closeButton = "_14foxft7";
    var successIcon = "_14foxft8";
    var errorIcon = "_14foxft9";
    var warningIcon = "_14foxfta";
    var SPACING_UNIT = 8;
    var vars = { color: { background: "var(--_11kci3x0)", darkBackground: "var(--_11kci3x1)", muted: "var(--_11kci3x2)", body: "var(--_11kci3x3)", border: "var(--_11kci3x4)", success: "var(--_11kci3x5)", danger: "var(--_11kci3x6)", warning: "var(--_11kci3x7)" }, opacity: { disabled: "var(--_11kci3x8)", active: "var(--_11kci3x9)" }, size: { body: "var(--_11kci3xa)", small: "var(--_11kci3xb)" }, zIndex: { toast: "var(--_11kci3xc)", bottomPanel: "var(--_11kci3xd)", titleBar: "var(--_11kci3xe)", backdrop: "var(--_11kci3xf)" } };
    const INITIAL_PROGRESS = 100;
    function Toast({ visible, message: message2, type, onClose }) {
      const [isClosing, setIsClosing] = reactExports.useState(false);
      const [progress$1, setProgress] = reactExports.useState(INITIAL_PROGRESS);
      const closingAnimation = reactExports.useRef(-1);
      const progressAnimation = reactExports.useRef(-1);
      const startAnimateClosing = reactExports.useCallback(() => {
        setIsClosing(true);
        const zero = performance.now();
        closingAnimation.current = requestAnimationFrame(
          function animateClosing(time2) {
            if (time2 - zero <= 200) {
              closingAnimation.current = requestAnimationFrame(animateClosing);
            } else {
              onClose();
            }
          }
        );
      }, [onClose]);
      reactExports.useEffect(() => {
        if (visible) {
          const zero = performance.now();
          progressAnimation.current = requestAnimationFrame(
            function animateProgress(time2) {
              const elapsed = time2 - zero;
              const progress2 = Math.min(elapsed / 2500, 1);
              const currentValue = INITIAL_PROGRESS + (0 - INITIAL_PROGRESS) * progress2;
              setProgress(currentValue);
              if (progress2 < 1) {
                progressAnimation.current = requestAnimationFrame(animateProgress);
              } else {
                cancelAnimationFrame(progressAnimation.current);
                startAnimateClosing();
              }
            }
          );
          return () => {
            setProgress(INITIAL_PROGRESS);
            cancelAnimationFrame(closingAnimation.current);
            cancelAnimationFrame(progressAnimation.current);
            setIsClosing(false);
          };
        }
        return () => {
        };
      }, [startAnimateClosing, visible]);
      if (!visible)
        return null;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: toast({ closing: isClosing }), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: toastContent, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: `${SPACING_UNIT}px` }, children: [
            type === "success" && /* @__PURE__ */ jsxRuntimeExports.jsx(CheckCircleFillIcon, { className: successIcon }),
            type === "error" && /* @__PURE__ */ jsxRuntimeExports.jsx(XCircleFillIcon, { className: errorIcon }),
            type === "warning" && /* @__PURE__ */ jsxRuntimeExports.jsx(AlertIcon, { className: warningIcon }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontWeight: "bold" }, children: message2 })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              className: closeButton,
              onClick: startAnimateClosing,
              "aria-label": "Close toast",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(XIcon, {})
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("progress", { className: progress, value: progress$1, max: 100 })
      ] });
    }
    var container$3 = "_1e6ixna0";
    var content$3 = "_1e6ixna1";
    var titleBar = "_1e6ixna2";
    function App() {
      const contentRef = reactExports.useRef(null);
      const { updateLibrary, library } = useLibrary();
      const { t: t2 } = useTranslation("app");
      const { clearDownload: clearDownload2, setLastPacket: setLastPacket2 } = useDownload();
      const { fetchUserDetails, updateUserDetails, clearUserDetails } = useUserDetails();
      const dispatch = useAppDispatch();
      const navigate = useNavigate();
      const location = useLocation();
      const search2 = useAppSelector((state) => state.search.value);
      const draggingDisabled = useAppSelector(
        (state) => state.window.draggingDisabled
      );
      const toast2 = useAppSelector((state) => state.toast);
      const { showSuccessToast } = useToast();
      reactExports.useEffect(() => {
        Promise.all([window.electron.getUserPreferences(), updateLibrary()]).then(
          ([preferences]) => {
            dispatch(setUserPreferences(preferences));
          }
        );
      }, [navigate, location.pathname, dispatch, updateLibrary]);
      reactExports.useEffect(() => {
        const unsubscribe = window.electron.onDownloadProgress(
          (downloadProgress) => {
            if (downloadProgress.game.progress === 1) {
              clearDownload2();
              updateLibrary();
              return;
            }
            setLastPacket2(downloadProgress);
          }
        );
        return () => {
          unsubscribe();
        };
      }, [clearDownload2, setLastPacket2, updateLibrary]);
      reactExports.useEffect(() => {
        const cachedUserDetails = window.localStorage.getItem("userDetails");
        if (cachedUserDetails) {
          const { profileBackground: profileBackground2, ...userDetails } = JSON.parse(cachedUserDetails);
          dispatch(setUserDetails(userDetails));
          dispatch(setProfileBackground(profileBackground2));
        }
        fetchUserDetails().then((response) => {
          if (response)
            updateUserDetails(response);
        });
      }, [fetchUserDetails, updateUserDetails, dispatch]);
      const onSignIn = reactExports.useCallback(() => {
        fetchUserDetails().then((response) => {
          if (response) {
            updateUserDetails(response);
            showSuccessToast(t2("successfully_signed_in"));
          }
        });
      }, [fetchUserDetails, t2, showSuccessToast, updateUserDetails]);
      reactExports.useEffect(() => {
        const unsubscribe = window.electron.onGamesRunning((gamesRunning) => {
          if (gamesRunning.length) {
            const lastGame = gamesRunning[gamesRunning.length - 1];
            const libraryGame = library.find(
              (library2) => library2.id === lastGame.id
            );
            if (libraryGame) {
              dispatch(
                setGameRunning({
                  ...libraryGame,
                  sessionDurationInMillis: lastGame.sessionDurationInMillis
                })
              );
              return;
            }
          }
          dispatch(setGameRunning(null));
        });
        return () => {
          unsubscribe();
        };
      }, [dispatch, library]);
      reactExports.useEffect(() => {
        const listeners = [
          window.electron.onSignIn(onSignIn),
          window.electron.onLibraryBatchComplete(() => {
            updateLibrary();
          }),
          window.electron.onSignOut(() => clearUserDetails())
        ];
        return () => {
          listeners.forEach((unsubscribe) => unsubscribe());
        };
      }, [onSignIn, updateLibrary, clearUserDetails]);
      const handleSearch = reactExports.useCallback(
        (query) => {
          dispatch(setSearch(query));
          if (query === "") {
            navigate(-1);
            return;
          }
          const searchParams = new URLSearchParams({
            query
          });
          navigate(`/search?${searchParams.toString()}`, {
            replace: location.pathname.startsWith("/search")
          });
        },
        [dispatch, location.pathname, navigate]
      );
      const handleClear = reactExports.useCallback(() => {
        dispatch(clearSearch());
        navigate(-1);
      }, [dispatch, navigate]);
      reactExports.useEffect(() => {
        if (contentRef.current)
          contentRef.current.scrollTop = 0;
      }, [location.pathname, location.search]);
      reactExports.useEffect(() => {
        new MutationObserver(() => {
          const modal2 = document.body.querySelector("[role=modal]");
          dispatch(toggleDraggingDisabled(Boolean(modal2)));
        }).observe(document.body, {
          attributes: false,
          childList: true
        });
      }, [dispatch, draggingDisabled]);
      const handleToastClose = reactExports.useCallback(() => {
        dispatch(closeToast());
      }, [dispatch]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        window.electron.platform === "win32" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: titleBar, children: /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: "NoFinder" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Toast,
          {
            visible: toast2.visible,
            message: toast2.message,
            type: toast2.type,
            onClose: handleToastClose
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("main", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Sidebar$1, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("article", { className: container$3, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Header,
              {
                onSearch: handleSearch,
                search: search2,
                onClear: handleClear
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("section", { ref: contentRef, className: content$3, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Outlet, {}) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(BottomPanel, {})
      ] });
    }
    const SkeletonThemeContext = React$1.createContext({});
    const defaultEnableAnimation = true;
    function styleOptionsToCssProperties({ baseColor, highlightColor, width: width2, height: height2, borderRadius, circle, direction, duration, enableAnimation = defaultEnableAnimation }) {
      const style = {};
      if (direction === "rtl")
        style["--animation-direction"] = "reverse";
      if (typeof duration === "number")
        style["--animation-duration"] = `${duration}s`;
      if (!enableAnimation)
        style["--pseudo-element-display"] = "none";
      if (typeof width2 === "string" || typeof width2 === "number")
        style.width = width2;
      if (typeof height2 === "string" || typeof height2 === "number")
        style.height = height2;
      if (typeof borderRadius === "string" || typeof borderRadius === "number")
        style.borderRadius = borderRadius;
      if (circle)
        style.borderRadius = "50%";
      if (typeof baseColor !== "undefined")
        style["--base-color"] = baseColor;
      if (typeof highlightColor !== "undefined")
        style["--highlight-color"] = highlightColor;
      return style;
    }
    function Skeleton({ count = 1, wrapper: Wrapper, className: customClassName, containerClassName, containerTestId, circle = false, style: styleProp, ...originalPropsStyleOptions }) {
      var _a, _b, _c;
      const contextStyleOptions = React$1.useContext(SkeletonThemeContext);
      const propsStyleOptions = { ...originalPropsStyleOptions };
      for (const [key2, value2] of Object.entries(originalPropsStyleOptions)) {
        if (typeof value2 === "undefined") {
          delete propsStyleOptions[key2];
        }
      }
      const styleOptions = {
        ...contextStyleOptions,
        ...propsStyleOptions,
        circle
      };
      const style = {
        ...styleProp,
        ...styleOptionsToCssProperties(styleOptions)
      };
      let className = "react-loading-skeleton";
      if (customClassName)
        className += ` ${customClassName}`;
      const inline = (_a = styleOptions.inline) !== null && _a !== void 0 ? _a : false;
      const elements = [];
      const countCeil = Math.ceil(count);
      for (let i2 = 0; i2 < countCeil; i2++) {
        let thisStyle = style;
        if (countCeil > count && i2 === countCeil - 1) {
          const width2 = (_b = thisStyle.width) !== null && _b !== void 0 ? _b : "100%";
          const fractionalPart = count % 1;
          const fractionalWidth = typeof width2 === "number" ? width2 * fractionalPart : `calc(${width2} * ${fractionalPart})`;
          thisStyle = { ...thisStyle, width: fractionalWidth };
        }
        const skeletonSpan = React$1.createElement("span", { className, style: thisStyle, key: i2 }, "‌");
        if (inline) {
          elements.push(skeletonSpan);
        } else {
          elements.push(React$1.createElement(
            React$1.Fragment,
            { key: i2 },
            skeletonSpan,
            React$1.createElement("br", null)
          ));
        }
      }
      return React$1.createElement("span", { className: containerClassName, "data-testid": containerTestId, "aria-live": "polite", "aria-busy": (_c = styleOptions.enableAnimation) !== null && _c !== void 0 ? _c : defaultEnableAnimation }, Wrapper ? elements.map((el2, i2) => React$1.createElement(Wrapper, { key: i2 }, el2)) : elements);
    }
    function SkeletonTheme({ children, ...styleOptions }) {
      return React$1.createElement(SkeletonThemeContext.Provider, { value: styleOptions }, children);
    }
    const v = "4.8.0";
    const meta = {
      g: "LottieFiles AE 3.5.6",
      a: "",
      k: "",
      d: "",
      tc: ""
    };
    const fr = 60;
    const ip = 0;
    const op = 120;
    const w = 300;
    const h = 300;
    const nm = "Comp 1";
    const ddd = 0;
    const assets = [
      {
        id: "comp_0",
        layers: [
          {
            ddd: 0,
            ind: 1,
            ty: 5,
            nm: "3",
            sr: 1,
            ks: {
              o: {
                a: 0,
                k: 100,
                ix: 11
              },
              r: {
                a: 1,
                k: [
                  {
                    i: {
                      x: [
                        0.055
                      ],
                      y: [
                        1
                      ]
                    },
                    o: {
                      x: [
                        0.333
                      ],
                      y: [
                        0
                      ]
                    },
                    t: 0,
                    s: [
                      0
                    ]
                  },
                  {
                    i: {
                      x: [
                        0.055
                      ],
                      y: [
                        1
                      ]
                    },
                    o: {
                      x: [
                        0.333
                      ],
                      y: [
                        0
                      ]
                    },
                    t: 30,
                    s: [
                      8
                    ]
                  },
                  {
                    t: 60,
                    s: [
                      0
                    ]
                  }
                ],
                ix: 10
              },
              p: {
                a: 0,
                k: [
                  930,
                  525,
                  0
                ],
                ix: 2
              },
              a: {
                a: 0,
                k: [
                  16.605,
                  -23.904,
                  0
                ],
                ix: 1
              },
              s: {
                a: 0,
                k: [
                  170,
                  170,
                  100
                ],
                ix: 6
              }
            },
            ao: 0,
            hasMask: true,
            masksProperties: [
              {
                inv: false,
                mode: "a",
                pt: {
                  a: 0,
                  k: {
                    i: [
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ]
                    ],
                    o: [
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ]
                    ],
                    v: [
                      [
                        14.987,
                        -34.426
                      ],
                      [
                        9.105,
                        -30.309
                      ],
                      [
                        9.987,
                        -22.073
                      ],
                      [
                        17.487,
                        -16.779
                      ],
                      [
                        24.105,
                        -23.544
                      ],
                      [
                        22.193,
                        -30.603
                      ]
                    ],
                    c: true
                  },
                  ix: 1
                },
                o: {
                  a: 0,
                  k: 100,
                  ix: 3
                },
                x: {
                  a: 0,
                  k: 0,
                  ix: 4
                },
                nm: "Mask 1"
              }
            ],
            ef: [
              {
                ty: 21,
                nm: "Fill",
                np: 9,
                mn: "ADBE Fill",
                ix: 1,
                en: 1,
                ef: [
                  {
                    ty: 10,
                    nm: "Fill Mask",
                    mn: "ADBE Fill-0001",
                    ix: 1,
                    v: {
                      a: 0,
                      k: 0,
                      ix: 1
                    }
                  },
                  {
                    ty: 7,
                    nm: "All Masks",
                    mn: "ADBE Fill-0007",
                    ix: 2,
                    v: {
                      a: 0,
                      k: 0,
                      ix: 2
                    }
                  },
                  {
                    ty: 2,
                    nm: "Color",
                    mn: "ADBE Fill-0002",
                    ix: 3,
                    v: {
                      a: 0,
                      k: [
                        0.992156863213,
                        0.880375564098,
                        0.128396704793,
                        1
                      ],
                      ix: 3
                    }
                  },
                  {
                    ty: 7,
                    nm: "Invert",
                    mn: "ADBE Fill-0006",
                    ix: 4,
                    v: {
                      a: 0,
                      k: 0,
                      ix: 4
                    }
                  },
                  {
                    ty: 0,
                    nm: "Horizontal Feather",
                    mn: "ADBE Fill-0003",
                    ix: 5,
                    v: {
                      a: 0,
                      k: 0,
                      ix: 5
                    }
                  },
                  {
                    ty: 0,
                    nm: "Vertical Feather",
                    mn: "ADBE Fill-0004",
                    ix: 6,
                    v: {
                      a: 0,
                      k: 0,
                      ix: 6
                    }
                  },
                  {
                    ty: 0,
                    nm: "Opacity",
                    mn: "ADBE Fill-0005",
                    ix: 7,
                    v: {
                      a: 0,
                      k: 1,
                      ix: 7
                    }
                  }
                ]
              }
            ],
            t: {
              d: {
                k: [
                  {
                    s: {
                      s: 40,
                      f: "SegoeUIEmoji",
                      t: "✨",
                      j: 0,
                      tr: 0,
                      lh: 48,
                      ls: 0,
                      fc: [
                        1,
                        1,
                        1
                      ]
                    },
                    t: 0
                  }
                ]
              },
              p: {},
              m: {
                g: 1,
                a: {
                  a: 0,
                  k: [
                    0,
                    0
                  ],
                  ix: 2
                }
              },
              a: []
            },
            ip: 0,
            op: 123,
            st: 0,
            bm: 0
          },
          {
            ddd: 0,
            ind: 2,
            ty: 5,
            nm: "2",
            sr: 1,
            ks: {
              o: {
                a: 0,
                k: 100,
                ix: 11
              },
              r: {
                a: 1,
                k: [
                  {
                    i: {
                      x: [
                        0.055
                      ],
                      y: [
                        1
                      ]
                    },
                    o: {
                      x: [
                        0.333
                      ],
                      y: [
                        0
                      ]
                    },
                    t: 0,
                    s: [
                      0
                    ]
                  },
                  {
                    i: {
                      x: [
                        0.055
                      ],
                      y: [
                        1
                      ]
                    },
                    o: {
                      x: [
                        0.333
                      ],
                      y: [
                        0
                      ]
                    },
                    t: 30,
                    s: [
                      -8
                    ]
                  },
                  {
                    t: 60,
                    s: [
                      0
                    ]
                  }
                ],
                ix: 10
              },
              p: {
                a: 0,
                k: [
                  960,
                  540,
                  0
                ],
                ix: 2
              },
              a: {
                a: 0,
                k: [
                  31.912,
                  -13.397,
                  0
                ],
                ix: 1
              },
              s: {
                a: 0,
                k: [
                  170,
                  170,
                  100
                ],
                ix: 6
              }
            },
            ao: 0,
            hasMask: true,
            masksProperties: [
              {
                inv: false,
                mode: "a",
                pt: {
                  a: 0,
                  k: {
                    i: [
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ]
                    ],
                    o: [
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ]
                    ],
                    v: [
                      [
                        31.31,
                        -34.72
                      ],
                      [
                        24.546,
                        -22.514
                      ],
                      [
                        16.605,
                        -16.485
                      ],
                      [
                        17.046,
                        -11.338
                      ],
                      [
                        21.163,
                        -7.073
                      ],
                      [
                        27.487,
                        -0.309
                      ],
                      [
                        33.663,
                        10.133
                      ],
                      [
                        47.634,
                        -1.926
                      ],
                      [
                        51.31,
                        -12.073
                      ]
                    ],
                    c: true
                  },
                  ix: 1
                },
                o: {
                  a: 0,
                  k: 100,
                  ix: 3
                },
                x: {
                  a: 0,
                  k: 0,
                  ix: 4
                },
                nm: "Mask 1"
              }
            ],
            ef: [
              {
                ty: 21,
                nm: "Fill",
                np: 9,
                mn: "ADBE Fill",
                ix: 1,
                en: 1,
                ef: [
                  {
                    ty: 10,
                    nm: "Fill Mask",
                    mn: "ADBE Fill-0001",
                    ix: 1,
                    v: {
                      a: 0,
                      k: 0,
                      ix: 1
                    }
                  },
                  {
                    ty: 7,
                    nm: "All Masks",
                    mn: "ADBE Fill-0007",
                    ix: 2,
                    v: {
                      a: 0,
                      k: 0,
                      ix: 2
                    }
                  },
                  {
                    ty: 2,
                    nm: "Color",
                    mn: "ADBE Fill-0002",
                    ix: 3,
                    v: {
                      a: 0,
                      k: [
                        0.992156863213,
                        0.880375564098,
                        0.128396704793,
                        1
                      ],
                      ix: 3
                    }
                  },
                  {
                    ty: 7,
                    nm: "Invert",
                    mn: "ADBE Fill-0006",
                    ix: 4,
                    v: {
                      a: 0,
                      k: 0,
                      ix: 4
                    }
                  },
                  {
                    ty: 0,
                    nm: "Horizontal Feather",
                    mn: "ADBE Fill-0003",
                    ix: 5,
                    v: {
                      a: 0,
                      k: 0,
                      ix: 5
                    }
                  },
                  {
                    ty: 0,
                    nm: "Vertical Feather",
                    mn: "ADBE Fill-0004",
                    ix: 6,
                    v: {
                      a: 0,
                      k: 0,
                      ix: 6
                    }
                  },
                  {
                    ty: 0,
                    nm: "Opacity",
                    mn: "ADBE Fill-0005",
                    ix: 7,
                    v: {
                      a: 0,
                      k: 1,
                      ix: 7
                    }
                  }
                ]
              }
            ],
            t: {
              d: {
                k: [
                  {
                    s: {
                      s: 40,
                      f: "SegoeUIEmoji",
                      t: "✨",
                      j: 0,
                      tr: 0,
                      lh: 48,
                      ls: 0,
                      fc: [
                        1,
                        1,
                        1
                      ]
                    },
                    t: 0
                  }
                ]
              },
              p: {},
              m: {
                g: 1,
                a: {
                  a: 0,
                  k: [
                    0,
                    0
                  ],
                  ix: 2
                }
              },
              a: []
            },
            ip: 0,
            op: 123,
            st: 0,
            bm: 0
          },
          {
            ddd: 0,
            ind: 3,
            ty: 5,
            nm: "✨",
            sr: 1,
            ks: {
              o: {
                a: 0,
                k: 100,
                ix: 11
              },
              r: {
                a: 1,
                k: [
                  {
                    i: {
                      x: [
                        0.055
                      ],
                      y: [
                        1
                      ]
                    },
                    o: {
                      x: [
                        0.333
                      ],
                      y: [
                        0
                      ]
                    },
                    t: 0,
                    s: [
                      0
                    ]
                  },
                  {
                    i: {
                      x: [
                        0.055
                      ],
                      y: [
                        1
                      ]
                    },
                    o: {
                      x: [
                        0.333
                      ],
                      y: [
                        0
                      ]
                    },
                    t: 30,
                    s: [
                      8
                    ]
                  },
                  {
                    t: 60,
                    s: [
                      0
                    ]
                  }
                ],
                ix: 10
              },
              p: {
                a: 0,
                k: [
                  935,
                  560,
                  0
                ],
                ix: 2
              },
              a: {
                a: 0,
                k: [
                  14.973,
                  -6.64,
                  0
                ],
                ix: 1
              },
              s: {
                a: 0,
                k: [
                  170,
                  170,
                  100
                ],
                ix: 6
              }
            },
            ao: 0,
            hasMask: true,
            masksProperties: [
              {
                inv: false,
                mode: "a",
                pt: {
                  a: 0,
                  k: {
                    i: [
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ]
                    ],
                    o: [
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ],
                      [
                        0,
                        0
                      ]
                    ],
                    v: [
                      [
                        13.957,
                        -17.514
                      ],
                      [
                        2.928,
                        -9.132
                      ],
                      [
                        2.487,
                        1.603
                      ],
                      [
                        14.105,
                        7.339
                      ],
                      [
                        21.605,
                        -0.161
                      ],
                      [
                        22.193,
                        -5.161
                      ],
                      [
                        17.34,
                        -10.014
                      ]
                    ],
                    c: true
                  },
                  ix: 1
                },
                o: {
                  a: 0,
                  k: 100,
                  ix: 3
                },
                x: {
                  a: 0,
                  k: 0,
                  ix: 4
                },
                nm: "Mask 1"
              }
            ],
            ef: [
              {
                ty: 21,
                nm: "Fill",
                np: 9,
                mn: "ADBE Fill",
                ix: 1,
                en: 1,
                ef: [
                  {
                    ty: 10,
                    nm: "Fill Mask",
                    mn: "ADBE Fill-0001",
                    ix: 1,
                    v: {
                      a: 0,
                      k: 0,
                      ix: 1
                    }
                  },
                  {
                    ty: 7,
                    nm: "All Masks",
                    mn: "ADBE Fill-0007",
                    ix: 2,
                    v: {
                      a: 0,
                      k: 0,
                      ix: 2
                    }
                  },
                  {
                    ty: 2,
                    nm: "Color",
                    mn: "ADBE Fill-0002",
                    ix: 3,
                    v: {
                      a: 0,
                      k: [
                        0.992156863213,
                        0.880375564098,
                        0.128396704793,
                        1
                      ],
                      ix: 3
                    }
                  },
                  {
                    ty: 7,
                    nm: "Invert",
                    mn: "ADBE Fill-0006",
                    ix: 4,
                    v: {
                      a: 0,
                      k: 0,
                      ix: 4
                    }
                  },
                  {
                    ty: 0,
                    nm: "Horizontal Feather",
                    mn: "ADBE Fill-0003",
                    ix: 5,
                    v: {
                      a: 0,
                      k: 0,
                      ix: 5
                    }
                  },
                  {
                    ty: 0,
                    nm: "Vertical Feather",
                    mn: "ADBE Fill-0004",
                    ix: 6,
                    v: {
                      a: 0,
                      k: 0,
                      ix: 6
                    }
                  },
                  {
                    ty: 0,
                    nm: "Opacity",
                    mn: "ADBE Fill-0005",
                    ix: 7,
                    v: {
                      a: 0,
                      k: 1,
                      ix: 7
                    }
                  }
                ]
              }
            ],
            t: {
              d: {
                k: [
                  {
                    s: {
                      s: 40,
                      f: "SegoeUIEmoji",
                      t: "✨",
                      j: 0,
                      tr: 0,
                      lh: 48,
                      ls: 0,
                      fc: [
                        1,
                        1,
                        1
                      ]
                    },
                    t: 0
                  }
                ]
              },
              p: {},
              m: {
                g: 1,
                a: {
                  a: 0,
                  k: [
                    0,
                    0
                  ],
                  ix: 2
                }
              },
              a: []
            },
            ip: 0,
            op: 123,
            st: 0,
            bm: 0
          }
        ]
      }
    ];
    const fonts = {
      list: [
        {
          fName: "SegoeUIEmoji",
          fFamily: "Segoe UI Emoji",
          fStyle: "Regular",
          ascent: 74.0234375
        }
      ]
    };
    const layers = [
      {
        ddd: 0,
        ind: 1,
        ty: 0,
        nm: "botão",
        refId: "comp_0",
        sr: 1,
        ks: {
          o: {
            a: 0,
            k: 100,
            ix: 11
          },
          r: {
            a: 0,
            k: 0,
            ix: 10
          },
          p: {
            a: 0,
            k: [
              155,
              154,
              0
            ],
            ix: 2
          },
          a: {
            a: 0,
            k: [
              960,
              540,
              0
            ],
            ix: 1
          },
          s: {
            a: 0,
            k: [
              100,
              100,
              100
            ],
            ix: 6
          }
        },
        ao: 0,
        ef: [
          {
            ty: 25,
            nm: "Drop Shadow",
            np: 8,
            mn: "ADBE Drop Shadow",
            ix: 1,
            en: 1,
            ef: [
              {
                ty: 2,
                nm: "Shadow Color",
                mn: "ADBE Drop Shadow-0001",
                ix: 1,
                v: {
                  a: 0,
                  k: [
                    1,
                    0.829733371735,
                    0.414901971817,
                    1
                  ],
                  ix: 1
                }
              },
              {
                ty: 0,
                nm: "Opacity",
                mn: "ADBE Drop Shadow-0002",
                ix: 2,
                v: {
                  a: 1,
                  k: [
                    {
                      i: {
                        x: [
                          0
                        ],
                        y: [
                          1
                        ]
                      },
                      o: {
                        x: [
                          0.333
                        ],
                        y: [
                          0
                        ]
                      },
                      t: 0,
                      s: [
                        127.5
                      ]
                    },
                    {
                      i: {
                        x: [
                          0
                        ],
                        y: [
                          1
                        ]
                      },
                      o: {
                        x: [
                          0.333
                        ],
                        y: [
                          0
                        ]
                      },
                      t: 15,
                      s: [
                        204
                      ]
                    },
                    {
                      i: {
                        x: [
                          0
                        ],
                        y: [
                          1
                        ]
                      },
                      o: {
                        x: [
                          0.333
                        ],
                        y: [
                          0
                        ]
                      },
                      t: 30,
                      s: [
                        127.5
                      ]
                    },
                    {
                      i: {
                        x: [
                          0
                        ],
                        y: [
                          1
                        ]
                      },
                      o: {
                        x: [
                          0.333
                        ],
                        y: [
                          0
                        ]
                      },
                      t: 45,
                      s: [
                        204
                      ]
                    },
                    {
                      t: 70,
                      s: [
                        76.5
                      ]
                    }
                  ],
                  ix: 2
                }
              },
              {
                ty: 0,
                nm: "Direction",
                mn: "ADBE Drop Shadow-0003",
                ix: 3,
                v: {
                  a: 0,
                  k: 135,
                  ix: 3
                }
              },
              {
                ty: 0,
                nm: "Distance",
                mn: "ADBE Drop Shadow-0004",
                ix: 4,
                v: {
                  a: 0,
                  k: 0,
                  ix: 4
                }
              },
              {
                ty: 0,
                nm: "Softness",
                mn: "ADBE Drop Shadow-0005",
                ix: 5,
                v: {
                  a: 0,
                  k: 40,
                  ix: 5
                }
              },
              {
                ty: 7,
                nm: "Shadow Only",
                mn: "ADBE Drop Shadow-0006",
                ix: 6,
                v: {
                  a: 0,
                  k: 0,
                  ix: 6
                }
              }
            ]
          }
        ],
        w: 1920,
        h: 1080,
        ip: 0,
        op: 120,
        st: 0,
        bm: 0
      }
    ];
    const markers = [];
    const chars$1 = [
      {
        ch: "✨",
        size: 40,
        style: "Regular",
        w: 137.3,
        data: {
          shapes: [
            {
              ty: "gr",
              it: [
                {
                  ind: 0,
                  ty: "sh",
                  ix: 1,
                  ks: {
                    a: 0,
                    k: {
                      i: [
                        [
                          0.423,
                          1.042
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          0.7,
                          0
                        ],
                        [
                          0.293,
                          -0.618
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          1.041,
                          -0.488
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          0,
                          -0.684
                        ],
                        [
                          -0.652,
                          -0.293
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          -0.423,
                          -1.041
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          -0.716,
                          0
                        ],
                        [
                          -0.293,
                          0.619
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          -1.042,
                          0.488
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          0,
                          0.684
                        ],
                        [
                          0.618,
                          0.293
                        ],
                        [
                          0,
                          0
                        ]
                      ],
                      o: [
                        [
                          0,
                          0
                        ],
                        [
                          -0.326,
                          -0.618
                        ],
                        [
                          -0.7,
                          0
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          -0.456,
                          1.009
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          -0.652,
                          0.293
                        ],
                        [
                          0,
                          0.684
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          1.074,
                          0.456
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          0.293,
                          0.619
                        ],
                        [
                          0.716,
                          0
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          0.455,
                          -1.009
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          0.618,
                          -0.293
                        ],
                        [
                          0,
                          -0.684
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          -1.074,
                          -0.455
                        ]
                      ],
                      v: [
                        [
                          47.119,
                          -68.994
                        ],
                        [
                          43.799,
                          -76.562
                        ],
                        [
                          42.261,
                          -77.49
                        ],
                        [
                          40.771,
                          -76.562
                        ],
                        [
                          37.402,
                          -68.994
                        ],
                        [
                          35.156,
                          -66.748
                        ],
                        [
                          30.908,
                          -64.893
                        ],
                        [
                          29.932,
                          -63.428
                        ],
                        [
                          30.908,
                          -61.963
                        ],
                        [
                          35.156,
                          -60.107
                        ],
                        [
                          37.402,
                          -57.861
                        ],
                        [
                          40.771,
                          -50.244
                        ],
                        [
                          42.285,
                          -49.316
                        ],
                        [
                          43.799,
                          -50.244
                        ],
                        [
                          47.119,
                          -57.861
                        ],
                        [
                          49.365,
                          -60.107
                        ],
                        [
                          53.662,
                          -61.963
                        ],
                        [
                          54.59,
                          -63.428
                        ],
                        [
                          53.662,
                          -64.893
                        ],
                        [
                          49.365,
                          -66.748
                        ]
                      ],
                      c: true
                    },
                    ix: 2
                  },
                  nm: "✨",
                  mn: "ADBE Vector Shape - Group",
                  hd: false
                },
                {
                  ind: 1,
                  ty: "sh",
                  ix: 2,
                  ks: {
                    a: 0,
                    k: {
                      i: [
                        [
                          1.334,
                          3.223
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          1.204,
                          0.423
                        ],
                        [
                          1.204,
                          -0.423
                        ],
                        [
                          0.618,
                          -1.237
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          3.125,
                          -1.432
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          0.423,
                          -1.221
                        ],
                        [
                          -0.423,
                          -1.221
                        ],
                        [
                          -1.27,
                          -0.618
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          -1.335,
                          -3.223
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          -1.205,
                          -0.407
                        ],
                        [
                          -1.205,
                          0.407
                        ],
                        [
                          -0.619,
                          1.27
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          -3.125,
                          1.433
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          -0.423,
                          1.221
                        ],
                        [
                          0.423,
                          1.221
                        ],
                        [
                          1.27,
                          0.619
                        ],
                        [
                          0,
                          0
                        ]
                      ],
                      o: [
                        [
                          0,
                          0
                        ],
                        [
                          -0.619,
                          -1.237
                        ],
                        [
                          -1.205,
                          -0.423
                        ],
                        [
                          -1.205,
                          0.423
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          -1.367,
                          3.223
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          -1.27,
                          0.619
                        ],
                        [
                          -0.423,
                          1.221
                        ],
                        [
                          0.423,
                          1.221
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          3.157,
                          1.433
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          0.618,
                          1.27
                        ],
                        [
                          1.204,
                          0.407
                        ],
                        [
                          1.204,
                          -0.407
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          1.367,
                          -3.223
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          1.27,
                          -0.618
                        ],
                        [
                          0.423,
                          -1.221
                        ],
                        [
                          -0.423,
                          -1.221
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          -3.158,
                          -1.432
                        ]
                      ],
                      v: [
                        [
                          95.605,
                          -50.83
                        ],
                        [
                          85.498,
                          -74.658
                        ],
                        [
                          82.764,
                          -77.148
                        ],
                        [
                          79.15,
                          -77.148
                        ],
                        [
                          76.416,
                          -74.658
                        ],
                        [
                          66.357,
                          -50.83
                        ],
                        [
                          59.619,
                          -43.848
                        ],
                        [
                          46.875,
                          -38.086
                        ],
                        [
                          44.336,
                          -35.327
                        ],
                        [
                          44.336,
                          -31.665
                        ],
                        [
                          46.875,
                          -28.906
                        ],
                        [
                          59.619,
                          -23.145
                        ],
                        [
                          66.357,
                          -16.162
                        ],
                        [
                          76.416,
                          7.666
                        ],
                        [
                          79.15,
                          10.181
                        ],
                        [
                          82.764,
                          10.181
                        ],
                        [
                          85.498,
                          7.666
                        ],
                        [
                          95.605,
                          -16.162
                        ],
                        [
                          102.344,
                          -23.145
                        ],
                        [
                          115.088,
                          -28.906
                        ],
                        [
                          117.627,
                          -31.665
                        ],
                        [
                          117.627,
                          -35.327
                        ],
                        [
                          115.088,
                          -38.086
                        ],
                        [
                          102.344,
                          -43.848
                        ]
                      ],
                      c: true
                    },
                    ix: 2
                  },
                  nm: "✨",
                  mn: "ADBE Vector Shape - Group",
                  hd: false
                },
                {
                  ind: 2,
                  ty: "sh",
                  ix: 3,
                  ks: {
                    a: 0,
                    k: {
                      i: [
                        [
                          -1.367,
                          -0.651
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          0,
                          -0.928
                        ],
                        [
                          0.813,
                          -0.423
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          0.586,
                          -1.399
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          0.895,
                          0
                        ],
                        [
                          0.391,
                          0.846
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          1.334,
                          0.652
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          0,
                          0.928
                        ],
                        [
                          -0.814,
                          0.423
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          -0.586,
                          1.4
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          -0.896,
                          0
                        ],
                        [
                          -0.391,
                          -0.846
                        ],
                        [
                          0,
                          0
                        ]
                      ],
                      o: [
                        [
                          0,
                          0
                        ],
                        [
                          0.813,
                          0.423
                        ],
                        [
                          0,
                          0.928
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          -1.335,
                          0.652
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          -0.391,
                          0.846
                        ],
                        [
                          -0.896,
                          0
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          -0.586,
                          -1.399
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          -0.814,
                          -0.423
                        ],
                        [
                          0,
                          -0.928
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          1.334,
                          -0.651
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          0.391,
                          -0.846
                        ],
                        [
                          0.895,
                          0
                        ],
                        [
                          0,
                          0
                        ],
                        [
                          0.553,
                          1.4
                        ]
                      ],
                      v: [
                        [
                          44.385,
                          -16.943
                        ],
                        [
                          49.854,
                          -14.404
                        ],
                        [
                          51.074,
                          -12.378
                        ],
                        [
                          49.854,
                          -10.352
                        ],
                        [
                          44.385,
                          -7.812
                        ],
                        [
                          41.504,
                          -4.736
                        ],
                        [
                          37.158,
                          5.713
                        ],
                        [
                          35.229,
                          6.982
                        ],
                        [
                          33.301,
                          5.713
                        ],
                        [
                          28.955,
                          -4.736
                        ],
                        [
                          26.074,
                          -7.812
                        ],
                        [
                          20.605,
                          -10.352
                        ],
                        [
                          19.385,
                          -12.378
                        ],
                        [
                          20.605,
                          -14.404
                        ],
                        [
                          26.074,
                          -16.943
                        ],
                        [
                          28.955,
                          -20.02
                        ],
                        [
                          33.301,
                          -30.469
                        ],
                        [
                          35.229,
                          -31.738
                        ],
                        [
                          37.158,
                          -30.469
                        ],
                        [
                          41.504,
                          -20.02
                        ]
                      ],
                      c: true
                    },
                    ix: 2
                  },
                  nm: "✨",
                  mn: "ADBE Vector Shape - Group",
                  hd: false
                }
              ],
              nm: "✨",
              np: 6,
              cix: 2,
              bm: 0,
              ix: 1,
              mn: "ADBE Vector Group",
              hd: false
            }
          ]
        },
        fFamily: "Segoe UI Emoji"
      }
    ];
    const starsAnimation = {
      v,
      meta,
      fr,
      ip,
      op,
      w,
      h,
      nm,
      ddd,
      assets,
      fonts,
      layers,
      markers,
      chars: chars$1
    };
    var homeHeader = "_1ot36hx0";
    var content$2 = "_1ot36hx1";
    var cards = "_1ot36hx2";
    var cardSkeleton = "_1ot36hx3";
    var noResults = "_1ot36hx4";
    function Home() {
      const { t: t2 } = useTranslation("home");
      const navigate = useNavigate();
      const [isLoading, setIsLoading] = reactExports.useState(false);
      const [randomGame, setRandomGame] = reactExports.useState(null);
      const [catalogue2, setCatalogue] = reactExports.useState([]);
      const getCatalogue = reactExports.useCallback(() => {
        setIsLoading(true);
        window.electron.getCatalogue().then((catalogue22) => {
          setCatalogue(catalogue22);
        }).catch(() => {
        }).finally(() => {
          setIsLoading(false);
        });
      }, []);
      const getRandomGame = reactExports.useCallback(() => {
        window.electron.getRandomGame().then((game) => {
          if (game)
            setRandomGame(game);
        });
      }, []);
      const handleRandomizerClick = () => {
        if (randomGame) {
          navigate(
            buildGameDetailsPath(
              { ...randomGame, shop: "steam" },
              {
                fromRandomizer: "1"
              }
            )
          );
        }
      };
      reactExports.useEffect(() => {
        setIsLoading(true);
        getCatalogue();
        getRandomGame();
      }, [getCatalogue, getRandomGame]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SkeletonTheme, { baseColor: vars.color.background, highlightColor: "#444", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: content$2, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("featured") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Hero, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: homeHeader, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("trending") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Button,
            {
              onClick: handleRandomizerClick,
              theme: "outline",
              disabled: !randomGame,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: 16, height: 16, position: "relative" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Lottie,
                  {
                    animationData: starsAnimation,
                    style: { width: 70, position: "absolute", top: -28, left: -27 },
                    loop: true
                  }
                ) }),
                t2("surprise_me")
              ]
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: cards, children: isLoading ? Array.from({ length: 12 }).map((_, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { className: cardSkeleton }, index2)) : catalogue2.map((result) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          GameCard,
          {
            game: result,
            onClick: () => navigate(buildGameDetailsPath(result))
          },
          result.objectID
        )) })
      ] }) });
    }
    var HERO_HEIGHT = 300;
    var wrapper$1 = "_1e13mxm1";
    var hero = "_1e13mxm2";
    var heroContent = "_1e13mxm3";
    var heroLogoBackdrop = "_1e13mxm4";
    var heroImage = "_1e13mxm5";
    var heroImageSkeleton = "_1e13mxm6";
    var container$2 = "_1e13mxm7";
    var descriptionContainer = "_1e13mxm8";
    var descriptionContent = "_1e13mxm9";
    var description$1 = "_1e13mxma";
    var descriptionSkeleton = "_1e13mxmb";
    var randomizerButton = "_1e13mxmc";
    var heroPanelSkeleton = "_1e13mxmd";
    var contentSidebar$1 = "zoj2n10";
    var contentSidebarTitle = "zoj2n11";
    var requirementButtonContainer = "zoj2n12";
    var requirementButton = "zoj2n13";
    var requirementsDetails = "zoj2n14";
    var requirementsDetailsSkeleton = "zoj2n15";
    var howLongToBeatCategoriesList = "zoj2n16";
    var howLongToBeatCategory = "zoj2n17";
    var howLongToBeatCategoryLabel = "zoj2n18";
    var howLongToBeatCategorySkeleton = "zoj2n19";
    var descriptionHeader = "goqr5y0";
    var descriptionHeaderInfo = "goqr5y1";
    function GameDetailsSkeleton() {
      const { t: t2 } = useTranslation("game_details");
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: container$2, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: hero, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { className: heroImageSkeleton }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: heroPanelSkeleton, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: descriptionHeaderInfo, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { width: 155 }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { width: 135 })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: descriptionContainer, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: descriptionContent, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: descriptionHeader, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: descriptionHeaderInfo, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { width: 145 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { width: 150 })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: descriptionSkeleton, children: [
              Array.from({ length: 3 }).map((_, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, {}, index2)),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { className: heroImageSkeleton }),
              Array.from({ length: 2 }).map((_, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, {}, index2)),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { className: heroImageSkeleton }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, {})
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: contentSidebar$1, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: contentSidebarTitle, children: /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "HowLongToBeat" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: howLongToBeatCategoriesList, children: Array.from({ length: 3 }).map((_, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              Skeleton,
              {
                className: howLongToBeatCategorySkeleton
              },
              index2
            )) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: contentSidebarTitle,
                style: { border: "none" },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: t2("requirements") })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: requirementButtonContainer, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  className: requirementButton,
                  theme: "primary",
                  disabled: true,
                  children: t2("minimum")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  className: requirementButton,
                  theme: "outline",
                  disabled: true,
                  children: t2("recommended")
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: requirementsDetailsSkeleton, children: Array.from({ length: 6 }).map((_, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { height: 20 }, index2)) })
          ] })
        ] })
      ] });
    }
    var heroPanelAction = "_2l10p50";
    var actions$1 = "_2l10p51";
    var separator$1 = "_2l10p52";
    const gameDetailsContext = reactExports.createContext({
      game: null,
      shopDetails: null,
      repacks: [],
      shop: "steam",
      gameTitle: "",
      isGameRunning: false,
      isLoading: false,
      objectID: void 0,
      gameColor: "",
      showRepacksModal: false,
      showGameOptionsModal: false,
      setGameColor: () => {
      },
      selectGameExecutable: async () => null,
      updateGame: async () => {
      },
      setShowGameOptionsModal: () => {
      },
      setShowRepacksModal: () => {
      }
    });
    const { Provider: Provider$1 } = gameDetailsContext;
    const { Consumer: GameDetailsContextConsumer } = gameDetailsContext;
    function GameDetailsContextProvider({
      children
    }) {
      const { objectID, shop } = useParams();
      const [shopDetails, setGameDetails] = reactExports.useState(null);
      const [repacks2, setRepacks] = reactExports.useState([]);
      const [game, setGame] = reactExports.useState(null);
      const [isLoading, setIsLoading] = reactExports.useState(false);
      const [gameColor, setGameColor] = reactExports.useState("");
      const [isGameRunning, setisGameRunning] = reactExports.useState(false);
      const [showRepacksModal, setShowRepacksModal] = reactExports.useState(false);
      const [showGameOptionsModal, setShowGameOptionsModal] = reactExports.useState(false);
      const [searchParams] = useSearchParams();
      const gameTitle = searchParams.get("title");
      const { i18n } = useTranslation("game_details");
      const dispatch = useAppDispatch();
      const { lastPacket } = useDownload();
      const userPreferences = useAppSelector(
        (state) => state.userPreferences.value
      );
      const updateGame = reactExports.useCallback(async () => {
        return window.electron.getGameByObjectID(objectID).then((result) => setGame(result));
      }, [setGame, objectID]);
      const isGameDownloading = lastPacket?.game.id === game?.id;
      reactExports.useEffect(() => {
        updateGame();
      }, [updateGame, isGameDownloading, lastPacket?.game.status]);
      reactExports.useEffect(() => {
        Promise.allSettled([
          window.electron.getGameShopDetails(
            objectID,
            shop,
            getSteamLanguage(i18n.language)
          ),
          window.electron.searchGameRepacks(gameTitle)
        ]).then(([appDetailsResult, repacksResult]) => {
          if (appDetailsResult.status === "fulfilled")
            setGameDetails(appDetailsResult.value);
          if (repacksResult.status === "fulfilled")
            setRepacks(repacksResult.value);
        }).finally(() => {
          setIsLoading(false);
        });
        updateGame();
      }, [updateGame, dispatch, gameTitle, objectID, shop, i18n.language]);
      reactExports.useEffect(() => {
        setGameDetails(null);
        setGame(null);
        setIsLoading(true);
        setisGameRunning(false);
        dispatch(setHeaderTitle(gameTitle));
      }, [objectID, gameTitle, dispatch]);
      reactExports.useEffect(() => {
        const unsubscribe = window.electron.onGamesRunning((gamesIds) => {
          const updatedIsGameRunning = !!game?.id && !!gamesIds.find((gameRunning) => gameRunning.id == game.id);
          if (isGameRunning != updatedIsGameRunning) {
            updateGame();
          }
          setisGameRunning(updatedIsGameRunning);
        });
        return () => {
          unsubscribe();
        };
      }, [game?.id, isGameRunning, updateGame]);
      const getDownloadsPath = async () => {
        if (userPreferences?.downloadsPath)
          return userPreferences.downloadsPath;
        return window.electron.getDefaultDownloadsPath();
      };
      const selectGameExecutable = async () => {
        const downloadsPath = await getDownloadsPath();
        return window.electron.showOpenDialog({
          properties: ["openFile"],
          defaultPath: downloadsPath,
          filters: [
            {
              name: "Game executable",
              extensions: ["exe", "lnk"]
            }
          ]
        }).then(({ filePaths }) => {
          if (filePaths && filePaths.length > 0) {
            return filePaths[0];
          }
          return null;
        });
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Provider$1,
        {
          value: {
            game,
            shopDetails,
            shop,
            repacks: repacks2,
            gameTitle,
            isGameRunning,
            isLoading,
            objectID,
            gameColor,
            showGameOptionsModal,
            showRepacksModal,
            setGameColor,
            selectGameExecutable,
            updateGame,
            setShowRepacksModal,
            setShowGameOptionsModal
          },
          children
        }
      );
    }
    const settingsContext = reactExports.createContext({
      updateUserPreferences: async () => {
      },
      setCurrentCategoryIndex: () => {
      },
      clearSourceUrl: () => {
      },
      sourceUrl: null,
      currentCategoryIndex: 0
    });
    const { Provider } = settingsContext;
    const { Consumer: SettingsContextConsumer } = settingsContext;
    function SettingsContextProvider({
      children
    }) {
      const dispatch = useAppDispatch();
      const [sourceUrl, setSourceUrl] = reactExports.useState(null);
      const [currentCategoryIndex, setCurrentCategoryIndex] = reactExports.useState(0);
      const [searchParams] = useSearchParams();
      const defaultSourceUrl = searchParams.get("urls");
      reactExports.useEffect(() => {
        if (sourceUrl)
          setCurrentCategoryIndex(2);
      }, [sourceUrl]);
      reactExports.useEffect(() => {
        if (defaultSourceUrl) {
          setSourceUrl(defaultSourceUrl);
        }
      }, [defaultSourceUrl]);
      const clearSourceUrl = () => setSourceUrl(null);
      const updateUserPreferences = async (values) => {
        await window.electron.updateUserPreferences(values);
        window.electron.getUserPreferences().then((userPreferences) => {
          dispatch(setUserPreferences(userPreferences));
        });
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Provider,
        {
          value: {
            updateUserPreferences,
            setCurrentCategoryIndex,
            clearSourceUrl,
            currentCategoryIndex,
            sourceUrl
          },
          children
        }
      );
    }
    function HeroPanelActions() {
      const [toggleLibraryGameDisabled, setToggleLibraryGameDisabled] = reactExports.useState(false);
      const { isGameDeleting } = useDownload();
      const {
        game,
        repacks: repacks2,
        isGameRunning,
        objectID,
        gameTitle,
        setShowGameOptionsModal,
        setShowRepacksModal,
        updateGame,
        selectGameExecutable
      } = reactExports.useContext(gameDetailsContext);
      const { updateLibrary } = useLibrary();
      const { t: t2 } = useTranslation("game_details");
      const addGameToLibrary = async () => {
        setToggleLibraryGameDisabled(true);
        try {
          await window.electron.addGameToLibrary(objectID, gameTitle, "steam");
          updateLibrary();
          updateGame();
        } finally {
          setToggleLibraryGameDisabled(false);
        }
      };
      const openGame = async () => {
        if (game) {
          if (game.executablePath) {
            window.electron.openGame(game.id, game.executablePath);
            return;
          }
          const gameExecutablePath = await selectGameExecutable();
          if (gameExecutablePath)
            window.electron.openGame(game.id, gameExecutablePath);
        }
      };
      const closeGame = () => {
        if (game)
          window.electron.closeGame(game.id);
      };
      const deleting = game ? isGameDeleting(game?.id) : false;
      const addGameToLibraryButton = /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Button,
        {
          theme: "outline",
          disabled: toggleLibraryGameDisabled,
          onClick: addGameToLibrary,
          className: heroPanelAction,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(PlusCircleIcon, {}),
            t2("add_to_library")
          ]
        }
      );
      const showDownloadOptionsButton = /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          onClick: () => setShowRepacksModal(true),
          theme: "outline",
          disabled: deleting,
          className: heroPanelAction,
          children: t2("open_download_options")
        }
      );
      if (repacks2.length && !game) {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          addGameToLibraryButton,
          showDownloadOptionsButton
        ] });
      }
      if (game) {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: actions$1, children: [
          isGameRunning ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              onClick: closeGame,
              theme: "outline",
              disabled: deleting,
              className: heroPanelAction,
              children: t2("close")
            }
          ) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Button,
            {
              onClick: openGame,
              theme: "outline",
              disabled: deleting || isGameRunning,
              className: heroPanelAction,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(PlayIcon, {}),
                t2("play")
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: separator$1 }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Button,
            {
              onClick: () => setShowGameOptionsModal(true),
              theme: "outline",
              disabled: deleting,
              className: heroPanelAction,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(GearIcon, {}),
                t2("options")
              ]
            }
          )
        ] });
      }
      return addGameToLibraryButton;
    }
    var panel = createRuntimeFn({ defaultClassName: "_16kj8yi0", variantClassNames: { stuck: { true: "_16kj8yi1" } }, defaultVariants: {}, compoundVariants: [] });
    var content$1 = "_16kj8yi2";
    var actions = "_16kj8yi3";
    var downloadDetailsRow = "_16kj8yi4";
    var downloadsLink = "_16kj8yi5";
    var progressBar = createRuntimeFn({ defaultClassName: "_16kj8yi6", variantClassNames: { disabled: { true: "_16kj8yi7" } }, defaultVariants: {}, compoundVariants: [] });
    const MAX_MINUTES_TO_SHOW_IN_PLAYTIME$1 = 120;
    function HeroPanelPlaytime() {
      const [lastTimePlayed, setLastTimePlayed] = reactExports.useState("");
      const { game, isGameRunning } = reactExports.useContext(gameDetailsContext);
      const { i18n, t: t2 } = useTranslation("game_details");
      const { progress: progress2, lastPacket } = useDownload();
      const { formatDistance: formatDistance2 } = useDate();
      reactExports.useEffect(() => {
        if (game?.lastTimePlayed) {
          setLastTimePlayed(
            formatDistance2(game.lastTimePlayed, /* @__PURE__ */ new Date(), {
              addSuffix: true
            })
          );
        }
      }, [game?.lastTimePlayed, formatDistance2]);
      const numberFormatter = reactExports.useMemo(() => {
        return new Intl.NumberFormat(i18n.language, {
          maximumFractionDigits: 0
        });
      }, [i18n.language]);
      const formatPlayTime = () => {
        const milliseconds = game?.playTimeInMilliseconds || 0;
        const seconds = milliseconds / 1e3;
        const minutes = seconds / 60;
        if (minutes < MAX_MINUTES_TO_SHOW_IN_PLAYTIME$1) {
          return t2("amount_minutes", {
            amount: minutes.toFixed(0)
          });
        }
        const hours = minutes / 60;
        return t2("amount_hours", { amount: numberFormatter.format(hours) });
      };
      if (!game)
        return null;
      const hasDownload = ["active", "paused"].includes(game.status) && game.progress !== 1;
      const isGameDownloading = game.status === "active" && lastPacket?.game.id === game.id;
      const downloadInProgressInfo = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: downloadDetailsRow, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/downloads", className: downloadsLink, children: game.status === "active" ? t2("download_in_progress") : t2("download_paused") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: isGameDownloading ? progress2 : formatDownloadProgress(game.progress) })
      ] });
      if (!game.lastTimePlayed) {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("not_played_yet", { title: game?.title }) }),
          hasDownload && downloadInProgressInfo
        ] });
      }
      if (isGameRunning) {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("playing_now") }),
          hasDownload && downloadInProgressInfo
        ] });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("play_time", {
          amount: formatPlayTime()
        }) }),
        hasDownload ? downloadInProgressInfo : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("last_time_played", {
          period: lastTimePlayed
        }) })
      ] });
    }
    function HeroPanel({ isHeaderStuck }) {
      const { t: t2 } = useTranslation("game_details");
      const { game, repacks: repacks2, gameColor } = reactExports.useContext(gameDetailsContext);
      const { lastPacket } = useDownload();
      const isGameDownloading = game?.status === "active" && lastPacket?.game.id === game?.id;
      const getInfo = () => {
        if (!game) {
          const [latestRepack] = repacks2;
          if (latestRepack) {
            const lastUpdate = format$1(latestRepack.uploadDate, "dd/MM/yyyy");
            const repacksCount = repacks2.length;
            return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("updated_at", { updated_at: lastUpdate }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("download_options", { count: repacksCount }) })
            ] });
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("no_downloads") });
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsx(HeroPanelPlaytime, {});
      };
      const showProgressBar = game?.status === "active" && game?.progress < 1 || game?.status === "paused";
      return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: { backgroundColor: gameColor },
          className: panel({ stuck: isHeaderStuck }),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: content$1, children: getInfo() }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: actions, children: /* @__PURE__ */ jsxRuntimeExports.jsx(HeroPanelActions, {}) }),
            showProgressBar && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "progress",
              {
                max: 1,
                value: isGameDownloading ? lastPacket?.game.progress : game?.progress,
                className: progressBar({
                  disabled: game?.status === "paused"
                })
              }
            )
          ]
        }
      ) });
    }
    function DescriptionHeader() {
      const { shopDetails } = reactExports.useContext(gameDetailsContext);
      const { t: t2 } = useTranslation("game_details");
      if (!shopDetails)
        return null;
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: descriptionHeader, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: descriptionHeaderInfo, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("release_date", {
          date: shopDetails?.release_date.date
        }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("publisher", { publisher: shopDetails.publishers[0] }) })
      ] }) });
    }
    var gallerySliderContainer = "_1bbejl00";
    var gallerySliderMedia = "_1bbejl01";
    var gallerySliderAnimationContainer = "_1bbejl02";
    var gallerySliderPreview = "_1bbejl03";
    var mediaPreviewButton = createRuntimeFn({ defaultClassName: "_1bbejl04", variantClassNames: { active: { true: "_1bbejl05" } }, defaultVariants: {}, compoundVariants: [] });
    var mediaPreview = "_1bbejl06";
    var gallerySliderButton = createRuntimeFn({ defaultClassName: "_1bbejl07", variantClassNames: { direction: { left: "_1bbejl08", right: "_1bbejl09" }, visible: { true: "_1bbejl0a", false: "_1bbejl0b" } }, defaultVariants: {}, compoundVariants: [] });
    function GallerySlider() {
      const { shopDetails } = reactExports.useContext(gameDetailsContext);
      const scrollContainerRef = reactExports.useRef(null);
      const mediaContainerRef = reactExports.useRef(null);
      const { t: t2 } = useTranslation("game_details");
      const hasScreenshots = shopDetails && shopDetails.screenshots?.length;
      const hasMovies = shopDetails && shopDetails.movies?.length;
      const mediaCount = reactExports.useMemo(() => {
        if (!shopDetails)
          return 0;
        if (shopDetails.screenshots && shopDetails.movies) {
          return shopDetails.screenshots.length + shopDetails.movies.length;
        } else if (shopDetails.movies) {
          return shopDetails.movies.length;
        } else if (shopDetails.screenshots) {
          return shopDetails.screenshots.length;
        }
        return 0;
      }, [shopDetails]);
      const [mediaIndex, setMediaIndex] = reactExports.useState(0);
      const [showArrows, setShowArrows] = reactExports.useState(false);
      const showNextImage = () => {
        setMediaIndex((index2) => {
          if (index2 === mediaCount - 1)
            return 0;
          return index2 + 1;
        });
      };
      const showPrevImage = () => {
        setMediaIndex((index2) => {
          if (index2 === 0)
            return mediaCount - 1;
          return index2 - 1;
        });
      };
      reactExports.useEffect(() => {
        setMediaIndex(0);
      }, [shopDetails]);
      reactExports.useEffect(() => {
        if (hasMovies && mediaContainerRef.current) {
          mediaContainerRef.current.childNodes.forEach((node2, index2) => {
            if (node2 instanceof HTMLVideoElement) {
              if (index2 !== mediaIndex) {
                node2.pause();
              }
            }
          });
        }
      }, [hasMovies, mediaContainerRef, mediaIndex]);
      reactExports.useEffect(() => {
        if (scrollContainerRef.current) {
          const container2 = scrollContainerRef.current;
          const totalWidth = container2.scrollWidth - container2.clientWidth;
          const itemWidth = totalWidth / (mediaCount - 1);
          const scrollLeft = mediaIndex * itemWidth;
          container2.scrollLeft = scrollLeft;
        }
      }, [shopDetails, mediaIndex, mediaCount]);
      const previews = reactExports.useMemo(() => {
        const screenshotPreviews = shopDetails?.screenshots?.map(({ id: id2, path_thumbnail }) => ({
          id: id2,
          thumbnail: path_thumbnail
        })) ?? [];
        if (shopDetails?.movies) {
          const moviePreviews = shopDetails.movies.map(({ id: id2, thumbnail }) => ({
            id: id2,
            thumbnail
          }));
          return [...moviePreviews, ...screenshotPreviews];
        }
        return screenshotPreviews;
      }, [shopDetails]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: hasScreenshots && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: gallerySliderContainer, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            onMouseEnter: () => setShowArrows(true),
            onMouseLeave: () => setShowArrows(false),
            className: gallerySliderAnimationContainer,
            ref: mediaContainerRef,
            children: [
              shopDetails.movies && shopDetails.movies.map((video) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                "video",
                {
                  controls: true,
                  className: gallerySliderMedia,
                  poster: video.thumbnail,
                  style: { translate: `${-100 * mediaIndex}%` },
                  loop: true,
                  muted: true,
                  tabIndex: -1,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("source", { src: video.mp4.max.replace("http", "https") })
                },
                video.id
              )),
              hasScreenshots && shopDetails.screenshots?.map((image, i2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                "img",
                {
                  className: gallerySliderMedia,
                  src: image.path_full,
                  style: { translate: `${-100 * mediaIndex}%` },
                  alt: t2("screenshot", { number: i2 + 1 })
                },
                image.id
              )),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: showPrevImage,
                  type: "button",
                  className: gallerySliderButton({
                    visible: showArrows,
                    direction: "left"
                  }),
                  "aria-label": t2("previous_screenshot"),
                  tabIndex: 0,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronLeftIcon, { size: 36 })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: showNextImage,
                  type: "button",
                  className: gallerySliderButton({
                    visible: showArrows,
                    direction: "right"
                  }),
                  "aria-label": t2("next_screenshot"),
                  tabIndex: 0,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightIcon, { size: 36 })
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: gallerySliderPreview, ref: scrollContainerRef, children: previews.map((media, i2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            type: "button",
            className: mediaPreviewButton({
              active: mediaIndex === i2
            }),
            onClick: () => setMediaIndex(i2),
            "aria-label": t2("open_screenshot", { number: i2 + 1 }),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: media.thumbnail,
                className: mediaPreview,
                alt: t2("screenshot", { number: i2 + 1 })
              }
            )
          },
          media.id
        )) })
      ] }) });
    }
    const durationTranslation = {
      Hours: "hours",
      Mins: "minutes"
    };
    function HowLongToBeatSection({
      howLongToBeatData,
      isLoading
    }) {
      const { t: t2 } = useTranslation("game_details");
      const getDuration = (duration) => {
        const [value2, unit] = duration.split(" ");
        return `${value2} ${t2(durationTranslation[unit])}`;
      };
      if (!howLongToBeatData && !isLoading)
        return null;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(SkeletonTheme, { baseColor: vars.color.background, highlightColor: "#444", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: contentSidebarTitle, children: /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "HowLongToBeat" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: howLongToBeatCategoriesList, children: howLongToBeatData ? howLongToBeatData.map((category) => /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: howLongToBeatCategory, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "p",
            {
              className: howLongToBeatCategoryLabel,
              style: {
                fontWeight: "bold"
              },
              children: category.title
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: howLongToBeatCategoryLabel, children: getDuration(category.duration) }),
          category.accuracy !== "00" && /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: t2("accuracy", { accuracy: category.accuracy }) })
        ] }, category.title)) : Array.from({ length: 4 }).map((_, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          Skeleton,
          {
            className: howLongToBeatCategorySkeleton
          },
          index2
        )) })
      ] });
    }
    function Sidebar() {
      const [howLongToBeat, setHowLongToBeat] = reactExports.useState({ isLoading: true, data: null });
      const [activeRequirement, setActiveRequirement] = reactExports.useState("minimum");
      const { gameTitle, shopDetails, objectID } = reactExports.useContext(gameDetailsContext);
      const { t: t2 } = useTranslation("game_details");
      reactExports.useEffect(() => {
        if (objectID) {
          setHowLongToBeat({ isLoading: true, data: null });
          window.electron.getHowLongToBeat(objectID, "steam", gameTitle).then((howLongToBeat2) => {
            setHowLongToBeat({ isLoading: false, data: howLongToBeat2 });
          }).catch(() => {
            setHowLongToBeat({ isLoading: false, data: null });
          });
        }
      }, [objectID, gameTitle]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("aside", { className: contentSidebar$1, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          HowLongToBeatSection,
          {
            howLongToBeatData: howLongToBeat.data,
            isLoading: howLongToBeat.isLoading
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: contentSidebarTitle, style: { border: "none" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: t2("requirements") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: requirementButtonContainer, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              className: requirementButton,
              onClick: () => setActiveRequirement("minimum"),
              theme: activeRequirement === "minimum" ? "primary" : "outline",
              children: t2("minimum")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              className: requirementButton,
              onClick: () => setActiveRequirement("recommended"),
              theme: activeRequirement === "recommended" ? "primary" : "outline",
              children: t2("recommended")
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: requirementsDetails,
            dangerouslySetInnerHTML: {
              __html: shopDetails?.pc_requirements?.[activeRequirement] ?? t2(`no_${activeRequirement}_requirements`, {
                gameTitle
              })
            }
          }
        )
      ] });
    }
    const HERO_ANIMATION_THRESHOLD = 25;
    function GameDetailsContent() {
      const heroRef = reactExports.useRef(null);
      const containerRef = reactExports.useRef(null);
      const [isHeaderStuck, setIsHeaderStuck] = reactExports.useState(false);
      const { t: t2 } = useTranslation("game_details");
      const { objectID, shopDetails, game, gameColor, setGameColor } = reactExports.useContext(gameDetailsContext);
      const [backdropOpactiy, setBackdropOpacity] = reactExports.useState(1);
      const handleHeroLoad = async () => {
        const output = await average(steamUrlBuilder.libraryHero(objectID), {
          amount: 1,
          format: "hex"
        });
        const backgroundColor = output ? new Color$1(output).darken(0.7).toString() : "";
        setGameColor(backgroundColor);
      };
      reactExports.useEffect(() => {
        setBackdropOpacity(1);
      }, [objectID]);
      const onScroll = (event) => {
        const heroHeight = heroRef.current?.clientHeight ?? HERO_HEIGHT;
        const scrollY = event.target.scrollTop;
        const opacity = Math.max(
          0,
          1 - scrollY / (heroHeight - HERO_ANIMATION_THRESHOLD)
        );
        if (scrollY >= heroHeight && !isHeaderStuck) {
          setIsHeaderStuck(true);
        }
        if (scrollY <= heroHeight && isHeaderStuck) {
          setIsHeaderStuck(false);
        }
        setBackdropOpacity(opacity);
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: wrapper$1, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: steamUrlBuilder.libraryHero(objectID),
            className: heroImage,
            alt: game?.title,
            onLoad: handleHeroLoad
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "section",
          {
            ref: containerRef,
            onScroll,
            className: container$2,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref: heroRef, className: hero, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    style: {
                      backgroundColor: gameColor,
                      flex: 1,
                      opacity: Math.min(1, 1 - backdropOpactiy)
                    }
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    className: heroLogoBackdrop,
                    style: { opacity: backdropOpactiy },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: heroContent, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "img",
                      {
                        src: steamUrlBuilder.logo(objectID),
                        style: { width: 300, alignSelf: "flex-end" },
                        alt: game?.title
                      }
                    ) })
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(HeroPanel, { isHeaderStuck }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: descriptionContainer, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: descriptionContent, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(DescriptionHeader, {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(GallerySlider, {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      dangerouslySetInnerHTML: {
                        __html: shopDetails?.about_the_game ?? t2("no_shop_details")
                      },
                      className: description$1
                    }
                  )
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Sidebar, {})
              ] })
            ]
          }
        )
      ] });
    }
    /* Common package for dealing with hex/string/uint8 conversions (and sha1 hashing)
    *
    * @author   Jimmy Wärting <jimmy@warting.se> (https://jimmy.warting.se/opensource)
    * @license  MIT
    */
    const alphabet = "0123456789abcdef";
    const encodeLookup = [];
    const decodeLookup = [];
    for (let i2 = 0; i2 < 256; i2++) {
      encodeLookup[i2] = alphabet[i2 >> 4 & 15] + alphabet[i2 & 15];
      if (i2 < 16) {
        if (i2 < 10) {
          decodeLookup[48 + i2] = i2;
        } else {
          decodeLookup[97 - 10 + i2] = i2;
        }
      }
    }
    const arr2hex = (data2) => {
      const length2 = data2.length;
      let string = "";
      let i2 = 0;
      while (i2 < length2) {
        string += encodeLookup[data2[i2++]];
      }
      return string;
    };
    const hex2arr = (str) => {
      const sizeof = str.length >> 1;
      const length2 = sizeof << 1;
      const array = new Uint8Array(sizeof);
      let n2 = 0;
      let i2 = 0;
      while (i2 < length2) {
        array[n2++] = decodeLookup[str.charCodeAt(i2++)] << 4 | decodeLookup[str.charCodeAt(i2++)];
      }
      return array;
    };
    const concat = (chunks, size = 0) => {
      const length2 = chunks.length || 0;
      if (!size) {
        let i3 = length2;
        while (i3--)
          size += chunks[i3].length;
      }
      const b = new Uint8Array(size);
      let offset = size;
      let i2 = length2;
      while (i2--) {
        offset -= chunks[i2].length;
        b.set(chunks[i2], offset);
      }
      return b;
    };
    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
    for (var i = 0; i < chars.length; i++) {
      lookup[chars.charCodeAt(i)] = i;
    }
    var encode$1 = function(arraybuffer) {
      var bytes = new Uint8Array(arraybuffer), i2, len = bytes.length, base64 = "";
      for (i2 = 0; i2 < len; i2 += 3) {
        base64 += chars[bytes[i2] >> 2];
        base64 += chars[(bytes[i2] & 3) << 4 | bytes[i2 + 1] >> 4];
        base64 += chars[(bytes[i2 + 1] & 15) << 2 | bytes[i2 + 2] >> 6];
        base64 += chars[bytes[i2 + 2] & 63];
      }
      if (len % 3 === 2) {
        base64 = base64.substring(0, base64.length - 1) + "=";
      } else if (len % 3 === 1) {
        base64 = base64.substring(0, base64.length - 2) + "==";
      }
      return base64;
    };
    const decoder = new TextDecoder();
    const arr2text = (data2, enc) => {
      return decoder.decode(data2);
    };
    const encoder = new TextEncoder();
    const text2arr = (str) => encoder.encode(str);
    const arr2base = (data2) => encode$1(data2);
    const scope = typeof window !== "undefined" ? window : self;
    const crypto = scope.crypto || scope.msCrypto || {};
    const subtle = crypto.subtle || crypto.webkitSubtle;
    const formatMap = {
      hex: arr2hex,
      base64: arr2base
    };
    const hash = async (data2, format2, algo = "sha-1") => {
      if (!subtle)
        throw new Error("no web crypto support");
      if (typeof data2 === "string")
        data2 = text2arr(data2);
      const out = new Uint8Array(await subtle.digest(algo, data2));
      return format2 ? formatMap[format2](out) : out;
    };
    function digitCount(value2) {
      const sign = value2 < 0 ? 1 : 0;
      value2 = Math.abs(Number(value2 || 1));
      return Math.floor(Math.log10(value2)) + 1 + sign;
    }
    function getType(value2) {
      if (ArrayBuffer.isView(value2))
        return "arraybufferview";
      if (Array.isArray(value2))
        return "array";
      if (value2 instanceof Number)
        return "number";
      if (value2 instanceof Boolean)
        return "boolean";
      if (value2 instanceof Set)
        return "set";
      if (value2 instanceof Map)
        return "map";
      if (value2 instanceof String)
        return "string";
      if (value2 instanceof ArrayBuffer)
        return "arraybuffer";
      return typeof value2;
    }
    function encode(data2, buffer, offset) {
      const buffers = [];
      let result = null;
      encode._encode(buffers, data2);
      result = concat(buffers);
      encode.bytes = result.length;
      if (ArrayBuffer.isView(buffer)) {
        buffer.set(result, offset);
        return buffer;
      }
      return result;
    }
    encode.bytes = -1;
    encode._floatConversionDetected = false;
    encode._encode = function(buffers, data2) {
      if (data2 == null) {
        return;
      }
      switch (getType(data2)) {
        case "object":
          encode.dict(buffers, data2);
          break;
        case "map":
          encode.dictMap(buffers, data2);
          break;
        case "array":
          encode.list(buffers, data2);
          break;
        case "set":
          encode.listSet(buffers, data2);
          break;
        case "string":
          encode.string(buffers, data2);
          break;
        case "number":
          encode.number(buffers, data2);
          break;
        case "boolean":
          encode.number(buffers, data2);
          break;
        case "arraybufferview":
          encode.buffer(buffers, new Uint8Array(data2.buffer, data2.byteOffset, data2.byteLength));
          break;
        case "arraybuffer":
          encode.buffer(buffers, new Uint8Array(data2));
          break;
      }
    };
    const buffE = new Uint8Array([101]);
    const buffD = new Uint8Array([100]);
    const buffL = new Uint8Array([108]);
    encode.buffer = function(buffers, data2) {
      buffers.push(text2arr(data2.length + ":"), data2);
    };
    encode.string = function(buffers, data2) {
      buffers.push(text2arr(text2arr(data2).byteLength + ":" + data2));
    };
    encode.number = function(buffers, data2) {
      if (Number.isInteger(data2))
        return buffers.push(text2arr("i" + BigInt(data2) + "e"));
      const maxLo = 2147483648;
      const hi2 = data2 / maxLo << 0;
      const lo = data2 % maxLo << 0;
      const val2 = hi2 * maxLo + lo;
      buffers.push(text2arr("i" + val2 + "e"));
      if (val2 !== data2 && !encode._floatConversionDetected) {
        encode._floatConversionDetected = true;
        console.warn(
          'WARNING: Possible data corruption detected with value "' + data2 + '":',
          'Bencoding only defines support for integers, value was converted to "' + val2 + '"'
        );
        console.trace();
      }
    };
    encode.dict = function(buffers, data2) {
      buffers.push(buffD);
      let j = 0;
      let k2;
      const keys2 = Object.keys(data2).sort();
      const kl2 = keys2.length;
      for (; j < kl2; j++) {
        k2 = keys2[j];
        if (data2[k2] == null)
          continue;
        encode.string(buffers, k2);
        encode._encode(buffers, data2[k2]);
      }
      buffers.push(buffE);
    };
    encode.dictMap = function(buffers, data2) {
      buffers.push(buffD);
      const keys2 = Array.from(data2.keys()).sort();
      for (const key2 of keys2) {
        if (data2.get(key2) == null)
          continue;
        ArrayBuffer.isView(key2) ? encode._encode(buffers, key2) : encode.string(buffers, String(key2));
        encode._encode(buffers, data2.get(key2));
      }
      buffers.push(buffE);
    };
    encode.list = function(buffers, data2) {
      let i2 = 0;
      const c2 = data2.length;
      buffers.push(buffL);
      for (; i2 < c2; i2++) {
        if (data2[i2] == null)
          continue;
        encode._encode(buffers, data2[i2]);
      }
      buffers.push(buffE);
    };
    encode.listSet = function(buffers, data2) {
      buffers.push(buffL);
      for (const item of data2) {
        if (item == null)
          continue;
        encode._encode(buffers, item);
      }
      buffers.push(buffE);
    };
    const INTEGER_START = 105;
    const STRING_DELIM = 58;
    const DICTIONARY_START = 100;
    const LIST_START = 108;
    const END_OF_TYPE = 101;
    function getIntFromBuffer(buffer, start, end) {
      let sum2 = 0;
      let sign = 1;
      for (let i2 = start; i2 < end; i2++) {
        const num = buffer[i2];
        if (num < 58 && num >= 48) {
          sum2 = sum2 * 10 + (num - 48);
          continue;
        }
        if (i2 === start && num === 43) {
          continue;
        }
        if (i2 === start && num === 45) {
          sign = -1;
          continue;
        }
        if (num === 46) {
          break;
        }
        throw new Error("not a number: buffer[" + i2 + "] = " + num);
      }
      return sum2 * sign;
    }
    function decode$1(data2, start, end, encoding) {
      if (data2 == null || data2.length === 0) {
        return null;
      }
      if (typeof start !== "number" && encoding == null) {
        encoding = start;
        start = void 0;
      }
      if (typeof end !== "number" && encoding == null) {
        encoding = end;
        end = void 0;
      }
      decode$1.position = 0;
      decode$1.encoding = encoding || null;
      decode$1.data = !ArrayBuffer.isView(data2) ? text2arr(data2) : new Uint8Array(data2.slice(start, end));
      decode$1.bytes = decode$1.data.length;
      return decode$1.next();
    }
    decode$1.bytes = 0;
    decode$1.position = 0;
    decode$1.data = null;
    decode$1.encoding = null;
    decode$1.next = function() {
      switch (decode$1.data[decode$1.position]) {
        case DICTIONARY_START:
          return decode$1.dictionary();
        case LIST_START:
          return decode$1.list();
        case INTEGER_START:
          return decode$1.integer();
        default:
          return decode$1.buffer();
      }
    };
    decode$1.find = function(chr) {
      let i2 = decode$1.position;
      const c2 = decode$1.data.length;
      const d = decode$1.data;
      while (i2 < c2) {
        if (d[i2] === chr)
          return i2;
        i2++;
      }
      throw new Error(
        'Invalid data: Missing delimiter "' + String.fromCharCode(chr) + '" [0x' + chr.toString(16) + "]"
      );
    };
    decode$1.dictionary = function() {
      decode$1.position++;
      const dict = {};
      while (decode$1.data[decode$1.position] !== END_OF_TYPE) {
        const buffer = decode$1.buffer();
        let key2 = arr2text(buffer);
        if (key2.includes("�"))
          key2 = arr2hex(buffer);
        dict[key2] = decode$1.next();
      }
      decode$1.position++;
      return dict;
    };
    decode$1.list = function() {
      decode$1.position++;
      const lst = [];
      while (decode$1.data[decode$1.position] !== END_OF_TYPE) {
        lst.push(decode$1.next());
      }
      decode$1.position++;
      return lst;
    };
    decode$1.integer = function() {
      const end = decode$1.find(END_OF_TYPE);
      const number = getIntFromBuffer(decode$1.data, decode$1.position + 1, end);
      decode$1.position += end + 1 - decode$1.position;
      return number;
    };
    decode$1.buffer = function() {
      let sep = decode$1.find(STRING_DELIM);
      const length2 = getIntFromBuffer(decode$1.data, decode$1.position, sep);
      const end = ++sep + length2;
      decode$1.position = end;
      return decode$1.encoding ? arr2text(decode$1.data.slice(sep, end)) : decode$1.data.slice(sep, end);
    };
    function listLength(list) {
      let length2 = 1 + 1;
      for (const value2 of list) {
        length2 += encodingLength$1(value2);
      }
      return length2;
    }
    function mapLength(map) {
      let length2 = 1 + 1;
      for (const [key2, value2] of map) {
        const keyLength = text2arr(key2).byteLength;
        length2 += digitCount(keyLength) + 1 + keyLength;
        length2 += encodingLength$1(value2);
      }
      return length2;
    }
    function objectLength(value2) {
      let length2 = 1 + 1;
      const keys2 = Object.keys(value2);
      for (let i2 = 0; i2 < keys2.length; i2++) {
        const keyLength = text2arr(keys2[i2]).byteLength;
        length2 += digitCount(keyLength) + 1 + keyLength;
        length2 += encodingLength$1(value2[keys2[i2]]);
      }
      return length2;
    }
    function stringLength(value2) {
      const length2 = text2arr(value2).byteLength;
      return digitCount(length2) + 1 + length2;
    }
    function arrayBufferLength(value2) {
      const length2 = value2.byteLength - value2.byteOffset;
      return digitCount(length2) + 1 + length2;
    }
    function encodingLength$1(value2) {
      const length2 = 0;
      if (value2 == null)
        return length2;
      const type = getType(value2);
      switch (type) {
        case "arraybufferview":
          return arrayBufferLength(value2);
        case "string":
          return stringLength(value2);
        case "array":
        case "set":
          return listLength(value2);
        case "number":
          return 1 + digitCount(Math.floor(value2)) + 1;
        case "bigint":
          return 1 + value2.toString().length + 1;
        case "object":
          return objectLength(value2);
        case "map":
          return mapLength(value2);
        default:
          throw new TypeError(`Unsupported value of type "${type}"`);
      }
    }
    const encodingLength = encodingLength$1;
    const bencode = { encode, decode: decode$1, byteLength: encodingLength$1, encodingLength };
    const path = {};
    const byteTable = [
      255,
      255,
      26,
      27,
      28,
      29,
      30,
      31,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      255,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      255,
      255,
      255,
      255,
      255,
      255,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      255,
      255,
      255,
      255,
      255
    ];
    const decode = function(encoded) {
      if (!ArrayBuffer.isView(encoded) && typeof encoded !== "string") {
        throw new TypeError("base32.decode only takes Buffer or string as parameter");
      }
      let shiftIndex = 0;
      let plainDigit = 0;
      let plainChar;
      let plainPos = 0;
      if (!ArrayBuffer.isView(encoded)) {
        encoded = text2arr(encoded);
      }
      const decoded = new Uint8Array(Math.ceil(encoded.length * 5 / 8));
      for (let i2 = 0; i2 < encoded.length; i2++) {
        if (encoded[i2] === 61) {
          break;
        }
        const encodedByte = encoded[i2] - 48;
        if (encodedByte < byteTable.length) {
          plainDigit = byteTable[encodedByte];
          if (shiftIndex <= 3) {
            shiftIndex = (shiftIndex + 5) % 8;
            if (shiftIndex === 0) {
              plainChar |= plainDigit;
              decoded[plainPos] = plainChar;
              plainPos++;
              plainChar = 0;
            } else {
              plainChar |= 255 & plainDigit << 8 - shiftIndex;
            }
          } else {
            shiftIndex = (shiftIndex + 5) % 8;
            plainChar |= 255 & plainDigit >>> shiftIndex;
            decoded[plainPos] = plainChar;
            plainPos++;
            plainChar = 255 & plainDigit << 8 - shiftIndex;
          }
        } else {
          throw new Error("Invalid input - it is not base32 encoded string");
        }
      }
      return decoded.subarray(0, plainPos);
    };
    function parseRange(range) {
      const generateRange = (start, end = start) => Array.from({ length: end - start + 1 }, (cur, idx) => idx + start);
      return range.reduce((acc, cur, idx, arr2) => {
        const r2 = cur.split("-").map((cur2) => parseInt(cur2));
        return acc.concat(generateRange(...r2));
      }, []);
    }
    /*! magnet-uri. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> */
    function magnetURIDecode(uri) {
      const result = {};
      const data2 = uri.split("magnet:?")[1];
      const params = data2 && data2.length >= 0 ? data2.split("&") : [];
      params.forEach((param) => {
        const keyval = param.split("=");
        if (keyval.length !== 2)
          return;
        const key2 = keyval[0];
        let val2 = keyval[1];
        if (key2 === "dn")
          val2 = decodeURIComponent(val2).replace(/\+/g, " ");
        if (key2 === "tr" || key2 === "xs" || key2 === "as" || key2 === "ws") {
          val2 = decodeURIComponent(val2);
        }
        if (key2 === "kt")
          val2 = decodeURIComponent(val2).split("+");
        if (key2 === "ix")
          val2 = Number(val2);
        if (key2 === "so")
          val2 = parseRange(decodeURIComponent(val2).split(","));
        if (result[key2]) {
          if (!Array.isArray(result[key2])) {
            result[key2] = [result[key2]];
          }
          result[key2].push(val2);
        } else {
          result[key2] = val2;
        }
      });
      let m2;
      if (result.xt) {
        const xts = Array.isArray(result.xt) ? result.xt : [result.xt];
        xts.forEach((xt) => {
          if (m2 = xt.match(/^urn:btih:(.{40})/)) {
            result.infoHash = m2[1].toLowerCase();
          } else if (m2 = xt.match(/^urn:btih:(.{32})/)) {
            result.infoHash = arr2hex(decode(m2[1]));
          } else if (m2 = xt.match(/^urn:btmh:1220(.{64})/)) {
            result.infoHashV2 = m2[1].toLowerCase();
          }
        });
      }
      if (result.xs) {
        const xss = Array.isArray(result.xs) ? result.xs : [result.xs];
        xss.forEach((xs) => {
          if (m2 = xs.match(/^urn:btpk:(.{64})/)) {
            result.publicKey = m2[1].toLowerCase();
          }
        });
      }
      if (result.infoHash)
        result.infoHashBuffer = hex2arr(result.infoHash);
      if (result.infoHashV2)
        result.infoHashV2Buffer = hex2arr(result.infoHashV2);
      if (result.publicKey)
        result.publicKeyBuffer = hex2arr(result.publicKey);
      if (result.dn)
        result.name = result.dn;
      if (result.kt)
        result.keywords = result.kt;
      result.announce = [];
      if (typeof result.tr === "string" || Array.isArray(result.tr)) {
        result.announce = result.announce.concat(result.tr);
      }
      result.urlList = [];
      if (typeof result.as === "string" || Array.isArray(result.as)) {
        result.urlList = result.urlList.concat(result.as);
      }
      if (typeof result.ws === "string" || Array.isArray(result.ws)) {
        result.urlList = result.urlList.concat(result.ws);
      }
      result.peerAddresses = [];
      if (typeof result["x.pe"] === "string" || Array.isArray(result["x.pe"])) {
        result.peerAddresses = result.peerAddresses.concat(result["x.pe"]);
      }
      result.announce = Array.from(new Set(result.announce));
      result.urlList = Array.from(new Set(result.urlList));
      result.peerAddresses = Array.from(new Set(result.peerAddresses));
      return result;
    }
    /*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
    let promise;
    typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : commonjsGlobal) : (cb2) => (promise || (promise = Promise.resolve())).then(cb2).catch((err) => setTimeout(() => {
      throw err;
    }, 0));
    /*! parse-torrent. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> */
    async function parseTorrent(torrentId) {
      if (typeof torrentId === "string" && /^(stream-)?magnet:/.test(torrentId)) {
        const torrentObj = magnetURIDecode(torrentId);
        if (!torrentObj.infoHash) {
          throw new Error("Invalid torrent identifier");
        }
        return torrentObj;
      } else if (typeof torrentId === "string" && (/^[a-f0-9]{40}$/i.test(torrentId) || /^[a-z2-7]{32}$/i.test(torrentId))) {
        return magnetURIDecode(`magnet:?xt=urn:btih:${torrentId}`);
      } else if (ArrayBuffer.isView(torrentId) && torrentId.length === 20) {
        return magnetURIDecode(`magnet:?xt=urn:btih:${arr2hex(torrentId)}`);
      } else if (ArrayBuffer.isView(torrentId)) {
        return await decodeTorrentFile(torrentId);
      } else if (torrentId && torrentId.infoHash) {
        torrentId.infoHash = torrentId.infoHash.toLowerCase();
        if (!torrentId.announce)
          torrentId.announce = [];
        if (typeof torrentId.announce === "string") {
          torrentId.announce = [torrentId.announce];
        }
        if (!torrentId.urlList)
          torrentId.urlList = [];
        return torrentId;
      } else {
        throw new Error("Invalid torrent identifier");
      }
    }
    async function decodeTorrentFile(torrent) {
      if (ArrayBuffer.isView(torrent)) {
        torrent = bencode.decode(torrent);
      }
      ensure(torrent.info, "info");
      ensure(torrent.info["name.utf-8"] || torrent.info.name, "info.name");
      ensure(torrent.info["piece length"], "info['piece length']");
      ensure(torrent.info.pieces, "info.pieces");
      if (torrent.info.files) {
        torrent.info.files.forEach((file) => {
          ensure(typeof file.length === "number", "info.files[0].length");
          ensure(file["path.utf-8"] || file.path, "info.files[0].path");
        });
      } else {
        ensure(typeof torrent.info.length === "number", "info.length");
      }
      const result = {
        info: torrent.info,
        infoBuffer: bencode.encode(torrent.info),
        name: arr2text(torrent.info["name.utf-8"] || torrent.info.name),
        announce: []
      };
      result.infoHashBuffer = await hash(result.infoBuffer);
      result.infoHash = arr2hex(result.infoHashBuffer);
      if (torrent.info.private !== void 0)
        result.private = !!torrent.info.private;
      if (torrent["creation date"])
        result.created = new Date(torrent["creation date"] * 1e3);
      if (torrent["created by"])
        result.createdBy = arr2text(torrent["created by"]);
      if (ArrayBuffer.isView(torrent.comment))
        result.comment = arr2text(torrent.comment);
      if (Array.isArray(torrent["announce-list"]) && torrent["announce-list"].length > 0) {
        torrent["announce-list"].forEach((urls) => {
          urls.forEach((url) => {
            result.announce.push(arr2text(url));
          });
        });
      } else if (torrent.announce) {
        result.announce.push(arr2text(torrent.announce));
      }
      if (ArrayBuffer.isView(torrent["url-list"])) {
        torrent["url-list"] = torrent["url-list"].length > 0 ? [torrent["url-list"]] : [];
      }
      result.urlList = (torrent["url-list"] || []).map((url) => arr2text(url));
      result.announce = Array.from(new Set(result.announce));
      result.urlList = Array.from(new Set(result.urlList));
      const files = torrent.info.files || [torrent.info];
      result.files = files.map((file, i2) => {
        const parts = [].concat(result.name, file["path.utf-8"] || file.path || []).map((p2) => ArrayBuffer.isView(p2) ? arr2text(p2) : p2);
        return {
          path: path.join.apply(null, [path.sep].concat(parts)).slice(1),
          name: parts[parts.length - 1],
          length: file.length,
          offset: files.slice(0, i2).reduce(sumLength, 0)
        };
      });
      result.length = files.reduce(sumLength, 0);
      const lastFile = result.files[result.files.length - 1];
      result.pieceLength = torrent.info["piece length"];
      result.lastPieceLength = (lastFile.offset + lastFile.length) % result.pieceLength || result.pieceLength;
      result.pieces = splitPieces(torrent.info.pieces);
      return result;
    }
    function sumLength(sum2, file) {
      return sum2 + file.length;
    }
    function splitPieces(buf) {
      const pieces = [];
      for (let i2 = 0; i2 < buf.length; i2 += 20) {
        pieces.push(arr2hex(buf.slice(i2, i2 + 20)));
      }
      return pieces;
    }
    function ensure(bool, fieldName) {
      if (!bool)
        throw new Error(`Torrent is missing required field: ${fieldName}`);
    }
    var repacks = "yhgcf0";
    var repackButton = "yhgcf1";
    var container$1 = "_3ej6mq0";
    var downloadsPathField = "_3ej6mq1";
    var hintText = "_3ej6mq2";
    var downloaders$1 = "_3ej6mq3";
    var downloaderOption = "_3ej6mq4";
    var downloaderIcon = "_3ej6mq5";
    const downloaders = [Downloader.Torrent, Downloader.RealDebrid];
    function DownloadSettingsModal({
      visible,
      onClose,
      startDownload,
      repack
    }) {
      const { t: t2 } = useTranslation("game_details");
      const [diskFreeSpace, setDiskFreeSpace] = reactExports.useState(null);
      const [selectedPath, setSelectedPath] = reactExports.useState("");
      const [downloadStarting, setDownloadStarting] = reactExports.useState(false);
      const [selectedDownloader, setSelectedDownloader] = reactExports.useState(
        Downloader.Torrent
      );
      const userPreferences = useAppSelector(
        (state) => state.userPreferences.value
      );
      reactExports.useEffect(() => {
        if (visible) {
          getDiskFreeSpace(selectedPath);
        }
      }, [visible, selectedPath]);
      reactExports.useEffect(() => {
        if (userPreferences?.downloadsPath) {
          setSelectedPath(userPreferences.downloadsPath);
        } else {
          window.electron.getDefaultDownloadsPath().then((defaultDownloadsPath) => setSelectedPath(defaultDownloadsPath));
        }
        if (userPreferences?.realDebridApiToken)
          setSelectedDownloader(Downloader.RealDebrid);
      }, [userPreferences?.downloadsPath, userPreferences?.realDebridApiToken]);
      const getDiskFreeSpace = (path2) => {
        window.electron.getDiskFreeSpace(path2).then((result) => {
          setDiskFreeSpace(result);
        });
      };
      const handleChooseDownloadsPath = async () => {
        const { filePaths } = await window.electron.showOpenDialog({
          defaultPath: selectedPath,
          properties: ["openDirectory"]
        });
        if (filePaths && filePaths.length > 0) {
          const path2 = filePaths[0];
          setSelectedPath(path2);
        }
      };
      const handleStartClick = () => {
        if (repack) {
          setDownloadStarting(true);
          startDownload(repack, selectedDownloader, selectedPath).finally(() => {
            setDownloadStarting(false);
            onClose();
          });
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Modal,
        {
          visible,
          title: t2("download_settings"),
          description: t2("space_left_on_disk", {
            space: formatBytes(diskFreeSpace?.free ?? 0)
          }),
          onClose,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: container$1, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "span",
                {
                  style: {
                    marginBottom: `${SPACING_UNIT}px`,
                    display: "block"
                  },
                  children: t2("downloader")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: downloaders$1, children: downloaders.map((downloader) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Button,
                {
                  className: downloaderOption,
                  theme: selectedDownloader === downloader ? "primary" : "outline",
                  disabled: downloader === Downloader.RealDebrid && !userPreferences?.realDebridApiToken,
                  onClick: () => setSelectedDownloader(downloader),
                  children: [
                    selectedDownloader === downloader && /* @__PURE__ */ jsxRuntimeExports.jsx(CheckCircleFillIcon, { className: downloaderIcon }),
                    DOWNLOADER_NAME[downloader]
                  ]
                },
                downloader
              )) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                style: {
                  display: "flex",
                  flexDirection: "column",
                  gap: `${SPACING_UNIT}px`
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: downloadsPathField, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      TextField,
                      {
                        value: selectedPath,
                        readOnly: true,
                        disabled: true,
                        label: t2("download_path")
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Button,
                      {
                        style: { alignSelf: "flex-end" },
                        theme: "outline",
                        onClick: handleChooseDownloadsPath,
                        disabled: downloadStarting,
                        children: t2("change")
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: hintText, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trans, { i18nKey: "select_folder_hint", ns: "game_details", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: "/settings" }) }) })
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { onClick: handleStartClick, disabled: downloadStarting, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(DownloadIcon$1, {}),
              t2("download_now")
            ] })
          ] })
        }
      );
    }
    function RepacksModal({
      visible,
      startDownload,
      onClose
    }) {
      const [filteredRepacks, setFilteredRepacks] = reactExports.useState([]);
      const [repack, setRepack] = reactExports.useState(null);
      const [showSelectFolderModal, setShowSelectFolderModal] = reactExports.useState(false);
      const [infoHash, setInfoHash] = reactExports.useState(null);
      const { repacks: repacks$1, game } = reactExports.useContext(gameDetailsContext);
      const { t: t2 } = useTranslation("game_details");
      const sortedRepacks = reactExports.useMemo(() => {
        return orderBy(repacks$1, (repack2) => repack2.uploadDate, "desc");
      }, [repacks$1]);
      const getInfoHash = reactExports.useCallback(async () => {
        const torrent = await parseTorrent(game?.uri ?? "");
        if (torrent.infoHash)
          setInfoHash(torrent.infoHash);
      }, [game]);
      reactExports.useEffect(() => {
        setFilteredRepacks(sortedRepacks);
        if (game?.uri)
          getInfoHash();
      }, [sortedRepacks, visible, game, getInfoHash]);
      const handleRepackClick = (repack2) => {
        setRepack(repack2);
        setShowSelectFolderModal(true);
      };
      const handleFilter = (event) => {
        const term = event.target.value.toLocaleLowerCase();
        setFilteredRepacks(
          sortedRepacks.filter((repack2) => {
            const lowerCaseTitle = repack2.title.toLowerCase();
            const lowerCaseRepacker = repack2.repacker.toLowerCase();
            return [lowerCaseTitle, lowerCaseRepacker].some(
              (value2) => value2.includes(term)
            );
          })
        );
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          DownloadSettingsModal,
          {
            visible: showSelectFolderModal,
            onClose: () => setShowSelectFolderModal(false),
            startDownload,
            repack
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Modal,
          {
            visible,
            title: t2("download_options"),
            description: t2("repacks_modal_description"),
            onClose,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginBottom: `${SPACING_UNIT * 2}px` }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextField, { placeholder: t2("filter"), onChange: handleFilter }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: repacks, children: filteredRepacks.map((repack2) => {
                const isLastDownloadedOption = infoHash !== null && repack2.magnet.toLowerCase().includes(infoHash);
                return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Button,
                  {
                    theme: "dark",
                    onClick: () => handleRepackClick(repack2),
                    className: repackButton,
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { color: "#DADBE1", wordBreak: "break-word" }, children: repack2.title }),
                      isLastDownloadedOption && /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { children: t2("last_downloaded_option") }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { style: { fontSize: "12px" }, children: [
                        repack2.fileSize,
                        " - ",
                        repack2.repacker,
                        " -",
                        " ",
                        repack2.uploadDate ? format$1(repack2.uploadDate, "dd/MM/yyyy") : ""
                      ] })
                    ]
                  },
                  repack2.id
                );
              }) })
            ]
          }
        )
      ] });
    }
    var optionsContainer = "zcmkhd0";
    var gameOptionHeader = "zcmkhd1";
    var gameOptionHeaderDescription = "zcmkhd2";
    var gameOptionRow = "zcmkhd3";
    var deleteActionsButtonsCtn$1 = "r2l7mq0";
    function DeleteGameModal({
      onClose,
      visible,
      deleteGame
    }) {
      const { t: t2 } = useTranslation("downloads");
      const handleDeleteGame = () => {
        deleteGame();
        onClose();
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Modal,
        {
          visible,
          title: t2("delete_modal_title"),
          description: t2("delete_modal_description"),
          onClose,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: deleteActionsButtonsCtn$1, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: handleDeleteGame, theme: "outline", children: t2("delete") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: onClose, theme: "primary", children: t2("cancel") })
          ] })
        }
      );
    }
    var deleteActionsButtonsCtn = "_1v6ahyi0";
    function RemoveGameFromLibraryModal({
      onClose,
      game,
      visible,
      removeGameFromLibrary
    }) {
      const { t: t2 } = useTranslation("game_details");
      const handleRemoveGame = async () => {
        await removeGameFromLibrary();
        onClose();
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Modal,
        {
          visible,
          title: t2("remove_from_library_title"),
          description: t2("remove_from_library_description", { game: game.title }),
          onClose,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: deleteActionsButtonsCtn, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: handleRemoveGame, theme: "outline", children: t2("remove") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: onClose, theme: "primary", children: t2("cancel") })
          ] })
        }
      );
    }
    function GameOptionsModal({
      visible,
      game,
      onClose
    }) {
      const { t: t2 } = useTranslation("game_details");
      const { showSuccessToast, showErrorToast } = useToast();
      const { updateGame, setShowRepacksModal, repacks: repacks2, selectGameExecutable } = reactExports.useContext(gameDetailsContext);
      const [showDeleteModal, setShowDeleteModal] = reactExports.useState(false);
      const [showRemoveGameModal, setShowRemoveGameModal] = reactExports.useState(false);
      const {
        removeGameInstaller,
        removeGameFromLibrary,
        isGameDeleting,
        cancelDownload
      } = useDownload();
      const deleting = isGameDeleting(game.id);
      const { lastPacket } = useDownload();
      const isGameDownloading = game.status === "active" && lastPacket?.game.id === game.id;
      const handleRemoveGameFromLibrary = async () => {
        if (isGameDownloading) {
          await cancelDownload(game.id);
        }
        await removeGameFromLibrary(game.id);
        updateGame();
        onClose();
      };
      const handleChangeExecutableLocation = async () => {
        const path2 = await selectGameExecutable();
        if (path2) {
          await window.electron.updateExecutablePath(game.id, path2);
          updateGame();
        }
      };
      const handleCreateShortcut = async () => {
        window.electron.createGameShortcut(game.id).then((success) => {
          if (success) {
            showSuccessToast(t2("create_shortcut_success"));
          } else {
            showErrorToast(t2("create_shortcut_error"));
          }
        });
      };
      const handleOpenDownloadFolder = async () => {
        await window.electron.openGameInstallerPath(game.id);
      };
      const handleDeleteGame = async () => {
        await removeGameInstaller(game.id);
        updateGame();
      };
      const handleOpenGameExecutablePath = async () => {
        await window.electron.openGameExecutablePath(game.id);
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          DeleteGameModal,
          {
            visible: showDeleteModal,
            onClose: () => setShowDeleteModal(false),
            deleteGame: handleDeleteGame
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          RemoveGameFromLibraryModal,
          {
            visible: showRemoveGameModal,
            onClose: () => setShowRemoveGameModal(false),
            removeGameFromLibrary: handleRemoveGameFromLibrary,
            game
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Modal,
          {
            visible,
            title: game.title,
            onClose,
            large: true,
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: optionsContainer, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: gameOptionHeader, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("executable_section_title") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: gameOptionHeaderDescription, children: t2("executable_section_description") })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                TextField,
                {
                  value: game.executablePath || "",
                  readOnly: true,
                  theme: "dark",
                  disabled: true,
                  placeholder: t2("no_executable_selected"),
                  rightContent: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button,
                    {
                      type: "button",
                      theme: "outline",
                      onClick: handleChangeExecutableLocation,
                      children: t2("select_executable")
                    }
                  )
                }
              ),
              game.executablePath && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: gameOptionRow, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    type: "button",
                    theme: "outline",
                    onClick: handleOpenGameExecutablePath,
                    children: t2("open_folder")
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: handleCreateShortcut, theme: "outline", children: t2("create_shortcut") })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: gameOptionHeader, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("downloads_secion_title") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: gameOptionHeaderDescription, children: t2("downloads_section_description") })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: gameOptionRow, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    onClick: () => setShowRepacksModal(true),
                    theme: "outline",
                    disabled: deleting || isGameDownloading || !repacks2.length,
                    children: t2("open_download_options")
                  }
                ),
                game.downloadPath && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    onClick: handleOpenDownloadFolder,
                    theme: "outline",
                    disabled: deleting,
                    children: t2("open_download_location")
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: gameOptionHeader, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("danger_zone_section_title") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: gameOptionHeaderDescription, children: t2("danger_zone_section_description") })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: gameOptionRow, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    onClick: () => setShowRemoveGameModal(true),
                    theme: "danger",
                    disabled: deleting,
                    children: t2("remove_from_library")
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    onClick: () => {
                      setShowDeleteModal(true);
                    },
                    theme: "danger",
                    disabled: isGameDownloading || deleting || !game.downloadPath,
                    children: t2("remove_files")
                  }
                )
              ] })
            ] })
          }
        )
      ] });
    }
    function GameDetails() {
      const [randomGame, setRandomGame] = reactExports.useState(null);
      const [randomizerLocked, setRandomizerLocked] = reactExports.useState(false);
      const { objectID } = useParams();
      const [searchParams] = useSearchParams();
      const fromRandomizer = searchParams.get("fromRandomizer");
      const { startDownload } = useDownload();
      const { t: t2 } = useTranslation("game_details");
      const navigate = useNavigate();
      reactExports.useEffect(() => {
        setRandomGame(null);
        window.electron.getRandomGame().then((randomGame2) => {
          setRandomGame(randomGame2);
        });
      }, [objectID]);
      const handleRandomizerClick = () => {
        if (randomGame) {
          navigate(
            buildGameDetailsPath(
              { ...randomGame, shop: "steam" },
              { fromRandomizer: "1" }
            )
          );
          setRandomizerLocked(true);
          const zero = performance.now();
          requestAnimationFrame(function animateLock(time2) {
            if (time2 - zero <= 1e3) {
              requestAnimationFrame(animateLock);
            } else {
              setRandomizerLocked(false);
            }
          });
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(GameDetailsContextProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(GameDetailsContextConsumer, { children: ({
        isLoading,
        game,
        gameTitle,
        shop,
        showRepacksModal,
        showGameOptionsModal,
        updateGame,
        setShowRepacksModal,
        setShowGameOptionsModal
      }) => {
        const handleStartDownload = async (repack, downloader, downloadPath) => {
          await startDownload({
            repackId: repack.id,
            objectID,
            title: gameTitle,
            downloader,
            shop,
            downloadPath
          });
          await updateGame();
          setShowRepacksModal(false);
          setShowGameOptionsModal(false);
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          SkeletonTheme,
          {
            baseColor: vars.color.background,
            highlightColor: "#444",
            children: [
              isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx(GameDetailsSkeleton, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(GameDetailsContent, {}),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                RepacksModal,
                {
                  visible: showRepacksModal,
                  startDownload: handleStartDownload,
                  onClose: () => setShowRepacksModal(false)
                }
              ),
              game && /* @__PURE__ */ jsxRuntimeExports.jsx(
                GameOptionsModal,
                {
                  visible: showGameOptionsModal,
                  game,
                  onClose: () => {
                    setShowGameOptionsModal(false);
                  }
                }
              ),
              fromRandomizer && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Button,
                {
                  className: randomizerButton,
                  onClick: handleRandomizerClick,
                  theme: "outline",
                  disabled: !randomGame || randomizerLocked,
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { width: 16, height: 16, position: "relative" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Lottie,
                      {
                        animationData: starsAnimation,
                        style: {
                          width: 70,
                          position: "absolute",
                          top: -28,
                          left: -27
                        },
                        loop: true
                      }
                    ) }),
                    t2("next_suggestion")
                  ]
                }
              )
            ]
          }
        );
      } }) });
    }
    function BinaryNotFoundModal({
      visible,
      onClose
    }) {
      const { t: t2 } = useTranslation("binary_not_found_modal");
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Modal,
        {
          visible,
          title: t2("title"),
          description: t2("description"),
          onClose,
          children: t2("instructions")
        }
      );
    }
    var downloadsContainer = "ketd500";
    var downloadGroups = "ketd501";
    var arrowIcon = "ketd502";
    var noDownloads$1 = "ketd503";
    var downloadTitleWrapper = "v66w8q0";
    var downloadTitle = "v66w8q1";
    var downloads$l = "v66w8q2";
    var downloadCover = "v66w8q3";
    var downloadCoverContent = "v66w8q4";
    var downloadCoverBackdrop = "v66w8q5";
    var downloadCoverImage = "v66w8q6";
    var download = "v66w8q7";
    var downloadDetails = "v66w8q8";
    var downloadRightContent = "v66w8q9";
    var downloadActions = "v66w8qa";
    var downloadGroup = "v66w8qb";
    function DownloadGroup({
      library,
      title: title2,
      openDeleteGameModal,
      openGameInstaller
    }) {
      const navigate = useNavigate();
      const { t: t2 } = useTranslation("downloads");
      const userPreferences = useAppSelector(
        (state) => state.userPreferences.value
      );
      const {
        lastPacket,
        progress: progress2,
        pauseDownload,
        resumeDownload,
        cancelDownload,
        isGameDeleting
      } = useDownload();
      const getFinalDownloadSize = (game) => {
        const isGameDownloading = lastPacket?.game.id === game.id;
        if (game.fileSize)
          return formatBytes(game.fileSize);
        if (lastPacket?.game.fileSize && isGameDownloading)
          return formatBytes(lastPacket?.game.fileSize);
        return "N/A";
      };
      const getGameInfo = (game) => {
        const isGameDownloading = lastPacket?.game.id === game.id;
        const finalDownloadSize = getFinalDownloadSize(game);
        if (isGameDeleting(game.id)) {
          return /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("deleting") });
        }
        if (isGameDownloading) {
          if (lastPacket?.isDownloadingMetadata) {
            return /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("downloading_metadata") });
          }
          if (lastPacket?.isCheckingFiles) {
            return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: progress2 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("checking_files") })
            ] });
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: progress2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
              formatBytes(lastPacket?.game.bytesDownloaded),
              " /",
              " ",
              finalDownloadSize
            ] }),
            game.downloader === Downloader.Torrent && /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { children: [
              lastPacket?.numPeers,
              " peers / ",
              lastPacket?.numSeeds,
              " seeds"
            ] })
          ] });
        }
        if (game.progress === 1) {
          return /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("completed") });
        }
        if (game.status === "paused") {
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: formatDownloadProgress(game.progress) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2(game.downloadQueue && lastPacket ? "queued" : "paused") })
          ] });
        }
        if (game.status === "active") {
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: formatDownloadProgress(game.progress) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
              formatBytes(game.bytesDownloaded),
              " / ",
              finalDownloadSize
            ] })
          ] });
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2(game.status) });
      };
      const getGameActions = (game) => {
        const isGameDownloading = lastPacket?.game.id === game.id;
        const deleting = isGameDeleting(game.id);
        if (game.progress === 1) {
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                onClick: () => openGameInstaller(game.id),
                theme: "outline",
                disabled: deleting,
                children: t2("install")
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: () => openDeleteGameModal(game.id), theme: "outline", children: t2("delete") })
          ] });
        }
        if (isGameDownloading || game.status === "active") {
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: () => pauseDownload(game.id), theme: "outline", children: t2("pause") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: () => cancelDownload(game.id), theme: "outline", children: t2("cancel") })
          ] });
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              onClick: () => resumeDownload(game.id),
              theme: "outline",
              disabled: game.downloader === Downloader.RealDebrid && !userPreferences?.realDebridApiToken,
              children: t2("resume")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: () => cancelDownload(game.id), theme: "outline", children: t2("cancel") })
        ] });
      };
      if (!library.length)
        return null;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: downloadGroup, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              display: "flex",
              alignItems: "center",
              justifyContent: "space-between",
              gap: `${SPACING_UNIT * 2}px`
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: title2 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: {
                    flex: 1,
                    backgroundColor: vars.color.border,
                    height: "1px"
                  }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { style: { fontWeight: "400" }, children: library.length })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: downloads$l, children: library.map((game) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: download, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: downloadCover, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: downloadCoverBackdrop, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "img",
                {
                  src: steamUrlBuilder.library(game.objectID),
                  className: downloadCoverImage,
                  alt: game.title
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: downloadCoverContent, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { children: DOWNLOADER_NAME[game.downloader] }) })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: downloadRightContent, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: downloadDetails, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: downloadTitleWrapper, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    className: downloadTitle,
                    onClick: () => navigate(buildGameDetailsPath(game)),
                    children: game.title
                  }
                ) }),
                getGameInfo(game)
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: downloadActions, children: getGameActions(game) })
            ] })
          ] }, game.id);
        }) })
      ] });
    }
    function Downloads() {
      const { library, updateLibrary } = useLibrary();
      const { t: t2 } = useTranslation("downloads");
      const gameToBeDeleted = reactExports.useRef(null);
      const [showBinaryNotFoundModal, setShowBinaryNotFoundModal] = reactExports.useState(false);
      const [showDeleteModal, setShowDeleteModal] = reactExports.useState(false);
      const { removeGameInstaller } = useDownload();
      const handleDeleteGame = async () => {
        if (gameToBeDeleted.current)
          await removeGameInstaller(gameToBeDeleted.current);
      };
      const { lastPacket } = useDownload();
      const handleOpenGameInstaller = (gameId) => window.electron.openGameInstaller(gameId).then((isBinaryInPath) => {
        if (!isBinaryInPath)
          setShowBinaryNotFoundModal(true);
        updateLibrary();
      });
      const handleOpenDeleteGameModal = (gameId) => {
        gameToBeDeleted.current = gameId;
        setShowDeleteModal(true);
      };
      const libraryGroup = reactExports.useMemo(() => {
        const initialValue = {
          downloading: [],
          queued: [],
          complete: []
        };
        const result = library.reduce((prev, next) => {
          if (!next.status || next.status === "removed")
            return prev;
          if (lastPacket?.game.id === next.id)
            return { ...prev, downloading: [...prev.downloading, next] };
          if (next.downloadQueue || next.status === "paused")
            return { ...prev, queued: [...prev.queued, next] };
          return { ...prev, complete: [...prev.complete, next] };
        }, initialValue);
        const queued = orderBy(
          result.queued,
          (game) => game.downloadQueue?.id ?? -1,
          ["desc"]
        );
        const complete = orderBy(
          result.complete,
          (game) => game.progress === 1 ? 0 : 1
        );
        return {
          ...result,
          queued,
          complete
        };
      }, [library, lastPacket?.game.id]);
      const downloadGroups$1 = [
        {
          title: t2("download_in_progress"),
          library: libraryGroup.downloading
        },
        {
          title: t2("queued_downloads"),
          library: libraryGroup.queued
        },
        {
          title: t2("downloads_completed"),
          library: libraryGroup.complete
        }
      ];
      const hasItemsInLibrary = reactExports.useMemo(() => {
        return Object.values(libraryGroup).some((group) => group.length > 0);
      }, [libraryGroup]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          BinaryNotFoundModal,
          {
            visible: showBinaryNotFoundModal,
            onClose: () => setShowBinaryNotFoundModal(false)
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          DeleteGameModal,
          {
            visible: showDeleteModal,
            onClose: () => setShowDeleteModal(false),
            deleteGame: handleDeleteGame
          }
        ),
        hasItemsInLibrary ? /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: downloadsContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: downloadGroups, children: downloadGroups$1.map((group) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          DownloadGroup,
          {
            title: group.title,
            library: group.library,
            openDeleteGameModal: handleOpenDeleteGameModal,
            openGameInstaller: handleOpenGameInstaller
          },
          group.title
        )) }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: noDownloads$1, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: arrowIcon, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowDownIcon, { size: 24 }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("no_downloads_title") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontFamily: "Fira Sans" }, children: t2("no_downloads_description") })
        ] })
      ] });
    }
    var lodash = { exports: {} };
    /**
     * @license
     * Lodash <https://lodash.com/>
     * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
     * Released under MIT license <https://lodash.com/license>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     */
    lodash.exports;
    (function(module2, exports2) {
      (function() {
        var undefined$1;
        var VERSION = "4.17.21";
        var LARGE_ARRAY_SIZE2 = 200;
        var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT2 = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
        var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
        var MAX_MEMOIZE_SIZE2 = 500;
        var PLACEHOLDER = "__lodash_placeholder__";
        var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
        var COMPARE_PARTIAL_FLAG2 = 1, COMPARE_UNORDERED_FLAG2 = 2;
        var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
        var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
        var HOT_COUNT2 = 800, HOT_SPAN2 = 16;
        var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
        var INFINITY2 = 1 / 0, MAX_SAFE_INTEGER2 = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
        var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var wrapFlags = [
          ["ary", WRAP_ARY_FLAG],
          ["bind", WRAP_BIND_FLAG],
          ["bindKey", WRAP_BIND_KEY_FLAG],
          ["curry", WRAP_CURRY_FLAG],
          ["curryRight", WRAP_CURRY_RIGHT_FLAG],
          ["flip", WRAP_FLIP_FLAG],
          ["partial", WRAP_PARTIAL_FLAG],
          ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
          ["rearg", WRAP_REARG_FLAG]
        ];
        var argsTag2 = "[object Arguments]", arrayTag2 = "[object Array]", asyncTag2 = "[object AsyncFunction]", boolTag2 = "[object Boolean]", dateTag2 = "[object Date]", domExcTag = "[object DOMException]", errorTag2 = "[object Error]", funcTag2 = "[object Function]", genTag2 = "[object GeneratorFunction]", mapTag2 = "[object Map]", numberTag2 = "[object Number]", nullTag2 = "[object Null]", objectTag2 = "[object Object]", promiseTag2 = "[object Promise]", proxyTag2 = "[object Proxy]", regexpTag2 = "[object RegExp]", setTag2 = "[object Set]", stringTag2 = "[object String]", symbolTag2 = "[object Symbol]", undefinedTag2 = "[object Undefined]", weakMapTag2 = "[object WeakMap]", weakSetTag = "[object WeakSet]";
        var arrayBufferTag2 = "[object ArrayBuffer]", dataViewTag2 = "[object DataView]", float32Tag2 = "[object Float32Array]", float64Tag2 = "[object Float64Array]", int8Tag2 = "[object Int8Array]", int16Tag2 = "[object Int16Array]", int32Tag2 = "[object Int32Array]", uint8Tag2 = "[object Uint8Array]", uint8ClampedTag2 = "[object Uint8ClampedArray]", uint16Tag2 = "[object Uint16Array]", uint32Tag2 = "[object Uint32Array]";
        var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
        var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
        var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
        var reIsDeepProp2 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp2 = /^\w*$/, rePropName2 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar2.source);
        var reTrimStart = /^\s+/;
        var reWhitespace = /\s/;
        var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
        var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
        var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
        var reEscapeChar2 = /\\(\\)?/g;
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
        var reFlags = /\w*$/;
        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
        var reIsBinary = /^0b[01]+$/i;
        var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
        var reIsOctal = /^0o[0-7]+$/i;
        var reIsUint2 = /^(?:0|[1-9]\d*)$/;
        var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
        var reNoMatch = /($^)/;
        var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
        var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
        var rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
        var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
        var reApos = RegExp(rsApos, "g");
        var reComboMark = RegExp(rsCombo, "g");
        var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
        var reUnicodeWord = RegExp([
          rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
          rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
          rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
          rsUpper + "+" + rsOptContrUpper,
          rsOrdUpper,
          rsOrdLower,
          rsDigits,
          rsEmoji
        ].join("|"), "g");
        var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
        var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
        var contextProps = [
          "Array",
          "Buffer",
          "DataView",
          "Date",
          "Error",
          "Float32Array",
          "Float64Array",
          "Function",
          "Int8Array",
          "Int16Array",
          "Int32Array",
          "Map",
          "Math",
          "Object",
          "Promise",
          "RegExp",
          "Set",
          "String",
          "Symbol",
          "TypeError",
          "Uint8Array",
          "Uint8ClampedArray",
          "Uint16Array",
          "Uint32Array",
          "WeakMap",
          "_",
          "clearTimeout",
          "isFinite",
          "parseInt",
          "setTimeout"
        ];
        var templateCounter = -1;
        var typedArrayTags2 = {};
        typedArrayTags2[float32Tag2] = typedArrayTags2[float64Tag2] = typedArrayTags2[int8Tag2] = typedArrayTags2[int16Tag2] = typedArrayTags2[int32Tag2] = typedArrayTags2[uint8Tag2] = typedArrayTags2[uint8ClampedTag2] = typedArrayTags2[uint16Tag2] = typedArrayTags2[uint32Tag2] = true;
        typedArrayTags2[argsTag2] = typedArrayTags2[arrayTag2] = typedArrayTags2[arrayBufferTag2] = typedArrayTags2[boolTag2] = typedArrayTags2[dataViewTag2] = typedArrayTags2[dateTag2] = typedArrayTags2[errorTag2] = typedArrayTags2[funcTag2] = typedArrayTags2[mapTag2] = typedArrayTags2[numberTag2] = typedArrayTags2[objectTag2] = typedArrayTags2[regexpTag2] = typedArrayTags2[setTag2] = typedArrayTags2[stringTag2] = typedArrayTags2[weakMapTag2] = false;
        var cloneableTags = {};
        cloneableTags[argsTag2] = cloneableTags[arrayTag2] = cloneableTags[arrayBufferTag2] = cloneableTags[dataViewTag2] = cloneableTags[boolTag2] = cloneableTags[dateTag2] = cloneableTags[float32Tag2] = cloneableTags[float64Tag2] = cloneableTags[int8Tag2] = cloneableTags[int16Tag2] = cloneableTags[int32Tag2] = cloneableTags[mapTag2] = cloneableTags[numberTag2] = cloneableTags[objectTag2] = cloneableTags[regexpTag2] = cloneableTags[setTag2] = cloneableTags[stringTag2] = cloneableTags[symbolTag2] = cloneableTags[uint8Tag2] = cloneableTags[uint8ClampedTag2] = cloneableTags[uint16Tag2] = cloneableTags[uint32Tag2] = true;
        cloneableTags[errorTag2] = cloneableTags[funcTag2] = cloneableTags[weakMapTag2] = false;
        var deburredLetters = {
          // Latin-1 Supplement block.
          "À": "A",
          "Á": "A",
          "Â": "A",
          "Ã": "A",
          "Ä": "A",
          "Å": "A",
          "à": "a",
          "á": "a",
          "â": "a",
          "ã": "a",
          "ä": "a",
          "å": "a",
          "Ç": "C",
          "ç": "c",
          "Ð": "D",
          "ð": "d",
          "È": "E",
          "É": "E",
          "Ê": "E",
          "Ë": "E",
          "è": "e",
          "é": "e",
          "ê": "e",
          "ë": "e",
          "Ì": "I",
          "Í": "I",
          "Î": "I",
          "Ï": "I",
          "ì": "i",
          "í": "i",
          "î": "i",
          "ï": "i",
          "Ñ": "N",
          "ñ": "n",
          "Ò": "O",
          "Ó": "O",
          "Ô": "O",
          "Õ": "O",
          "Ö": "O",
          "Ø": "O",
          "ò": "o",
          "ó": "o",
          "ô": "o",
          "õ": "o",
          "ö": "o",
          "ø": "o",
          "Ù": "U",
          "Ú": "U",
          "Û": "U",
          "Ü": "U",
          "ù": "u",
          "ú": "u",
          "û": "u",
          "ü": "u",
          "Ý": "Y",
          "ý": "y",
          "ÿ": "y",
          "Æ": "Ae",
          "æ": "ae",
          "Þ": "Th",
          "þ": "th",
          "ß": "ss",
          // Latin Extended-A block.
          "Ā": "A",
          "Ă": "A",
          "Ą": "A",
          "ā": "a",
          "ă": "a",
          "ą": "a",
          "Ć": "C",
          "Ĉ": "C",
          "Ċ": "C",
          "Č": "C",
          "ć": "c",
          "ĉ": "c",
          "ċ": "c",
          "č": "c",
          "Ď": "D",
          "Đ": "D",
          "ď": "d",
          "đ": "d",
          "Ē": "E",
          "Ĕ": "E",
          "Ė": "E",
          "Ę": "E",
          "Ě": "E",
          "ē": "e",
          "ĕ": "e",
          "ė": "e",
          "ę": "e",
          "ě": "e",
          "Ĝ": "G",
          "Ğ": "G",
          "Ġ": "G",
          "Ģ": "G",
          "ĝ": "g",
          "ğ": "g",
          "ġ": "g",
          "ģ": "g",
          "Ĥ": "H",
          "Ħ": "H",
          "ĥ": "h",
          "ħ": "h",
          "Ĩ": "I",
          "Ī": "I",
          "Ĭ": "I",
          "Į": "I",
          "İ": "I",
          "ĩ": "i",
          "ī": "i",
          "ĭ": "i",
          "į": "i",
          "ı": "i",
          "Ĵ": "J",
          "ĵ": "j",
          "Ķ": "K",
          "ķ": "k",
          "ĸ": "k",
          "Ĺ": "L",
          "Ļ": "L",
          "Ľ": "L",
          "Ŀ": "L",
          "Ł": "L",
          "ĺ": "l",
          "ļ": "l",
          "ľ": "l",
          "ŀ": "l",
          "ł": "l",
          "Ń": "N",
          "Ņ": "N",
          "Ň": "N",
          "Ŋ": "N",
          "ń": "n",
          "ņ": "n",
          "ň": "n",
          "ŋ": "n",
          "Ō": "O",
          "Ŏ": "O",
          "Ő": "O",
          "ō": "o",
          "ŏ": "o",
          "ő": "o",
          "Ŕ": "R",
          "Ŗ": "R",
          "Ř": "R",
          "ŕ": "r",
          "ŗ": "r",
          "ř": "r",
          "Ś": "S",
          "Ŝ": "S",
          "Ş": "S",
          "Š": "S",
          "ś": "s",
          "ŝ": "s",
          "ş": "s",
          "š": "s",
          "Ţ": "T",
          "Ť": "T",
          "Ŧ": "T",
          "ţ": "t",
          "ť": "t",
          "ŧ": "t",
          "Ũ": "U",
          "Ū": "U",
          "Ŭ": "U",
          "Ů": "U",
          "Ű": "U",
          "Ų": "U",
          "ũ": "u",
          "ū": "u",
          "ŭ": "u",
          "ů": "u",
          "ű": "u",
          "ų": "u",
          "Ŵ": "W",
          "ŵ": "w",
          "Ŷ": "Y",
          "ŷ": "y",
          "Ÿ": "Y",
          "Ź": "Z",
          "Ż": "Z",
          "Ž": "Z",
          "ź": "z",
          "ż": "z",
          "ž": "z",
          "Ĳ": "IJ",
          "ĳ": "ij",
          "Œ": "Oe",
          "œ": "oe",
          "ŉ": "'n",
          "ſ": "s"
        };
        var htmlEscapes = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;"
        };
        var htmlUnescapes = {
          "&amp;": "&",
          "&lt;": "<",
          "&gt;": ">",
          "&quot;": '"',
          "&#39;": "'"
        };
        var stringEscapes = {
          "\\": "\\",
          "'": "'",
          "\n": "n",
          "\r": "r",
          "\u2028": "u2028",
          "\u2029": "u2029"
        };
        var freeParseFloat = parseFloat, freeParseInt = parseInt;
        var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
        var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
        var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
        var freeExports2 = exports2 && !exports2.nodeType && exports2;
        var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
        var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
        var freeProcess2 = moduleExports2 && freeGlobal2.process;
        var nodeUtil2 = function() {
          try {
            var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
            if (types) {
              return types;
            }
            return freeProcess2 && freeProcess2.binding && freeProcess2.binding("util");
          } catch (e2) {
          }
        }();
        var nodeIsArrayBuffer = nodeUtil2 && nodeUtil2.isArrayBuffer, nodeIsDate = nodeUtil2 && nodeUtil2.isDate, nodeIsMap = nodeUtil2 && nodeUtil2.isMap, nodeIsRegExp = nodeUtil2 && nodeUtil2.isRegExp, nodeIsSet = nodeUtil2 && nodeUtil2.isSet, nodeIsTypedArray2 = nodeUtil2 && nodeUtil2.isTypedArray;
        function apply2(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);
            case 1:
              return func.call(thisArg, args[0]);
            case 2:
              return func.call(thisArg, args[0], args[1]);
            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }
          return func.apply(thisArg, args);
        }
        function arrayAggregator(array, setter, iteratee, accumulator) {
          var index2 = -1, length2 = array == null ? 0 : array.length;
          while (++index2 < length2) {
            var value2 = array[index2];
            setter(accumulator, value2, iteratee(value2), array);
          }
          return accumulator;
        }
        function arrayEach(array, iteratee) {
          var index2 = -1, length2 = array == null ? 0 : array.length;
          while (++index2 < length2) {
            if (iteratee(array[index2], index2, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEachRight(array, iteratee) {
          var length2 = array == null ? 0 : array.length;
          while (length2--) {
            if (iteratee(array[length2], length2, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEvery(array, predicate) {
          var index2 = -1, length2 = array == null ? 0 : array.length;
          while (++index2 < length2) {
            if (!predicate(array[index2], index2, array)) {
              return false;
            }
          }
          return true;
        }
        function arrayFilter2(array, predicate) {
          var index2 = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
          while (++index2 < length2) {
            var value2 = array[index2];
            if (predicate(value2, index2, array)) {
              result[resIndex++] = value2;
            }
          }
          return result;
        }
        function arrayIncludes(array, value2) {
          var length2 = array == null ? 0 : array.length;
          return !!length2 && baseIndexOf(array, value2, 0) > -1;
        }
        function arrayIncludesWith(array, value2, comparator) {
          var index2 = -1, length2 = array == null ? 0 : array.length;
          while (++index2 < length2) {
            if (comparator(value2, array[index2])) {
              return true;
            }
          }
          return false;
        }
        function arrayMap2(array, iteratee) {
          var index2 = -1, length2 = array == null ? 0 : array.length, result = Array(length2);
          while (++index2 < length2) {
            result[index2] = iteratee(array[index2], index2, array);
          }
          return result;
        }
        function arrayPush2(array, values) {
          var index2 = -1, length2 = values.length, offset = array.length;
          while (++index2 < length2) {
            array[offset + index2] = values[index2];
          }
          return array;
        }
        function arrayReduce(array, iteratee, accumulator, initAccum) {
          var index2 = -1, length2 = array == null ? 0 : array.length;
          if (initAccum && length2) {
            accumulator = array[++index2];
          }
          while (++index2 < length2) {
            accumulator = iteratee(accumulator, array[index2], index2, array);
          }
          return accumulator;
        }
        function arrayReduceRight(array, iteratee, accumulator, initAccum) {
          var length2 = array == null ? 0 : array.length;
          if (initAccum && length2) {
            accumulator = array[--length2];
          }
          while (length2--) {
            accumulator = iteratee(accumulator, array[length2], length2, array);
          }
          return accumulator;
        }
        function arraySome2(array, predicate) {
          var index2 = -1, length2 = array == null ? 0 : array.length;
          while (++index2 < length2) {
            if (predicate(array[index2], index2, array)) {
              return true;
            }
          }
          return false;
        }
        var asciiSize = baseProperty2("length");
        function asciiToArray(string) {
          return string.split("");
        }
        function asciiWords(string) {
          return string.match(reAsciiWord) || [];
        }
        function baseFindKey(collection, predicate, eachFunc) {
          var result;
          eachFunc(collection, function(value2, key2, collection2) {
            if (predicate(value2, key2, collection2)) {
              result = key2;
              return false;
            }
          });
          return result;
        }
        function baseFindIndex(array, predicate, fromIndex, fromRight) {
          var length2 = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
          while (fromRight ? index2-- : ++index2 < length2) {
            if (predicate(array[index2], index2, array)) {
              return index2;
            }
          }
          return -1;
        }
        function baseIndexOf(array, value2, fromIndex) {
          return value2 === value2 ? strictIndexOf(array, value2, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
        }
        function baseIndexOfWith(array, value2, fromIndex, comparator) {
          var index2 = fromIndex - 1, length2 = array.length;
          while (++index2 < length2) {
            if (comparator(array[index2], value2)) {
              return index2;
            }
          }
          return -1;
        }
        function baseIsNaN(value2) {
          return value2 !== value2;
        }
        function baseMean(array, iteratee) {
          var length2 = array == null ? 0 : array.length;
          return length2 ? baseSum(array, iteratee) / length2 : NAN;
        }
        function baseProperty2(key2) {
          return function(object) {
            return object == null ? undefined$1 : object[key2];
          };
        }
        function basePropertyOf(object) {
          return function(key2) {
            return object == null ? undefined$1 : object[key2];
          };
        }
        function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
          eachFunc(collection, function(value2, index2, collection2) {
            accumulator = initAccum ? (initAccum = false, value2) : iteratee(accumulator, value2, index2, collection2);
          });
          return accumulator;
        }
        function baseSortBy2(array, comparer) {
          var length2 = array.length;
          array.sort(comparer);
          while (length2--) {
            array[length2] = array[length2].value;
          }
          return array;
        }
        function baseSum(array, iteratee) {
          var result, index2 = -1, length2 = array.length;
          while (++index2 < length2) {
            var current2 = iteratee(array[index2]);
            if (current2 !== undefined$1) {
              result = result === undefined$1 ? current2 : result + current2;
            }
          }
          return result;
        }
        function baseTimes2(n2, iteratee) {
          var index2 = -1, result = Array(n2);
          while (++index2 < n2) {
            result[index2] = iteratee(index2);
          }
          return result;
        }
        function baseToPairs(object, props) {
          return arrayMap2(props, function(key2) {
            return [key2, object[key2]];
          });
        }
        function baseTrim(string) {
          return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
        }
        function baseUnary2(func) {
          return function(value2) {
            return func(value2);
          };
        }
        function baseValues(object, props) {
          return arrayMap2(props, function(key2) {
            return object[key2];
          });
        }
        function cacheHas2(cache, key2) {
          return cache.has(key2);
        }
        function charsStartIndex(strSymbols, chrSymbols) {
          var index2 = -1, length2 = strSymbols.length;
          while (++index2 < length2 && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
          }
          return index2;
        }
        function charsEndIndex(strSymbols, chrSymbols) {
          var index2 = strSymbols.length;
          while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
          }
          return index2;
        }
        function countHolders(array, placeholder) {
          var length2 = array.length, result = 0;
          while (length2--) {
            if (array[length2] === placeholder) {
              ++result;
            }
          }
          return result;
        }
        var deburrLetter = basePropertyOf(deburredLetters);
        var escapeHtmlChar = basePropertyOf(htmlEscapes);
        function escapeStringChar(chr) {
          return "\\" + stringEscapes[chr];
        }
        function getValue2(object, key2) {
          return object == null ? undefined$1 : object[key2];
        }
        function hasUnicode(string) {
          return reHasUnicode.test(string);
        }
        function hasUnicodeWord(string) {
          return reHasUnicodeWord.test(string);
        }
        function iteratorToArray(iterator) {
          var data2, result = [];
          while (!(data2 = iterator.next()).done) {
            result.push(data2.value);
          }
          return result;
        }
        function mapToArray2(map) {
          var index2 = -1, result = Array(map.size);
          map.forEach(function(value2, key2) {
            result[++index2] = [key2, value2];
          });
          return result;
        }
        function overArg2(func, transform2) {
          return function(arg) {
            return func(transform2(arg));
          };
        }
        function replaceHolders(array, placeholder) {
          var index2 = -1, length2 = array.length, resIndex = 0, result = [];
          while (++index2 < length2) {
            var value2 = array[index2];
            if (value2 === placeholder || value2 === PLACEHOLDER) {
              array[index2] = PLACEHOLDER;
              result[resIndex++] = index2;
            }
          }
          return result;
        }
        function setToArray2(set2) {
          var index2 = -1, result = Array(set2.size);
          set2.forEach(function(value2) {
            result[++index2] = value2;
          });
          return result;
        }
        function setToPairs(set2) {
          var index2 = -1, result = Array(set2.size);
          set2.forEach(function(value2) {
            result[++index2] = [value2, value2];
          });
          return result;
        }
        function strictIndexOf(array, value2, fromIndex) {
          var index2 = fromIndex - 1, length2 = array.length;
          while (++index2 < length2) {
            if (array[index2] === value2) {
              return index2;
            }
          }
          return -1;
        }
        function strictLastIndexOf(array, value2, fromIndex) {
          var index2 = fromIndex + 1;
          while (index2--) {
            if (array[index2] === value2) {
              return index2;
            }
          }
          return index2;
        }
        function stringSize(string) {
          return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
        }
        function stringToArray(string) {
          return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
        }
        function trimmedEndIndex(string) {
          var index2 = string.length;
          while (index2-- && reWhitespace.test(string.charAt(index2))) {
          }
          return index2;
        }
        var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
        function unicodeSize(string) {
          var result = reUnicode.lastIndex = 0;
          while (reUnicode.test(string)) {
            ++result;
          }
          return result;
        }
        function unicodeToArray(string) {
          return string.match(reUnicode) || [];
        }
        function unicodeWords(string) {
          return string.match(reUnicodeWord) || [];
        }
        var runInContext = function runInContext2(context) {
          context = context == null ? root2 : _.defaults(root2.Object(), context, _.pick(root2, contextProps));
          var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
          var arrayProto2 = Array2.prototype, funcProto2 = Function2.prototype, objectProto2 = Object2.prototype;
          var coreJsData2 = context["__core-js_shared__"];
          var funcToString2 = funcProto2.toString;
          var hasOwnProperty2 = objectProto2.hasOwnProperty;
          var idCounter = 0;
          var maskSrcKey2 = function() {
            var uid = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
            return uid ? "Symbol(src)_1." + uid : "";
          }();
          var nativeObjectToString2 = objectProto2.toString;
          var objectCtorString2 = funcToString2.call(Object2);
          var oldDash = root2._;
          var reIsNative2 = RegExp2(
            "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
          );
          var Buffer2 = moduleExports2 ? context.Buffer : undefined$1, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined$1, getPrototype = overArg2(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable2 = objectProto2.propertyIsEnumerable, splice2 = arrayProto2.splice, spreadableSymbol2 = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag2 = Symbol2 ? Symbol2.toStringTag : undefined$1;
          var defineProperty2 = function() {
            try {
              var func = getNative2(Object2, "defineProperty");
              func({}, "", {});
              return func;
            } catch (e2) {
            }
          }();
          var ctxClearTimeout = context.clearTimeout !== root2.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root2.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root2.setTimeout && context.setTimeout;
          var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols2 = Object2.getOwnPropertySymbols, nativeIsBuffer2 = Buffer2 ? Buffer2.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto2.join, nativeKeys2 = overArg2(Object2.keys, Object2), nativeMax2 = Math2.max, nativeMin = Math2.min, nativeNow2 = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto2.reverse;
          var DataView2 = getNative2(context, "DataView"), Map2 = getNative2(context, "Map"), Promise2 = getNative2(context, "Promise"), Set2 = getNative2(context, "Set"), WeakMap2 = getNative2(context, "WeakMap"), nativeCreate2 = getNative2(Object2, "create");
          var metaMap = WeakMap2 && new WeakMap2();
          var realNames = {};
          var dataViewCtorString2 = toSource2(DataView2), mapCtorString2 = toSource2(Map2), promiseCtorString2 = toSource2(Promise2), setCtorString2 = toSource2(Set2), weakMapCtorString2 = toSource2(WeakMap2);
          var symbolProto2 = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf2 = symbolProto2 ? symbolProto2.valueOf : undefined$1, symbolToString2 = symbolProto2 ? symbolProto2.toString : undefined$1;
          function lodash2(value2) {
            if (isObjectLike2(value2) && !isArray2(value2) && !(value2 instanceof LazyWrapper)) {
              if (value2 instanceof LodashWrapper) {
                return value2;
              }
              if (hasOwnProperty2.call(value2, "__wrapped__")) {
                return wrapperClone(value2);
              }
            }
            return new LodashWrapper(value2);
          }
          var baseCreate = /* @__PURE__ */ function() {
            function object() {
            }
            return function(proto) {
              if (!isObject2(proto)) {
                return {};
              }
              if (objectCreate) {
                return objectCreate(proto);
              }
              object.prototype = proto;
              var result2 = new object();
              object.prototype = undefined$1;
              return result2;
            };
          }();
          function baseLodash() {
          }
          function LodashWrapper(value2, chainAll) {
            this.__wrapped__ = value2;
            this.__actions__ = [];
            this.__chain__ = !!chainAll;
            this.__index__ = 0;
            this.__values__ = undefined$1;
          }
          lodash2.templateSettings = {
            /**
             * Used to detect `data` property values to be HTML-escaped.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "escape": reEscape,
            /**
             * Used to detect code to be evaluated.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "evaluate": reEvaluate,
            /**
             * Used to detect `data` property values to inject.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "interpolate": reInterpolate,
            /**
             * Used to reference the data object in the template text.
             *
             * @memberOf _.templateSettings
             * @type {string}
             */
            "variable": "",
            /**
             * Used to import variables into the compiled template.
             *
             * @memberOf _.templateSettings
             * @type {Object}
             */
            "imports": {
              /**
               * A reference to the `lodash` function.
               *
               * @memberOf _.templateSettings.imports
               * @type {Function}
               */
              "_": lodash2
            }
          };
          lodash2.prototype = baseLodash.prototype;
          lodash2.prototype.constructor = lodash2;
          LodashWrapper.prototype = baseCreate(baseLodash.prototype);
          LodashWrapper.prototype.constructor = LodashWrapper;
          function LazyWrapper(value2) {
            this.__wrapped__ = value2;
            this.__actions__ = [];
            this.__dir__ = 1;
            this.__filtered__ = false;
            this.__iteratees__ = [];
            this.__takeCount__ = MAX_ARRAY_LENGTH;
            this.__views__ = [];
          }
          function lazyClone() {
            var result2 = new LazyWrapper(this.__wrapped__);
            result2.__actions__ = copyArray(this.__actions__);
            result2.__dir__ = this.__dir__;
            result2.__filtered__ = this.__filtered__;
            result2.__iteratees__ = copyArray(this.__iteratees__);
            result2.__takeCount__ = this.__takeCount__;
            result2.__views__ = copyArray(this.__views__);
            return result2;
          }
          function lazyReverse() {
            if (this.__filtered__) {
              var result2 = new LazyWrapper(this);
              result2.__dir__ = -1;
              result2.__filtered__ = true;
            } else {
              result2 = this.clone();
              result2.__dir__ *= -1;
            }
            return result2;
          }
          function lazyValue() {
            var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length2 = end - start, index2 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length2, this.__takeCount__);
            if (!isArr || !isRight && arrLength == length2 && takeCount == length2) {
              return baseWrapperValue(array, this.__actions__);
            }
            var result2 = [];
            outer:
              while (length2-- && resIndex < takeCount) {
                index2 += dir;
                var iterIndex = -1, value2 = array[index2];
                while (++iterIndex < iterLength) {
                  var data2 = iteratees[iterIndex], iteratee2 = data2.iteratee, type = data2.type, computed = iteratee2(value2);
                  if (type == LAZY_MAP_FLAG) {
                    value2 = computed;
                  } else if (!computed) {
                    if (type == LAZY_FILTER_FLAG) {
                      continue outer;
                    } else {
                      break outer;
                    }
                  }
                }
                result2[resIndex++] = value2;
              }
            return result2;
          }
          LazyWrapper.prototype = baseCreate(baseLodash.prototype);
          LazyWrapper.prototype.constructor = LazyWrapper;
          function Hash2(entries) {
            var index2 = -1, length2 = entries == null ? 0 : entries.length;
            this.clear();
            while (++index2 < length2) {
              var entry = entries[index2];
              this.set(entry[0], entry[1]);
            }
          }
          function hashClear2() {
            this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
            this.size = 0;
          }
          function hashDelete2(key2) {
            var result2 = this.has(key2) && delete this.__data__[key2];
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function hashGet2(key2) {
            var data2 = this.__data__;
            if (nativeCreate2) {
              var result2 = data2[key2];
              return result2 === HASH_UNDEFINED2 ? undefined$1 : result2;
            }
            return hasOwnProperty2.call(data2, key2) ? data2[key2] : undefined$1;
          }
          function hashHas2(key2) {
            var data2 = this.__data__;
            return nativeCreate2 ? data2[key2] !== undefined$1 : hasOwnProperty2.call(data2, key2);
          }
          function hashSet2(key2, value2) {
            var data2 = this.__data__;
            this.size += this.has(key2) ? 0 : 1;
            data2[key2] = nativeCreate2 && value2 === undefined$1 ? HASH_UNDEFINED2 : value2;
            return this;
          }
          Hash2.prototype.clear = hashClear2;
          Hash2.prototype["delete"] = hashDelete2;
          Hash2.prototype.get = hashGet2;
          Hash2.prototype.has = hashHas2;
          Hash2.prototype.set = hashSet2;
          function ListCache2(entries) {
            var index2 = -1, length2 = entries == null ? 0 : entries.length;
            this.clear();
            while (++index2 < length2) {
              var entry = entries[index2];
              this.set(entry[0], entry[1]);
            }
          }
          function listCacheClear2() {
            this.__data__ = [];
            this.size = 0;
          }
          function listCacheDelete2(key2) {
            var data2 = this.__data__, index2 = assocIndexOf2(data2, key2);
            if (index2 < 0) {
              return false;
            }
            var lastIndex = data2.length - 1;
            if (index2 == lastIndex) {
              data2.pop();
            } else {
              splice2.call(data2, index2, 1);
            }
            --this.size;
            return true;
          }
          function listCacheGet2(key2) {
            var data2 = this.__data__, index2 = assocIndexOf2(data2, key2);
            return index2 < 0 ? undefined$1 : data2[index2][1];
          }
          function listCacheHas2(key2) {
            return assocIndexOf2(this.__data__, key2) > -1;
          }
          function listCacheSet2(key2, value2) {
            var data2 = this.__data__, index2 = assocIndexOf2(data2, key2);
            if (index2 < 0) {
              ++this.size;
              data2.push([key2, value2]);
            } else {
              data2[index2][1] = value2;
            }
            return this;
          }
          ListCache2.prototype.clear = listCacheClear2;
          ListCache2.prototype["delete"] = listCacheDelete2;
          ListCache2.prototype.get = listCacheGet2;
          ListCache2.prototype.has = listCacheHas2;
          ListCache2.prototype.set = listCacheSet2;
          function MapCache2(entries) {
            var index2 = -1, length2 = entries == null ? 0 : entries.length;
            this.clear();
            while (++index2 < length2) {
              var entry = entries[index2];
              this.set(entry[0], entry[1]);
            }
          }
          function mapCacheClear2() {
            this.size = 0;
            this.__data__ = {
              "hash": new Hash2(),
              "map": new (Map2 || ListCache2)(),
              "string": new Hash2()
            };
          }
          function mapCacheDelete2(key2) {
            var result2 = getMapData2(this, key2)["delete"](key2);
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function mapCacheGet2(key2) {
            return getMapData2(this, key2).get(key2);
          }
          function mapCacheHas2(key2) {
            return getMapData2(this, key2).has(key2);
          }
          function mapCacheSet2(key2, value2) {
            var data2 = getMapData2(this, key2), size2 = data2.size;
            data2.set(key2, value2);
            this.size += data2.size == size2 ? 0 : 1;
            return this;
          }
          MapCache2.prototype.clear = mapCacheClear2;
          MapCache2.prototype["delete"] = mapCacheDelete2;
          MapCache2.prototype.get = mapCacheGet2;
          MapCache2.prototype.has = mapCacheHas2;
          MapCache2.prototype.set = mapCacheSet2;
          function SetCache2(values2) {
            var index2 = -1, length2 = values2 == null ? 0 : values2.length;
            this.__data__ = new MapCache2();
            while (++index2 < length2) {
              this.add(values2[index2]);
            }
          }
          function setCacheAdd2(value2) {
            this.__data__.set(value2, HASH_UNDEFINED2);
            return this;
          }
          function setCacheHas2(value2) {
            return this.__data__.has(value2);
          }
          SetCache2.prototype.add = SetCache2.prototype.push = setCacheAdd2;
          SetCache2.prototype.has = setCacheHas2;
          function Stack2(entries) {
            var data2 = this.__data__ = new ListCache2(entries);
            this.size = data2.size;
          }
          function stackClear2() {
            this.__data__ = new ListCache2();
            this.size = 0;
          }
          function stackDelete2(key2) {
            var data2 = this.__data__, result2 = data2["delete"](key2);
            this.size = data2.size;
            return result2;
          }
          function stackGet2(key2) {
            return this.__data__.get(key2);
          }
          function stackHas2(key2) {
            return this.__data__.has(key2);
          }
          function stackSet2(key2, value2) {
            var data2 = this.__data__;
            if (data2 instanceof ListCache2) {
              var pairs = data2.__data__;
              if (!Map2 || pairs.length < LARGE_ARRAY_SIZE2 - 1) {
                pairs.push([key2, value2]);
                this.size = ++data2.size;
                return this;
              }
              data2 = this.__data__ = new MapCache2(pairs);
            }
            data2.set(key2, value2);
            this.size = data2.size;
            return this;
          }
          Stack2.prototype.clear = stackClear2;
          Stack2.prototype["delete"] = stackDelete2;
          Stack2.prototype.get = stackGet2;
          Stack2.prototype.has = stackHas2;
          Stack2.prototype.set = stackSet2;
          function arrayLikeKeys2(value2, inherited) {
            var isArr = isArray2(value2), isArg = !isArr && isArguments2(value2), isBuff = !isArr && !isArg && isBuffer2(value2), isType = !isArr && !isArg && !isBuff && isTypedArray2(value2), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes2(value2.length, String2) : [], length2 = result2.length;
            for (var key2 in value2) {
              if ((inherited || hasOwnProperty2.call(value2, key2)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
              (key2 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
              isBuff && (key2 == "offset" || key2 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
              isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || // Skip index properties.
              isIndex2(key2, length2)))) {
                result2.push(key2);
              }
            }
            return result2;
          }
          function arraySample(array) {
            var length2 = array.length;
            return length2 ? array[baseRandom(0, length2 - 1)] : undefined$1;
          }
          function arraySampleSize(array, n2) {
            return shuffleSelf(copyArray(array), baseClamp(n2, 0, array.length));
          }
          function arrayShuffle(array) {
            return shuffleSelf(copyArray(array));
          }
          function assignMergeValue(object, key2, value2) {
            if (value2 !== undefined$1 && !eq2(object[key2], value2) || value2 === undefined$1 && !(key2 in object)) {
              baseAssignValue(object, key2, value2);
            }
          }
          function assignValue(object, key2, value2) {
            var objValue = object[key2];
            if (!(hasOwnProperty2.call(object, key2) && eq2(objValue, value2)) || value2 === undefined$1 && !(key2 in object)) {
              baseAssignValue(object, key2, value2);
            }
          }
          function assocIndexOf2(array, key2) {
            var length2 = array.length;
            while (length2--) {
              if (eq2(array[length2][0], key2)) {
                return length2;
              }
            }
            return -1;
          }
          function baseAggregator(collection, setter, iteratee2, accumulator) {
            baseEach2(collection, function(value2, key2, collection2) {
              setter(accumulator, value2, iteratee2(value2), collection2);
            });
            return accumulator;
          }
          function baseAssign(object, source) {
            return object && copyObject(source, keys2(source), object);
          }
          function baseAssignIn(object, source) {
            return object && copyObject(source, keysIn(source), object);
          }
          function baseAssignValue(object, key2, value2) {
            if (key2 == "__proto__" && defineProperty2) {
              defineProperty2(object, key2, {
                "configurable": true,
                "enumerable": true,
                "value": value2,
                "writable": true
              });
            } else {
              object[key2] = value2;
            }
          }
          function baseAt(object, paths) {
            var index2 = -1, length2 = paths.length, result2 = Array2(length2), skip = object == null;
            while (++index2 < length2) {
              result2[index2] = skip ? undefined$1 : get2(object, paths[index2]);
            }
            return result2;
          }
          function baseClamp(number, lower, upper) {
            if (number === number) {
              if (upper !== undefined$1) {
                number = number <= upper ? number : upper;
              }
              if (lower !== undefined$1) {
                number = number >= lower ? number : lower;
              }
            }
            return number;
          }
          function baseClone(value2, bitmask, customizer, key2, object, stack) {
            var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
            if (customizer) {
              result2 = object ? customizer(value2, key2, object, stack) : customizer(value2);
            }
            if (result2 !== undefined$1) {
              return result2;
            }
            if (!isObject2(value2)) {
              return value2;
            }
            var isArr = isArray2(value2);
            if (isArr) {
              result2 = initCloneArray(value2);
              if (!isDeep) {
                return copyArray(value2, result2);
              }
            } else {
              var tag = getTag2(value2), isFunc = tag == funcTag2 || tag == genTag2;
              if (isBuffer2(value2)) {
                return cloneBuffer(value2, isDeep);
              }
              if (tag == objectTag2 || tag == argsTag2 || isFunc && !object) {
                result2 = isFlat || isFunc ? {} : initCloneObject(value2);
                if (!isDeep) {
                  return isFlat ? copySymbolsIn(value2, baseAssignIn(result2, value2)) : copySymbols(value2, baseAssign(result2, value2));
                }
              } else {
                if (!cloneableTags[tag]) {
                  return object ? value2 : {};
                }
                result2 = initCloneByTag(value2, tag, isDeep);
              }
            }
            stack || (stack = new Stack2());
            var stacked = stack.get(value2);
            if (stacked) {
              return stacked;
            }
            stack.set(value2, result2);
            if (isSet2(value2)) {
              value2.forEach(function(subValue) {
                result2.add(baseClone(subValue, bitmask, customizer, subValue, value2, stack));
              });
            } else if (isMap2(value2)) {
              value2.forEach(function(subValue, key3) {
                result2.set(key3, baseClone(subValue, bitmask, customizer, key3, value2, stack));
              });
            }
            var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys2 : isFlat ? keysIn : keys2;
            var props = isArr ? undefined$1 : keysFunc(value2);
            arrayEach(props || value2, function(subValue, key3) {
              if (props) {
                key3 = subValue;
                subValue = value2[key3];
              }
              assignValue(result2, key3, baseClone(subValue, bitmask, customizer, key3, value2, stack));
            });
            return result2;
          }
          function baseConforms(source) {
            var props = keys2(source);
            return function(object) {
              return baseConformsTo(object, source, props);
            };
          }
          function baseConformsTo(object, source, props) {
            var length2 = props.length;
            if (object == null) {
              return !length2;
            }
            object = Object2(object);
            while (length2--) {
              var key2 = props[length2], predicate = source[key2], value2 = object[key2];
              if (value2 === undefined$1 && !(key2 in object) || !predicate(value2)) {
                return false;
              }
            }
            return true;
          }
          function baseDelay(func, wait, args) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT2);
            }
            return setTimeout2(function() {
              func.apply(undefined$1, args);
            }, wait);
          }
          function baseDifference(array, values2, iteratee2, comparator) {
            var index2 = -1, includes2 = arrayIncludes, isCommon = true, length2 = array.length, result2 = [], valuesLength = values2.length;
            if (!length2) {
              return result2;
            }
            if (iteratee2) {
              values2 = arrayMap2(values2, baseUnary2(iteratee2));
            }
            if (comparator) {
              includes2 = arrayIncludesWith;
              isCommon = false;
            } else if (values2.length >= LARGE_ARRAY_SIZE2) {
              includes2 = cacheHas2;
              isCommon = false;
              values2 = new SetCache2(values2);
            }
            outer:
              while (++index2 < length2) {
                var value2 = array[index2], computed = iteratee2 == null ? value2 : iteratee2(value2);
                value2 = comparator || value2 !== 0 ? value2 : 0;
                if (isCommon && computed === computed) {
                  var valuesIndex = valuesLength;
                  while (valuesIndex--) {
                    if (values2[valuesIndex] === computed) {
                      continue outer;
                    }
                  }
                  result2.push(value2);
                } else if (!includes2(values2, computed, comparator)) {
                  result2.push(value2);
                }
              }
            return result2;
          }
          var baseEach2 = createBaseEach2(baseForOwn2);
          var baseEachRight = createBaseEach2(baseForOwnRight, true);
          function baseEvery(collection, predicate) {
            var result2 = true;
            baseEach2(collection, function(value2, index2, collection2) {
              result2 = !!predicate(value2, index2, collection2);
              return result2;
            });
            return result2;
          }
          function baseExtremum(array, iteratee2, comparator) {
            var index2 = -1, length2 = array.length;
            while (++index2 < length2) {
              var value2 = array[index2], current2 = iteratee2(value2);
              if (current2 != null && (computed === undefined$1 ? current2 === current2 && !isSymbol2(current2) : comparator(current2, computed))) {
                var computed = current2, result2 = value2;
              }
            }
            return result2;
          }
          function baseFill(array, value2, start, end) {
            var length2 = array.length;
            start = toInteger(start);
            if (start < 0) {
              start = -start > length2 ? 0 : length2 + start;
            }
            end = end === undefined$1 || end > length2 ? length2 : toInteger(end);
            if (end < 0) {
              end += length2;
            }
            end = start > end ? 0 : toLength(end);
            while (start < end) {
              array[start++] = value2;
            }
            return array;
          }
          function baseFilter(collection, predicate) {
            var result2 = [];
            baseEach2(collection, function(value2, index2, collection2) {
              if (predicate(value2, index2, collection2)) {
                result2.push(value2);
              }
            });
            return result2;
          }
          function baseFlatten2(array, depth, predicate, isStrict, result2) {
            var index2 = -1, length2 = array.length;
            predicate || (predicate = isFlattenable2);
            result2 || (result2 = []);
            while (++index2 < length2) {
              var value2 = array[index2];
              if (depth > 0 && predicate(value2)) {
                if (depth > 1) {
                  baseFlatten2(value2, depth - 1, predicate, isStrict, result2);
                } else {
                  arrayPush2(result2, value2);
                }
              } else if (!isStrict) {
                result2[result2.length] = value2;
              }
            }
            return result2;
          }
          var baseFor2 = createBaseFor2();
          var baseForRight = createBaseFor2(true);
          function baseForOwn2(object, iteratee2) {
            return object && baseFor2(object, iteratee2, keys2);
          }
          function baseForOwnRight(object, iteratee2) {
            return object && baseForRight(object, iteratee2, keys2);
          }
          function baseFunctions(object, props) {
            return arrayFilter2(props, function(key2) {
              return isFunction2(object[key2]);
            });
          }
          function baseGet2(object, path2) {
            path2 = castPath2(path2, object);
            var index2 = 0, length2 = path2.length;
            while (object != null && index2 < length2) {
              object = object[toKey2(path2[index2++])];
            }
            return index2 && index2 == length2 ? object : undefined$1;
          }
          function baseGetAllKeys2(object, keysFunc, symbolsFunc) {
            var result2 = keysFunc(object);
            return isArray2(object) ? result2 : arrayPush2(result2, symbolsFunc(object));
          }
          function baseGetTag2(value2) {
            if (value2 == null) {
              return value2 === undefined$1 ? undefinedTag2 : nullTag2;
            }
            return symToStringTag2 && symToStringTag2 in Object2(value2) ? getRawTag2(value2) : objectToString2(value2);
          }
          function baseGt(value2, other) {
            return value2 > other;
          }
          function baseHas(object, key2) {
            return object != null && hasOwnProperty2.call(object, key2);
          }
          function baseHasIn2(object, key2) {
            return object != null && key2 in Object2(object);
          }
          function baseInRange(number, start, end) {
            return number >= nativeMin(start, end) && number < nativeMax2(start, end);
          }
          function baseIntersection(arrays, iteratee2, comparator) {
            var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length2 = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
            while (othIndex--) {
              var array = arrays[othIndex];
              if (othIndex && iteratee2) {
                array = arrayMap2(array, baseUnary2(iteratee2));
              }
              maxLength = nativeMin(array.length, maxLength);
              caches[othIndex] = !comparator && (iteratee2 || length2 >= 120 && array.length >= 120) ? new SetCache2(othIndex && array) : undefined$1;
            }
            array = arrays[0];
            var index2 = -1, seen = caches[0];
            outer:
              while (++index2 < length2 && result2.length < maxLength) {
                var value2 = array[index2], computed = iteratee2 ? iteratee2(value2) : value2;
                value2 = comparator || value2 !== 0 ? value2 : 0;
                if (!(seen ? cacheHas2(seen, computed) : includes2(result2, computed, comparator))) {
                  othIndex = othLength;
                  while (--othIndex) {
                    var cache = caches[othIndex];
                    if (!(cache ? cacheHas2(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                      continue outer;
                    }
                  }
                  if (seen) {
                    seen.push(computed);
                  }
                  result2.push(value2);
                }
              }
            return result2;
          }
          function baseInverter(object, setter, iteratee2, accumulator) {
            baseForOwn2(object, function(value2, key2, object2) {
              setter(accumulator, iteratee2(value2), key2, object2);
            });
            return accumulator;
          }
          function baseInvoke(object, path2, args) {
            path2 = castPath2(path2, object);
            object = parent2(object, path2);
            var func = object == null ? object : object[toKey2(last(path2))];
            return func == null ? undefined$1 : apply2(func, object, args);
          }
          function baseIsArguments2(value2) {
            return isObjectLike2(value2) && baseGetTag2(value2) == argsTag2;
          }
          function baseIsArrayBuffer(value2) {
            return isObjectLike2(value2) && baseGetTag2(value2) == arrayBufferTag2;
          }
          function baseIsDate(value2) {
            return isObjectLike2(value2) && baseGetTag2(value2) == dateTag2;
          }
          function baseIsEqual2(value2, other, bitmask, customizer, stack) {
            if (value2 === other) {
              return true;
            }
            if (value2 == null || other == null || !isObjectLike2(value2) && !isObjectLike2(other)) {
              return value2 !== value2 && other !== other;
            }
            return baseIsEqualDeep2(value2, other, bitmask, customizer, baseIsEqual2, stack);
          }
          function baseIsEqualDeep2(object, other, bitmask, customizer, equalFunc, stack) {
            var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag2 : getTag2(object), othTag = othIsArr ? arrayTag2 : getTag2(other);
            objTag = objTag == argsTag2 ? objectTag2 : objTag;
            othTag = othTag == argsTag2 ? objectTag2 : othTag;
            var objIsObj = objTag == objectTag2, othIsObj = othTag == objectTag2, isSameTag = objTag == othTag;
            if (isSameTag && isBuffer2(object)) {
              if (!isBuffer2(other)) {
                return false;
              }
              objIsArr = true;
              objIsObj = false;
            }
            if (isSameTag && !objIsObj) {
              stack || (stack = new Stack2());
              return objIsArr || isTypedArray2(object) ? equalArrays2(object, other, bitmask, customizer, equalFunc, stack) : equalByTag2(object, other, objTag, bitmask, customizer, equalFunc, stack);
            }
            if (!(bitmask & COMPARE_PARTIAL_FLAG2)) {
              var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
              if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                stack || (stack = new Stack2());
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
              }
            }
            if (!isSameTag) {
              return false;
            }
            stack || (stack = new Stack2());
            return equalObjects2(object, other, bitmask, customizer, equalFunc, stack);
          }
          function baseIsMap(value2) {
            return isObjectLike2(value2) && getTag2(value2) == mapTag2;
          }
          function baseIsMatch2(object, source, matchData, customizer) {
            var index2 = matchData.length, length2 = index2, noCustomizer = !customizer;
            if (object == null) {
              return !length2;
            }
            object = Object2(object);
            while (index2--) {
              var data2 = matchData[index2];
              if (noCustomizer && data2[2] ? data2[1] !== object[data2[0]] : !(data2[0] in object)) {
                return false;
              }
            }
            while (++index2 < length2) {
              data2 = matchData[index2];
              var key2 = data2[0], objValue = object[key2], srcValue = data2[1];
              if (noCustomizer && data2[2]) {
                if (objValue === undefined$1 && !(key2 in object)) {
                  return false;
                }
              } else {
                var stack = new Stack2();
                if (customizer) {
                  var result2 = customizer(objValue, srcValue, key2, object, source, stack);
                }
                if (!(result2 === undefined$1 ? baseIsEqual2(srcValue, objValue, COMPARE_PARTIAL_FLAG2 | COMPARE_UNORDERED_FLAG2, customizer, stack) : result2)) {
                  return false;
                }
              }
            }
            return true;
          }
          function baseIsNative2(value2) {
            if (!isObject2(value2) || isMasked2(value2)) {
              return false;
            }
            var pattern = isFunction2(value2) ? reIsNative2 : reIsHostCtor2;
            return pattern.test(toSource2(value2));
          }
          function baseIsRegExp(value2) {
            return isObjectLike2(value2) && baseGetTag2(value2) == regexpTag2;
          }
          function baseIsSet(value2) {
            return isObjectLike2(value2) && getTag2(value2) == setTag2;
          }
          function baseIsTypedArray2(value2) {
            return isObjectLike2(value2) && isLength2(value2.length) && !!typedArrayTags2[baseGetTag2(value2)];
          }
          function baseIteratee2(value2) {
            if (typeof value2 == "function") {
              return value2;
            }
            if (value2 == null) {
              return identity2;
            }
            if (typeof value2 == "object") {
              return isArray2(value2) ? baseMatchesProperty2(value2[0], value2[1]) : baseMatches2(value2);
            }
            return property2(value2);
          }
          function baseKeys2(object) {
            if (!isPrototype2(object)) {
              return nativeKeys2(object);
            }
            var result2 = [];
            for (var key2 in Object2(object)) {
              if (hasOwnProperty2.call(object, key2) && key2 != "constructor") {
                result2.push(key2);
              }
            }
            return result2;
          }
          function baseKeysIn(object) {
            if (!isObject2(object)) {
              return nativeKeysIn(object);
            }
            var isProto = isPrototype2(object), result2 = [];
            for (var key2 in object) {
              if (!(key2 == "constructor" && (isProto || !hasOwnProperty2.call(object, key2)))) {
                result2.push(key2);
              }
            }
            return result2;
          }
          function baseLt(value2, other) {
            return value2 < other;
          }
          function baseMap2(collection, iteratee2) {
            var index2 = -1, result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
            baseEach2(collection, function(value2, key2, collection2) {
              result2[++index2] = iteratee2(value2, key2, collection2);
            });
            return result2;
          }
          function baseMatches2(source) {
            var matchData = getMatchData2(source);
            if (matchData.length == 1 && matchData[0][2]) {
              return matchesStrictComparable2(matchData[0][0], matchData[0][1]);
            }
            return function(object) {
              return object === source || baseIsMatch2(object, source, matchData);
            };
          }
          function baseMatchesProperty2(path2, srcValue) {
            if (isKey2(path2) && isStrictComparable2(srcValue)) {
              return matchesStrictComparable2(toKey2(path2), srcValue);
            }
            return function(object) {
              var objValue = get2(object, path2);
              return objValue === undefined$1 && objValue === srcValue ? hasIn2(object, path2) : baseIsEqual2(srcValue, objValue, COMPARE_PARTIAL_FLAG2 | COMPARE_UNORDERED_FLAG2);
            };
          }
          function baseMerge(object, source, srcIndex, customizer, stack) {
            if (object === source) {
              return;
            }
            baseFor2(source, function(srcValue, key2) {
              stack || (stack = new Stack2());
              if (isObject2(srcValue)) {
                baseMergeDeep(object, source, key2, srcIndex, baseMerge, customizer, stack);
              } else {
                var newValue = customizer ? customizer(safeGet(object, key2), srcValue, key2 + "", object, source, stack) : undefined$1;
                if (newValue === undefined$1) {
                  newValue = srcValue;
                }
                assignMergeValue(object, key2, newValue);
              }
            }, keysIn);
          }
          function baseMergeDeep(object, source, key2, srcIndex, mergeFunc, customizer, stack) {
            var objValue = safeGet(object, key2), srcValue = safeGet(source, key2), stacked = stack.get(srcValue);
            if (stacked) {
              assignMergeValue(object, key2, stacked);
              return;
            }
            var newValue = customizer ? customizer(objValue, srcValue, key2 + "", object, source, stack) : undefined$1;
            var isCommon = newValue === undefined$1;
            if (isCommon) {
              var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
              newValue = srcValue;
              if (isArr || isBuff || isTyped) {
                if (isArray2(objValue)) {
                  newValue = objValue;
                } else if (isArrayLikeObject(objValue)) {
                  newValue = copyArray(objValue);
                } else if (isBuff) {
                  isCommon = false;
                  newValue = cloneBuffer(srcValue, true);
                } else if (isTyped) {
                  isCommon = false;
                  newValue = cloneTypedArray(srcValue, true);
                } else {
                  newValue = [];
                }
              } else if (isPlainObject2(srcValue) || isArguments2(srcValue)) {
                newValue = objValue;
                if (isArguments2(objValue)) {
                  newValue = toPlainObject(objValue);
                } else if (!isObject2(objValue) || isFunction2(objValue)) {
                  newValue = initCloneObject(srcValue);
                }
              } else {
                isCommon = false;
              }
            }
            if (isCommon) {
              stack.set(srcValue, newValue);
              mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
              stack["delete"](srcValue);
            }
            assignMergeValue(object, key2, newValue);
          }
          function baseNth(array, n2) {
            var length2 = array.length;
            if (!length2) {
              return;
            }
            n2 += n2 < 0 ? length2 : 0;
            return isIndex2(n2, length2) ? array[n2] : undefined$1;
          }
          function baseOrderBy2(collection, iteratees, orders) {
            if (iteratees.length) {
              iteratees = arrayMap2(iteratees, function(iteratee2) {
                if (isArray2(iteratee2)) {
                  return function(value2) {
                    return baseGet2(value2, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                  };
                }
                return iteratee2;
              });
            } else {
              iteratees = [identity2];
            }
            var index2 = -1;
            iteratees = arrayMap2(iteratees, baseUnary2(getIteratee()));
            var result2 = baseMap2(collection, function(value2, key2, collection2) {
              var criteria = arrayMap2(iteratees, function(iteratee2) {
                return iteratee2(value2);
              });
              return { "criteria": criteria, "index": ++index2, "value": value2 };
            });
            return baseSortBy2(result2, function(object, other) {
              return compareMultiple2(object, other, orders);
            });
          }
          function basePick(object, paths) {
            return basePickBy(object, paths, function(value2, path2) {
              return hasIn2(object, path2);
            });
          }
          function basePickBy(object, paths, predicate) {
            var index2 = -1, length2 = paths.length, result2 = {};
            while (++index2 < length2) {
              var path2 = paths[index2], value2 = baseGet2(object, path2);
              if (predicate(value2, path2)) {
                baseSet(result2, castPath2(path2, object), value2);
              }
            }
            return result2;
          }
          function basePropertyDeep2(path2) {
            return function(object) {
              return baseGet2(object, path2);
            };
          }
          function basePullAll(array, values2, iteratee2, comparator) {
            var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length2 = values2.length, seen = array;
            if (array === values2) {
              values2 = copyArray(values2);
            }
            if (iteratee2) {
              seen = arrayMap2(array, baseUnary2(iteratee2));
            }
            while (++index2 < length2) {
              var fromIndex = 0, value2 = values2[index2], computed = iteratee2 ? iteratee2(value2) : value2;
              while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
                if (seen !== array) {
                  splice2.call(seen, fromIndex, 1);
                }
                splice2.call(array, fromIndex, 1);
              }
            }
            return array;
          }
          function basePullAt(array, indexes) {
            var length2 = array ? indexes.length : 0, lastIndex = length2 - 1;
            while (length2--) {
              var index2 = indexes[length2];
              if (length2 == lastIndex || index2 !== previous) {
                var previous = index2;
                if (isIndex2(index2)) {
                  splice2.call(array, index2, 1);
                } else {
                  baseUnset(array, index2);
                }
              }
            }
            return array;
          }
          function baseRandom(lower, upper) {
            return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
          }
          function baseRange(start, end, step, fromRight) {
            var index2 = -1, length2 = nativeMax2(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length2);
            while (length2--) {
              result2[fromRight ? length2 : ++index2] = start;
              start += step;
            }
            return result2;
          }
          function baseRepeat(string, n2) {
            var result2 = "";
            if (!string || n2 < 1 || n2 > MAX_SAFE_INTEGER2) {
              return result2;
            }
            do {
              if (n2 % 2) {
                result2 += string;
              }
              n2 = nativeFloor(n2 / 2);
              if (n2) {
                string += string;
              }
            } while (n2);
            return result2;
          }
          function baseRest2(func, start) {
            return setToString2(overRest2(func, start, identity2), func + "");
          }
          function baseSample(collection) {
            return arraySample(values(collection));
          }
          function baseSampleSize(collection, n2) {
            var array = values(collection);
            return shuffleSelf(array, baseClamp(n2, 0, array.length));
          }
          function baseSet(object, path2, value2, customizer) {
            if (!isObject2(object)) {
              return object;
            }
            path2 = castPath2(path2, object);
            var index2 = -1, length2 = path2.length, lastIndex = length2 - 1, nested = object;
            while (nested != null && ++index2 < length2) {
              var key2 = toKey2(path2[index2]), newValue = value2;
              if (key2 === "__proto__" || key2 === "constructor" || key2 === "prototype") {
                return object;
              }
              if (index2 != lastIndex) {
                var objValue = nested[key2];
                newValue = customizer ? customizer(objValue, key2, nested) : undefined$1;
                if (newValue === undefined$1) {
                  newValue = isObject2(objValue) ? objValue : isIndex2(path2[index2 + 1]) ? [] : {};
                }
              }
              assignValue(nested, key2, newValue);
              nested = nested[key2];
            }
            return object;
          }
          var baseSetData = !metaMap ? identity2 : function(func, data2) {
            metaMap.set(func, data2);
            return func;
          };
          var baseSetToString2 = !defineProperty2 ? identity2 : function(func, string) {
            return defineProperty2(func, "toString", {
              "configurable": true,
              "enumerable": false,
              "value": constant2(string),
              "writable": true
            });
          };
          function baseShuffle(collection) {
            return shuffleSelf(values(collection));
          }
          function baseSlice(array, start, end) {
            var index2 = -1, length2 = array.length;
            if (start < 0) {
              start = -start > length2 ? 0 : length2 + start;
            }
            end = end > length2 ? length2 : end;
            if (end < 0) {
              end += length2;
            }
            length2 = start > end ? 0 : end - start >>> 0;
            start >>>= 0;
            var result2 = Array2(length2);
            while (++index2 < length2) {
              result2[index2] = array[index2 + start];
            }
            return result2;
          }
          function baseSome(collection, predicate) {
            var result2;
            baseEach2(collection, function(value2, index2, collection2) {
              result2 = predicate(value2, index2, collection2);
              return !result2;
            });
            return !!result2;
          }
          function baseSortedIndex(array, value2, retHighest) {
            var low = 0, high = array == null ? low : array.length;
            if (typeof value2 == "number" && value2 === value2 && high <= HALF_MAX_ARRAY_LENGTH) {
              while (low < high) {
                var mid = low + high >>> 1, computed = array[mid];
                if (computed !== null && !isSymbol2(computed) && (retHighest ? computed <= value2 : computed < value2)) {
                  low = mid + 1;
                } else {
                  high = mid;
                }
              }
              return high;
            }
            return baseSortedIndexBy(array, value2, identity2, retHighest);
          }
          function baseSortedIndexBy(array, value2, iteratee2, retHighest) {
            var low = 0, high = array == null ? 0 : array.length;
            if (high === 0) {
              return 0;
            }
            value2 = iteratee2(value2);
            var valIsNaN = value2 !== value2, valIsNull = value2 === null, valIsSymbol = isSymbol2(value2), valIsUndefined = value2 === undefined$1;
            while (low < high) {
              var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined$1, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol2(computed);
              if (valIsNaN) {
                var setLow = retHighest || othIsReflexive;
              } else if (valIsUndefined) {
                setLow = othIsReflexive && (retHighest || othIsDefined);
              } else if (valIsNull) {
                setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
              } else if (valIsSymbol) {
                setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
              } else if (othIsNull || othIsSymbol) {
                setLow = false;
              } else {
                setLow = retHighest ? computed <= value2 : computed < value2;
              }
              if (setLow) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return nativeMin(high, MAX_ARRAY_INDEX);
          }
          function baseSortedUniq(array, iteratee2) {
            var index2 = -1, length2 = array.length, resIndex = 0, result2 = [];
            while (++index2 < length2) {
              var value2 = array[index2], computed = iteratee2 ? iteratee2(value2) : value2;
              if (!index2 || !eq2(computed, seen)) {
                var seen = computed;
                result2[resIndex++] = value2 === 0 ? 0 : value2;
              }
            }
            return result2;
          }
          function baseToNumber(value2) {
            if (typeof value2 == "number") {
              return value2;
            }
            if (isSymbol2(value2)) {
              return NAN;
            }
            return +value2;
          }
          function baseToString2(value2) {
            if (typeof value2 == "string") {
              return value2;
            }
            if (isArray2(value2)) {
              return arrayMap2(value2, baseToString2) + "";
            }
            if (isSymbol2(value2)) {
              return symbolToString2 ? symbolToString2.call(value2) : "";
            }
            var result2 = value2 + "";
            return result2 == "0" && 1 / value2 == -INFINITY2 ? "-0" : result2;
          }
          function baseUniq(array, iteratee2, comparator) {
            var index2 = -1, includes2 = arrayIncludes, length2 = array.length, isCommon = true, result2 = [], seen = result2;
            if (comparator) {
              isCommon = false;
              includes2 = arrayIncludesWith;
            } else if (length2 >= LARGE_ARRAY_SIZE2) {
              var set3 = iteratee2 ? null : createSet(array);
              if (set3) {
                return setToArray2(set3);
              }
              isCommon = false;
              includes2 = cacheHas2;
              seen = new SetCache2();
            } else {
              seen = iteratee2 ? [] : result2;
            }
            outer:
              while (++index2 < length2) {
                var value2 = array[index2], computed = iteratee2 ? iteratee2(value2) : value2;
                value2 = comparator || value2 !== 0 ? value2 : 0;
                if (isCommon && computed === computed) {
                  var seenIndex = seen.length;
                  while (seenIndex--) {
                    if (seen[seenIndex] === computed) {
                      continue outer;
                    }
                  }
                  if (iteratee2) {
                    seen.push(computed);
                  }
                  result2.push(value2);
                } else if (!includes2(seen, computed, comparator)) {
                  if (seen !== result2) {
                    seen.push(computed);
                  }
                  result2.push(value2);
                }
              }
            return result2;
          }
          function baseUnset(object, path2) {
            path2 = castPath2(path2, object);
            object = parent2(object, path2);
            return object == null || delete object[toKey2(last(path2))];
          }
          function baseUpdate(object, path2, updater, customizer) {
            return baseSet(object, path2, updater(baseGet2(object, path2)), customizer);
          }
          function baseWhile(array, predicate, isDrop, fromRight) {
            var length2 = array.length, index2 = fromRight ? length2 : -1;
            while ((fromRight ? index2-- : ++index2 < length2) && predicate(array[index2], index2, array)) {
            }
            return isDrop ? baseSlice(array, fromRight ? 0 : index2, fromRight ? index2 + 1 : length2) : baseSlice(array, fromRight ? index2 + 1 : 0, fromRight ? length2 : index2);
          }
          function baseWrapperValue(value2, actions2) {
            var result2 = value2;
            if (result2 instanceof LazyWrapper) {
              result2 = result2.value();
            }
            return arrayReduce(actions2, function(result3, action) {
              return action.func.apply(action.thisArg, arrayPush2([result3], action.args));
            }, result2);
          }
          function baseXor(arrays, iteratee2, comparator) {
            var length2 = arrays.length;
            if (length2 < 2) {
              return length2 ? baseUniq(arrays[0]) : [];
            }
            var index2 = -1, result2 = Array2(length2);
            while (++index2 < length2) {
              var array = arrays[index2], othIndex = -1;
              while (++othIndex < length2) {
                if (othIndex != index2) {
                  result2[index2] = baseDifference(result2[index2] || array, arrays[othIndex], iteratee2, comparator);
                }
              }
            }
            return baseUniq(baseFlatten2(result2, 1), iteratee2, comparator);
          }
          function baseZipObject(props, values2, assignFunc) {
            var index2 = -1, length2 = props.length, valsLength = values2.length, result2 = {};
            while (++index2 < length2) {
              var value2 = index2 < valsLength ? values2[index2] : undefined$1;
              assignFunc(result2, props[index2], value2);
            }
            return result2;
          }
          function castArrayLikeObject(value2) {
            return isArrayLikeObject(value2) ? value2 : [];
          }
          function castFunction(value2) {
            return typeof value2 == "function" ? value2 : identity2;
          }
          function castPath2(value2, object) {
            if (isArray2(value2)) {
              return value2;
            }
            return isKey2(value2, object) ? [value2] : stringToPath2(toString2(value2));
          }
          var castRest = baseRest2;
          function castSlice(array, start, end) {
            var length2 = array.length;
            end = end === undefined$1 ? length2 : end;
            return !start && end >= length2 ? array : baseSlice(array, start, end);
          }
          var clearTimeout2 = ctxClearTimeout || function(id2) {
            return root2.clearTimeout(id2);
          };
          function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
              return buffer.slice();
            }
            var length2 = buffer.length, result2 = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);
            buffer.copy(result2);
            return result2;
          }
          function cloneArrayBuffer(arrayBuffer) {
            var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
            return result2;
          }
          function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
          }
          function cloneRegExp(regexp) {
            var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result2.lastIndex = regexp.lastIndex;
            return result2;
          }
          function cloneSymbol(symbol) {
            return symbolValueOf2 ? Object2(symbolValueOf2.call(symbol)) : {};
          }
          function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
          }
          function compareAscending2(value2, other) {
            if (value2 !== other) {
              var valIsDefined = value2 !== undefined$1, valIsNull = value2 === null, valIsReflexive = value2 === value2, valIsSymbol = isSymbol2(value2);
              var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol2(other);
              if (!othIsNull && !othIsSymbol && !valIsSymbol && value2 > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                return 1;
              }
              if (!valIsNull && !valIsSymbol && !othIsSymbol && value2 < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                return -1;
              }
            }
            return 0;
          }
          function compareMultiple2(object, other, orders) {
            var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length2 = objCriteria.length, ordersLength = orders.length;
            while (++index2 < length2) {
              var result2 = compareAscending2(objCriteria[index2], othCriteria[index2]);
              if (result2) {
                if (index2 >= ordersLength) {
                  return result2;
                }
                var order = orders[index2];
                return result2 * (order == "desc" ? -1 : 1);
              }
            }
            return object.index - other.index;
          }
          function composeArgs(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax2(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
            while (++leftIndex < leftLength) {
              result2[leftIndex] = partials[leftIndex];
            }
            while (++argsIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[holders[argsIndex]] = args[argsIndex];
              }
            }
            while (rangeLength--) {
              result2[leftIndex++] = args[argsIndex++];
            }
            return result2;
          }
          function composeArgsRight(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax2(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
            while (++argsIndex < rangeLength) {
              result2[argsIndex] = args[argsIndex];
            }
            var offset = argsIndex;
            while (++rightIndex < rightLength) {
              result2[offset + rightIndex] = partials[rightIndex];
            }
            while (++holdersIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[offset + holders[holdersIndex]] = args[argsIndex++];
              }
            }
            return result2;
          }
          function copyArray(source, array) {
            var index2 = -1, length2 = source.length;
            array || (array = Array2(length2));
            while (++index2 < length2) {
              array[index2] = source[index2];
            }
            return array;
          }
          function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            var index2 = -1, length2 = props.length;
            while (++index2 < length2) {
              var key2 = props[index2];
              var newValue = customizer ? customizer(object[key2], source[key2], key2, object, source) : undefined$1;
              if (newValue === undefined$1) {
                newValue = source[key2];
              }
              if (isNew) {
                baseAssignValue(object, key2, newValue);
              } else {
                assignValue(object, key2, newValue);
              }
            }
            return object;
          }
          function copySymbols(source, object) {
            return copyObject(source, getSymbols2(source), object);
          }
          function copySymbolsIn(source, object) {
            return copyObject(source, getSymbolsIn(source), object);
          }
          function createAggregator(setter, initializer) {
            return function(collection, iteratee2) {
              var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
              return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
            };
          }
          function createAssigner(assigner) {
            return baseRest2(function(object, sources) {
              var index2 = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : undefined$1, guard = length2 > 2 ? sources[2] : undefined$1;
              customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : undefined$1;
              if (guard && isIterateeCall2(sources[0], sources[1], guard)) {
                customizer = length2 < 3 ? undefined$1 : customizer;
                length2 = 1;
              }
              object = Object2(object);
              while (++index2 < length2) {
                var source = sources[index2];
                if (source) {
                  assigner(object, source, index2, customizer);
                }
              }
              return object;
            });
          }
          function createBaseEach2(eachFunc, fromRight) {
            return function(collection, iteratee2) {
              if (collection == null) {
                return collection;
              }
              if (!isArrayLike2(collection)) {
                return eachFunc(collection, iteratee2);
              }
              var length2 = collection.length, index2 = fromRight ? length2 : -1, iterable = Object2(collection);
              while (fromRight ? index2-- : ++index2 < length2) {
                if (iteratee2(iterable[index2], index2, iterable) === false) {
                  break;
                }
              }
              return collection;
            };
          }
          function createBaseFor2(fromRight) {
            return function(object, iteratee2, keysFunc) {
              var index2 = -1, iterable = Object2(object), props = keysFunc(object), length2 = props.length;
              while (length2--) {
                var key2 = props[fromRight ? length2 : ++index2];
                if (iteratee2(iterable[key2], key2, iterable) === false) {
                  break;
                }
              }
              return object;
            };
          }
          function createBind(func, bitmask, thisArg) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper2() {
              var fn = this && this !== root2 && this instanceof wrapper2 ? Ctor : func;
              return fn.apply(isBind ? thisArg : this, arguments);
            }
            return wrapper2;
          }
          function createCaseFirst(methodName) {
            return function(string) {
              string = toString2(string);
              var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$1;
              var chr = strSymbols ? strSymbols[0] : string.charAt(0);
              var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
              return chr[methodName]() + trailing;
            };
          }
          function createCompounder(callback) {
            return function(string) {
              return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
            };
          }
          function createCtor(Ctor) {
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return new Ctor();
                case 1:
                  return new Ctor(args[0]);
                case 2:
                  return new Ctor(args[0], args[1]);
                case 3:
                  return new Ctor(args[0], args[1], args[2]);
                case 4:
                  return new Ctor(args[0], args[1], args[2], args[3]);
                case 5:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                case 6:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                case 7:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
              }
              var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
              return isObject2(result2) ? result2 : thisBinding;
            };
          }
          function createCurry(func, bitmask, arity) {
            var Ctor = createCtor(func);
            function wrapper2() {
              var length2 = arguments.length, args = Array2(length2), index2 = length2, placeholder = getHolder(wrapper2);
              while (index2--) {
                args[index2] = arguments[index2];
              }
              var holders = length2 < 3 && args[0] !== placeholder && args[length2 - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
              length2 -= holders.length;
              if (length2 < arity) {
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper2.placeholder,
                  undefined$1,
                  args,
                  holders,
                  undefined$1,
                  undefined$1,
                  arity - length2
                );
              }
              var fn = this && this !== root2 && this instanceof wrapper2 ? Ctor : func;
              return apply2(fn, this, args);
            }
            return wrapper2;
          }
          function createFind(findIndexFunc) {
            return function(collection, predicate, fromIndex) {
              var iterable = Object2(collection);
              if (!isArrayLike2(collection)) {
                var iteratee2 = getIteratee(predicate, 3);
                collection = keys2(collection);
                predicate = function(key2) {
                  return iteratee2(iterable[key2], key2, iterable);
                };
              }
              var index2 = findIndexFunc(collection, predicate, fromIndex);
              return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined$1;
            };
          }
          function createFlow(fromRight) {
            return flatRest(function(funcs) {
              var length2 = funcs.length, index2 = length2, prereq = LodashWrapper.prototype.thru;
              if (fromRight) {
                funcs.reverse();
              }
              while (index2--) {
                var func = funcs[index2];
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT2);
                }
                if (prereq && !wrapper2 && getFuncName(func) == "wrapper") {
                  var wrapper2 = new LodashWrapper([], true);
                }
              }
              index2 = wrapper2 ? index2 : length2;
              while (++index2 < length2) {
                func = funcs[index2];
                var funcName = getFuncName(func), data2 = funcName == "wrapper" ? getData(func) : undefined$1;
                if (data2 && isLaziable(data2[0]) && data2[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data2[4].length && data2[9] == 1) {
                  wrapper2 = wrapper2[getFuncName(data2[0])].apply(wrapper2, data2[3]);
                } else {
                  wrapper2 = func.length == 1 && isLaziable(func) ? wrapper2[funcName]() : wrapper2.thru(func);
                }
              }
              return function() {
                var args = arguments, value2 = args[0];
                if (wrapper2 && args.length == 1 && isArray2(value2)) {
                  return wrapper2.plant(value2).value();
                }
                var index3 = 0, result2 = length2 ? funcs[index3].apply(this, args) : value2;
                while (++index3 < length2) {
                  result2 = funcs[index3].call(this, result2);
                }
                return result2;
              };
            });
          }
          function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
            var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
            function wrapper2() {
              var length2 = arguments.length, args = Array2(length2), index2 = length2;
              while (index2--) {
                args[index2] = arguments[index2];
              }
              if (isCurried) {
                var placeholder = getHolder(wrapper2), holdersCount = countHolders(args, placeholder);
              }
              if (partials) {
                args = composeArgs(args, partials, holders, isCurried);
              }
              if (partialsRight) {
                args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
              }
              length2 -= holdersCount;
              if (isCurried && length2 < arity) {
                var newHolders = replaceHolders(args, placeholder);
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper2.placeholder,
                  thisArg,
                  args,
                  newHolders,
                  argPos,
                  ary2,
                  arity - length2
                );
              }
              var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
              length2 = args.length;
              if (argPos) {
                args = reorder(args, argPos);
              } else if (isFlip && length2 > 1) {
                args.reverse();
              }
              if (isAry && ary2 < length2) {
                args.length = ary2;
              }
              if (this && this !== root2 && this instanceof wrapper2) {
                fn = Ctor || createCtor(fn);
              }
              return fn.apply(thisBinding, args);
            }
            return wrapper2;
          }
          function createInverter(setter, toIteratee) {
            return function(object, iteratee2) {
              return baseInverter(object, setter, toIteratee(iteratee2), {});
            };
          }
          function createMathOperation(operator, defaultValue) {
            return function(value2, other) {
              var result2;
              if (value2 === undefined$1 && other === undefined$1) {
                return defaultValue;
              }
              if (value2 !== undefined$1) {
                result2 = value2;
              }
              if (other !== undefined$1) {
                if (result2 === undefined$1) {
                  return other;
                }
                if (typeof value2 == "string" || typeof other == "string") {
                  value2 = baseToString2(value2);
                  other = baseToString2(other);
                } else {
                  value2 = baseToNumber(value2);
                  other = baseToNumber(other);
                }
                result2 = operator(value2, other);
              }
              return result2;
            };
          }
          function createOver(arrayFunc) {
            return flatRest(function(iteratees) {
              iteratees = arrayMap2(iteratees, baseUnary2(getIteratee()));
              return baseRest2(function(args) {
                var thisArg = this;
                return arrayFunc(iteratees, function(iteratee2) {
                  return apply2(iteratee2, thisArg, args);
                });
              });
            });
          }
          function createPadding(length2, chars2) {
            chars2 = chars2 === undefined$1 ? " " : baseToString2(chars2);
            var charsLength = chars2.length;
            if (charsLength < 2) {
              return charsLength ? baseRepeat(chars2, length2) : chars2;
            }
            var result2 = baseRepeat(chars2, nativeCeil(length2 / stringSize(chars2)));
            return hasUnicode(chars2) ? castSlice(stringToArray(result2), 0, length2).join("") : result2.slice(0, length2);
          }
          function createPartial(func, bitmask, thisArg, partials) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper2() {
              var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root2 && this instanceof wrapper2 ? Ctor : func;
              while (++leftIndex < leftLength) {
                args[leftIndex] = partials[leftIndex];
              }
              while (argsLength--) {
                args[leftIndex++] = arguments[++argsIndex];
              }
              return apply2(fn, isBind ? thisArg : this, args);
            }
            return wrapper2;
          }
          function createRange(fromRight) {
            return function(start, end, step) {
              if (step && typeof step != "number" && isIterateeCall2(start, end, step)) {
                end = step = undefined$1;
              }
              start = toFinite(start);
              if (end === undefined$1) {
                end = start;
                start = 0;
              } else {
                end = toFinite(end);
              }
              step = step === undefined$1 ? start < end ? 1 : -1 : toFinite(step);
              return baseRange(start, end, step, fromRight);
            };
          }
          function createRelationalOperation(operator) {
            return function(value2, other) {
              if (!(typeof value2 == "string" && typeof other == "string")) {
                value2 = toNumber(value2);
                other = toNumber(other);
              }
              return operator(value2, other);
            };
          }
          function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
            var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
            bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
            bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
            if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
              bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
            }
            var newData = [
              func,
              bitmask,
              thisArg,
              newPartials,
              newHolders,
              newPartialsRight,
              newHoldersRight,
              argPos,
              ary2,
              arity
            ];
            var result2 = wrapFunc.apply(undefined$1, newData);
            if (isLaziable(func)) {
              setData(result2, newData);
            }
            result2.placeholder = placeholder;
            return setWrapToString(result2, func, bitmask);
          }
          function createRound(methodName) {
            var func = Math2[methodName];
            return function(number, precision) {
              number = toNumber(number);
              precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
              if (precision && nativeIsFinite(number)) {
                var pair = (toString2(number) + "e").split("e"), value2 = func(pair[0] + "e" + (+pair[1] + precision));
                pair = (toString2(value2) + "e").split("e");
                return +(pair[0] + "e" + (+pair[1] - precision));
              }
              return func(number);
            };
          }
          var createSet = !(Set2 && 1 / setToArray2(new Set2([, -0]))[1] == INFINITY2) ? noop2 : function(values2) {
            return new Set2(values2);
          };
          function createToPairs(keysFunc) {
            return function(object) {
              var tag = getTag2(object);
              if (tag == mapTag2) {
                return mapToArray2(object);
              }
              if (tag == setTag2) {
                return setToPairs(object);
              }
              return baseToPairs(object, keysFunc(object));
            };
          }
          function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
            if (!isBindKey && typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT2);
            }
            var length2 = partials ? partials.length : 0;
            if (!length2) {
              bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
              partials = holders = undefined$1;
            }
            ary2 = ary2 === undefined$1 ? ary2 : nativeMax2(toInteger(ary2), 0);
            arity = arity === undefined$1 ? arity : toInteger(arity);
            length2 -= holders ? holders.length : 0;
            if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
              var partialsRight = partials, holdersRight = holders;
              partials = holders = undefined$1;
            }
            var data2 = isBindKey ? undefined$1 : getData(func);
            var newData = [
              func,
              bitmask,
              thisArg,
              partials,
              holders,
              partialsRight,
              holdersRight,
              argPos,
              ary2,
              arity
            ];
            if (data2) {
              mergeData(newData, data2);
            }
            func = newData[0];
            bitmask = newData[1];
            thisArg = newData[2];
            partials = newData[3];
            holders = newData[4];
            arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax2(newData[9] - length2, 0);
            if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
              bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
            }
            if (!bitmask || bitmask == WRAP_BIND_FLAG) {
              var result2 = createBind(func, bitmask, thisArg);
            } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
              result2 = createCurry(func, bitmask, arity);
            } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
              result2 = createPartial(func, bitmask, thisArg, partials);
            } else {
              result2 = createHybrid.apply(undefined$1, newData);
            }
            var setter = data2 ? baseSetData : setData;
            return setWrapToString(setter(result2, newData), func, bitmask);
          }
          function customDefaultsAssignIn(objValue, srcValue, key2, object) {
            if (objValue === undefined$1 || eq2(objValue, objectProto2[key2]) && !hasOwnProperty2.call(object, key2)) {
              return srcValue;
            }
            return objValue;
          }
          function customDefaultsMerge(objValue, srcValue, key2, object, source, stack) {
            if (isObject2(objValue) && isObject2(srcValue)) {
              stack.set(srcValue, objValue);
              baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
              stack["delete"](srcValue);
            }
            return objValue;
          }
          function customOmitClone(value2) {
            return isPlainObject2(value2) ? undefined$1 : value2;
          }
          function equalArrays2(array, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG2, arrLength = array.length, othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
              return false;
            }
            var arrStacked = stack.get(array);
            var othStacked = stack.get(other);
            if (arrStacked && othStacked) {
              return arrStacked == other && othStacked == array;
            }
            var index2 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG2 ? new SetCache2() : undefined$1;
            stack.set(array, other);
            stack.set(other, array);
            while (++index2 < arrLength) {
              var arrValue = array[index2], othValue = other[index2];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
              }
              if (compared !== undefined$1) {
                if (compared) {
                  continue;
                }
                result2 = false;
                break;
              }
              if (seen) {
                if (!arraySome2(other, function(othValue2, othIndex) {
                  if (!cacheHas2(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                    return seen.push(othIndex);
                  }
                })) {
                  result2 = false;
                  break;
                }
              } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                result2 = false;
                break;
              }
            }
            stack["delete"](array);
            stack["delete"](other);
            return result2;
          }
          function equalByTag2(object, other, tag, bitmask, customizer, equalFunc, stack) {
            switch (tag) {
              case dataViewTag2:
                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                  return false;
                }
                object = object.buffer;
                other = other.buffer;
              case arrayBufferTag2:
                if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                  return false;
                }
                return true;
              case boolTag2:
              case dateTag2:
              case numberTag2:
                return eq2(+object, +other);
              case errorTag2:
                return object.name == other.name && object.message == other.message;
              case regexpTag2:
              case stringTag2:
                return object == other + "";
              case mapTag2:
                var convert2 = mapToArray2;
              case setTag2:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;
                convert2 || (convert2 = setToArray2);
                if (object.size != other.size && !isPartial) {
                  return false;
                }
                var stacked = stack.get(object);
                if (stacked) {
                  return stacked == other;
                }
                bitmask |= COMPARE_UNORDERED_FLAG2;
                stack.set(object, other);
                var result2 = equalArrays2(convert2(object), convert2(other), bitmask, customizer, equalFunc, stack);
                stack["delete"](object);
                return result2;
              case symbolTag2:
                if (symbolValueOf2) {
                  return symbolValueOf2.call(object) == symbolValueOf2.call(other);
                }
            }
            return false;
          }
          function equalObjects2(object, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG2, objProps = getAllKeys2(object), objLength = objProps.length, othProps = getAllKeys2(other), othLength = othProps.length;
            if (objLength != othLength && !isPartial) {
              return false;
            }
            var index2 = objLength;
            while (index2--) {
              var key2 = objProps[index2];
              if (!(isPartial ? key2 in other : hasOwnProperty2.call(other, key2))) {
                return false;
              }
            }
            var objStacked = stack.get(object);
            var othStacked = stack.get(other);
            if (objStacked && othStacked) {
              return objStacked == other && othStacked == object;
            }
            var result2 = true;
            stack.set(object, other);
            stack.set(other, object);
            var skipCtor = isPartial;
            while (++index2 < objLength) {
              key2 = objProps[index2];
              var objValue = object[key2], othValue = other[key2];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, objValue, key2, other, object, stack) : customizer(objValue, othValue, key2, object, other, stack);
              }
              if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                result2 = false;
                break;
              }
              skipCtor || (skipCtor = key2 == "constructor");
            }
            if (result2 && !skipCtor) {
              var objCtor = object.constructor, othCtor = other.constructor;
              if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                result2 = false;
              }
            }
            stack["delete"](object);
            stack["delete"](other);
            return result2;
          }
          function flatRest(func) {
            return setToString2(overRest2(func, undefined$1, flatten), func + "");
          }
          function getAllKeys2(object) {
            return baseGetAllKeys2(object, keys2, getSymbols2);
          }
          function getAllKeysIn(object) {
            return baseGetAllKeys2(object, keysIn, getSymbolsIn);
          }
          var getData = !metaMap ? noop2 : function(func) {
            return metaMap.get(func);
          };
          function getFuncName(func) {
            var result2 = func.name + "", array = realNames[result2], length2 = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
            while (length2--) {
              var data2 = array[length2], otherFunc = data2.func;
              if (otherFunc == null || otherFunc == func) {
                return data2.name;
              }
            }
            return result2;
          }
          function getHolder(func) {
            var object = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
            return object.placeholder;
          }
          function getIteratee() {
            var result2 = lodash2.iteratee || iteratee;
            result2 = result2 === iteratee ? baseIteratee2 : result2;
            return arguments.length ? result2(arguments[0], arguments[1]) : result2;
          }
          function getMapData2(map2, key2) {
            var data2 = map2.__data__;
            return isKeyable2(key2) ? data2[typeof key2 == "string" ? "string" : "hash"] : data2.map;
          }
          function getMatchData2(object) {
            var result2 = keys2(object), length2 = result2.length;
            while (length2--) {
              var key2 = result2[length2], value2 = object[key2];
              result2[length2] = [key2, value2, isStrictComparable2(value2)];
            }
            return result2;
          }
          function getNative2(object, key2) {
            var value2 = getValue2(object, key2);
            return baseIsNative2(value2) ? value2 : undefined$1;
          }
          function getRawTag2(value2) {
            var isOwn = hasOwnProperty2.call(value2, symToStringTag2), tag = value2[symToStringTag2];
            try {
              value2[symToStringTag2] = undefined$1;
              var unmasked = true;
            } catch (e2) {
            }
            var result2 = nativeObjectToString2.call(value2);
            if (unmasked) {
              if (isOwn) {
                value2[symToStringTag2] = tag;
              } else {
                delete value2[symToStringTag2];
              }
            }
            return result2;
          }
          var getSymbols2 = !nativeGetSymbols2 ? stubArray2 : function(object) {
            if (object == null) {
              return [];
            }
            object = Object2(object);
            return arrayFilter2(nativeGetSymbols2(object), function(symbol) {
              return propertyIsEnumerable2.call(object, symbol);
            });
          };
          var getSymbolsIn = !nativeGetSymbols2 ? stubArray2 : function(object) {
            var result2 = [];
            while (object) {
              arrayPush2(result2, getSymbols2(object));
              object = getPrototype(object);
            }
            return result2;
          };
          var getTag2 = baseGetTag2;
          if (DataView2 && getTag2(new DataView2(new ArrayBuffer(1))) != dataViewTag2 || Map2 && getTag2(new Map2()) != mapTag2 || Promise2 && getTag2(Promise2.resolve()) != promiseTag2 || Set2 && getTag2(new Set2()) != setTag2 || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag2) {
            getTag2 = function(value2) {
              var result2 = baseGetTag2(value2), Ctor = result2 == objectTag2 ? value2.constructor : undefined$1, ctorString = Ctor ? toSource2(Ctor) : "";
              if (ctorString) {
                switch (ctorString) {
                  case dataViewCtorString2:
                    return dataViewTag2;
                  case mapCtorString2:
                    return mapTag2;
                  case promiseCtorString2:
                    return promiseTag2;
                  case setCtorString2:
                    return setTag2;
                  case weakMapCtorString2:
                    return weakMapTag2;
                }
              }
              return result2;
            };
          }
          function getView(start, end, transforms) {
            var index2 = -1, length2 = transforms.length;
            while (++index2 < length2) {
              var data2 = transforms[index2], size2 = data2.size;
              switch (data2.type) {
                case "drop":
                  start += size2;
                  break;
                case "dropRight":
                  end -= size2;
                  break;
                case "take":
                  end = nativeMin(end, start + size2);
                  break;
                case "takeRight":
                  start = nativeMax2(start, end - size2);
                  break;
              }
            }
            return { "start": start, "end": end };
          }
          function getWrapDetails(source) {
            var match2 = source.match(reWrapDetails);
            return match2 ? match2[1].split(reSplitDetails) : [];
          }
          function hasPath2(object, path2, hasFunc) {
            path2 = castPath2(path2, object);
            var index2 = -1, length2 = path2.length, result2 = false;
            while (++index2 < length2) {
              var key2 = toKey2(path2[index2]);
              if (!(result2 = object != null && hasFunc(object, key2))) {
                break;
              }
              object = object[key2];
            }
            if (result2 || ++index2 != length2) {
              return result2;
            }
            length2 = object == null ? 0 : object.length;
            return !!length2 && isLength2(length2) && isIndex2(key2, length2) && (isArray2(object) || isArguments2(object));
          }
          function initCloneArray(array) {
            var length2 = array.length, result2 = new array.constructor(length2);
            if (length2 && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
              result2.index = array.index;
              result2.input = array.input;
            }
            return result2;
          }
          function initCloneObject(object) {
            return typeof object.constructor == "function" && !isPrototype2(object) ? baseCreate(getPrototype(object)) : {};
          }
          function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
              case arrayBufferTag2:
                return cloneArrayBuffer(object);
              case boolTag2:
              case dateTag2:
                return new Ctor(+object);
              case dataViewTag2:
                return cloneDataView(object, isDeep);
              case float32Tag2:
              case float64Tag2:
              case int8Tag2:
              case int16Tag2:
              case int32Tag2:
              case uint8Tag2:
              case uint8ClampedTag2:
              case uint16Tag2:
              case uint32Tag2:
                return cloneTypedArray(object, isDeep);
              case mapTag2:
                return new Ctor();
              case numberTag2:
              case stringTag2:
                return new Ctor(object);
              case regexpTag2:
                return cloneRegExp(object);
              case setTag2:
                return new Ctor();
              case symbolTag2:
                return cloneSymbol(object);
            }
          }
          function insertWrapDetails(source, details) {
            var length2 = details.length;
            if (!length2) {
              return source;
            }
            var lastIndex = length2 - 1;
            details[lastIndex] = (length2 > 1 ? "& " : "") + details[lastIndex];
            details = details.join(length2 > 2 ? ", " : " ");
            return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
          }
          function isFlattenable2(value2) {
            return isArray2(value2) || isArguments2(value2) || !!(spreadableSymbol2 && value2 && value2[spreadableSymbol2]);
          }
          function isIndex2(value2, length2) {
            var type = typeof value2;
            length2 = length2 == null ? MAX_SAFE_INTEGER2 : length2;
            return !!length2 && (type == "number" || type != "symbol" && reIsUint2.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length2);
          }
          function isIterateeCall2(value2, index2, object) {
            if (!isObject2(object)) {
              return false;
            }
            var type = typeof index2;
            if (type == "number" ? isArrayLike2(object) && isIndex2(index2, object.length) : type == "string" && index2 in object) {
              return eq2(object[index2], value2);
            }
            return false;
          }
          function isKey2(value2, object) {
            if (isArray2(value2)) {
              return false;
            }
            var type = typeof value2;
            if (type == "number" || type == "symbol" || type == "boolean" || value2 == null || isSymbol2(value2)) {
              return true;
            }
            return reIsPlainProp2.test(value2) || !reIsDeepProp2.test(value2) || object != null && value2 in Object2(object);
          }
          function isKeyable2(value2) {
            var type = typeof value2;
            return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value2 !== "__proto__" : value2 === null;
          }
          function isLaziable(func) {
            var funcName = getFuncName(func), other = lodash2[funcName];
            if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
              return false;
            }
            if (func === other) {
              return true;
            }
            var data2 = getData(other);
            return !!data2 && func === data2[0];
          }
          function isMasked2(func) {
            return !!maskSrcKey2 && maskSrcKey2 in func;
          }
          var isMaskable = coreJsData2 ? isFunction2 : stubFalse2;
          function isPrototype2(value2) {
            var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
            return value2 === proto;
          }
          function isStrictComparable2(value2) {
            return value2 === value2 && !isObject2(value2);
          }
          function matchesStrictComparable2(key2, srcValue) {
            return function(object) {
              if (object == null) {
                return false;
              }
              return object[key2] === srcValue && (srcValue !== undefined$1 || key2 in Object2(object));
            };
          }
          function memoizeCapped2(func) {
            var result2 = memoize2(func, function(key2) {
              if (cache.size === MAX_MEMOIZE_SIZE2) {
                cache.clear();
              }
              return key2;
            });
            var cache = result2.cache;
            return result2;
          }
          function mergeData(data2, source) {
            var bitmask = data2[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
            var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data2[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
            if (!(isCommon || isCombo)) {
              return data2;
            }
            if (srcBitmask & WRAP_BIND_FLAG) {
              data2[2] = source[2];
              newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
            }
            var value2 = source[3];
            if (value2) {
              var partials = data2[3];
              data2[3] = partials ? composeArgs(partials, value2, source[4]) : value2;
              data2[4] = partials ? replaceHolders(data2[3], PLACEHOLDER) : source[4];
            }
            value2 = source[5];
            if (value2) {
              partials = data2[5];
              data2[5] = partials ? composeArgsRight(partials, value2, source[6]) : value2;
              data2[6] = partials ? replaceHolders(data2[5], PLACEHOLDER) : source[6];
            }
            value2 = source[7];
            if (value2) {
              data2[7] = value2;
            }
            if (srcBitmask & WRAP_ARY_FLAG) {
              data2[8] = data2[8] == null ? source[8] : nativeMin(data2[8], source[8]);
            }
            if (data2[9] == null) {
              data2[9] = source[9];
            }
            data2[0] = source[0];
            data2[1] = newBitmask;
            return data2;
          }
          function nativeKeysIn(object) {
            var result2 = [];
            if (object != null) {
              for (var key2 in Object2(object)) {
                result2.push(key2);
              }
            }
            return result2;
          }
          function objectToString2(value2) {
            return nativeObjectToString2.call(value2);
          }
          function overRest2(func, start, transform3) {
            start = nativeMax2(start === undefined$1 ? func.length - 1 : start, 0);
            return function() {
              var args = arguments, index2 = -1, length2 = nativeMax2(args.length - start, 0), array = Array2(length2);
              while (++index2 < length2) {
                array[index2] = args[start + index2];
              }
              index2 = -1;
              var otherArgs = Array2(start + 1);
              while (++index2 < start) {
                otherArgs[index2] = args[index2];
              }
              otherArgs[start] = transform3(array);
              return apply2(func, this, otherArgs);
            };
          }
          function parent2(object, path2) {
            return path2.length < 2 ? object : baseGet2(object, baseSlice(path2, 0, -1));
          }
          function reorder(array, indexes) {
            var arrLength = array.length, length2 = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
            while (length2--) {
              var index2 = indexes[length2];
              array[length2] = isIndex2(index2, arrLength) ? oldArray[index2] : undefined$1;
            }
            return array;
          }
          function safeGet(object, key2) {
            if (key2 === "constructor" && typeof object[key2] === "function") {
              return;
            }
            if (key2 == "__proto__") {
              return;
            }
            return object[key2];
          }
          var setData = shortOut2(baseSetData);
          var setTimeout2 = ctxSetTimeout || function(func, wait) {
            return root2.setTimeout(func, wait);
          };
          var setToString2 = shortOut2(baseSetToString2);
          function setWrapToString(wrapper2, reference, bitmask) {
            var source = reference + "";
            return setToString2(wrapper2, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
          }
          function shortOut2(func) {
            var count = 0, lastCalled = 0;
            return function() {
              var stamp = nativeNow2(), remaining = HOT_SPAN2 - (stamp - lastCalled);
              lastCalled = stamp;
              if (remaining > 0) {
                if (++count >= HOT_COUNT2) {
                  return arguments[0];
                }
              } else {
                count = 0;
              }
              return func.apply(undefined$1, arguments);
            };
          }
          function shuffleSelf(array, size2) {
            var index2 = -1, length2 = array.length, lastIndex = length2 - 1;
            size2 = size2 === undefined$1 ? length2 : size2;
            while (++index2 < size2) {
              var rand = baseRandom(index2, lastIndex), value2 = array[rand];
              array[rand] = array[index2];
              array[index2] = value2;
            }
            array.length = size2;
            return array;
          }
          var stringToPath2 = memoizeCapped2(function(string) {
            var result2 = [];
            if (string.charCodeAt(0) === 46) {
              result2.push("");
            }
            string.replace(rePropName2, function(match2, number, quote, subString) {
              result2.push(quote ? subString.replace(reEscapeChar2, "$1") : number || match2);
            });
            return result2;
          });
          function toKey2(value2) {
            if (typeof value2 == "string" || isSymbol2(value2)) {
              return value2;
            }
            var result2 = value2 + "";
            return result2 == "0" && 1 / value2 == -INFINITY2 ? "-0" : result2;
          }
          function toSource2(func) {
            if (func != null) {
              try {
                return funcToString2.call(func);
              } catch (e2) {
              }
              try {
                return func + "";
              } catch (e2) {
              }
            }
            return "";
          }
          function updateWrapDetails(details, bitmask) {
            arrayEach(wrapFlags, function(pair) {
              var value2 = "_." + pair[0];
              if (bitmask & pair[1] && !arrayIncludes(details, value2)) {
                details.push(value2);
              }
            });
            return details.sort();
          }
          function wrapperClone(wrapper2) {
            if (wrapper2 instanceof LazyWrapper) {
              return wrapper2.clone();
            }
            var result2 = new LodashWrapper(wrapper2.__wrapped__, wrapper2.__chain__);
            result2.__actions__ = copyArray(wrapper2.__actions__);
            result2.__index__ = wrapper2.__index__;
            result2.__values__ = wrapper2.__values__;
            return result2;
          }
          function chunk(array, size2, guard) {
            if (guard ? isIterateeCall2(array, size2, guard) : size2 === undefined$1) {
              size2 = 1;
            } else {
              size2 = nativeMax2(toInteger(size2), 0);
            }
            var length2 = array == null ? 0 : array.length;
            if (!length2 || size2 < 1) {
              return [];
            }
            var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length2 / size2));
            while (index2 < length2) {
              result2[resIndex++] = baseSlice(array, index2, index2 += size2);
            }
            return result2;
          }
          function compact(array) {
            var index2 = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result2 = [];
            while (++index2 < length2) {
              var value2 = array[index2];
              if (value2) {
                result2[resIndex++] = value2;
              }
            }
            return result2;
          }
          function concat2() {
            var length2 = arguments.length;
            if (!length2) {
              return [];
            }
            var args = Array2(length2 - 1), array = arguments[0], index2 = length2;
            while (index2--) {
              args[index2 - 1] = arguments[index2];
            }
            return arrayPush2(isArray2(array) ? copyArray(array) : [array], baseFlatten2(args, 1));
          }
          var difference = baseRest2(function(array, values2) {
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten2(values2, 1, isArrayLikeObject, true)) : [];
          });
          var differenceBy = baseRest2(function(array, values2) {
            var iteratee2 = last(values2);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined$1;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten2(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
          });
          var differenceWith = baseRest2(function(array, values2) {
            var comparator = last(values2);
            if (isArrayLikeObject(comparator)) {
              comparator = undefined$1;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten2(values2, 1, isArrayLikeObject, true), undefined$1, comparator) : [];
          });
          function drop(array, n2, guard) {
            var length2 = array == null ? 0 : array.length;
            if (!length2) {
              return [];
            }
            n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
            return baseSlice(array, n2 < 0 ? 0 : n2, length2);
          }
          function dropRight(array, n2, guard) {
            var length2 = array == null ? 0 : array.length;
            if (!length2) {
              return [];
            }
            n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
            n2 = length2 - n2;
            return baseSlice(array, 0, n2 < 0 ? 0 : n2);
          }
          function dropRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
          }
          function dropWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
          }
          function fill2(array, value2, start, end) {
            var length2 = array == null ? 0 : array.length;
            if (!length2) {
              return [];
            }
            if (start && typeof start != "number" && isIterateeCall2(array, value2, start)) {
              start = 0;
              end = length2;
            }
            return baseFill(array, value2, start, end);
          }
          function findIndex2(array, predicate, fromIndex) {
            var length2 = array == null ? 0 : array.length;
            if (!length2) {
              return -1;
            }
            var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index2 < 0) {
              index2 = nativeMax2(length2 + index2, 0);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index2);
          }
          function findLastIndex(array, predicate, fromIndex) {
            var length2 = array == null ? 0 : array.length;
            if (!length2) {
              return -1;
            }
            var index2 = length2 - 1;
            if (fromIndex !== undefined$1) {
              index2 = toInteger(fromIndex);
              index2 = fromIndex < 0 ? nativeMax2(length2 + index2, 0) : nativeMin(index2, length2 - 1);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index2, true);
          }
          function flatten(array) {
            var length2 = array == null ? 0 : array.length;
            return length2 ? baseFlatten2(array, 1) : [];
          }
          function flattenDeep(array) {
            var length2 = array == null ? 0 : array.length;
            return length2 ? baseFlatten2(array, INFINITY2) : [];
          }
          function flattenDepth(array, depth) {
            var length2 = array == null ? 0 : array.length;
            if (!length2) {
              return [];
            }
            depth = depth === undefined$1 ? 1 : toInteger(depth);
            return baseFlatten2(array, depth);
          }
          function fromPairs(pairs) {
            var index2 = -1, length2 = pairs == null ? 0 : pairs.length, result2 = {};
            while (++index2 < length2) {
              var pair = pairs[index2];
              result2[pair[0]] = pair[1];
            }
            return result2;
          }
          function head(array) {
            return array && array.length ? array[0] : undefined$1;
          }
          function indexOf(array, value2, fromIndex) {
            var length2 = array == null ? 0 : array.length;
            if (!length2) {
              return -1;
            }
            var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index2 < 0) {
              index2 = nativeMax2(length2 + index2, 0);
            }
            return baseIndexOf(array, value2, index2);
          }
          function initial(array) {
            var length2 = array == null ? 0 : array.length;
            return length2 ? baseSlice(array, 0, -1) : [];
          }
          var intersection = baseRest2(function(arrays) {
            var mapped = arrayMap2(arrays, castArrayLikeObject);
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
          });
          var intersectionBy = baseRest2(function(arrays) {
            var iteratee2 = last(arrays), mapped = arrayMap2(arrays, castArrayLikeObject);
            if (iteratee2 === last(mapped)) {
              iteratee2 = undefined$1;
            } else {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
          });
          var intersectionWith = baseRest2(function(arrays) {
            var comparator = last(arrays), mapped = arrayMap2(arrays, castArrayLikeObject);
            comparator = typeof comparator == "function" ? comparator : undefined$1;
            if (comparator) {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
          });
          function join(array, separator2) {
            return array == null ? "" : nativeJoin.call(array, separator2);
          }
          function last(array) {
            var length2 = array == null ? 0 : array.length;
            return length2 ? array[length2 - 1] : undefined$1;
          }
          function lastIndexOf(array, value2, fromIndex) {
            var length2 = array == null ? 0 : array.length;
            if (!length2) {
              return -1;
            }
            var index2 = length2;
            if (fromIndex !== undefined$1) {
              index2 = toInteger(fromIndex);
              index2 = index2 < 0 ? nativeMax2(length2 + index2, 0) : nativeMin(index2, length2 - 1);
            }
            return value2 === value2 ? strictLastIndexOf(array, value2, index2) : baseFindIndex(array, baseIsNaN, index2, true);
          }
          function nth(array, n2) {
            return array && array.length ? baseNth(array, toInteger(n2)) : undefined$1;
          }
          var pull = baseRest2(pullAll);
          function pullAll(array, values2) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
          }
          function pullAllBy(array, values2, iteratee2) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
          }
          function pullAllWith(array, values2, comparator) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined$1, comparator) : array;
          }
          var pullAt = flatRest(function(array, indexes) {
            var length2 = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
            basePullAt(array, arrayMap2(indexes, function(index2) {
              return isIndex2(index2, length2) ? +index2 : index2;
            }).sort(compareAscending2));
            return result2;
          });
          function remove(array, predicate) {
            var result2 = [];
            if (!(array && array.length)) {
              return result2;
            }
            var index2 = -1, indexes = [], length2 = array.length;
            predicate = getIteratee(predicate, 3);
            while (++index2 < length2) {
              var value2 = array[index2];
              if (predicate(value2, index2, array)) {
                result2.push(value2);
                indexes.push(index2);
              }
            }
            basePullAt(array, indexes);
            return result2;
          }
          function reverse(array) {
            return array == null ? array : nativeReverse.call(array);
          }
          function slice2(array, start, end) {
            var length2 = array == null ? 0 : array.length;
            if (!length2) {
              return [];
            }
            if (end && typeof end != "number" && isIterateeCall2(array, start, end)) {
              start = 0;
              end = length2;
            } else {
              start = start == null ? 0 : toInteger(start);
              end = end === undefined$1 ? length2 : toInteger(end);
            }
            return baseSlice(array, start, end);
          }
          function sortedIndex(array, value2) {
            return baseSortedIndex(array, value2);
          }
          function sortedIndexBy(array, value2, iteratee2) {
            return baseSortedIndexBy(array, value2, getIteratee(iteratee2, 2));
          }
          function sortedIndexOf(array, value2) {
            var length2 = array == null ? 0 : array.length;
            if (length2) {
              var index2 = baseSortedIndex(array, value2);
              if (index2 < length2 && eq2(array[index2], value2)) {
                return index2;
              }
            }
            return -1;
          }
          function sortedLastIndex(array, value2) {
            return baseSortedIndex(array, value2, true);
          }
          function sortedLastIndexBy(array, value2, iteratee2) {
            return baseSortedIndexBy(array, value2, getIteratee(iteratee2, 2), true);
          }
          function sortedLastIndexOf(array, value2) {
            var length2 = array == null ? 0 : array.length;
            if (length2) {
              var index2 = baseSortedIndex(array, value2, true) - 1;
              if (eq2(array[index2], value2)) {
                return index2;
              }
            }
            return -1;
          }
          function sortedUniq(array) {
            return array && array.length ? baseSortedUniq(array) : [];
          }
          function sortedUniqBy(array, iteratee2) {
            return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
          }
          function tail(array) {
            var length2 = array == null ? 0 : array.length;
            return length2 ? baseSlice(array, 1, length2) : [];
          }
          function take(array, n2, guard) {
            if (!(array && array.length)) {
              return [];
            }
            n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
            return baseSlice(array, 0, n2 < 0 ? 0 : n2);
          }
          function takeRight(array, n2, guard) {
            var length2 = array == null ? 0 : array.length;
            if (!length2) {
              return [];
            }
            n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
            n2 = length2 - n2;
            return baseSlice(array, n2 < 0 ? 0 : n2, length2);
          }
          function takeRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
          }
          function takeWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
          }
          var union = baseRest2(function(arrays) {
            return baseUniq(baseFlatten2(arrays, 1, isArrayLikeObject, true));
          });
          var unionBy = baseRest2(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined$1;
            }
            return baseUniq(baseFlatten2(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
          });
          var unionWith = baseRest2(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined$1;
            return baseUniq(baseFlatten2(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
          });
          function uniq(array) {
            return array && array.length ? baseUniq(array) : [];
          }
          function uniqBy(array, iteratee2) {
            return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
          }
          function uniqWith(array, comparator) {
            comparator = typeof comparator == "function" ? comparator : undefined$1;
            return array && array.length ? baseUniq(array, undefined$1, comparator) : [];
          }
          function unzip(array) {
            if (!(array && array.length)) {
              return [];
            }
            var length2 = 0;
            array = arrayFilter2(array, function(group) {
              if (isArrayLikeObject(group)) {
                length2 = nativeMax2(group.length, length2);
                return true;
              }
            });
            return baseTimes2(length2, function(index2) {
              return arrayMap2(array, baseProperty2(index2));
            });
          }
          function unzipWith(array, iteratee2) {
            if (!(array && array.length)) {
              return [];
            }
            var result2 = unzip(array);
            if (iteratee2 == null) {
              return result2;
            }
            return arrayMap2(result2, function(group) {
              return apply2(iteratee2, undefined$1, group);
            });
          }
          var without = baseRest2(function(array, values2) {
            return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
          });
          var xor = baseRest2(function(arrays) {
            return baseXor(arrayFilter2(arrays, isArrayLikeObject));
          });
          var xorBy = baseRest2(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined$1;
            }
            return baseXor(arrayFilter2(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
          });
          var xorWith = baseRest2(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined$1;
            return baseXor(arrayFilter2(arrays, isArrayLikeObject), undefined$1, comparator);
          });
          var zip = baseRest2(unzip);
          function zipObject(props, values2) {
            return baseZipObject(props || [], values2 || [], assignValue);
          }
          function zipObjectDeep(props, values2) {
            return baseZipObject(props || [], values2 || [], baseSet);
          }
          var zipWith = baseRest2(function(arrays) {
            var length2 = arrays.length, iteratee2 = length2 > 1 ? arrays[length2 - 1] : undefined$1;
            iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
            return unzipWith(arrays, iteratee2);
          });
          function chain(value2) {
            var result2 = lodash2(value2);
            result2.__chain__ = true;
            return result2;
          }
          function tap(value2, interceptor) {
            interceptor(value2);
            return value2;
          }
          function thru(value2, interceptor) {
            return interceptor(value2);
          }
          var wrapperAt = flatRest(function(paths) {
            var length2 = paths.length, start = length2 ? paths[0] : 0, value2 = this.__wrapped__, interceptor = function(object) {
              return baseAt(object, paths);
            };
            if (length2 > 1 || this.__actions__.length || !(value2 instanceof LazyWrapper) || !isIndex2(start)) {
              return this.thru(interceptor);
            }
            value2 = value2.slice(start, +start + (length2 ? 1 : 0));
            value2.__actions__.push({
              "func": thru,
              "args": [interceptor],
              "thisArg": undefined$1
            });
            return new LodashWrapper(value2, this.__chain__).thru(function(array) {
              if (length2 && !array.length) {
                array.push(undefined$1);
              }
              return array;
            });
          });
          function wrapperChain() {
            return chain(this);
          }
          function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
          }
          function wrapperNext() {
            if (this.__values__ === undefined$1) {
              this.__values__ = toArray(this.value());
            }
            var done = this.__index__ >= this.__values__.length, value2 = done ? undefined$1 : this.__values__[this.__index__++];
            return { "done": done, "value": value2 };
          }
          function wrapperToIterator() {
            return this;
          }
          function wrapperPlant(value2) {
            var result2, parent3 = this;
            while (parent3 instanceof baseLodash) {
              var clone2 = wrapperClone(parent3);
              clone2.__index__ = 0;
              clone2.__values__ = undefined$1;
              if (result2) {
                previous.__wrapped__ = clone2;
              } else {
                result2 = clone2;
              }
              var previous = clone2;
              parent3 = parent3.__wrapped__;
            }
            previous.__wrapped__ = value2;
            return result2;
          }
          function wrapperReverse() {
            var value2 = this.__wrapped__;
            if (value2 instanceof LazyWrapper) {
              var wrapped = value2;
              if (this.__actions__.length) {
                wrapped = new LazyWrapper(this);
              }
              wrapped = wrapped.reverse();
              wrapped.__actions__.push({
                "func": thru,
                "args": [reverse],
                "thisArg": undefined$1
              });
              return new LodashWrapper(wrapped, this.__chain__);
            }
            return this.thru(reverse);
          }
          function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
          }
          var countBy = createAggregator(function(result2, value2, key2) {
            if (hasOwnProperty2.call(result2, key2)) {
              ++result2[key2];
            } else {
              baseAssignValue(result2, key2, 1);
            }
          });
          function every(collection, predicate, guard) {
            var func = isArray2(collection) ? arrayEvery : baseEvery;
            if (guard && isIterateeCall2(collection, predicate, guard)) {
              predicate = undefined$1;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          function filter(collection, predicate) {
            var func = isArray2(collection) ? arrayFilter2 : baseFilter;
            return func(collection, getIteratee(predicate, 3));
          }
          var find = createFind(findIndex2);
          var findLast = createFind(findLastIndex);
          function flatMap(collection, iteratee2) {
            return baseFlatten2(map(collection, iteratee2), 1);
          }
          function flatMapDeep(collection, iteratee2) {
            return baseFlatten2(map(collection, iteratee2), INFINITY2);
          }
          function flatMapDepth(collection, iteratee2, depth) {
            depth = depth === undefined$1 ? 1 : toInteger(depth);
            return baseFlatten2(map(collection, iteratee2), depth);
          }
          function forEach(collection, iteratee2) {
            var func = isArray2(collection) ? arrayEach : baseEach2;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function forEachRight(collection, iteratee2) {
            var func = isArray2(collection) ? arrayEachRight : baseEachRight;
            return func(collection, getIteratee(iteratee2, 3));
          }
          var groupBy = createAggregator(function(result2, value2, key2) {
            if (hasOwnProperty2.call(result2, key2)) {
              result2[key2].push(value2);
            } else {
              baseAssignValue(result2, key2, [value2]);
            }
          });
          function includes(collection, value2, fromIndex, guard) {
            collection = isArrayLike2(collection) ? collection : values(collection);
            fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
            var length2 = collection.length;
            if (fromIndex < 0) {
              fromIndex = nativeMax2(length2 + fromIndex, 0);
            }
            return isString2(collection) ? fromIndex <= length2 && collection.indexOf(value2, fromIndex) > -1 : !!length2 && baseIndexOf(collection, value2, fromIndex) > -1;
          }
          var invokeMap = baseRest2(function(collection, path2, args) {
            var index2 = -1, isFunc = typeof path2 == "function", result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
            baseEach2(collection, function(value2) {
              result2[++index2] = isFunc ? apply2(path2, value2, args) : baseInvoke(value2, path2, args);
            });
            return result2;
          });
          var keyBy = createAggregator(function(result2, value2, key2) {
            baseAssignValue(result2, key2, value2);
          });
          function map(collection, iteratee2) {
            var func = isArray2(collection) ? arrayMap2 : baseMap2;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function orderBy2(collection, iteratees, orders, guard) {
            if (collection == null) {
              return [];
            }
            if (!isArray2(iteratees)) {
              iteratees = iteratees == null ? [] : [iteratees];
            }
            orders = guard ? undefined$1 : orders;
            if (!isArray2(orders)) {
              orders = orders == null ? [] : [orders];
            }
            return baseOrderBy2(collection, iteratees, orders);
          }
          var partition = createAggregator(function(result2, value2, key2) {
            result2[key2 ? 0 : 1].push(value2);
          }, function() {
            return [[], []];
          });
          function reduce(collection, iteratee2, accumulator) {
            var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach2);
          }
          function reduceRight(collection, iteratee2, accumulator) {
            var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
          }
          function reject(collection, predicate) {
            var func = isArray2(collection) ? arrayFilter2 : baseFilter;
            return func(collection, negate(getIteratee(predicate, 3)));
          }
          function sample(collection) {
            var func = isArray2(collection) ? arraySample : baseSample;
            return func(collection);
          }
          function sampleSize(collection, n2, guard) {
            if (guard ? isIterateeCall2(collection, n2, guard) : n2 === undefined$1) {
              n2 = 1;
            } else {
              n2 = toInteger(n2);
            }
            var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
            return func(collection, n2);
          }
          function shuffle(collection) {
            var func = isArray2(collection) ? arrayShuffle : baseShuffle;
            return func(collection);
          }
          function size(collection) {
            if (collection == null) {
              return 0;
            }
            if (isArrayLike2(collection)) {
              return isString2(collection) ? stringSize(collection) : collection.length;
            }
            var tag = getTag2(collection);
            if (tag == mapTag2 || tag == setTag2) {
              return collection.size;
            }
            return baseKeys2(collection).length;
          }
          function some(collection, predicate, guard) {
            var func = isArray2(collection) ? arraySome2 : baseSome;
            if (guard && isIterateeCall2(collection, predicate, guard)) {
              predicate = undefined$1;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          var sortBy2 = baseRest2(function(collection, iteratees) {
            if (collection == null) {
              return [];
            }
            var length2 = iteratees.length;
            if (length2 > 1 && isIterateeCall2(collection, iteratees[0], iteratees[1])) {
              iteratees = [];
            } else if (length2 > 2 && isIterateeCall2(iteratees[0], iteratees[1], iteratees[2])) {
              iteratees = [iteratees[0]];
            }
            return baseOrderBy2(collection, baseFlatten2(iteratees, 1), []);
          });
          var now = ctxNow || function() {
            return root2.Date.now();
          };
          function after(n2, func) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT2);
            }
            n2 = toInteger(n2);
            return function() {
              if (--n2 < 1) {
                return func.apply(this, arguments);
              }
            };
          }
          function ary(func, n2, guard) {
            n2 = guard ? undefined$1 : n2;
            n2 = func && n2 == null ? func.length : n2;
            return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n2);
          }
          function before(n2, func) {
            var result2;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT2);
            }
            n2 = toInteger(n2);
            return function() {
              if (--n2 > 0) {
                result2 = func.apply(this, arguments);
              }
              if (n2 <= 1) {
                func = undefined$1;
              }
              return result2;
            };
          }
          var bind = baseRest2(function(func, thisArg, partials) {
            var bitmask = WRAP_BIND_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bind));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(func, bitmask, thisArg, partials, holders);
          });
          var bindKey = baseRest2(function(object, key2, partials) {
            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bindKey));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(key2, bitmask, object, partials, holders);
          });
          function curry(func, arity, guard) {
            arity = guard ? undefined$1 : arity;
            var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
            result2.placeholder = curry.placeholder;
            return result2;
          }
          function curryRight(func, arity, guard) {
            arity = guard ? undefined$1 : arity;
            var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
            result2.placeholder = curryRight.placeholder;
            return result2;
          }
          function debounce(func, wait, options) {
            var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT2);
            }
            wait = toNumber(wait) || 0;
            if (isObject2(options)) {
              leading = !!options.leading;
              maxing = "maxWait" in options;
              maxWait = maxing ? nativeMax2(toNumber(options.maxWait) || 0, wait) : maxWait;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            function invokeFunc(time2) {
              var args = lastArgs, thisArg = lastThis;
              lastArgs = lastThis = undefined$1;
              lastInvokeTime = time2;
              result2 = func.apply(thisArg, args);
              return result2;
            }
            function leadingEdge(time2) {
              lastInvokeTime = time2;
              timerId = setTimeout2(timerExpired, wait);
              return leading ? invokeFunc(time2) : result2;
            }
            function remainingWait(time2) {
              var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
              return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            }
            function shouldInvoke(time2) {
              var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
              return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
              var time2 = now();
              if (shouldInvoke(time2)) {
                return trailingEdge(time2);
              }
              timerId = setTimeout2(timerExpired, remainingWait(time2));
            }
            function trailingEdge(time2) {
              timerId = undefined$1;
              if (trailing && lastArgs) {
                return invokeFunc(time2);
              }
              lastArgs = lastThis = undefined$1;
              return result2;
            }
            function cancel() {
              if (timerId !== undefined$1) {
                clearTimeout2(timerId);
              }
              lastInvokeTime = 0;
              lastArgs = lastCallTime = lastThis = timerId = undefined$1;
            }
            function flush() {
              return timerId === undefined$1 ? result2 : trailingEdge(now());
            }
            function debounced() {
              var time2 = now(), isInvoking = shouldInvoke(time2);
              lastArgs = arguments;
              lastThis = this;
              lastCallTime = time2;
              if (isInvoking) {
                if (timerId === undefined$1) {
                  return leadingEdge(lastCallTime);
                }
                if (maxing) {
                  clearTimeout2(timerId);
                  timerId = setTimeout2(timerExpired, wait);
                  return invokeFunc(lastCallTime);
                }
              }
              if (timerId === undefined$1) {
                timerId = setTimeout2(timerExpired, wait);
              }
              return result2;
            }
            debounced.cancel = cancel;
            debounced.flush = flush;
            return debounced;
          }
          var defer2 = baseRest2(function(func, args) {
            return baseDelay(func, 1, args);
          });
          var delay = baseRest2(function(func, wait, args) {
            return baseDelay(func, toNumber(wait) || 0, args);
          });
          function flip(func) {
            return createWrap(func, WRAP_FLIP_FLAG);
          }
          function memoize2(func, resolver) {
            if (typeof func != "function" || resolver != null && typeof resolver != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT2);
            }
            var memoized = function() {
              var args = arguments, key2 = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
              if (cache.has(key2)) {
                return cache.get(key2);
              }
              var result2 = func.apply(this, args);
              memoized.cache = cache.set(key2, result2) || cache;
              return result2;
            };
            memoized.cache = new (memoize2.Cache || MapCache2)();
            return memoized;
          }
          memoize2.Cache = MapCache2;
          function negate(predicate) {
            if (typeof predicate != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT2);
            }
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return !predicate.call(this);
                case 1:
                  return !predicate.call(this, args[0]);
                case 2:
                  return !predicate.call(this, args[0], args[1]);
                case 3:
                  return !predicate.call(this, args[0], args[1], args[2]);
              }
              return !predicate.apply(this, args);
            };
          }
          function once(func) {
            return before(2, func);
          }
          var overArgs = castRest(function(func, transforms) {
            transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap2(transforms[0], baseUnary2(getIteratee())) : arrayMap2(baseFlatten2(transforms, 1), baseUnary2(getIteratee()));
            var funcsLength = transforms.length;
            return baseRest2(function(args) {
              var index2 = -1, length2 = nativeMin(args.length, funcsLength);
              while (++index2 < length2) {
                args[index2] = transforms[index2].call(this, args[index2]);
              }
              return apply2(func, this, args);
            });
          });
          var partial = baseRest2(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partial));
            return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
          });
          var partialRight = baseRest2(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partialRight));
            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
          });
          var rearg = flatRest(function(func, indexes) {
            return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
          });
          function rest(func, start) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT2);
            }
            start = start === undefined$1 ? start : toInteger(start);
            return baseRest2(func, start);
          }
          function spread(func, start) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT2);
            }
            start = start == null ? 0 : nativeMax2(toInteger(start), 0);
            return baseRest2(function(args) {
              var array = args[start], otherArgs = castSlice(args, 0, start);
              if (array) {
                arrayPush2(otherArgs, array);
              }
              return apply2(func, this, otherArgs);
            });
          }
          function throttle(func, wait, options) {
            var leading = true, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT2);
            }
            if (isObject2(options)) {
              leading = "leading" in options ? !!options.leading : leading;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            return debounce(func, wait, {
              "leading": leading,
              "maxWait": wait,
              "trailing": trailing
            });
          }
          function unary(func) {
            return ary(func, 1);
          }
          function wrap2(value2, wrapper2) {
            return partial(castFunction(wrapper2), value2);
          }
          function castArray() {
            if (!arguments.length) {
              return [];
            }
            var value2 = arguments[0];
            return isArray2(value2) ? value2 : [value2];
          }
          function clone(value2) {
            return baseClone(value2, CLONE_SYMBOLS_FLAG);
          }
          function cloneWith(value2, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined$1;
            return baseClone(value2, CLONE_SYMBOLS_FLAG, customizer);
          }
          function cloneDeep(value2) {
            return baseClone(value2, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
          }
          function cloneDeepWith(value2, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined$1;
            return baseClone(value2, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
          }
          function conformsTo(object, source) {
            return source == null || baseConformsTo(object, source, keys2(source));
          }
          function eq2(value2, other) {
            return value2 === other || value2 !== value2 && other !== other;
          }
          var gt = createRelationalOperation(baseGt);
          var gte = createRelationalOperation(function(value2, other) {
            return value2 >= other;
          });
          var isArguments2 = baseIsArguments2(/* @__PURE__ */ function() {
            return arguments;
          }()) ? baseIsArguments2 : function(value2) {
            return isObjectLike2(value2) && hasOwnProperty2.call(value2, "callee") && !propertyIsEnumerable2.call(value2, "callee");
          };
          var isArray2 = Array2.isArray;
          var isArrayBuffer = nodeIsArrayBuffer ? baseUnary2(nodeIsArrayBuffer) : baseIsArrayBuffer;
          function isArrayLike2(value2) {
            return value2 != null && isLength2(value2.length) && !isFunction2(value2);
          }
          function isArrayLikeObject(value2) {
            return isObjectLike2(value2) && isArrayLike2(value2);
          }
          function isBoolean2(value2) {
            return value2 === true || value2 === false || isObjectLike2(value2) && baseGetTag2(value2) == boolTag2;
          }
          var isBuffer2 = nativeIsBuffer2 || stubFalse2;
          var isDate2 = nodeIsDate ? baseUnary2(nodeIsDate) : baseIsDate;
          function isElement2(value2) {
            return isObjectLike2(value2) && value2.nodeType === 1 && !isPlainObject2(value2);
          }
          function isEmpty(value2) {
            if (value2 == null) {
              return true;
            }
            if (isArrayLike2(value2) && (isArray2(value2) || typeof value2 == "string" || typeof value2.splice == "function" || isBuffer2(value2) || isTypedArray2(value2) || isArguments2(value2))) {
              return !value2.length;
            }
            var tag = getTag2(value2);
            if (tag == mapTag2 || tag == setTag2) {
              return !value2.size;
            }
            if (isPrototype2(value2)) {
              return !baseKeys2(value2).length;
            }
            for (var key2 in value2) {
              if (hasOwnProperty2.call(value2, key2)) {
                return false;
              }
            }
            return true;
          }
          function isEqual(value2, other) {
            return baseIsEqual2(value2, other);
          }
          function isEqualWith(value2, other, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined$1;
            var result2 = customizer ? customizer(value2, other) : undefined$1;
            return result2 === undefined$1 ? baseIsEqual2(value2, other, undefined$1, customizer) : !!result2;
          }
          function isError2(value2) {
            if (!isObjectLike2(value2)) {
              return false;
            }
            var tag = baseGetTag2(value2);
            return tag == errorTag2 || tag == domExcTag || typeof value2.message == "string" && typeof value2.name == "string" && !isPlainObject2(value2);
          }
          function isFinite(value2) {
            return typeof value2 == "number" && nativeIsFinite(value2);
          }
          function isFunction2(value2) {
            if (!isObject2(value2)) {
              return false;
            }
            var tag = baseGetTag2(value2);
            return tag == funcTag2 || tag == genTag2 || tag == asyncTag2 || tag == proxyTag2;
          }
          function isInteger(value2) {
            return typeof value2 == "number" && value2 == toInteger(value2);
          }
          function isLength2(value2) {
            return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER2;
          }
          function isObject2(value2) {
            var type = typeof value2;
            return value2 != null && (type == "object" || type == "function");
          }
          function isObjectLike2(value2) {
            return value2 != null && typeof value2 == "object";
          }
          var isMap2 = nodeIsMap ? baseUnary2(nodeIsMap) : baseIsMap;
          function isMatch(object, source) {
            return object === source || baseIsMatch2(object, source, getMatchData2(source));
          }
          function isMatchWith(object, source, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined$1;
            return baseIsMatch2(object, source, getMatchData2(source), customizer);
          }
          function isNaN2(value2) {
            return isNumber(value2) && value2 != +value2;
          }
          function isNative(value2) {
            if (isMaskable(value2)) {
              throw new Error2(CORE_ERROR_TEXT);
            }
            return baseIsNative2(value2);
          }
          function isNull(value2) {
            return value2 === null;
          }
          function isNil(value2) {
            return value2 == null;
          }
          function isNumber(value2) {
            return typeof value2 == "number" || isObjectLike2(value2) && baseGetTag2(value2) == numberTag2;
          }
          function isPlainObject2(value2) {
            if (!isObjectLike2(value2) || baseGetTag2(value2) != objectTag2) {
              return false;
            }
            var proto = getPrototype(value2);
            if (proto === null) {
              return true;
            }
            var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
            return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString2.call(Ctor) == objectCtorString2;
          }
          var isRegExp2 = nodeIsRegExp ? baseUnary2(nodeIsRegExp) : baseIsRegExp;
          function isSafeInteger(value2) {
            return isInteger(value2) && value2 >= -MAX_SAFE_INTEGER2 && value2 <= MAX_SAFE_INTEGER2;
          }
          var isSet2 = nodeIsSet ? baseUnary2(nodeIsSet) : baseIsSet;
          function isString2(value2) {
            return typeof value2 == "string" || !isArray2(value2) && isObjectLike2(value2) && baseGetTag2(value2) == stringTag2;
          }
          function isSymbol2(value2) {
            return typeof value2 == "symbol" || isObjectLike2(value2) && baseGetTag2(value2) == symbolTag2;
          }
          var isTypedArray2 = nodeIsTypedArray2 ? baseUnary2(nodeIsTypedArray2) : baseIsTypedArray2;
          function isUndefined(value2) {
            return value2 === undefined$1;
          }
          function isWeakMap(value2) {
            return isObjectLike2(value2) && getTag2(value2) == weakMapTag2;
          }
          function isWeakSet(value2) {
            return isObjectLike2(value2) && baseGetTag2(value2) == weakSetTag;
          }
          var lt = createRelationalOperation(baseLt);
          var lte = createRelationalOperation(function(value2, other) {
            return value2 <= other;
          });
          function toArray(value2) {
            if (!value2) {
              return [];
            }
            if (isArrayLike2(value2)) {
              return isString2(value2) ? stringToArray(value2) : copyArray(value2);
            }
            if (symIterator && value2[symIterator]) {
              return iteratorToArray(value2[symIterator]());
            }
            var tag = getTag2(value2), func = tag == mapTag2 ? mapToArray2 : tag == setTag2 ? setToArray2 : values;
            return func(value2);
          }
          function toFinite(value2) {
            if (!value2) {
              return value2 === 0 ? value2 : 0;
            }
            value2 = toNumber(value2);
            if (value2 === INFINITY2 || value2 === -INFINITY2) {
              var sign = value2 < 0 ? -1 : 1;
              return sign * MAX_INTEGER;
            }
            return value2 === value2 ? value2 : 0;
          }
          function toInteger(value2) {
            var result2 = toFinite(value2), remainder = result2 % 1;
            return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
          }
          function toLength(value2) {
            return value2 ? baseClamp(toInteger(value2), 0, MAX_ARRAY_LENGTH) : 0;
          }
          function toNumber(value2) {
            if (typeof value2 == "number") {
              return value2;
            }
            if (isSymbol2(value2)) {
              return NAN;
            }
            if (isObject2(value2)) {
              var other = typeof value2.valueOf == "function" ? value2.valueOf() : value2;
              value2 = isObject2(other) ? other + "" : other;
            }
            if (typeof value2 != "string") {
              return value2 === 0 ? value2 : +value2;
            }
            value2 = baseTrim(value2);
            var isBinary = reIsBinary.test(value2);
            return isBinary || reIsOctal.test(value2) ? freeParseInt(value2.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value2) ? NAN : +value2;
          }
          function toPlainObject(value2) {
            return copyObject(value2, keysIn(value2));
          }
          function toSafeInteger(value2) {
            return value2 ? baseClamp(toInteger(value2), -MAX_SAFE_INTEGER2, MAX_SAFE_INTEGER2) : value2 === 0 ? value2 : 0;
          }
          function toString2(value2) {
            return value2 == null ? "" : baseToString2(value2);
          }
          var assign = createAssigner(function(object, source) {
            if (isPrototype2(source) || isArrayLike2(source)) {
              copyObject(source, keys2(source), object);
              return;
            }
            for (var key2 in source) {
              if (hasOwnProperty2.call(source, key2)) {
                assignValue(object, key2, source[key2]);
              }
            }
          });
          var assignIn = createAssigner(function(object, source) {
            copyObject(source, keysIn(source), object);
          });
          var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keysIn(source), object, customizer);
          });
          var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keys2(source), object, customizer);
          });
          var at = flatRest(baseAt);
          function create(prototype, properties) {
            var result2 = baseCreate(prototype);
            return properties == null ? result2 : baseAssign(result2, properties);
          }
          var defaults2 = baseRest2(function(object, sources) {
            object = Object2(object);
            var index2 = -1;
            var length2 = sources.length;
            var guard = length2 > 2 ? sources[2] : undefined$1;
            if (guard && isIterateeCall2(sources[0], sources[1], guard)) {
              length2 = 1;
            }
            while (++index2 < length2) {
              var source = sources[index2];
              var props = keysIn(source);
              var propsIndex = -1;
              var propsLength = props.length;
              while (++propsIndex < propsLength) {
                var key2 = props[propsIndex];
                var value2 = object[key2];
                if (value2 === undefined$1 || eq2(value2, objectProto2[key2]) && !hasOwnProperty2.call(object, key2)) {
                  object[key2] = source[key2];
                }
              }
            }
            return object;
          });
          var defaultsDeep = baseRest2(function(args) {
            args.push(undefined$1, customDefaultsMerge);
            return apply2(mergeWith, undefined$1, args);
          });
          function findKey2(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwn2);
          }
          function findLastKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
          }
          function forIn(object, iteratee2) {
            return object == null ? object : baseFor2(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forInRight(object, iteratee2) {
            return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forOwn(object, iteratee2) {
            return object && baseForOwn2(object, getIteratee(iteratee2, 3));
          }
          function forOwnRight(object, iteratee2) {
            return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
          }
          function functions(object) {
            return object == null ? [] : baseFunctions(object, keys2(object));
          }
          function functionsIn(object) {
            return object == null ? [] : baseFunctions(object, keysIn(object));
          }
          function get2(object, path2, defaultValue) {
            var result2 = object == null ? undefined$1 : baseGet2(object, path2);
            return result2 === undefined$1 ? defaultValue : result2;
          }
          function has2(object, path2) {
            return object != null && hasPath2(object, path2, baseHas);
          }
          function hasIn2(object, path2) {
            return object != null && hasPath2(object, path2, baseHasIn2);
          }
          var invert = createInverter(function(result2, value2, key2) {
            if (value2 != null && typeof value2.toString != "function") {
              value2 = nativeObjectToString2.call(value2);
            }
            result2[value2] = key2;
          }, constant2(identity2));
          var invertBy = createInverter(function(result2, value2, key2) {
            if (value2 != null && typeof value2.toString != "function") {
              value2 = nativeObjectToString2.call(value2);
            }
            if (hasOwnProperty2.call(result2, value2)) {
              result2[value2].push(key2);
            } else {
              result2[value2] = [key2];
            }
          }, getIteratee);
          var invoke = baseRest2(baseInvoke);
          function keys2(object) {
            return isArrayLike2(object) ? arrayLikeKeys2(object) : baseKeys2(object);
          }
          function keysIn(object) {
            return isArrayLike2(object) ? arrayLikeKeys2(object, true) : baseKeysIn(object);
          }
          function mapKeys(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn2(object, function(value2, key2, object2) {
              baseAssignValue(result2, iteratee2(value2, key2, object2), value2);
            });
            return result2;
          }
          function mapValues2(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn2(object, function(value2, key2, object2) {
              baseAssignValue(result2, key2, iteratee2(value2, key2, object2));
            });
            return result2;
          }
          var merge = createAssigner(function(object, source, srcIndex) {
            baseMerge(object, source, srcIndex);
          });
          var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
            baseMerge(object, source, srcIndex, customizer);
          });
          var omit = flatRest(function(object, paths) {
            var result2 = {};
            if (object == null) {
              return result2;
            }
            var isDeep = false;
            paths = arrayMap2(paths, function(path2) {
              path2 = castPath2(path2, object);
              isDeep || (isDeep = path2.length > 1);
              return path2;
            });
            copyObject(object, getAllKeysIn(object), result2);
            if (isDeep) {
              result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
            }
            var length2 = paths.length;
            while (length2--) {
              baseUnset(result2, paths[length2]);
            }
            return result2;
          });
          function omitBy(object, predicate) {
            return pickBy(object, negate(getIteratee(predicate)));
          }
          var pick = flatRest(function(object, paths) {
            return object == null ? {} : basePick(object, paths);
          });
          function pickBy(object, predicate) {
            if (object == null) {
              return {};
            }
            var props = arrayMap2(getAllKeysIn(object), function(prop) {
              return [prop];
            });
            predicate = getIteratee(predicate);
            return basePickBy(object, props, function(value2, path2) {
              return predicate(value2, path2[0]);
            });
          }
          function result(object, path2, defaultValue) {
            path2 = castPath2(path2, object);
            var index2 = -1, length2 = path2.length;
            if (!length2) {
              length2 = 1;
              object = undefined$1;
            }
            while (++index2 < length2) {
              var value2 = object == null ? undefined$1 : object[toKey2(path2[index2])];
              if (value2 === undefined$1) {
                index2 = length2;
                value2 = defaultValue;
              }
              object = isFunction2(value2) ? value2.call(object) : value2;
            }
            return object;
          }
          function set2(object, path2, value2) {
            return object == null ? object : baseSet(object, path2, value2);
          }
          function setWith(object, path2, value2, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined$1;
            return object == null ? object : baseSet(object, path2, value2, customizer);
          }
          var toPairs = createToPairs(keys2);
          var toPairsIn = createToPairs(keysIn);
          function transform2(object, iteratee2, accumulator) {
            var isArr = isArray2(object), isArrLike = isArr || isBuffer2(object) || isTypedArray2(object);
            iteratee2 = getIteratee(iteratee2, 4);
            if (accumulator == null) {
              var Ctor = object && object.constructor;
              if (isArrLike) {
                accumulator = isArr ? new Ctor() : [];
              } else if (isObject2(object)) {
                accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
              } else {
                accumulator = {};
              }
            }
            (isArrLike ? arrayEach : baseForOwn2)(object, function(value2, index2, object2) {
              return iteratee2(accumulator, value2, index2, object2);
            });
            return accumulator;
          }
          function unset(object, path2) {
            return object == null ? true : baseUnset(object, path2);
          }
          function update(object, path2, updater) {
            return object == null ? object : baseUpdate(object, path2, castFunction(updater));
          }
          function updateWith(object, path2, updater, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined$1;
            return object == null ? object : baseUpdate(object, path2, castFunction(updater), customizer);
          }
          function values(object) {
            return object == null ? [] : baseValues(object, keys2(object));
          }
          function valuesIn(object) {
            return object == null ? [] : baseValues(object, keysIn(object));
          }
          function clamp2(number, lower, upper) {
            if (upper === undefined$1) {
              upper = lower;
              lower = undefined$1;
            }
            if (upper !== undefined$1) {
              upper = toNumber(upper);
              upper = upper === upper ? upper : 0;
            }
            if (lower !== undefined$1) {
              lower = toNumber(lower);
              lower = lower === lower ? lower : 0;
            }
            return baseClamp(toNumber(number), lower, upper);
          }
          function inRange(number, start, end) {
            start = toFinite(start);
            if (end === undefined$1) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            number = toNumber(number);
            return baseInRange(number, start, end);
          }
          function random2(lower, upper, floating) {
            if (floating && typeof floating != "boolean" && isIterateeCall2(lower, upper, floating)) {
              upper = floating = undefined$1;
            }
            if (floating === undefined$1) {
              if (typeof upper == "boolean") {
                floating = upper;
                upper = undefined$1;
              } else if (typeof lower == "boolean") {
                floating = lower;
                lower = undefined$1;
              }
            }
            if (lower === undefined$1 && upper === undefined$1) {
              lower = 0;
              upper = 1;
            } else {
              lower = toFinite(lower);
              if (upper === undefined$1) {
                upper = lower;
                lower = 0;
              } else {
                upper = toFinite(upper);
              }
            }
            if (lower > upper) {
              var temp = lower;
              lower = upper;
              upper = temp;
            }
            if (floating || lower % 1 || upper % 1) {
              var rand = nativeRandom();
              return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
            }
            return baseRandom(lower, upper);
          }
          var camelCase = createCompounder(function(result2, word, index2) {
            word = word.toLowerCase();
            return result2 + (index2 ? capitalize2(word) : word);
          });
          function capitalize2(string) {
            return upperFirst(toString2(string).toLowerCase());
          }
          function deburr(string) {
            string = toString2(string);
            return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
          }
          function endsWith(string, target, position2) {
            string = toString2(string);
            target = baseToString2(target);
            var length2 = string.length;
            position2 = position2 === undefined$1 ? length2 : baseClamp(toInteger(position2), 0, length2);
            var end = position2;
            position2 -= target.length;
            return position2 >= 0 && string.slice(position2, end) == target;
          }
          function escape2(string) {
            string = toString2(string);
            return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
          }
          function escapeRegExp(string) {
            string = toString2(string);
            return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar2, "\\$&") : string;
          }
          var kebabCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? "-" : "") + word.toLowerCase();
          });
          var lowerCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? " " : "") + word.toLowerCase();
          });
          var lowerFirst = createCaseFirst("toLowerCase");
          function pad(string, length2, chars2) {
            string = toString2(string);
            length2 = toInteger(length2);
            var strLength = length2 ? stringSize(string) : 0;
            if (!length2 || strLength >= length2) {
              return string;
            }
            var mid = (length2 - strLength) / 2;
            return createPadding(nativeFloor(mid), chars2) + string + createPadding(nativeCeil(mid), chars2);
          }
          function padEnd(string, length2, chars2) {
            string = toString2(string);
            length2 = toInteger(length2);
            var strLength = length2 ? stringSize(string) : 0;
            return length2 && strLength < length2 ? string + createPadding(length2 - strLength, chars2) : string;
          }
          function padStart(string, length2, chars2) {
            string = toString2(string);
            length2 = toInteger(length2);
            var strLength = length2 ? stringSize(string) : 0;
            return length2 && strLength < length2 ? createPadding(length2 - strLength, chars2) + string : string;
          }
          function parseInt2(string, radix, guard) {
            if (guard || radix == null) {
              radix = 0;
            } else if (radix) {
              radix = +radix;
            }
            return nativeParseInt(toString2(string).replace(reTrimStart, ""), radix || 0);
          }
          function repeat(string, n2, guard) {
            if (guard ? isIterateeCall2(string, n2, guard) : n2 === undefined$1) {
              n2 = 1;
            } else {
              n2 = toInteger(n2);
            }
            return baseRepeat(toString2(string), n2);
          }
          function replace() {
            var args = arguments, string = toString2(args[0]);
            return args.length < 3 ? string : string.replace(args[1], args[2]);
          }
          var snakeCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? "_" : "") + word.toLowerCase();
          });
          function split(string, separator2, limit) {
            if (limit && typeof limit != "number" && isIterateeCall2(string, separator2, limit)) {
              separator2 = limit = undefined$1;
            }
            limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
            if (!limit) {
              return [];
            }
            string = toString2(string);
            if (string && (typeof separator2 == "string" || separator2 != null && !isRegExp2(separator2))) {
              separator2 = baseToString2(separator2);
              if (!separator2 && hasUnicode(string)) {
                return castSlice(stringToArray(string), 0, limit);
              }
            }
            return string.split(separator2, limit);
          }
          var startCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? " " : "") + upperFirst(word);
          });
          function startsWith(string, target, position2) {
            string = toString2(string);
            position2 = position2 == null ? 0 : baseClamp(toInteger(position2), 0, string.length);
            target = baseToString2(target);
            return string.slice(position2, position2 + target.length) == target;
          }
          function template(string, options, guard) {
            var settings2 = lodash2.templateSettings;
            if (guard && isIterateeCall2(string, options, guard)) {
              options = undefined$1;
            }
            string = toString2(string);
            options = assignInWith({}, options, settings2, customDefaultsAssignIn);
            var imports = assignInWith({}, options.imports, settings2.imports, customDefaultsAssignIn), importsKeys = keys2(imports), importsValues = baseValues(imports, importsKeys);
            var isEscaping, isEvaluating, index2 = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
            var reDelimiters = RegExp2(
              (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
              "g"
            );
            var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
            string.replace(reDelimiters, function(match2, escapeValue, interpolateValue2, esTemplateValue, evaluateValue, offset) {
              interpolateValue2 || (interpolateValue2 = esTemplateValue);
              source += string.slice(index2, offset).replace(reUnescapedString, escapeStringChar);
              if (escapeValue) {
                isEscaping = true;
                source += "' +\n__e(" + escapeValue + ") +\n'";
              }
              if (evaluateValue) {
                isEvaluating = true;
                source += "';\n" + evaluateValue + ";\n__p += '";
              }
              if (interpolateValue2) {
                source += "' +\n((__t = (" + interpolateValue2 + ")) == null ? '' : __t) +\n'";
              }
              index2 = offset + match2.length;
              return match2;
            });
            source += "';\n";
            var variable = hasOwnProperty2.call(options, "variable") && options.variable;
            if (!variable) {
              source = "with (obj) {\n" + source + "\n}\n";
            } else if (reForbiddenIdentifierChars.test(variable)) {
              throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
            }
            source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
            source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var result2 = attempt(function() {
              return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
            });
            result2.source = source;
            if (isError2(result2)) {
              throw result2;
            }
            return result2;
          }
          function toLower(value2) {
            return toString2(value2).toLowerCase();
          }
          function toUpper(value2) {
            return toString2(value2).toUpperCase();
          }
          function trim(string, chars2, guard) {
            string = toString2(string);
            if (string && (guard || chars2 === undefined$1)) {
              return baseTrim(string);
            }
            if (!string || !(chars2 = baseToString2(chars2))) {
              return string;
            }
            var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars2), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
            return castSlice(strSymbols, start, end).join("");
          }
          function trimEnd(string, chars2, guard) {
            string = toString2(string);
            if (string && (guard || chars2 === undefined$1)) {
              return string.slice(0, trimmedEndIndex(string) + 1);
            }
            if (!string || !(chars2 = baseToString2(chars2))) {
              return string;
            }
            var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars2)) + 1;
            return castSlice(strSymbols, 0, end).join("");
          }
          function trimStart(string, chars2, guard) {
            string = toString2(string);
            if (string && (guard || chars2 === undefined$1)) {
              return string.replace(reTrimStart, "");
            }
            if (!string || !(chars2 = baseToString2(chars2))) {
              return string;
            }
            var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars2));
            return castSlice(strSymbols, start).join("");
          }
          function truncate2(string, options) {
            var length2 = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
            if (isObject2(options)) {
              var separator2 = "separator" in options ? options.separator : separator2;
              length2 = "length" in options ? toInteger(options.length) : length2;
              omission = "omission" in options ? baseToString2(options.omission) : omission;
            }
            string = toString2(string);
            var strLength = string.length;
            if (hasUnicode(string)) {
              var strSymbols = stringToArray(string);
              strLength = strSymbols.length;
            }
            if (length2 >= strLength) {
              return string;
            }
            var end = length2 - stringSize(omission);
            if (end < 1) {
              return omission;
            }
            var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
            if (separator2 === undefined$1) {
              return result2 + omission;
            }
            if (strSymbols) {
              end += result2.length - end;
            }
            if (isRegExp2(separator2)) {
              if (string.slice(end).search(separator2)) {
                var match2, substring2 = result2;
                if (!separator2.global) {
                  separator2 = RegExp2(separator2.source, toString2(reFlags.exec(separator2)) + "g");
                }
                separator2.lastIndex = 0;
                while (match2 = separator2.exec(substring2)) {
                  var newEnd = match2.index;
                }
                result2 = result2.slice(0, newEnd === undefined$1 ? end : newEnd);
              }
            } else if (string.indexOf(baseToString2(separator2), end) != end) {
              var index2 = result2.lastIndexOf(separator2);
              if (index2 > -1) {
                result2 = result2.slice(0, index2);
              }
            }
            return result2 + omission;
          }
          function unescape2(string) {
            string = toString2(string);
            return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
          }
          var upperCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? " " : "") + word.toUpperCase();
          });
          var upperFirst = createCaseFirst("toUpperCase");
          function words(string, pattern, guard) {
            string = toString2(string);
            pattern = guard ? undefined$1 : pattern;
            if (pattern === undefined$1) {
              return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
            }
            return string.match(pattern) || [];
          }
          var attempt = baseRest2(function(func, args) {
            try {
              return apply2(func, undefined$1, args);
            } catch (e2) {
              return isError2(e2) ? e2 : new Error2(e2);
            }
          });
          var bindAll = flatRest(function(object, methodNames) {
            arrayEach(methodNames, function(key2) {
              key2 = toKey2(key2);
              baseAssignValue(object, key2, bind(object[key2], object));
            });
            return object;
          });
          function cond(pairs) {
            var length2 = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
            pairs = !length2 ? [] : arrayMap2(pairs, function(pair) {
              if (typeof pair[1] != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT2);
              }
              return [toIteratee(pair[0]), pair[1]];
            });
            return baseRest2(function(args) {
              var index2 = -1;
              while (++index2 < length2) {
                var pair = pairs[index2];
                if (apply2(pair[0], this, args)) {
                  return apply2(pair[1], this, args);
                }
              }
            });
          }
          function conforms(source) {
            return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
          }
          function constant2(value2) {
            return function() {
              return value2;
            };
          }
          function defaultTo(value2, defaultValue) {
            return value2 == null || value2 !== value2 ? defaultValue : value2;
          }
          var flow = createFlow();
          var flowRight = createFlow(true);
          function identity2(value2) {
            return value2;
          }
          function iteratee(func) {
            return baseIteratee2(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
          }
          function matches(source) {
            return baseMatches2(baseClone(source, CLONE_DEEP_FLAG));
          }
          function matchesProperty(path2, srcValue) {
            return baseMatchesProperty2(path2, baseClone(srcValue, CLONE_DEEP_FLAG));
          }
          var method = baseRest2(function(path2, args) {
            return function(object) {
              return baseInvoke(object, path2, args);
            };
          });
          var methodOf = baseRest2(function(object, args) {
            return function(path2) {
              return baseInvoke(object, path2, args);
            };
          });
          function mixin(object, source, options) {
            var props = keys2(source), methodNames = baseFunctions(source, props);
            if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
              options = source;
              source = object;
              object = this;
              methodNames = baseFunctions(source, keys2(source));
            }
            var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
            arrayEach(methodNames, function(methodName) {
              var func = source[methodName];
              object[methodName] = func;
              if (isFunc) {
                object.prototype[methodName] = function() {
                  var chainAll = this.__chain__;
                  if (chain2 || chainAll) {
                    var result2 = object(this.__wrapped__), actions2 = result2.__actions__ = copyArray(this.__actions__);
                    actions2.push({ "func": func, "args": arguments, "thisArg": object });
                    result2.__chain__ = chainAll;
                    return result2;
                  }
                  return func.apply(object, arrayPush2([this.value()], arguments));
                };
              }
            });
            return object;
          }
          function noConflict() {
            if (root2._ === this) {
              root2._ = oldDash;
            }
            return this;
          }
          function noop2() {
          }
          function nthArg(n2) {
            n2 = toInteger(n2);
            return baseRest2(function(args) {
              return baseNth(args, n2);
            });
          }
          var over = createOver(arrayMap2);
          var overEvery = createOver(arrayEvery);
          var overSome = createOver(arraySome2);
          function property2(path2) {
            return isKey2(path2) ? baseProperty2(toKey2(path2)) : basePropertyDeep2(path2);
          }
          function propertyOf(object) {
            return function(path2) {
              return object == null ? undefined$1 : baseGet2(object, path2);
            };
          }
          var range = createRange();
          var rangeRight = createRange(true);
          function stubArray2() {
            return [];
          }
          function stubFalse2() {
            return false;
          }
          function stubObject() {
            return {};
          }
          function stubString() {
            return "";
          }
          function stubTrue() {
            return true;
          }
          function times(n2, iteratee2) {
            n2 = toInteger(n2);
            if (n2 < 1 || n2 > MAX_SAFE_INTEGER2) {
              return [];
            }
            var index2 = MAX_ARRAY_LENGTH, length2 = nativeMin(n2, MAX_ARRAY_LENGTH);
            iteratee2 = getIteratee(iteratee2);
            n2 -= MAX_ARRAY_LENGTH;
            var result2 = baseTimes2(length2, iteratee2);
            while (++index2 < n2) {
              iteratee2(index2);
            }
            return result2;
          }
          function toPath(value2) {
            if (isArray2(value2)) {
              return arrayMap2(value2, toKey2);
            }
            return isSymbol2(value2) ? [value2] : copyArray(stringToPath2(toString2(value2)));
          }
          function uniqueId(prefix) {
            var id2 = ++idCounter;
            return toString2(prefix) + id2;
          }
          var add2 = createMathOperation(function(augend, addend) {
            return augend + addend;
          }, 0);
          var ceil = createRound("ceil");
          var divide = createMathOperation(function(dividend, divisor) {
            return dividend / divisor;
          }, 1);
          var floor = createRound("floor");
          function max(array) {
            return array && array.length ? baseExtremum(array, identity2, baseGt) : undefined$1;
          }
          function maxBy(array, iteratee2) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$1;
          }
          function mean(array) {
            return baseMean(array, identity2);
          }
          function meanBy(array, iteratee2) {
            return baseMean(array, getIteratee(iteratee2, 2));
          }
          function min(array) {
            return array && array.length ? baseExtremum(array, identity2, baseLt) : undefined$1;
          }
          function minBy(array, iteratee2) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$1;
          }
          var multiply = createMathOperation(function(multiplier, multiplicand) {
            return multiplier * multiplicand;
          }, 1);
          var round = createRound("round");
          var subtract = createMathOperation(function(minuend, subtrahend) {
            return minuend - subtrahend;
          }, 0);
          function sum2(array) {
            return array && array.length ? baseSum(array, identity2) : 0;
          }
          function sumBy(array, iteratee2) {
            return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
          }
          lodash2.after = after;
          lodash2.ary = ary;
          lodash2.assign = assign;
          lodash2.assignIn = assignIn;
          lodash2.assignInWith = assignInWith;
          lodash2.assignWith = assignWith;
          lodash2.at = at;
          lodash2.before = before;
          lodash2.bind = bind;
          lodash2.bindAll = bindAll;
          lodash2.bindKey = bindKey;
          lodash2.castArray = castArray;
          lodash2.chain = chain;
          lodash2.chunk = chunk;
          lodash2.compact = compact;
          lodash2.concat = concat2;
          lodash2.cond = cond;
          lodash2.conforms = conforms;
          lodash2.constant = constant2;
          lodash2.countBy = countBy;
          lodash2.create = create;
          lodash2.curry = curry;
          lodash2.curryRight = curryRight;
          lodash2.debounce = debounce;
          lodash2.defaults = defaults2;
          lodash2.defaultsDeep = defaultsDeep;
          lodash2.defer = defer2;
          lodash2.delay = delay;
          lodash2.difference = difference;
          lodash2.differenceBy = differenceBy;
          lodash2.differenceWith = differenceWith;
          lodash2.drop = drop;
          lodash2.dropRight = dropRight;
          lodash2.dropRightWhile = dropRightWhile;
          lodash2.dropWhile = dropWhile;
          lodash2.fill = fill2;
          lodash2.filter = filter;
          lodash2.flatMap = flatMap;
          lodash2.flatMapDeep = flatMapDeep;
          lodash2.flatMapDepth = flatMapDepth;
          lodash2.flatten = flatten;
          lodash2.flattenDeep = flattenDeep;
          lodash2.flattenDepth = flattenDepth;
          lodash2.flip = flip;
          lodash2.flow = flow;
          lodash2.flowRight = flowRight;
          lodash2.fromPairs = fromPairs;
          lodash2.functions = functions;
          lodash2.functionsIn = functionsIn;
          lodash2.groupBy = groupBy;
          lodash2.initial = initial;
          lodash2.intersection = intersection;
          lodash2.intersectionBy = intersectionBy;
          lodash2.intersectionWith = intersectionWith;
          lodash2.invert = invert;
          lodash2.invertBy = invertBy;
          lodash2.invokeMap = invokeMap;
          lodash2.iteratee = iteratee;
          lodash2.keyBy = keyBy;
          lodash2.keys = keys2;
          lodash2.keysIn = keysIn;
          lodash2.map = map;
          lodash2.mapKeys = mapKeys;
          lodash2.mapValues = mapValues2;
          lodash2.matches = matches;
          lodash2.matchesProperty = matchesProperty;
          lodash2.memoize = memoize2;
          lodash2.merge = merge;
          lodash2.mergeWith = mergeWith;
          lodash2.method = method;
          lodash2.methodOf = methodOf;
          lodash2.mixin = mixin;
          lodash2.negate = negate;
          lodash2.nthArg = nthArg;
          lodash2.omit = omit;
          lodash2.omitBy = omitBy;
          lodash2.once = once;
          lodash2.orderBy = orderBy2;
          lodash2.over = over;
          lodash2.overArgs = overArgs;
          lodash2.overEvery = overEvery;
          lodash2.overSome = overSome;
          lodash2.partial = partial;
          lodash2.partialRight = partialRight;
          lodash2.partition = partition;
          lodash2.pick = pick;
          lodash2.pickBy = pickBy;
          lodash2.property = property2;
          lodash2.propertyOf = propertyOf;
          lodash2.pull = pull;
          lodash2.pullAll = pullAll;
          lodash2.pullAllBy = pullAllBy;
          lodash2.pullAllWith = pullAllWith;
          lodash2.pullAt = pullAt;
          lodash2.range = range;
          lodash2.rangeRight = rangeRight;
          lodash2.rearg = rearg;
          lodash2.reject = reject;
          lodash2.remove = remove;
          lodash2.rest = rest;
          lodash2.reverse = reverse;
          lodash2.sampleSize = sampleSize;
          lodash2.set = set2;
          lodash2.setWith = setWith;
          lodash2.shuffle = shuffle;
          lodash2.slice = slice2;
          lodash2.sortBy = sortBy2;
          lodash2.sortedUniq = sortedUniq;
          lodash2.sortedUniqBy = sortedUniqBy;
          lodash2.split = split;
          lodash2.spread = spread;
          lodash2.tail = tail;
          lodash2.take = take;
          lodash2.takeRight = takeRight;
          lodash2.takeRightWhile = takeRightWhile;
          lodash2.takeWhile = takeWhile;
          lodash2.tap = tap;
          lodash2.throttle = throttle;
          lodash2.thru = thru;
          lodash2.toArray = toArray;
          lodash2.toPairs = toPairs;
          lodash2.toPairsIn = toPairsIn;
          lodash2.toPath = toPath;
          lodash2.toPlainObject = toPlainObject;
          lodash2.transform = transform2;
          lodash2.unary = unary;
          lodash2.union = union;
          lodash2.unionBy = unionBy;
          lodash2.unionWith = unionWith;
          lodash2.uniq = uniq;
          lodash2.uniqBy = uniqBy;
          lodash2.uniqWith = uniqWith;
          lodash2.unset = unset;
          lodash2.unzip = unzip;
          lodash2.unzipWith = unzipWith;
          lodash2.update = update;
          lodash2.updateWith = updateWith;
          lodash2.values = values;
          lodash2.valuesIn = valuesIn;
          lodash2.without = without;
          lodash2.words = words;
          lodash2.wrap = wrap2;
          lodash2.xor = xor;
          lodash2.xorBy = xorBy;
          lodash2.xorWith = xorWith;
          lodash2.zip = zip;
          lodash2.zipObject = zipObject;
          lodash2.zipObjectDeep = zipObjectDeep;
          lodash2.zipWith = zipWith;
          lodash2.entries = toPairs;
          lodash2.entriesIn = toPairsIn;
          lodash2.extend = assignIn;
          lodash2.extendWith = assignInWith;
          mixin(lodash2, lodash2);
          lodash2.add = add2;
          lodash2.attempt = attempt;
          lodash2.camelCase = camelCase;
          lodash2.capitalize = capitalize2;
          lodash2.ceil = ceil;
          lodash2.clamp = clamp2;
          lodash2.clone = clone;
          lodash2.cloneDeep = cloneDeep;
          lodash2.cloneDeepWith = cloneDeepWith;
          lodash2.cloneWith = cloneWith;
          lodash2.conformsTo = conformsTo;
          lodash2.deburr = deburr;
          lodash2.defaultTo = defaultTo;
          lodash2.divide = divide;
          lodash2.endsWith = endsWith;
          lodash2.eq = eq2;
          lodash2.escape = escape2;
          lodash2.escapeRegExp = escapeRegExp;
          lodash2.every = every;
          lodash2.find = find;
          lodash2.findIndex = findIndex2;
          lodash2.findKey = findKey2;
          lodash2.findLast = findLast;
          lodash2.findLastIndex = findLastIndex;
          lodash2.findLastKey = findLastKey;
          lodash2.floor = floor;
          lodash2.forEach = forEach;
          lodash2.forEachRight = forEachRight;
          lodash2.forIn = forIn;
          lodash2.forInRight = forInRight;
          lodash2.forOwn = forOwn;
          lodash2.forOwnRight = forOwnRight;
          lodash2.get = get2;
          lodash2.gt = gt;
          lodash2.gte = gte;
          lodash2.has = has2;
          lodash2.hasIn = hasIn2;
          lodash2.head = head;
          lodash2.identity = identity2;
          lodash2.includes = includes;
          lodash2.indexOf = indexOf;
          lodash2.inRange = inRange;
          lodash2.invoke = invoke;
          lodash2.isArguments = isArguments2;
          lodash2.isArray = isArray2;
          lodash2.isArrayBuffer = isArrayBuffer;
          lodash2.isArrayLike = isArrayLike2;
          lodash2.isArrayLikeObject = isArrayLikeObject;
          lodash2.isBoolean = isBoolean2;
          lodash2.isBuffer = isBuffer2;
          lodash2.isDate = isDate2;
          lodash2.isElement = isElement2;
          lodash2.isEmpty = isEmpty;
          lodash2.isEqual = isEqual;
          lodash2.isEqualWith = isEqualWith;
          lodash2.isError = isError2;
          lodash2.isFinite = isFinite;
          lodash2.isFunction = isFunction2;
          lodash2.isInteger = isInteger;
          lodash2.isLength = isLength2;
          lodash2.isMap = isMap2;
          lodash2.isMatch = isMatch;
          lodash2.isMatchWith = isMatchWith;
          lodash2.isNaN = isNaN2;
          lodash2.isNative = isNative;
          lodash2.isNil = isNil;
          lodash2.isNull = isNull;
          lodash2.isNumber = isNumber;
          lodash2.isObject = isObject2;
          lodash2.isObjectLike = isObjectLike2;
          lodash2.isPlainObject = isPlainObject2;
          lodash2.isRegExp = isRegExp2;
          lodash2.isSafeInteger = isSafeInteger;
          lodash2.isSet = isSet2;
          lodash2.isString = isString2;
          lodash2.isSymbol = isSymbol2;
          lodash2.isTypedArray = isTypedArray2;
          lodash2.isUndefined = isUndefined;
          lodash2.isWeakMap = isWeakMap;
          lodash2.isWeakSet = isWeakSet;
          lodash2.join = join;
          lodash2.kebabCase = kebabCase;
          lodash2.last = last;
          lodash2.lastIndexOf = lastIndexOf;
          lodash2.lowerCase = lowerCase;
          lodash2.lowerFirst = lowerFirst;
          lodash2.lt = lt;
          lodash2.lte = lte;
          lodash2.max = max;
          lodash2.maxBy = maxBy;
          lodash2.mean = mean;
          lodash2.meanBy = meanBy;
          lodash2.min = min;
          lodash2.minBy = minBy;
          lodash2.stubArray = stubArray2;
          lodash2.stubFalse = stubFalse2;
          lodash2.stubObject = stubObject;
          lodash2.stubString = stubString;
          lodash2.stubTrue = stubTrue;
          lodash2.multiply = multiply;
          lodash2.nth = nth;
          lodash2.noConflict = noConflict;
          lodash2.noop = noop2;
          lodash2.now = now;
          lodash2.pad = pad;
          lodash2.padEnd = padEnd;
          lodash2.padStart = padStart;
          lodash2.parseInt = parseInt2;
          lodash2.random = random2;
          lodash2.reduce = reduce;
          lodash2.reduceRight = reduceRight;
          lodash2.repeat = repeat;
          lodash2.replace = replace;
          lodash2.result = result;
          lodash2.round = round;
          lodash2.runInContext = runInContext2;
          lodash2.sample = sample;
          lodash2.size = size;
          lodash2.snakeCase = snakeCase;
          lodash2.some = some;
          lodash2.sortedIndex = sortedIndex;
          lodash2.sortedIndexBy = sortedIndexBy;
          lodash2.sortedIndexOf = sortedIndexOf;
          lodash2.sortedLastIndex = sortedLastIndex;
          lodash2.sortedLastIndexBy = sortedLastIndexBy;
          lodash2.sortedLastIndexOf = sortedLastIndexOf;
          lodash2.startCase = startCase;
          lodash2.startsWith = startsWith;
          lodash2.subtract = subtract;
          lodash2.sum = sum2;
          lodash2.sumBy = sumBy;
          lodash2.template = template;
          lodash2.times = times;
          lodash2.toFinite = toFinite;
          lodash2.toInteger = toInteger;
          lodash2.toLength = toLength;
          lodash2.toLower = toLower;
          lodash2.toNumber = toNumber;
          lodash2.toSafeInteger = toSafeInteger;
          lodash2.toString = toString2;
          lodash2.toUpper = toUpper;
          lodash2.trim = trim;
          lodash2.trimEnd = trimEnd;
          lodash2.trimStart = trimStart;
          lodash2.truncate = truncate2;
          lodash2.unescape = unescape2;
          lodash2.uniqueId = uniqueId;
          lodash2.upperCase = upperCase;
          lodash2.upperFirst = upperFirst;
          lodash2.each = forEach;
          lodash2.eachRight = forEachRight;
          lodash2.first = head;
          mixin(lodash2, function() {
            var source = {};
            baseForOwn2(lodash2, function(func, methodName) {
              if (!hasOwnProperty2.call(lodash2.prototype, methodName)) {
                source[methodName] = func;
              }
            });
            return source;
          }(), { "chain": false });
          lodash2.VERSION = VERSION;
          arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
            lodash2[methodName].placeholder = lodash2;
          });
          arrayEach(["drop", "take"], function(methodName, index2) {
            LazyWrapper.prototype[methodName] = function(n2) {
              n2 = n2 === undefined$1 ? 1 : nativeMax2(toInteger(n2), 0);
              var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
              if (result2.__filtered__) {
                result2.__takeCount__ = nativeMin(n2, result2.__takeCount__);
              } else {
                result2.__views__.push({
                  "size": nativeMin(n2, MAX_ARRAY_LENGTH),
                  "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
                });
              }
              return result2;
            };
            LazyWrapper.prototype[methodName + "Right"] = function(n2) {
              return this.reverse()[methodName](n2).reverse();
            };
          });
          arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
            var type = index2 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
            LazyWrapper.prototype[methodName] = function(iteratee2) {
              var result2 = this.clone();
              result2.__iteratees__.push({
                "iteratee": getIteratee(iteratee2, 3),
                "type": type
              });
              result2.__filtered__ = result2.__filtered__ || isFilter;
              return result2;
            };
          });
          arrayEach(["head", "last"], function(methodName, index2) {
            var takeName = "take" + (index2 ? "Right" : "");
            LazyWrapper.prototype[methodName] = function() {
              return this[takeName](1).value()[0];
            };
          });
          arrayEach(["initial", "tail"], function(methodName, index2) {
            var dropName = "drop" + (index2 ? "" : "Right");
            LazyWrapper.prototype[methodName] = function() {
              return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
            };
          });
          LazyWrapper.prototype.compact = function() {
            return this.filter(identity2);
          };
          LazyWrapper.prototype.find = function(predicate) {
            return this.filter(predicate).head();
          };
          LazyWrapper.prototype.findLast = function(predicate) {
            return this.reverse().find(predicate);
          };
          LazyWrapper.prototype.invokeMap = baseRest2(function(path2, args) {
            if (typeof path2 == "function") {
              return new LazyWrapper(this);
            }
            return this.map(function(value2) {
              return baseInvoke(value2, path2, args);
            });
          });
          LazyWrapper.prototype.reject = function(predicate) {
            return this.filter(negate(getIteratee(predicate)));
          };
          LazyWrapper.prototype.slice = function(start, end) {
            start = toInteger(start);
            var result2 = this;
            if (result2.__filtered__ && (start > 0 || end < 0)) {
              return new LazyWrapper(result2);
            }
            if (start < 0) {
              result2 = result2.takeRight(-start);
            } else if (start) {
              result2 = result2.drop(start);
            }
            if (end !== undefined$1) {
              end = toInteger(end);
              result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
            }
            return result2;
          };
          LazyWrapper.prototype.takeRightWhile = function(predicate) {
            return this.reverse().takeWhile(predicate).reverse();
          };
          LazyWrapper.prototype.toArray = function() {
            return this.take(MAX_ARRAY_LENGTH);
          };
          baseForOwn2(LazyWrapper.prototype, function(func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
            if (!lodashFunc) {
              return;
            }
            lodash2.prototype[methodName] = function() {
              var value2 = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value2 instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value2);
              var interceptor = function(value3) {
                var result3 = lodashFunc.apply(lodash2, arrayPush2([value3], args));
                return isTaker && chainAll ? result3[0] : result3;
              };
              if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
                isLazy = useLazy = false;
              }
              var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
              if (!retUnwrapped && useLazy) {
                value2 = onlyLazy ? value2 : new LazyWrapper(this);
                var result2 = func.apply(value2, args);
                result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
                return new LodashWrapper(result2, chainAll);
              }
              if (isUnwrapped && onlyLazy) {
                return func.apply(this, args);
              }
              result2 = this.thru(interceptor);
              return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
            };
          });
          arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
            var func = arrayProto2[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
            lodash2.prototype[methodName] = function() {
              var args = arguments;
              if (retUnwrapped && !this.__chain__) {
                var value2 = this.value();
                return func.apply(isArray2(value2) ? value2 : [], args);
              }
              return this[chainName](function(value3) {
                return func.apply(isArray2(value3) ? value3 : [], args);
              });
            };
          });
          baseForOwn2(LazyWrapper.prototype, function(func, methodName) {
            var lodashFunc = lodash2[methodName];
            if (lodashFunc) {
              var key2 = lodashFunc.name + "";
              if (!hasOwnProperty2.call(realNames, key2)) {
                realNames[key2] = [];
              }
              realNames[key2].push({ "name": methodName, "func": lodashFunc });
            }
          });
          realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
            "name": "wrapper",
            "func": undefined$1
          }];
          LazyWrapper.prototype.clone = lazyClone;
          LazyWrapper.prototype.reverse = lazyReverse;
          LazyWrapper.prototype.value = lazyValue;
          lodash2.prototype.at = wrapperAt;
          lodash2.prototype.chain = wrapperChain;
          lodash2.prototype.commit = wrapperCommit;
          lodash2.prototype.next = wrapperNext;
          lodash2.prototype.plant = wrapperPlant;
          lodash2.prototype.reverse = wrapperReverse;
          lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
          lodash2.prototype.first = lodash2.prototype.head;
          if (symIterator) {
            lodash2.prototype[symIterator] = wrapperToIterator;
          }
          return lodash2;
        };
        var _ = runInContext();
        if (freeModule2) {
          (freeModule2.exports = _)._ = _;
          freeExports2._ = _;
        } else {
          root2._ = _;
        }
      }).call(commonjsGlobal);
    })(lodash, lodash.exports);
    var lodashExports = lodash.exports;
    function SearchResults() {
      const dispatch = useAppDispatch();
      const { t: t2 } = useTranslation("home");
      const [searchParams] = useSearchParams();
      const [searchResults, setSearchResults] = reactExports.useState([]);
      const [isLoading, setIsLoading] = reactExports.useState(false);
      const debouncedFunc = reactExports.useRef(null);
      const navigate = useNavigate();
      const handleGameClick = (game) => {
        dispatch(clearSearch());
        navigate(buildGameDetailsPath(game));
      };
      reactExports.useEffect(() => {
        setIsLoading(true);
        if (debouncedFunc.current)
          debouncedFunc.current.cancel();
        debouncedFunc.current = lodashExports.debounce(() => {
          window.electron.searchGames(searchParams.get("query") ?? "").then((results) => {
            setSearchResults(results);
          }).finally(() => {
            setIsLoading(false);
          });
        }, 300);
        debouncedFunc.current();
      }, [searchParams, dispatch]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SkeletonTheme, { baseColor: vars.color.background, highlightColor: "#444", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: content$2, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: cards, children: [
          isLoading && Array.from({ length: 12 }).map((_, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { className: cardSkeleton }, index2)),
          !isLoading && searchResults.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: searchResults.map((game) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            GameCard,
            {
              game,
              onClick: () => handleGameClick(game)
            },
            game.objectID
          )) })
        ] }),
        !isLoading && searchResults.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: noResults, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(InboxIcon, { size: 56 }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("no_results") })
        ] })
      ] }) });
    }
    var container = "hffxco0";
    var content = "hffxco1";
    var settingsCategories = "hffxco2";
    var form = "d2c2eb0";
    var description = "d2c2eb1";
    const REAL_DEBRID_API_TOKEN_URL = "https://real-debrid.com/apitoken";
    function SettingsRealDebrid() {
      const userPreferences = useAppSelector(
        (state) => state.userPreferences.value
      );
      const { updateUserPreferences } = reactExports.useContext(settingsContext);
      const [isLoading, setIsLoading] = reactExports.useState(false);
      const [form$1, setForm] = reactExports.useState({
        useRealDebrid: false,
        realDebridApiToken: null
      });
      const { showSuccessToast, showErrorToast } = useToast();
      const { t: t2 } = useTranslation("settings");
      reactExports.useEffect(() => {
        if (userPreferences) {
          setForm({
            useRealDebrid: Boolean(userPreferences.realDebridApiToken),
            realDebridApiToken: userPreferences.realDebridApiToken ?? null
          });
        }
      }, [userPreferences]);
      const handleFormSubmit = async (event) => {
        setIsLoading(true);
        event.preventDefault();
        try {
          if (form$1.useRealDebrid) {
            const user = await window.electron.authenticateRealDebrid(
              form$1.realDebridApiToken
            );
            if (user.type === "free") {
              showErrorToast(
                t2("real_debrid_free_account_error", { username: user.username })
              );
              return;
            } else {
              showSuccessToast(
                t2("real_debrid_linked_message", { username: user.username })
              );
            }
          } else {
            showSuccessToast(t2("changes_saved"));
          }
          updateUserPreferences({
            realDebridApiToken: form$1.useRealDebrid ? form$1.realDebridApiToken : null
          });
        } catch (err) {
          showErrorToast(t2("real_debrid_invalid_token"));
        } finally {
          setIsLoading(false);
        }
      };
      const isButtonDisabled = form$1.useRealDebrid && !form$1.realDebridApiToken || isLoading;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { className: form, onSubmit: handleFormSubmit, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: description, children: t2("real_debrid_description") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          CheckboxField,
          {
            label: t2("enable_real_debrid"),
            checked: form$1.useRealDebrid,
            onChange: () => setForm((prev) => ({
              ...prev,
              useRealDebrid: !form$1.useRealDebrid
            }))
          }
        ),
        form$1.useRealDebrid && /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField,
          {
            label: t2("real_debrid_api_token"),
            value: form$1.realDebridApiToken ?? "",
            type: "password",
            onChange: (event) => setForm({ ...form$1, realDebridApiToken: event.target.value }),
            placeholder: "API Token",
            containerProps: { style: { marginTop: `${SPACING_UNIT}px` } },
            hint: /* @__PURE__ */ jsxRuntimeExports.jsx(Trans, { i18nKey: "real_debrid_api_token_hint", ns: "settings", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: REAL_DEBRID_API_TOKEN_URL }) })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            type: "submit",
            style: { alignSelf: "flex-end", marginTop: `${SPACING_UNIT * 2}px` },
            disabled: isButtonDisabled,
            children: t2("save_changes")
          }
        )
      ] });
    }
    const LANGUAGES_LIST$1 = {
      aa: {
        name: "Afar",
        nativeName: "Afaraf"
      },
      ab: {
        name: "Abkhaz",
        nativeName: "аҧсуа бызшәа"
      },
      ae: {
        name: "Avestan",
        nativeName: "avesta"
      },
      af: {
        name: "Afrikaans",
        nativeName: "Afrikaans"
      },
      ak: {
        name: "Akan",
        nativeName: "Akan"
      },
      am: {
        name: "Amharic",
        nativeName: "አማርኛ"
      },
      an: {
        name: "Aragonese",
        nativeName: "aragonés"
      },
      ar: {
        name: "Arabic",
        nativeName: "اَلْعَرَبِيَّةُ"
      },
      as: {
        name: "Assamese",
        nativeName: "অসমীয়া"
      },
      av: {
        name: "Avaric",
        nativeName: "авар мацӀ"
      },
      ay: {
        name: "Aymara",
        nativeName: "aymar aru"
      },
      az: {
        name: "Azerbaijani",
        nativeName: "azərbaycan dili"
      },
      ba: {
        name: "Bashkir",
        nativeName: "башҡорт теле"
      },
      be: {
        name: "Belarusian",
        nativeName: "беларуская мова"
      },
      bg: {
        name: "Bulgarian",
        nativeName: "български език"
      },
      bi: {
        name: "Bislama",
        nativeName: "Bislama"
      },
      bm: {
        name: "Bambara",
        nativeName: "bamanankan"
      },
      bn: {
        name: "Bengali",
        nativeName: "বাংলা"
      },
      bo: {
        name: "Tibetan",
        nativeName: "བོད་ཡིག"
      },
      br: {
        name: "Breton",
        nativeName: "brezhoneg"
      },
      bs: {
        name: "Bosnian",
        nativeName: "bosanski jezik"
      },
      ca: {
        name: "Catalan",
        nativeName: "Català"
      },
      ce: {
        name: "Chechen",
        nativeName: "нохчийн мотт"
      },
      ch: {
        name: "Chamorro",
        nativeName: "Chamoru"
      },
      co: {
        name: "Corsican",
        nativeName: "corsu"
      },
      cr: {
        name: "Cree",
        nativeName: "ᓀᐦᐃᔭᐍᐏᐣ"
      },
      cs: {
        name: "Czech",
        nativeName: "čeština"
      },
      cu: {
        name: "Old Church Slavonic",
        nativeName: "ѩзыкъ словѣньскъ"
      },
      cv: {
        name: "Chuvash",
        nativeName: "чӑваш чӗлхи"
      },
      cy: {
        name: "Welsh",
        nativeName: "Cymraeg"
      },
      da: {
        name: "Danish",
        nativeName: "Dansk"
      },
      de: {
        name: "German",
        nativeName: "Deutsch"
      },
      dv: {
        name: "Divehi",
        nativeName: "ދިވެހި"
      },
      dz: {
        name: "Dzongkha",
        nativeName: "རྫོང་ཁ"
      },
      ee: {
        name: "Ewe",
        nativeName: "Eʋegbe"
      },
      el: {
        name: "Greek",
        nativeName: "Ελληνικά"
      },
      en: {
        name: "English",
        nativeName: "English"
      },
      eo: {
        name: "Esperanto",
        nativeName: "Esperanto"
      },
      es: {
        name: "Spanish",
        nativeName: "Español"
      },
      et: {
        name: "Estonian",
        nativeName: "eesti"
      },
      eu: {
        name: "Basque",
        nativeName: "euskara"
      },
      fa: {
        name: "Persian",
        nativeName: "فارسی"
      },
      ff: {
        name: "Fula",
        nativeName: "Fulfulde"
      },
      fi: {
        name: "Finnish",
        nativeName: "suomi"
      },
      fj: {
        name: "Fijian",
        nativeName: "vosa Vakaviti"
      },
      fo: {
        name: "Faroese",
        nativeName: "Føroyskt"
      },
      fr: {
        name: "French",
        nativeName: "Français"
      },
      fy: {
        name: "Western Frisian",
        nativeName: "Frysk"
      },
      ga: {
        name: "Irish",
        nativeName: "Gaeilge"
      },
      gd: {
        name: "Scottish Gaelic",
        nativeName: "Gàidhlig"
      },
      gl: {
        name: "Galician",
        nativeName: "galego"
      },
      gn: {
        name: "Guaraní",
        nativeName: "Avañe'ẽ"
      },
      gu: {
        name: "Gujarati",
        nativeName: "ગુજરાતી"
      },
      gv: {
        name: "Manx",
        nativeName: "Gaelg"
      },
      ha: {
        name: "Hausa",
        nativeName: "هَوُسَ"
      },
      he: {
        name: "Hebrew",
        nativeName: "עברית"
      },
      hi: {
        name: "Hindi",
        nativeName: "हिन्दी"
      },
      ho: {
        name: "Hiri Motu",
        nativeName: "Hiri Motu"
      },
      hr: {
        name: "Croatian",
        nativeName: "Hrvatski"
      },
      ht: {
        name: "Haitian",
        nativeName: "Kreyòl ayisyen"
      },
      hu: {
        name: "Hungarian",
        nativeName: "magyar"
      },
      hy: {
        name: "Armenian",
        nativeName: "Հայերեն"
      },
      hz: {
        name: "Herero",
        nativeName: "Otjiherero"
      },
      ia: {
        name: "Interlingua",
        nativeName: "Interlingua"
      },
      id: {
        name: "Indonesian",
        nativeName: "Bahasa Indonesia"
      },
      ie: {
        name: "Interlingue",
        nativeName: "Interlingue"
      },
      ig: {
        name: "Igbo",
        nativeName: "Asụsụ Igbo"
      },
      ii: {
        name: "Nuosu",
        nativeName: "ꆈꌠ꒿ Nuosuhxop"
      },
      ik: {
        name: "Inupiaq",
        nativeName: "Iñupiaq"
      },
      io: {
        name: "Ido",
        nativeName: "Ido"
      },
      is: {
        name: "Icelandic",
        nativeName: "Íslenska"
      },
      it: {
        name: "Italian",
        nativeName: "Italiano"
      },
      iu: {
        name: "Inuktitut",
        nativeName: "ᐃᓄᒃᑎᑐᑦ"
      },
      ja: {
        name: "Japanese",
        nativeName: "日本語"
      },
      jv: {
        name: "Javanese",
        nativeName: "basa Jawa"
      },
      ka: {
        name: "Georgian",
        nativeName: "ქართული"
      },
      kg: {
        name: "Kongo",
        nativeName: "Kikongo"
      },
      ki: {
        name: "Kikuyu",
        nativeName: "Gĩkũyũ"
      },
      kj: {
        name: "Kwanyama",
        nativeName: "Kuanyama"
      },
      kk: {
        name: "Kazakh",
        nativeName: "қазақ тілі"
      },
      kl: {
        name: "Kalaallisut",
        nativeName: "kalaallisut"
      },
      km: {
        name: "Khmer",
        nativeName: "ខេមរភាសា"
      },
      kn: {
        name: "Kannada",
        nativeName: "ಕನ್ನಡ"
      },
      ko: {
        name: "Korean",
        nativeName: "한국어"
      },
      kr: {
        name: "Kanuri",
        nativeName: "Kanuri"
      },
      ks: {
        name: "Kashmiri",
        nativeName: "कश्मीरी"
      },
      ku: {
        name: "Kurdish",
        nativeName: "Kurdî"
      },
      kv: {
        name: "Komi",
        nativeName: "коми кыв"
      },
      kw: {
        name: "Cornish",
        nativeName: "Kernewek"
      },
      ky: {
        name: "Kyrgyz",
        nativeName: "Кыргызча"
      },
      la: {
        name: "Latin",
        nativeName: "latine"
      },
      lb: {
        name: "Luxembourgish",
        nativeName: "Lëtzebuergesch"
      },
      lg: {
        name: "Ganda",
        nativeName: "Luganda"
      },
      li: {
        name: "Limburgish",
        nativeName: "Limburgs"
      },
      ln: {
        name: "Lingala",
        nativeName: "Lingála"
      },
      lo: {
        name: "Lao",
        nativeName: "ພາສາລາວ"
      },
      lt: {
        name: "Lithuanian",
        nativeName: "lietuvių kalba"
      },
      lu: {
        name: "Luba-Katanga",
        nativeName: "Kiluba"
      },
      lv: {
        name: "Latvian",
        nativeName: "latviešu valoda"
      },
      mg: {
        name: "Malagasy",
        nativeName: "fiteny malagasy"
      },
      mh: {
        name: "Marshallese",
        nativeName: "Kajin M̧ajeļ"
      },
      mi: {
        name: "Māori",
        nativeName: "te reo Māori"
      },
      mk: {
        name: "Macedonian",
        nativeName: "македонски јазик"
      },
      ml: {
        name: "Malayalam",
        nativeName: "മലയാളം"
      },
      mn: {
        name: "Mongolian",
        nativeName: "Монгол хэл"
      },
      mr: {
        name: "Marathi",
        nativeName: "मराठी"
      },
      ms: {
        name: "Malay",
        nativeName: "Bahasa Melayu"
      },
      mt: {
        name: "Maltese",
        nativeName: "Malti"
      },
      my: {
        name: "Burmese",
        nativeName: "ဗမာစာ"
      },
      na: {
        name: "Nauru",
        nativeName: "Dorerin Naoero"
      },
      nb: {
        name: "Norwegian Bokmål",
        nativeName: "Norsk bokmål"
      },
      nd: {
        name: "Northern Ndebele",
        nativeName: "isiNdebele"
      },
      ne: {
        name: "Nepali",
        nativeName: "नेपाली"
      },
      ng: {
        name: "Ndonga",
        nativeName: "Owambo"
      },
      nl: {
        name: "Dutch",
        nativeName: "Nederlands"
      },
      nn: {
        name: "Norwegian Nynorsk",
        nativeName: "Norsk nynorsk"
      },
      no: {
        name: "Norwegian",
        nativeName: "Norsk"
      },
      nr: {
        name: "Southern Ndebele",
        nativeName: "isiNdebele"
      },
      nv: {
        name: "Navajo",
        nativeName: "Diné bizaad"
      },
      ny: {
        name: "Chichewa",
        nativeName: "chiCheŵa"
      },
      oc: {
        name: "Occitan",
        nativeName: "occitan"
      },
      oj: {
        name: "Ojibwe",
        nativeName: "ᐊᓂᔑᓈᐯᒧᐎᓐ"
      },
      om: {
        name: "Oromo",
        nativeName: "Afaan Oromoo"
      },
      or: {
        name: "Oriya",
        nativeName: "ଓଡ଼ିଆ"
      },
      os: {
        name: "Ossetian",
        nativeName: "ирон æвзаг"
      },
      pa: {
        name: "Panjabi",
        nativeName: "ਪੰਜਾਬੀ"
      },
      pi: {
        name: "Pāli",
        nativeName: "पाऴि"
      },
      pl: {
        name: "Polish",
        nativeName: "Polski"
      },
      ps: {
        name: "Pashto",
        nativeName: "پښتو"
      },
      pt: {
        name: "Portuguese",
        nativeName: "Português"
      },
      qu: {
        name: "Quechua",
        nativeName: "Runa Simi"
      },
      rm: {
        name: "Romansh",
        nativeName: "rumantsch grischun"
      },
      rn: {
        name: "Kirundi",
        nativeName: "Ikirundi"
      },
      ro: {
        name: "Romanian",
        nativeName: "Română"
      },
      ru: {
        name: "Russian",
        nativeName: "Русский"
      },
      rw: {
        name: "Kinyarwanda",
        nativeName: "Ikinyarwanda"
      },
      sa: {
        name: "Sanskrit",
        nativeName: "संस्कृतम्"
      },
      sc: {
        name: "Sardinian",
        nativeName: "sardu"
      },
      sd: {
        name: "Sindhi",
        nativeName: "सिन्धी"
      },
      se: {
        name: "Northern Sami",
        nativeName: "Davvisámegiella"
      },
      sg: {
        name: "Sango",
        nativeName: "yângâ tî sängö"
      },
      si: {
        name: "Sinhala",
        nativeName: "සිංහල"
      },
      sk: {
        name: "Slovak",
        nativeName: "slovenčina"
      },
      sl: {
        name: "Slovenian",
        nativeName: "slovenščina"
      },
      sm: {
        name: "Samoan",
        nativeName: "gagana fa'a Samoa"
      },
      sn: {
        name: "Shona",
        nativeName: "chiShona"
      },
      so: {
        name: "Somali",
        nativeName: "Soomaaliga"
      },
      sq: {
        name: "Albanian",
        nativeName: "Shqip"
      },
      sr: {
        name: "Serbian",
        nativeName: "српски језик"
      },
      ss: {
        name: "Swati",
        nativeName: "SiSwati"
      },
      st: {
        name: "Southern Sotho",
        nativeName: "Sesotho"
      },
      su: {
        name: "Sundanese",
        nativeName: "Basa Sunda"
      },
      sv: {
        name: "Swedish",
        nativeName: "Svenska"
      },
      sw: {
        name: "Swahili",
        nativeName: "Kiswahili"
      },
      ta: {
        name: "Tamil",
        nativeName: "தமிழ்"
      },
      te: {
        name: "Telugu",
        nativeName: "తెలుగు"
      },
      tg: {
        name: "Tajik",
        nativeName: "тоҷикӣ"
      },
      th: {
        name: "Thai",
        nativeName: "ไทย"
      },
      ti: {
        name: "Tigrinya",
        nativeName: "ትግርኛ"
      },
      tk: {
        name: "Turkmen",
        nativeName: "Türkmençe"
      },
      tl: {
        name: "Tagalog",
        nativeName: "Wikang Tagalog"
      },
      tn: {
        name: "Tswana",
        nativeName: "Setswana"
      },
      to: {
        name: "Tonga",
        nativeName: "faka Tonga"
      },
      tr: {
        name: "Turkish",
        nativeName: "Türkçe"
      },
      ts: {
        name: "Tsonga",
        nativeName: "Xitsonga"
      },
      tt: {
        name: "Tatar",
        nativeName: "татар теле"
      },
      tw: {
        name: "Twi",
        nativeName: "Twi"
      },
      ty: {
        name: "Tahitian",
        nativeName: "Reo Tahiti"
      },
      ug: {
        name: "Uyghur",
        nativeName: "ئۇيغۇرچە‎"
      },
      uk: {
        name: "Ukrainian",
        nativeName: "Українська"
      },
      ur: {
        name: "Urdu",
        nativeName: "اردو"
      },
      uz: {
        name: "Uzbek",
        nativeName: "Ўзбек"
      },
      ve: {
        name: "Venda",
        nativeName: "Tshivenḓa"
      },
      vi: {
        name: "Vietnamese",
        nativeName: "Tiếng Việt"
      },
      vo: {
        name: "Volapük",
        nativeName: "Volapük"
      },
      wa: {
        name: "Walloon",
        nativeName: "walon"
      },
      wo: {
        name: "Wolof",
        nativeName: "Wollof"
      },
      xh: {
        name: "Xhosa",
        nativeName: "isiXhosa"
      },
      yi: {
        name: "Yiddish",
        nativeName: "ייִדיש"
      },
      yo: {
        name: "Yoruba",
        nativeName: "Yorùbá"
      },
      za: {
        name: "Zhuang",
        nativeName: "Saɯ cueŋƅ"
      },
      zh: {
        name: "Chinese",
        nativeName: "中文"
      },
      zu: {
        name: "Zulu",
        nativeName: "isiZulu"
      }
    };
    var data = LANGUAGES_LIST$1;
    const LANGUAGES_LIST = data;
    const LANGUAGES = {};
    const LANGUAGES_BY_NAME = {};
    const LANGUAGE_CODES = [];
    const LANGUAGE_NAMES = [];
    const LANGUAGE_NATIVE_NAMES = [];
    for (const code in LANGUAGES_LIST) {
      const { name: name2, nativeName } = LANGUAGES_LIST[code];
      LANGUAGES[code] = LANGUAGES_BY_NAME[name2.toLowerCase()] = LANGUAGES_BY_NAME[nativeName.toLowerCase()] = { code, name: name2, nativeName };
      LANGUAGE_CODES.push(code);
      LANGUAGE_NAMES.push(name2);
      LANGUAGE_NATIVE_NAMES.push(nativeName);
    }
    var src = class ISO63912 {
      static getLanguages(codes = []) {
        return codes.map(
          (code) => ISO63912.validate(code) ? Object.assign({}, LANGUAGES[code]) : { code, name: "", nativeName: "" }
        );
      }
      static getName(code) {
        return ISO63912.validate(code) ? LANGUAGES_LIST[code].name : "";
      }
      static getAllNames() {
        return LANGUAGE_NAMES.slice();
      }
      static getNativeName(code) {
        return ISO63912.validate(code) ? LANGUAGES_LIST[code].nativeName : "";
      }
      static getAllNativeNames() {
        return LANGUAGE_NATIVE_NAMES.slice();
      }
      static getCode(name2) {
        name2 = name2.toLowerCase();
        return LANGUAGES_BY_NAME.hasOwnProperty(name2) ? LANGUAGES_BY_NAME[name2].code : "";
      }
      static getAllCodes() {
        return LANGUAGE_CODES.slice();
      }
      static validate(code) {
        return LANGUAGES_LIST.hasOwnProperty(code);
      }
    };
    const ISO6391 = /* @__PURE__ */ getDefaultExportFromCjs(src);
    const app$6 = {
      successfully_signed_in: "Successfully signed in"
    };
    const home$k = {
      featured: "Featured",
      trending: "Trending",
      surprise_me: "Surprise me",
      no_results: "No results found"
    };
    const sidebar$k = {
      catalogue: "Catalogue",
      downloads: "Downloads",
      settings: "Settings",
      my_library: "My library",
      downloading_metadata: "{{title}} (Downloading metadata…)",
      paused: "{{title}} (Paused)",
      downloading: "{{title}} ({{percentage}} - Downloading…)",
      filter: "Filter library",
      home: "Home",
      queued: "{{title}} (Queued)",
      game_has_no_executable: "Game has no executable selected",
      sign_in: "Sign in"
    };
    const header$k = {
      search: "Search games",
      home: "Home",
      catalogue: "Catalogue",
      downloads: "Downloads",
      search_results: "Search results",
      settings: "Settings",
      version_available_install: "Version {{version}} available. Click here to restart and install.",
      version_available_download: "Version {{version}} available. Click here to download."
    };
    const bottom_panel$k = {
      no_downloads_in_progress: "No downloads in progress",
      downloading_metadata: "Downloading {{title}} metadata…",
      downloading: "Downloading {{title}}… ({{percentage}} complete) - Conclusion {{eta}} - {{speed}}",
      calculating_eta: "Downloading {{title}}… ({{percentage}} complete) - Calculating remaining time…",
      checking_files: "Checking {{title}} files… ({{percentage}} complete)"
    };
    const catalogue$k = {
      next_page: "Next page",
      previous_page: "Previous page"
    };
    const game_details$k = {
      open_download_options: "Open download options",
      download_options_zero: "No download option",
      download_options_one: "{{count}} download option",
      download_options_other: "{{count}} download options",
      updated_at: "Updated {{updated_at}}",
      install: "Install",
      resume: "Resume",
      pause: "Pause",
      cancel: "Cancel",
      remove: "Remove",
      space_left_on_disk: "{{space}} left on disk",
      eta: "Conclusion {{eta}}",
      calculating_eta: "Calculating remaining time…",
      downloading_metadata: "Downloading metadata…",
      filter: "Filter repacks",
      requirements: "System requirements",
      minimum: "Minimum",
      recommended: "Recommended",
      paused: "Paused",
      release_date: "Released on {{date}}",
      publisher: "Published by {{publisher}}",
      hours: "hours",
      minutes: "minutes",
      amount_hours: "{{amount}} hours",
      amount_minutes: "{{amount}} minutes",
      accuracy: "{{accuracy}}% accuracy",
      add_to_library: "Add to library",
      remove_from_library: "Remove from library",
      no_downloads: "No downloads available",
      play_time: "Played for {{amount}}",
      last_time_played: "Last played {{period}}",
      not_played_yet: "You haven't played {{title}} yet",
      next_suggestion: "Next suggestion",
      play: "Play",
      deleting: "Deleting installer…",
      close: "Close",
      playing_now: "Playing now",
      change: "Change",
      repacks_modal_description: "Choose the repack you want to download",
      select_folder_hint: "To change the default folder, go to the <0>Settings</0>",
      download_now: "Download now",
      no_shop_details: "Could not retrieve shop details.",
      download_options: "Download options",
      download_path: "Download path",
      previous_screenshot: "Previous screenshot",
      next_screenshot: "Next screenshot",
      screenshot: "Screenshot {{number}}",
      open_screenshot: "Open screenshot {{number}}",
      download_settings: "Download settings",
      downloader: "Downloader",
      select_executable: "Select",
      no_executable_selected: "No executable selected",
      open_folder: "Open folder",
      open_download_location: "See downloaded files",
      create_shortcut: "Create desktop shortcut",
      remove_files: "Remove files",
      remove_from_library_title: "Are you sure?",
      remove_from_library_description: "This will remove {{game}} from your library",
      options: "Options",
      executable_section_title: "Executable",
      executable_section_description: 'Path of the file that will be executed when "Play" is clicked',
      downloads_secion_title: "Downloads",
      downloads_section_description: "Check out updates or other versions of this game",
      danger_zone_section_title: "Danger zone",
      danger_zone_section_description: "Remove this game from your library or the files downloaded by Hydra",
      download_in_progress: "Download in progress",
      download_paused: "Download paused",
      last_downloaded_option: "Last downloaded option",
      create_shortcut_success: "Shortcut created successfully",
      create_shortcut_error: "Error creating shortcut"
    };
    const activation$k = {
      title: "Activate Hydra",
      installation_id: "Installation ID:",
      enter_activation_code: "Enter your activation code",
      message: "If you don't know where to ask for this, then you shouldn't have this.",
      activate: "Activate",
      loading: "Loading…"
    };
    const downloads$k = {
      resume: "Resume",
      pause: "Pause",
      eta: "Conclusion {{eta}}",
      paused: "Paused",
      verifying: "Verifying…",
      completed: "Completed",
      removed: "Not downloaded",
      cancel: "Cancel",
      filter: "Filter downloaded games",
      remove: "Remove",
      downloading_metadata: "Downloading metadata…",
      deleting: "Deleting installer…",
      "delete": "Remove installer",
      delete_modal_title: "Are you sure?",
      delete_modal_description: "This will remove all the installation files from your computer",
      install: "Install",
      download_in_progress: "In progress",
      queued_downloads: "Queued downloads",
      downloads_completed: "Completed",
      queued: "Queued",
      no_downloads_title: "Such empty",
      no_downloads_description: "You haven't downloaded anything with Hydra yet, but it's never too late to start.",
      checking_files: "Checking files…"
    };
    const settings$k = {
      downloads_path: "Downloads path",
      change: "Update",
      notifications: "Notifications",
      enable_download_notifications: "When a download is complete",
      enable_repack_list_notifications: "When a new repack is added",
      real_debrid_api_token_label: "Real-Debrid API token",
      quit_app_instead_hiding: "Don't hide Hydra when closing",
      launch_with_system: "Launch Hydra on system start-up",
      general: "General",
      behavior: "Behavior",
      download_sources: "Download sources",
      language: "Language",
      real_debrid_api_token: "API Token",
      enable_real_debrid: "Enable Real-Debrid",
      real_debrid_description: "Real-Debrid is an unrestricted downloader that allows you to download files instantly and at the best of your Internet speed.",
      real_debrid_invalid_token: "Invalid API token",
      real_debrid_api_token_hint: "You can get your API token <0>here</0>",
      real_debrid_free_account_error: 'The account "{{username}}" is a free account. Please subscribe to Real-Debrid',
      real_debrid_linked_message: 'Account "{{username}}" linked',
      save_changes: "Save changes",
      changes_saved: "Changes successfully saved",
      download_sources_description: "Hydra will fetch the download links from these sources. The source URL must be a direct link to a .json file containing the download links.",
      validate_download_source: "Validate",
      remove_download_source: "Remove",
      add_download_source: "Add source",
      download_count_zero: "No downloads in list",
      download_count_one: "{{countFormatted}} download in list",
      download_count_other: "{{countFormatted}} downloads in list",
      download_options_zero: "No download available",
      download_options_one: "{{countFormatted}} download available",
      download_options_other: "{{countFormatted}} downloads available",
      download_source_url: "Download source URL",
      add_download_source_description: "Insert the URL containing the .json file",
      download_source_up_to_date: "Up-to-date",
      download_source_errored: "Errored",
      sync_download_sources: "Sync sources",
      removed_download_source: "Download source removed",
      added_download_source: "Added download source",
      download_sources_synced: "All download sources are synced",
      insert_valid_json_url: "Insert a valid JSON url",
      found_download_option_zero: "No download option found",
      found_download_option_one: "Found {{countFormatted}} download option",
      found_download_option_other: "Found {{countFormatted}} download options",
      "import": "Import"
    };
    const notifications$j = {
      download_complete: "Download complete",
      game_ready_to_install: "{{title}} is ready to install",
      repack_list_updated: "Repack list updated",
      repack_count_one: "{{count}} repack added",
      repack_count_other: "{{count}} repacks added",
      new_update_available: "Version {{version}} available",
      restart_to_install_update: "Restart Hydra to install the update"
    };
    const system_tray$j = {
      open: "Open Hydra",
      quit: "Quit"
    };
    const game_card$j = {
      no_downloads: "No downloads available"
    };
    const binary_not_found_modal$j = {
      title: "Programs not installed",
      description: "Wine or Lutris executables were not found on your system",
      instructions: "Check the correct way to install any of them on your Linux distro so that the game can run normally"
    };
    const modal$i = {
      close: "Close button"
    };
    const forms$6 = {
      toggle_password_visibility: "Toggle password visibility"
    };
    const user_profile$6 = {
      amount_hours: "{{amount}} hours",
      amount_minutes: "{{amount}} minutes",
      last_time_played: "Last played {{period}}",
      activity: "Recent activity",
      library: "Library",
      total_play_time: "Total playtime: {{amount}}",
      no_recent_activity_title: "Hmmm… nothing here",
      no_recent_activity_description: "You haven't played any games recently. It's time to change that!",
      display_name: "Display name",
      saving: "Saving",
      save: "Save",
      edit_profile: "Edit Profile",
      saved_successfully: "Saved successfully",
      try_again: "Please, try again",
      sign_out_modal_title: "Are you sure?",
      cancel: "Cancel",
      successfully_signed_out: "Successfully signed out",
      sign_out: "Sign out",
      playing_for: "Playing for {{amount}}",
      sign_out_modal_text: "Your library is linked with your current account. When signing out, your library will not be visible anymore, and any progress will not be saved. Continue with sign out?"
    };
    const translation$k = {
      app: app$6,
      home: home$k,
      sidebar: sidebar$k,
      header: header$k,
      bottom_panel: bottom_panel$k,
      catalogue: catalogue$k,
      game_details: game_details$k,
      activation: activation$k,
      downloads: downloads$k,
      settings: settings$k,
      notifications: notifications$j,
      system_tray: system_tray$j,
      game_card: game_card$j,
      binary_not_found_modal: binary_not_found_modal$j,
      modal: modal$i,
      forms: forms$6,
      user_profile: user_profile$6
    };
    const app$5 = {
      successfully_signed_in: "Autenticado com sucesso"
    };
    const home$j = {
      featured: "Destaques",
      trending: "Populares",
      surprise_me: "Surpreenda-me",
      no_results: "Nenhum resultado encontrado"
    };
    const sidebar$j = {
      catalogue: "Catálogo",
      downloads: "Downloads",
      settings: "Ajustes",
      my_library: "Minha biblioteca",
      downloading_metadata: "{{title}} (Baixando metadados…)",
      paused: "{{title}} (Pausado)",
      downloading: "{{title}} ({{percentage}} - Baixando…)",
      filter: "Filtrar biblioteca",
      home: "Início",
      queued: "{{title}} (Na fila)",
      game_has_no_executable: "Jogo não possui executável selecionado",
      sign_in: "Login"
    };
    const header$j = {
      search: "Buscar jogos",
      catalogue: "Catálogo",
      downloads: "Downloads",
      search_results: "Resultados da busca",
      settings: "Ajustes",
      home: "Início",
      version_available_install: "Versão {{version}} disponível. Clique aqui para reiniciar e instalar.",
      version_available_download: "Versão {{version}} disponível. Clique aqui para fazer o download."
    };
    const bottom_panel$j = {
      no_downloads_in_progress: "Sem downloads em andamento",
      downloading_metadata: "Baixando metadados de {{title}}…",
      downloading: "Baixando {{title}}… ({{percentage}} concluído) - Conclusão {{eta}} - {{speed}}",
      calculating_eta: "Baixando {{title}}… ({{percentage}} concluído) - Calculando tempo restante…",
      checking_files: "Verificando arquivos de {{title}}…"
    };
    const game_details$j = {
      open_download_options: "Ver opções de download",
      download_options_zero: "Sem opções de download",
      download_options_one: "{{count}} opção de download",
      download_options_other: "{{count}} opções de download",
      updated_at: "Atualizado {{updated_at}}",
      resume: "Resumir",
      pause: "Pausar",
      cancel: "Cancelar",
      remove: "Remover",
      space_left_on_disk: "{{space}} livres em disco",
      eta: "Conclusão {{eta}}",
      calculating_eta: "Calculando tempo restante…",
      downloading_metadata: "Baixando metadados…",
      filter: "Filtrar repacks",
      requirements: "Requisitos do sistema",
      minimum: "Mínimos",
      recommended: "Recomendados",
      paused: "Pausado",
      release_date: "Lançado em {{date}}",
      publisher: "Publicado por {{publisher}}",
      hours: "horas",
      minutes: "minutos",
      amount_hours: "{{amount}} horas",
      amount_minutes: "{{amount}} minutos",
      accuracy: "{{accuracy}}% de precisão",
      add_to_library: "Adicionar à biblioteca",
      remove_from_library: "Remover da biblioteca",
      no_downloads: "Nenhum download disponível",
      play_time: "Jogado por {{amount}}",
      next_suggestion: "Próxima sugestão",
      install: "Instalar",
      last_time_played: "Jogou por último {{period}}",
      play: "Jogar",
      not_played_yet: "Você ainda não jogou {{title}}",
      close: "Fechar",
      deleting: "Excluindo instalador…",
      playing_now: "Jogando agora",
      change: "Mudar",
      repacks_modal_description: "Escolha o repack do jogo que deseja baixar",
      select_folder_hint: "Para trocar o diretório padrão, acesse a <0>Tela de Ajustes</0>",
      download_now: "Iniciar download",
      no_shop_details: "Não foi possível obter os detalhes da loja.",
      download_options: "Opções de download",
      download_path: "Diretório de download",
      previous_screenshot: "Captura de tela anterior",
      next_screenshot: "Próxima captura de tela",
      screenshot: "Captura de tela {{number}}",
      open_screenshot: "Ver captura de tela {{number}}",
      download_settings: "Ajustes do download",
      downloader: "Downloader",
      select_executable: "Selecionar",
      no_executable_selected: "Nenhum executável selecionado",
      open_folder: "Abrir pasta",
      open_download_location: "Ver arquivos baixados",
      create_shortcut: "Criar atalho na área de trabalho",
      remove_files: "Remover arquivos",
      options: "Opções",
      remove_from_library_description: "Isso irá remover {{game}} da sua biblioteca",
      remove_from_library_title: "Tem certeza?",
      executable_section_title: "Executável",
      executable_section_description: 'O caminho do arquivo que será executado ao clicar em "Jogar"',
      downloads_secion_title: "Downloads",
      downloads_section_description: "Confira atualizações ou versões diferentes para este mesmo título",
      danger_zone_section_title: "Zona de perigo",
      danger_zone_section_description: "Remova o jogo da sua biblioteca ou os arquivos que foram baixados pelo Hydra",
      download_in_progress: "Download em andamento",
      download_paused: "Download pausado",
      last_downloaded_option: "Última opção baixada",
      create_shortcut_success: "Atalho criado com sucesso",
      create_shortcut_error: "Erro ao criar atalho"
    };
    const activation$j = {
      title: "Ativação",
      installation_id: "ID da instalação:",
      enter_activation_code: "Insira seu código de ativação",
      message: "Se você não sabe onde conseguir o código, talvez você não devesse estar aqui.",
      activate: "Ativar",
      loading: "Carregando…"
    };
    const downloads$j = {
      resume: "Resumir",
      pause: "Pausar",
      eta: "Conclusão {{eta}}",
      paused: "Pausado",
      verifying: "Verificando…",
      completed: "Concluído",
      removed: "Cancelado",
      cancel: "Cancelar",
      filter: "Filtrar jogos baixados",
      remove: "Remover",
      downloading_metadata: "Baixando metadados…",
      "delete": "Remover instalador",
      delete_modal_description: "Isso removerá todos os arquivos de instalação do seu computador",
      delete_modal_title: "Tem certeza?",
      deleting: "Excluindo instalador…",
      install: "Instalar",
      download_in_progress: "Baixando agora",
      queued_downloads: "Na fila",
      downloads_completed: "Completo",
      queued: "Na fila",
      no_downloads_title: "Nada por aqui…",
      no_downloads_description: "Você ainda não baixou nada pelo Hydra, mas nunca é tarde para começar.",
      checking_files: "Verificando arquivos…"
    };
    const settings$j = {
      downloads_path: "Diretório dos downloads",
      change: "Mudar",
      notifications: "Notificações",
      enable_download_notifications: "Quando um download for concluído",
      enable_repack_list_notifications: "Quando a lista de repacks for atualizada",
      real_debrid_api_token_label: "Token de API do Real-Debrid",
      quit_app_instead_hiding: "Encerrar o Hydra ao invés de minimizá-lo ao fechar",
      launch_with_system: "Iniciar o Hydra junto com o sistema",
      general: "Geral",
      behavior: "Comportamento",
      download_sources: "Fontes de download",
      language: "Idioma",
      real_debrid_api_token: "Token de API",
      enable_real_debrid: "Habilitar Real-Debrid",
      real_debrid_api_token_hint: "Você pode obter seu token de API <0>aqui</0>",
      real_debrid_description: "O Real-Debrid é um downloader sem restrições que permite baixar arquivos instantaneamente e com a melhor velocidade da sua Internet.",
      real_debrid_invalid_token: "Token de API inválido",
      real_debrid_free_account_error: 'A conta "{{username}}" é uma conta gratuita. Por favor, assine a Real-Debrid',
      real_debrid_linked_message: 'Conta "{{username}}" vinculada',
      save_changes: "Salvar mudanças",
      changes_saved: "Ajustes salvos com sucesso",
      download_sources_description: "Hydra vai buscar links de download em todas as fonte habilitadas. A URL da fonte deve ser um link direto para um arquivo .json contendo uma lista de links.",
      validate_download_source: "Validar",
      remove_download_source: "Remover",
      add_download_source: "Adicionar fonte",
      download_count_zero: "Sem downloads na lista",
      download_count_one: "{{countFormatted}} download na lista",
      download_count_other: "{{countFormatted}} downloads na lista",
      download_options_zero: "Sem downloads disponíveis",
      download_options_one: "{{countFormatted}} download disponível",
      download_options_other: "{{countFormatted}} downloads disponíveis",
      download_source_url: "URL da fonte",
      add_download_source_description: "Insira a URL contendo o arquivo .json",
      download_source_up_to_date: "Sincronizada",
      download_source_errored: "Falhou",
      sync_download_sources: "Sincronizar",
      removed_download_source: "Fonte removida",
      added_download_source: "Fonte adicionada",
      download_sources_synced: "As fontes foram sincronizadas",
      insert_valid_json_url: "Insira a url de um JSON válido",
      found_download_option_zero: "Nenhuma opção de download encontrada",
      found_download_option_one: "{{countFormatted}} opção de download encontrada",
      found_download_option_other: "{{countFormatted}} opções de download encontradas",
      "import": "Importar"
    };
    const notifications$i = {
      download_complete: "Download concluído",
      game_ready_to_install: "{{title}} está pronto para ser instalado",
      repack_list_updated: "Lista de repacks atualizada",
      repack_count_one: "{{count}} novo repack",
      repack_count_other: "{{count}} novos repacks",
      new_update_available: "Versão {{version}} disponível",
      restart_to_install_update: "Reinicie o Hydra para instalar a nova versão"
    };
    const system_tray$i = {
      open: "Abrir Hydra",
      quit: "Fechar"
    };
    const game_card$i = {
      no_downloads: "Sem downloads disponíveis"
    };
    const binary_not_found_modal$i = {
      title: "Programas não instalados",
      description: "Não foram encontrados no seu sistema os executáveis do Wine ou Lutris",
      instructions: "Verifique a forma correta de instalar algum deles no seu distro Linux, garantindo assim a execução normal do jogo"
    };
    const catalogue$j = {
      next_page: "Próxima página",
      previous_page: "Página anterior"
    };
    const modal$h = {
      close: "Botão de fechar"
    };
    const forms$5 = {
      toggle_password_visibility: "Alternar visibilidade da senha"
    };
    const user_profile$5 = {
      amount_hours: "{{amount}} horas",
      amount_minutes: "{{amount}} minutos",
      last_time_played: "Jogou {{period}}",
      activity: "Atividade recente",
      library: "Biblioteca",
      total_play_time: "Tempo total de jogo: {{amount}}",
      no_recent_activity_title: "Hmmm… nada por aqui",
      no_recent_activity_description: "Parece que você não jogou nada recentemente. Que tal começar agora?",
      display_name: "Nome de exibição",
      saving: "Salvando…",
      save: "Salvar",
      edit_profile: "Editar Perfil",
      saved_successfully: "Salvo com sucesso",
      try_again: "Por favor, tente novamente",
      cancel: "Cancelar",
      successfully_signed_out: "Deslogado com sucesso",
      sign_out: "Sair da conta",
      sign_out_modal_title: "Tem certeza?",
      playing_for: "Jogando por {{amount}}",
      sign_out_modal_text: "Sua biblioteca de jogos está associada com a sua conta atual. Ao sair, sua biblioteca não aparecerá mais no Hydra e qualquer progresso não será salvo. Deseja continuar?"
    };
    const translation$j = {
      app: app$5,
      home: home$j,
      sidebar: sidebar$j,
      header: header$j,
      bottom_panel: bottom_panel$j,
      game_details: game_details$j,
      activation: activation$j,
      downloads: downloads$j,
      settings: settings$j,
      notifications: notifications$i,
      system_tray: system_tray$i,
      game_card: game_card$i,
      binary_not_found_modal: binary_not_found_modal$i,
      catalogue: catalogue$j,
      modal: modal$h,
      forms: forms$5,
      user_profile: user_profile$5
    };
    const app$4 = {
      successfully_signed_in: "Sesión iniciada correctamente"
    };
    const home$i = {
      featured: "Destacado",
      trending: "Tendencias",
      surprise_me: "¡Sorpréndeme!",
      no_results: "No se encontraron resultados"
    };
    const sidebar$i = {
      catalogue: "Catálogo",
      downloads: "Descargas",
      settings: "Ajustes",
      my_library: "Mi biblioteca",
      downloading_metadata: "{{title}} (Descargando metadatos…)",
      paused: "{{title}} (Pausado)",
      downloading: "{{title}} ({{percentage}} - Descargando…)",
      filter: "Buscar en la biblioteca",
      home: "Inicio",
      queued: "{{title}} (En Cola)",
      game_has_no_executable: "El juego no tiene un ejecutable",
      sign_in: "Iniciar sesión"
    };
    const header$i = {
      search: "Buscar juegos",
      home: "Inicio",
      catalogue: "Catálogo",
      downloads: "Descargas",
      search_results: "Resultados de búsqueda",
      settings: "Ajustes",
      version_available_install: "Version {{version}} disponible. Haz clic aquí para reiniciar e instalar.",
      version_available_download: "Version {{version}} disponible. Haz clic aquí para descargar."
    };
    const bottom_panel$i = {
      no_downloads_in_progress: "Sin descargas en progreso",
      downloading_metadata: "Descargando metadatos de {{title}}…",
      downloading: "Descargando {{title}}… ({{percentage}} completado) - Finalizando {{eta}} - {{speed}}",
      calculating_eta: "Descargando {{title}}… ({{percentage}} completado) - Calculando tiempo restante…",
      checking_files: "Verificando archivos de {{title}}… ({{percentage}} completado)"
    };
    const catalogue$i = {
      next_page: "Siguiente página",
      previous_page: "Pagina anterior"
    };
    const game_details$i = {
      open_download_options: "Ver opciones de descargas",
      download_options_zero: "No hay opciones de descargas disponibles",
      download_options_one: "{{count}} opción de descarga",
      download_options_other: "{{count}} opciones de descargas",
      updated_at: "Actualizado el {{updated_at}}",
      install: "Instalar",
      resume: "Continuar",
      pause: "Pausa",
      cancel: "Cancelar",
      remove: "Eliminar",
      space_left_on_disk: "{{space}} restantes en el disco",
      eta: "Tiempo restante: {{eta}}",
      calculating_eta: "Calculando tiempo restante…",
      downloading_metadata: "Descargando metadatos…",
      filter: "Buscar repacks",
      requirements: "Requisitos del Sistema",
      minimum: "Mínimos",
      recommended: "Recomendados",
      paused: "Pausado",
      release_date: "Fecha de lanzamiento: {{date}}",
      publisher: "Publicado por: {{publisher}}",
      hours: "horas",
      minutes: "minutos",
      amount_hours: "{{amount}} horas",
      amount_minutes: "{{amount}} minutos",
      accuracy: "{{accuracy}}% precisión",
      add_to_library: "Agregar a la biblioteca",
      remove_from_library: "Eliminar de la biblioteca",
      no_downloads: "No hay descargas disponibles",
      play_time: "Jugado por {{amount}}",
      last_time_played: "Jugado por última vez {{period}}",
      not_played_yet: "Aún no has jugado a {{title}}",
      next_suggestion: "Siguiente sugerencia",
      play: "Jugar",
      deleting: "Eliminando instalador…",
      close: "Cerrar",
      playing_now: "Jugando ahora",
      change: "Cambiar",
      repacks_modal_description: "Selecciona el repack que quieres descargar",
      select_folder_hint: "Para cambiar la carpeta predeterminada, ve a <0>Ajustes</0>",
      download_now: "Descargar ahora",
      no_shop_details: "No se pudieron obtener detalles de la tienda.",
      download_options: "Opciones de descarga",
      download_path: "Ruta de descarga",
      previous_screenshot: "Anterior captura",
      next_screenshot: "Siguiente captura",
      screenshot: "Captura {{number}}",
      open_screenshot: "Abrir captura {{number}}",
      download_settings: "Ajustes de descarga",
      downloader: "Método de descarga",
      select_executable: "Seleccionar",
      no_executable_selected: "No se seleccionó un ejecutable",
      open_folder: "Abrir carpeta",
      open_download_location: "Ver archivos descargados",
      create_shortcut: "Crear acceso directo en el escritorio",
      remove_files: "Eliminar archivos",
      remove_from_library_title: "¿Estás seguro?",
      remove_from_library_description: "Esto eliminará {{game}} de tu biblioteca",
      options: "Opciones",
      executable_section_title: "Ejecutable",
      executable_section_description: 'Ruta del archivo que se ejecutará cuando se presione "Jugar"',
      downloads_secion_title: "Descargas",
      downloads_section_description: "Buscar actualizaciones u otras versiones de este juego",
      danger_zone_section_title: "Zona de Peligro",
      danger_zone_section_description: "Eliminar este juego de tu librería o los archivos descargados por Hydra",
      download_in_progress: "Descarga en progreso",
      download_paused: "Descarga pausada",
      last_downloaded_option: "Última opción descargada",
      create_shortcut_success: "Atajo creado con éxito",
      create_shortcut_error: "Error al crear un atajo"
    };
    const activation$i = {
      title: "Activar Hydra",
      installation_id: "ID de la Instalación:",
      enter_activation_code: "Introduce tu código de activación",
      message: "Si no sabes donde obtener el código, no deberías de tener esto.",
      activate: "Activar",
      loading: "Cargando…"
    };
    const downloads$i = {
      resume: "Resumir",
      pause: "Pausa",
      eta: "Finalizando en {{eta}}",
      paused: "En Pausa",
      verifying: "Verificando…",
      completed: "Completado",
      removed: "No descargado",
      cancel: "Cancelar",
      filter: "Buscar juegos descargados",
      remove: "Eliminar",
      downloading_metadata: "Descargando metadatos…",
      deleting: "Eliminando instalador…",
      "delete": "Eliminar instalador",
      delete_modal_title: "¿Estás seguro?",
      delete_modal_description: "Esto eliminará todos los archivos de instalación de tu computadora.",
      install: "Instalar",
      download_in_progress: "En progreso",
      queued_downloads: "Descargas en cola",
      downloads_completed: "Completado",
      queued: "En cola",
      no_downloads_title: "Esto está tan... vacío",
      no_downloads_description: "No has descargado nada con Hydra... aún, ¡pero nunca es tarde para comenzar!.",
      checking_files: "Verificando archivos…"
    };
    const settings$i = {
      downloads_path: "Ruta de descarga",
      change: "Cambiar",
      notifications: "Notificaciones",
      enable_download_notifications: "Cuando se completa una descarga",
      enable_repack_list_notifications: "Cuando se añade un repack nuevo",
      real_debrid_api_token_label: "Token API de Real-Debrid",
      quit_app_instead_hiding: "Salir de Hydra en vez de minimizar en la bandeja del sistema",
      launch_with_system: "Iniciar Hydra al inicio del sistema",
      general: "General",
      behavior: "Otros",
      download_sources: "Fuentes de descarga",
      language: "Idioma",
      real_debrid_api_token: "Token API",
      enable_real_debrid: "Activar Real-Debrid",
      real_debrid_description: "Real-Debrid es una forma de descargar sin restricciones archivos instantáneamente con la máxima velocidad de tu internet.",
      real_debrid_invalid_token: "Token de API inválido",
      real_debrid_api_token_hint: "Puedes obtener tu clave de API <0>aquí</0>",
      real_debrid_free_account_error: 'La cuenta "{{username}}" es una cuenta gratuita. Por favor, suscríbete a Real-Debrid',
      real_debrid_linked_message: 'Cuenta "{{username}}" vinculada',
      save_changes: "Guardar cambios",
      changes_saved: "Ajustes guardados exitosamente",
      download_sources_description: "Hydra buscará los enlaces de descarga de estas fuentes. La URL de origen debe ser un enlace directo a un archivo .json que contenga los enlaces de descarga",
      validate_download_source: "Validar",
      remove_download_source: "Eliminar",
      add_download_source: "Añadir fuente de descarga",
      download_count_zero: "No hay descargas en la lista",
      download_count_one: "{{countFormatted}} descarga en la lista",
      download_count_other: "{{countFormatted}} descargas en la lista",
      download_options_zero: "No hay descargas disponibles",
      download_options_one: "{{countFormatted}} descarga disponible",
      download_options_other: "{{countFormatted}} descargas disponibles",
      download_source_url: "Descargar URL de origen",
      add_download_source_description: "Introduce la URL con el archivo .json",
      download_source_up_to_date: "Al día",
      download_source_errored: "Error",
      sync_download_sources: "Sincronizar fuentes",
      removed_download_source: "Fuente de descarga eliminada",
      added_download_source: "Fuente de descarga añadida",
      download_sources_synced: "Todas las fuentes de descargas están actualizadas.",
      insert_valid_json_url: "Introduce una URL JSON válida",
      found_download_option_zero: "No se encontró una opción de descarga",
      found_download_option_one: "Se encontró {{countFormatted}} opción de descarga",
      found_download_option_other: "Se encontraron {{countFormatted}} opciones de descarga",
      "import": "Importar"
    };
    const notifications$h = {
      download_complete: "Descarga completada",
      game_ready_to_install: "{{title}} está listo para instalarse",
      repack_list_updated: "Lista de repacks actualizadas",
      repack_count_one: "{{count}} repack ha sido añadido",
      repack_count_other: "{{count}} repacks añadidos",
      new_update_available: "Version {{version}} disponible"
    };
    const system_tray$h = {
      open: "Abrir Hydra",
      quit: "Salir"
    };
    const game_card$h = {
      no_downloads: "No hay descargas disponibles"
    };
    const binary_not_found_modal$h = {
      title: "Programas no instalados",
      description: "Los ejecutables de Wine o Lutris no se encontraron en su sistema",
      instructions: "Comprueba como instalar de forma correcta uno de los dos en tu distro de Linux para ejecutar el juego con normalidad"
    };
    const modal$g = {
      close: "Botón de cierre"
    };
    const forms$4 = {
      toggle_password_visibility: "Cambiar visibilidad de contraseña"
    };
    const user_profile$4 = {
      amount_hours: "{{amount}} horas",
      amount_minutes: "{{amount}} minutos",
      last_time_played: "Última vez jugado {{period}}",
      activity: "Actividad reciente",
      library: "Biblioteca",
      total_play_time: "Total de tiempo jugado: {{amount}}",
      no_recent_activity_title: "Que raro, no hay nada por acá, ¿que tal si jugamos algo para empezar?",
      no_recent_activity_description: "No has jugado ningún juego recientemente, ¡vamos a cambiar eso ahora!",
      display_name: "Nombre a mostrar",
      saving: "Guardando",
      save: "Guardar",
      edit_profile: "Editar perfil",
      saved_successfully: "Guardado exitosamente",
      try_again: "Por favor, intenta de nuevo",
      sign_out_modal_title: "¿Estás seguro?",
      cancel: "Cancelar",
      successfully_signed_out: "Sesión cerrada exitosamente",
      sign_out: "Cerrar sesión",
      playing_for: "Jugando por {{amount}}",
      sign_out_modal_text: "Tu biblioteca se ha vinculado con tu cuenta. Cuando cierres sesión, tú biblioteca ya no será visible y cualquier progreso no se guardará. ¿Continuar con el cierre de sesión?"
    };
    const translation$i = {
      app: app$4,
      home: home$i,
      sidebar: sidebar$i,
      header: header$i,
      bottom_panel: bottom_panel$i,
      catalogue: catalogue$i,
      game_details: game_details$i,
      activation: activation$i,
      downloads: downloads$i,
      settings: settings$i,
      notifications: notifications$h,
      system_tray: system_tray$h,
      game_card: game_card$h,
      binary_not_found_modal: binary_not_found_modal$h,
      modal: modal$g,
      forms: forms$4,
      user_profile: user_profile$4
    };
    const home$h = {
      featured: "Uitgelicht",
      trending: "Trending",
      surprise_me: "Verrasing",
      no_results: "Geen resultaten gevonden"
    };
    const sidebar$h = {
      catalogue: "catalogus",
      downloads: "Downloads",
      settings: "Instellingen",
      my_library: "Mijn Bibliotheek",
      downloading_metadata: "{{title}} (Downloading metadata…)",
      paused: "{{title}} (Gepauzeerd)",
      downloading: "{{title}} ({{percentage}} - Downloading…)",
      filter: "Filter Bibliotheek",
      home: "Home"
    };
    const header$h = {
      search: "Zoek spellen",
      home: "Home",
      catalogue: "Bibliotheek",
      downloads: "Downloads",
      search_results: "Zoek resultaten",
      settings: "Instellingen"
    };
    const bottom_panel$h = {
      no_downloads_in_progress: "Geen Downloads bezig",
      downloading_metadata: "Downloading {{title}} metadata…",
      downloading: "Downloading {{title}}… ({{percentage}} complete) - Conclusion {{eta}} - {{speed}}"
    };
    const catalogue$h = {
      next_page: "Volgende Pagina",
      previous_page: "Vorige Pagina"
    };
    const game_details$h = {
      open_download_options: "Open download Instellingen",
      download_options_zero: "Geen download Instellingen",
      download_options_one: "{{count}} download Instellingen",
      download_options_other: "{{count}} download Instellingen",
      updated_at: "Geupdate {{updated_at}}",
      install: "Instaleer",
      resume: "Verder gaan",
      pause: "Pauze",
      cancel: "Stoppen",
      remove: "Verwijderen",
      space_left_on_disk: "{{space}} Over op schijf",
      eta: "Conclusie {{eta}}",
      downloading_metadata: "Downloading metadata…",
      filter: "Filter repacks",
      requirements: "Systeem vereisten",
      minimum: "Minimaal",
      recommended: "Aanbevolen",
      release_date: "Uitgebracht op {{date}}",
      publisher: "Gepubliceerd door {{publisher}}",
      hours: "uren",
      minutes: "minuten",
      amount_hours: "{{amount}} uren",
      amount_minutes: "{{amount}} minuten",
      accuracy: "{{accuracy}}% nauwkeurigheid",
      add_to_library: "Toevoegen aan bibliotheek",
      remove_from_library: "Verwijderen uit bibliotheek",
      no_downloads: "Geen downloads beschikbaar",
      play_time: "Voor gespeeld {{amount}}",
      last_time_played: "Laatst gespeeld {{period}}",
      not_played_yet: "Je hebt nog niet gespeeld {{title}}",
      next_suggestion: "Volgende suggestie",
      play: "Speel",
      deleting: "Installatieprogramma verwijderen…",
      close: "Sluiten",
      playing_now: "Speel nu",
      change: "Verander",
      repacks_modal_description: "Kies de herverpakking die u wilt downloaden",
      select_folder_hint: "Om de standaardmap te wijzigen, gaat u naar <0>instellingen</0>",
      download_now: "Download nu"
    };
    const activation$h = {
      title: "Activeer Hydra",
      installation_id: "Installatie-ID:",
      enter_activation_code: "Voer uw activatiecode in",
      message: "Als je niet weet waar je dit moet vragen, dan moet je dit niet hebben.",
      activate: "Activeren",
      loading: "Bezig met laden…"
    };
    const downloads$h = {
      resume: "Hervatten",
      pause: "Pauze",
      eta: "Conclusie{{eta}}",
      paused: "Gepauzeerd",
      verifying: "Verifiëren…",
      completed: "Voltooid",
      cancel: "Annuleren",
      filter: "Filter gedownloade games",
      remove: "Verwijderen",
      downloading_metadata: "Metagegevens downloaden",
      deleting: "Installatieprogramma verwijderen…",
      "delete": "Installatieprogramma verwijderen",
      delete_modal_title: "Weet je het zeker?",
      delete_modal_description: "Hiermee worden alle installatiebestanden van uw computer verwijderd",
      install: "Installeren"
    };
    const settings$h = {
      downloads_path: "Downloadpad",
      change: "Update",
      notifications: "Meldingen",
      enable_download_notifications: "Wanneer een download voltooid is",
      enable_repack_list_notifications: "Wanneer een nieuwe herverpakking wordt toegevoegd",
      real_debrid_api_token_label: "Real-Debrid API token",
      quit_app_instead_hiding: "Sluit Hydra af in plaats van te minimaliseren naar de lade",
      launch_with_system: "Start Hydra bij het opstarten van het systeem",
      general: "Algemeen",
      behavior: "Gedrag",
      enable_real_debrid: "Enable Real-Debrid",
      real_debrid_api_token_hint: "U kunt uw API-sleutel <0>hier</0> verkrijgen.",
      save_changes: "Wijzigingen opslaan"
    };
    const notifications$g = {
      download_complete: "Download compleet",
      game_ready_to_install: "{{title}} is klaar om te installeren",
      repack_list_updated: "Herpaklijst bijgewerkt",
      repack_count_one: "{{count}} herverpakking toegevoegd",
      repack_count_other: "{{count}} herverpakkingen toegevoegd"
    };
    const system_tray$g = {
      open: "Open Hydra",
      quit: "Verlaten"
    };
    const game_card$g = {
      no_downloads: "Geen downloads beschikbaar"
    };
    const binary_not_found_modal$g = {
      title: "Programma's niet geïnstalleerd",
      description: "Er zijn geen uitvoerbare bestanden van Wine of Lutris gevonden op uw systeem",
      instructions: "Controleer de juiste manier om ze op je Linux-distro te installeren, zodat de game normaal kan werken"
    };
    const modal$f = {
      close: "Knop Sluiten"
    };
    const translation$h = {
      home: home$h,
      sidebar: sidebar$h,
      header: header$h,
      bottom_panel: bottom_panel$h,
      catalogue: catalogue$h,
      game_details: game_details$h,
      activation: activation$h,
      downloads: downloads$h,
      settings: settings$h,
      notifications: notifications$g,
      system_tray: system_tray$g,
      game_card: game_card$g,
      binary_not_found_modal: binary_not_found_modal$g,
      modal: modal$f
    };
    const home$g = {
      featured: "En vedette",
      trending: "Tendance",
      surprise_me: "Surprenez-moi",
      no_results: "Aucun résultat trouvé"
    };
    const sidebar$g = {
      catalogue: "Catalogue",
      downloads: "Téléchargements",
      settings: "Paramètres",
      my_library: "Ma bibliothèque",
      downloading_metadata: "{{title}} (Téléchargement des métadonnées…)",
      paused: "{{title}} (En pause)",
      downloading: "{{title}} ({{percentage}} - Téléchargement en cours…)",
      filter: "Filtrer la bibliothèque",
      home: "Page d’accueil"
    };
    const header$g = {
      search: "Recherche",
      catalogue: "Catalogue",
      downloads: "Téléchargements",
      search_results: "Résultats de la recherche",
      settings: "Paramètres",
      home: "Accueil"
    };
    const bottom_panel$g = {
      no_downloads_in_progress: "Aucun téléchargement en cours",
      downloading_metadata: "Téléchargement des métadonnées de {{title}}…",
      downloading: "Téléchargement de {{title}}… ({{percentage}} terminé) - Fin dans {{eta}} - {{speed}}"
    };
    const game_details$g = {
      open_download_options: "Ouvrir les options de téléchargement",
      download_options_zero: "Aucune option de téléchargement",
      download_options_one: "{{count}} option de téléchargement",
      download_options_other: "{{count}} options de téléchargement",
      updated_at: "Mis à jour le {{updated_at}}",
      resume: "Reprendre",
      pause: "Pause",
      cancel: "Annuler",
      remove: "Supprimer",
      space_left_on_disk: "{{space}} restant sur le disque",
      eta: "Fin dans {{eta}}",
      downloading_metadata: "Téléchargement des métadonnées en cours…",
      filter: "Filtrer les repacks",
      requirements: "Configuration requise",
      minimum: "Minimum",
      recommended: "Recommandée",
      release_date: "Sorti le {{date}}",
      publisher: "Édité par {{publisher}}",
      hours: "heures",
      minutes: "minutes",
      amount_hours: "{{amount}} heures",
      amount_minutes: "{{amount}} minutes",
      accuracy: "{{accuracy}}% précision",
      add_to_library: "Ajouter à la bibliothèque",
      remove_from_library: "Supprimer de la bibliothèque",
      no_downloads: "Aucun téléchargement disponible",
      next_suggestion: "Suggestion suivante",
      play_time: "Joué pour {{montant}}",
      install: "Installer",
      play: "Jouer",
      not_played_yet: "Vous n'avez pas encore joué à {{title}}",
      close: "Fermer",
      deleting: "Suppression du programme d'installation…",
      playing_now: "Jeu en cours",
      last_time_played: "Dernièrement joué {{période}}"
    };
    const activation$g = {
      title: "Activer Hydra",
      installation_id: "ID d'installation :",
      enter_activation_code: "Entrez votre code d'activation",
      message: "Si vous ne savez pas où demander ceci, vous ne devriez pas l'avoir.",
      activate: "Activer",
      loading: "Chargement en cours…"
    };
    const downloads$g = {
      resume: "Reprendre",
      pause: "Pause",
      eta: "Fin dans {{eta}}",
      paused: "En pause",
      verifying: "Vérification en cours…",
      completed: "Terminé",
      cancel: "Annuler",
      filter: "Filtrer les jeux téléchargés",
      remove: "Supprimer",
      downloading_metadata: "Téléchargement des métadonnées en cours…",
      "delete": "Supprimer le programme d'installation",
      delete_modal_description: "Cela supprimera tous les fichiers d'installation de votre ordinateur",
      delete_modal_title: "Es-tu sûr?",
      deleting: "Suppression du programme d'installation…",
      install: "Installer"
    };
    const settings$g = {
      downloads_path: "Chemin des téléchargements",
      change: "Mettre à jour",
      notifications: "Notifications",
      enable_download_notifications: "Quand un téléchargement est terminé",
      enable_repack_list_notifications: "Quand un nouveau repack est ajouté",
      language: "Langue"
    };
    const notifications$f = {
      download_complete: "Téléchargement terminé",
      game_ready_to_install: "{{title}} est prêt à être installé",
      repack_list_updated: "Liste de repacks mise à jour",
      repack_count_one: "{{count}} repack ajouté",
      repack_count_other: "{{count}} repacks ajoutés"
    };
    const system_tray$f = {
      open: "Ouvrir NoFinder",
      quit: "Quitter"
    };
    const game_card$f = {
      no_downloads: "Aucun téléchargement disponible"
    };
    const binary_not_found_modal$f = {
      description: "Les exécutables Wine ou Lutris sont introuvables sur votre système",
      instructions: "Vérifiez la bonne façon d'installer l'un d'entre eux sur votre distribution Linux afin que le jeu puisse fonctionner normalement",
      title: "Programmes non installés"
    };
    const catalogue$g = {
      next_page: "Page suivante",
      previous_page: "Page précédente"
    };
    const translation$g = {
      home: home$g,
      sidebar: sidebar$g,
      header: header$g,
      bottom_panel: bottom_panel$g,
      game_details: game_details$g,
      activation: activation$g,
      downloads: downloads$g,
      settings: settings$g,
      notifications: notifications$f,
      system_tray: system_tray$f,
      game_card: game_card$f,
      binary_not_found_modal: binary_not_found_modal$f,
      catalogue: catalogue$g
    };
    const home$f = {
      featured: "Featured",
      trending: "Népszerű",
      surprise_me: "Lepj meg",
      no_results: "Nem található"
    };
    const sidebar$f = {
      catalogue: "Katalógus",
      downloads: "Letöltések",
      settings: "Beállítások",
      my_library: "Könyvtáram",
      downloading_metadata: "{{title}} (Metadata letöltése…)",
      paused: "{{title}} (Szünet)",
      downloading: "{{title}} ({{percentage}} - Letöltés…)",
      filter: "Könyvtár szűrése",
      home: "Főoldal"
    };
    const header$f = {
      search: "Keresés",
      home: "Főoldal",
      catalogue: "Katalógus",
      downloads: "Letöltések",
      search_results: "Keresési eredmények",
      settings: "Beállítások"
    };
    const bottom_panel$f = {
      no_downloads_in_progress: "Nincsenek folyamatban lévő letöltések",
      downloading_metadata: "{{title}} metaadatainak letöltése…",
      downloading: "{{title}} letöltése… ({{percentage}} kész) - Befejezés {{eta}} - {{speed}}"
    };
    const catalogue$f = {
      next_page: "Következő olda",
      previous_page: "Előző olda"
    };
    const game_details$f = {
      open_download_options: "Letöltési lehetőségek",
      download_options_zero: "Nincs letöltési lehetőség",
      download_options_one: "{{count}} letöltési lehetőség",
      download_options_other: "{{count}} letöltési lehetőség",
      updated_at: "Frissítve: {{updated_at}}",
      install: "Letöltés",
      resume: "Folytatás",
      pause: "Szüneteltetés",
      cancel: "Mégse",
      remove: "Eltávolítás",
      space_left_on_disk: "{{space}} szabad hely a lemezen",
      eta: "Befejezés {{eta}}",
      downloading_metadata: "Metaadatok letöltése…",
      filter: "Repackek szűrése",
      requirements: "Rendszerkövetelmények",
      minimum: "Minimális",
      recommended: "Ajánlott",
      release_date: "Megjelenés: {{date}}",
      publisher: "Kiadta: {{publisher}}",
      hours: "óra",
      minutes: "perc",
      amount_hours: "{{amount}} óra",
      amount_minutes: "{{amount}} perc",
      accuracy: "{{accuracy}}% pontosság",
      add_to_library: "Hozzáadás a könyvtárhoz",
      remove_from_library: "Eltávolítás a könyvtárból",
      no_downloads: "Nincs elérhető letöltés",
      play_time: "Játszva: {{amount}}",
      last_time_played: "Utoljára játszva {{period}}",
      not_played_yet: "{{title}} még nem játszottál",
      next_suggestion: "Következő javaslat",
      play: "Játék",
      deleting: "Telepítő törlése…",
      close: "Bezárás",
      playing_now: "Jelenleg játszva",
      change: "Változtatás",
      repacks_modal_description: "Choose the repack you want to download",
      select_folder_hint: "Ahhoz, hogy megváltoztasd a helyet, hozzákell férned a",
      download_now: "Töltsd le most"
    };
    const activation$f = {
      title: "Hydra Aktiválása",
      installation_id: "Telepítési ID:",
      enter_activation_code: "Add meg az aktiválási kódodat",
      message: "Ha nem tudod, hol kérdezd meg ezt, akkor nem is kellene, hogy legyen ilyened.",
      activate: "Aktiválás",
      loading: "Betöltés…"
    };
    const downloads$f = {
      resume: "Folytatás",
      pause: "Szüneteltetés",
      eta: "Befejezés {{eta}}",
      paused: "Szüneteltetve",
      verifying: "Ellenőrzés…",
      completed: "Befejezve",
      cancel: "Mégse",
      filter: "Letöltött játékok szűrése",
      remove: "Eltávolítás",
      downloading_metadata: "Metaadatok letöltése…",
      deleting: "Telepítő törlése…",
      "delete": "Telepítő eltávolítása",
      delete_modal_title: "Biztos vagy benne?",
      delete_modal_description: "Ez eltávolít minden telepítési fájlt a számítógépedről",
      install: "Telepítés"
    };
    const settings$f = {
      downloads_path: "Letöltések helye",
      change: "Frissítés",
      notifications: "Értesítések",
      enable_download_notifications: "Amikor egy letöltés befejeződik",
      enable_repack_list_notifications: "Amikor egy új repack hozzáadásra kerül"
    };
    const notifications$e = {
      download_complete: "Letöltés befejeződött",
      game_ready_to_install: "{{title}} telepítésre kész",
      repack_list_updated: "Repack lista frissítve",
      repack_count_one: "{{count}} repack hozzáadva",
      repack_count_other: "{{count}} repack hozzáadva"
    };
    const system_tray$e = {
      open: "Hydra megnyitása",
      quit: "Kilépés"
    };
    const game_card$e = {
      no_downloads: "Nincs elérhető letöltés"
    };
    const binary_not_found_modal$e = {
      title: "A programok nincsenek telepítve",
      description: "A Wine vagy a Lutris végrehajtható fájljai nem találhatók a rendszereden",
      instructions: "Ellenőrizd a megfelelő telepítési módot bármelyiküknek a Linux disztribúciódon, hogy a játék normálisan fusson"
    };
    const translation$f = {
      home: home$f,
      sidebar: sidebar$f,
      header: header$f,
      bottom_panel: bottom_panel$f,
      catalogue: catalogue$f,
      game_details: game_details$f,
      activation: activation$f,
      downloads: downloads$f,
      settings: settings$f,
      notifications: notifications$e,
      system_tray: system_tray$e,
      game_card: game_card$e,
      binary_not_found_modal: binary_not_found_modal$e
    };
    const home$e = {
      featured: "In primo piano",
      trending: "Di tendenza",
      surprise_me: "Sorprendimi",
      no_results: "Nessun risultato trovato"
    };
    const sidebar$e = {
      catalogue: "Catalogo",
      downloads: "Download",
      settings: "Impostazioni",
      my_library: "La mia libreria",
      downloading_metadata: "{{title}} (Scaricamento metadati…)",
      paused: "{{title}} (In pausa)",
      downloading: "{{title}} ({{percentage}} - Download…)",
      filter: "Filtra libreria",
      home: "Home"
    };
    const header$e = {
      search: "Cerca",
      home: "Home",
      catalogue: "Catalogo",
      downloads: "Download",
      search_results: "Risultati della ricerca",
      settings: "Impostazioni"
    };
    const bottom_panel$e = {
      no_downloads_in_progress: "Nessun download in corso",
      downloading_metadata: "Scaricamento metadati di {{title}}…",
      downloading: "Download di {{title}}… ({{percentage}} completato) - Conclusione {{eta}} - {{speed}}"
    };
    const catalogue$e = {
      next_page: "Pagina successiva",
      previous_page: "Pagina precedente"
    };
    const game_details$e = {
      open_download_options: "Apri opzioni di download",
      download_options_zero: "Nessuna opzione di download",
      download_options_one: "{{count}} opzione di download",
      download_options_other: "{{count}} opzioni di download",
      updated_at: "Aggiornato il {{updated_at}}",
      install: "Installa",
      resume: "Riprendi",
      pause: "Metti in pausa",
      cancel: "Annulla",
      remove: "Rimuovi",
      space_left_on_disk: "{{space}} rimasto sul disco",
      eta: "Conclusione {{eta}}",
      downloading_metadata: "Scaricamento metadati…",
      filter: "Filtra repack",
      requirements: "Requisiti di sistema",
      minimum: "Minimi",
      recommended: "Consigliati",
      release_date: "Rilasciato il {{date}}",
      publisher: "Pubblicato da {{publisher}}",
      hours: "ore",
      minutes: "minuti",
      amount_hours: "{{amount}} ore",
      amount_minutes: "{{amount}} minuti",
      accuracy: "{{accuracy}}% di accuratezza",
      add_to_library: "Aggiungi alla libreria",
      remove_from_library: "Rimuovi dalla libreria",
      no_downloads: "Nessun download disponibile",
      play_time: "Giocato per {{amount}}",
      last_time_played: "Ultimo gioco giocato {{period}}",
      not_played_yet: "Non hai ancora giocato a {{title}}",
      next_suggestion: "Prossimo suggerimento",
      play: "Gioca",
      deleting: "Eliminazione dell'installer…",
      close: "Chiudi",
      playing_now: "Stai giocando adesso",
      change: "Aggiorna",
      repacks_modal_description: "Scegli il repack che vuoi scaricare",
      select_folder_hint: "Per cambiare la cartella predefinita, accedi alle",
      download_now: "Scarica ora",
      no_shop_details: "Impossibile recuperare i dettagli del negozio.",
      download_options: "Opzioni di download",
      download_path: "Percorso di download",
      previous_screenshot: "Screenshot precedente",
      next_screenshot: "Screenshot successivo",
      screenshot: "Screenshot {{number}}",
      open_screenshot: "Apri screenshot {{number}}"
    };
    const activation$e = {
      title: "Attiva Hydra",
      installation_id: "ID installazione:",
      enter_activation_code: "Inserisci il tuo codice di attivazione",
      message: "Se non sai dove chiederlo, allora non dovresti averlo.",
      activate: "Attiva",
      loading: "Caricamento…"
    };
    const downloads$e = {
      resume: "Riprendi",
      pause: "Metti in pausa",
      eta: "Conclusione {{eta}}",
      paused: "In pausa",
      verifying: "Verifica…",
      completed: "Completato",
      cancel: "Annulla",
      filter: "Filtra giochi scaricati",
      remove: "Rimuovi",
      downloading_metadata: "Scaricamento metadati…",
      deleting: "Eliminazione dell'installer…",
      "delete": "Rimuovi installer",
      delete_modal_title: "Sei sicuro?",
      delete_modal_description: "Questo rimuoverà tutti i file di installazione dal tuo computer",
      install: "Installa"
    };
    const settings$e = {
      downloads_path: "Percorso dei download",
      change: "Aggiorna",
      notifications: "Notifiche",
      enable_download_notifications: "Quando un download è completo",
      enable_repack_list_notifications: "Quando viene aggiunto un nuovo repack",
      real_debrid_api_token_label: "Token API Real Debrid",
      quit_app_instead_hiding: "Esci da Hydra invece di nascondere nell'area di notifica",
      launch_with_system: "Apri Hydra all'avvio",
      general: "Generale",
      behavior: "Comportamento",
      enable_real_debrid: "Abilita Real Debrid",
      real_debrid_api_token_hint: "Puoi trovare la tua chiave API <0>here</0>",
      save_changes: "Salva modifiche"
    };
    const notifications$d = {
      download_complete: "Download completato",
      game_ready_to_install: "{{title}} è pronto per l'installazione",
      repack_list_updated: "Elenco repack aggiornato",
      repack_count_one: "{{count}} repack aggiunto",
      repack_count_other: "{{count}} repack aggiunti"
    };
    const system_tray$d = {
      open: "Apri Hydra",
      quit: "Esci"
    };
    const game_card$d = {
      no_downloads: "Nessun download disponibile"
    };
    const binary_not_found_modal$d = {
      title: "Programmi non installati",
      description: "Gli eseguibili di Wine o Lutris non sono stati trovati sul tuo sistema",
      instructions: "Verifica il modo corretto di installare uno di essi sulla tua distribuzione Linux in modo che il gioco possa funzionare normalmente"
    };
    const modal$e = {
      close: "Pulsante Chiudi"
    };
    const translation$e = {
      home: home$e,
      sidebar: sidebar$e,
      header: header$e,
      bottom_panel: bottom_panel$e,
      catalogue: catalogue$e,
      game_details: game_details$e,
      activation: activation$e,
      downloads: downloads$e,
      settings: settings$e,
      notifications: notifications$d,
      system_tray: system_tray$d,
      game_card: game_card$d,
      binary_not_found_modal: binary_not_found_modal$d,
      modal: modal$e
    };
    const home$d = {
      featured: "Wyróżnione",
      trending: "Trendujące",
      surprise_me: "Zaskocz mnie",
      no_results: "Nie znaleziono wyników"
    };
    const sidebar$d = {
      catalogue: "Katalog",
      downloads: "Pobrane",
      settings: "Ustawienia",
      my_library: "Moja biblioteka",
      downloading_metadata: "{{title}} (Pobieranie metadata…)",
      paused: "{{title}} (Zatrzymano)",
      downloading: "{{title}} ({{percentage}} - Pobieranie…)",
      filter: "Filtruj biblioteke",
      home: "Główna"
    };
    const header$d = {
      search: "Szukaj",
      home: "Główna",
      catalogue: "Katalog",
      downloads: "Pobrane",
      search_results: "Wyniki wyszukiwania",
      settings: "Ustawienia"
    };
    const bottom_panel$d = {
      no_downloads_in_progress: "Brak pobierań w toku",
      downloading_metadata: "Pobieranie {{title}} metadata…",
      downloading: "Pobieranie {{title}}… (ukończone w {{percentage}}) - Podsumowanie {{eta}} - {{speed}}"
    };
    const catalogue$d = {
      next_page: "Następna strona",
      previous_page: "Poprzednia strona"
    };
    const game_details$d = {
      open_download_options: "Otwórz opcje pobierania",
      download_options_zero: "Brak opcji pobierania",
      download_options_one: "{{count}} opcja pobierania",
      download_options_other: "{{count}} opcji pobierania",
      updated_at: "Zaktualizowano {{updated_at}}",
      install: "Instaluj",
      resume: "Wznów",
      pause: "Zatrzymaj",
      cancel: "Anuluj",
      remove: "Usuń",
      space_left_on_disk: "{{space}} wolnego na dysku",
      eta: "Podsumowanie {{eta}}",
      downloading_metadata: "Pobieranie metadata…",
      filter: "Filtruj repacki",
      requirements: "Wymagania systemowe",
      minimum: "Minimalne",
      recommended: "Zalecane",
      release_date: "Wydano w {{date}}",
      publisher: "Opublikowany przez {{publisher}}",
      hours: "godzin",
      minutes: "minut",
      amount_hours: "{{amount}} godzin",
      amount_minutes: "{{amount}} minut",
      accuracy: "{{accuracy}}% dokładność",
      add_to_library: "Dodaj do biblioteki",
      remove_from_library: "Usuń z biblioteki",
      no_downloads: "Brak dostępnych plików do pobrania",
      play_time: "Grano przez {{amount}}",
      last_time_played: "Ostatnio grano {{period}}",
      not_played_yet: "Nie grano {{title}}",
      next_suggestion: "Następna sugestia",
      play: "Graj",
      deleting: "Usuwanie instalatora…",
      close: "Zamknij",
      playing_now: "Granie teraz",
      change: "Zmień",
      repacks_modal_description: "Wybierz repack, który chcesz pobrać",
      select_folder_hint: "Aby zmienić domyślny folder, przejdź do",
      download_now: "Pobierz teraz",
      no_shop_details: "Nie udało się pobrać danych sklepu.",
      download_options: "Opcje pobierania",
      download_path: "Ścieżka pobierania",
      previous_screenshot: "Poprzedni zrzut ekranu",
      next_screenshot: "Następny zrzut ekranu",
      screenshot: "Zrzut ekranu {{number}}",
      open_screenshot: "Otwórz zrzut ekranu {{number}}"
    };
    const activation$d = {
      title: "Aktywuj Hydra",
      installation_id: "Identyfikator instalacji:",
      enter_activation_code: "Enter your activation code",
      message: "Jeśli nie wiesz, gdzie o to poprosić, to nie powinieneś/aś tego mieć.",
      activate: "Aktywuj",
      loading: "Ładowanie…"
    };
    const downloads$d = {
      resume: "Wznów",
      pause: "Zatrzymaj",
      eta: "Podsumowanie {{eta}}",
      paused: "Zatrzymano",
      verifying: "Weryfikowanie…",
      completed: "Zakończono",
      cancel: "Anuluj",
      filter: "Filtruj pobrane gry",
      remove: "Usuń",
      downloading_metadata: "Pobieranie metadata…",
      deleting: "Usuwanie instalatora…",
      "delete": "Usuń instalator",
      delete_modal_title: "Czy na pewno?",
      delete_modal_description: "Spowoduje to usunięcie wszystkich plików instalacyjnych z komputera",
      install: "Instaluj"
    };
    const settings$d = {
      downloads_path: "Ścieżka pobierania",
      change: "Aktualizuj",
      notifications: "Powiadomienia",
      enable_download_notifications: "Gdy pobieranie zostanie zakończone",
      enable_repack_list_notifications: "Gdy dodawany jest nowy repack",
      real_debrid_api_token_label: "Real-Debrid API token",
      quit_app_instead_hiding: "Zamknij Hydr zamiast minimalizować do zasobnika",
      launch_with_system: "Uruchom Hydra przy starcie systemu",
      general: "Ogólne",
      behavior: "Zachowania",
      language: "Język",
      enable_real_debrid: "Włącz Real-Debrid",
      real_debrid_api_token_hint: "Możesz uzyskać swój klucz API <0>tutaj</0>",
      save_changes: "Zapisz zmiany"
    };
    const notifications$c = {
      download_complete: "Pobieranie zakończone",
      game_ready_to_install: "{{title}} jest gotowe do zainstalowania",
      repack_list_updated: "Lista repacków zaktualizowana",
      repack_count_one: "{{count}} repack dodany",
      repack_count_other: "{{count}} repacki dodane"
    };
    const system_tray$c = {
      open: "Otwórz Hydra",
      quit: "Wyjdź"
    };
    const game_card$c = {
      no_downloads: "Brak dostępnych plików do pobrania"
    };
    const binary_not_found_modal$c = {
      title: "Programy nie są zainstalowane",
      description: "Pliki wykonywalne Wine lub Lutris nie zostały znalezione na twoim systemie",
      instructions: "Sprawdź prawidłowy sposób instalacji dowolnego z nich w swojej dystrybucji Linuksa, aby gra działała normalnie"
    };
    const modal$d = {
      close: "Zamknij"
    };
    const translation$d = {
      home: home$d,
      sidebar: sidebar$d,
      header: header$d,
      bottom_panel: bottom_panel$d,
      catalogue: catalogue$d,
      game_details: game_details$d,
      activation: activation$d,
      downloads: downloads$d,
      settings: settings$d,
      notifications: notifications$c,
      system_tray: system_tray$c,
      game_card: game_card$c,
      binary_not_found_modal: binary_not_found_modal$c,
      modal: modal$d
    };
    const app$3 = {
      successfully_signed_in: "Успешный вход"
    };
    const home$c = {
      featured: "Рекомендованное",
      trending: "В тренде",
      surprise_me: "Удиви меня",
      no_results: "Ничего не найдено"
    };
    const sidebar$c = {
      catalogue: "Каталог",
      downloads: "Загрузки",
      settings: "Настройки",
      my_library: "Библиотека",
      downloading_metadata: "{{title}} (Загрузка метаданных…)",
      paused: "{{title}} (Приостановлено)",
      downloading: "{{title}} ({{percentage}} - Загрузка…)",
      filter: "Фильтр библиотеки",
      home: "Главная",
      queued: "{{title}} (В очереди)",
      game_has_no_executable: "Файл запуска игры не выбран",
      sign_in: "Войти"
    };
    const header$c = {
      search: "Поиск",
      home: "Главная",
      catalogue: "Каталог",
      downloads: "Загрузки",
      search_results: "Результаты поиска",
      settings: "Настройки",
      version_available_install: "Доступна версия {{version}}. Нажмите здесь для перезапуска и установки.",
      version_available_download: "Доступна версия {{version}}. Нажмите здесь для загрузки."
    };
    const bottom_panel$c = {
      no_downloads_in_progress: "Нет активных загрузок",
      downloading_metadata: "Загрузка метаданных {{title}}…",
      downloading: "Загрузка {{title}}… ({{percentage}} завершено) - Окончание {{eta}} - {{speed}}",
      calculating_eta: "Загрузка {{title}}… ({{percentage}} завершено) - Подсчёт оставшегося времени…"
    };
    const catalogue$c = {
      next_page: "Следующая страница",
      previous_page: "Предыдущая страница"
    };
    const game_details$c = {
      open_download_options: "Открыть варианты загрузки",
      download_options_zero: "Нет вариантов загрузки",
      download_options_one: "{{count}} вариант загрузки",
      download_options_other: "{{count}} вариантов загрузки",
      updated_at: "Обновлено {{updated_at}}",
      install: "Установить",
      resume: "Возобновить",
      pause: "Приостановить",
      cancel: "Отменить",
      remove: "Удалить",
      space_left_on_disk: "{{space}} свободно на диске",
      eta: "Окончание {{eta}}",
      calculating_eta: "Подсчёт оставшегося времени…",
      downloading_metadata: "Загрузка метаданных…",
      filter: "Фильтр репаков",
      requirements: "Системные требования",
      minimum: "Минимальные",
      recommended: "Рекомендуемые",
      paused: "Приостановлено",
      release_date: "Выпущено {{date}}",
      publisher: "Издатель {{publisher}}",
      hours: "часов",
      minutes: "минут",
      amount_hours: "{{amount}} часов",
      amount_minutes: "{{amount}} минут",
      accuracy: "точность {{accuracy}}%",
      add_to_library: "Добавить в библиотеку",
      remove_from_library: "Удалить из библиотеки",
      no_downloads: "Нет доступных загрузок",
      play_time: "Сыграно {{amount}}",
      last_time_played: "Последний запуск {{period}}",
      not_played_yet: "Вы ещё не играли в {{title}}",
      next_suggestion: "Следующее предложение",
      play: "Играть",
      deleting: "Удаление установщика…",
      close: "Закрыть",
      playing_now: "Запущено",
      change: "Изменить",
      repacks_modal_description: "Выберите репак для загрузки",
      select_folder_hint: "Чтобы изменить папку загрузок по умолчанию, откройте <0>Настройки</0>",
      download_now: "Загрузить сейчас",
      no_shop_details: "Не удалось получить описание",
      download_options: "Вариантов загрузки",
      download_path: "Путь для загрузок",
      previous_screenshot: "Предыдущий скриншот",
      next_screenshot: "Следующий скриншот",
      screenshot: "Скриншот {{number}}",
      open_screenshot: "Открыть скриншот {{number}}",
      download_settings: "Параметры загрузки",
      downloader: "Загрузчик",
      select_executable: "Выбрать",
      no_executable_selected: "Файл не выбран",
      open_folder: "Открыть папку",
      open_download_location: "Просмотреть папку загрузок",
      create_shortcut: "Создать ярлык на рабочем столе",
      remove_files: "Удалить файлы",
      remove_from_library_title: "Вы уверены?",
      remove_from_library_description: "{{game}} будет удалена из вашей библиотеки.",
      options: "Настройки",
      executable_section_title: "Файл",
      executable_section_description: 'Путь к файлу, который будет запущен при нажатии на "Play"',
      downloads_secion_title: "Загрузки",
      downloads_section_description: "Проверить наличие обновлений или других версий игры",
      danger_zone_section_title: "Опасная зона",
      danger_zone_section_description: "Удалить эту игру из вашей библиотеки или файлы скачанные Hydra",
      download_in_progress: "Идёт загрузка",
      download_paused: "Загрузка приостановлена",
      last_downloaded_option: "Последний вариант загрузки",
      create_shortcut_success: "Ярлык создан",
      create_shortcut_error: "Не удалось создать ярлык"
    };
    const activation$c = {
      title: "Активировать Hydra",
      installation_id: "ID установки:",
      enter_activation_code: "Введите ваш активационный код",
      message: "Если вы не знаете, где его запросить, у вас его не должно быть.",
      activate: "Активировать",
      loading: "Загрузка…"
    };
    const downloads$c = {
      resume: "Возобновить",
      pause: "Приостановить",
      eta: "Окончание {{eta}}",
      paused: "Приостановлено",
      verifying: "Проверка…",
      completed: "Завершено",
      removed: "Не скачано",
      cancel: "Отмена",
      filter: "Фильтр загруженных игр",
      remove: "Удалить",
      downloading_metadata: "Загрузка метаданных…",
      deleting: "Удаление установщика…",
      "delete": "Удалить установщик",
      delete_modal_title: "Вы уверены?",
      delete_modal_description: "Это удалит все установщики с вашего компьютера",
      install: "Установить",
      download_in_progress: "В процессе",
      queued_downloads: "Загрузки в очереди",
      downloads_completed: "Завершено",
      queued: "В очереди",
      no_downloads_title: "Здесь так пусто...",
      no_downloads_description: "Вы ещё ничего не скачали через Hydra, но никогда не поздно начать."
    };
    const settings$c = {
      downloads_path: "Путь загрузок",
      change: "Изменить",
      notifications: "Уведомления",
      enable_download_notifications: "По завершении загрузки",
      enable_repack_list_notifications: "При добавлении нового репака",
      real_debrid_api_token_label: "Real-Debrid API-токен",
      quit_app_instead_hiding: "Закрывать приложение вместо сворачивания в трей",
      launch_with_system: "Запускать Hydra вместе с системой",
      general: "Основные",
      behavior: "Поведение",
      download_sources: "Источники загрузки",
      language: "Язык",
      real_debrid_api_token: "API Ключ",
      enable_real_debrid: "Включить Real-Debrid",
      real_debrid_description: "Real-Debrid - это неограниченный загрузчик, который позволяет быстро скачивать файлы, размещенные в Интернете, или мгновенно передавать их в плеер через частную сеть, позволяющую обходить любые блокировки.",
      real_debrid_invalid_token: "Неверный API ключ",
      real_debrid_api_token_hint: "API ключ можно получить <0>здесь</0>",
      real_debrid_free_account_error: 'Аккаунт "{{username}}" - не имеет подписки. Пожалуйста, оформите подписку на Real-Debrid',
      real_debrid_linked_message: 'Привязан аккаунт "{{username}}"',
      save_changes: "Сохранить изменения",
      changes_saved: "Изменения успешно сохранены",
      download_sources_description: "Hydra будет получать ссылки на загрузки из этих источников. URL должна содержать прямую ссылку на .json-файл с ссылками для загрузок.",
      validate_download_source: "Проверить",
      remove_download_source: "Удалить",
      add_download_source: "Добавить источник",
      download_count_zero: "В списке нет загрузок",
      download_count_one: "{{countFormatted}} загрузка в списке",
      download_count_other: "{{countFormatted}} загрузок в списке",
      download_options_zero: "Нет доступных загрузок",
      download_options_one: "{{countFormatted}} вариант загрузки доступен",
      download_options_other: "{{countFormatted}} вариантов загрузки доступно",
      download_source_url: "Ссылка на источник",
      add_download_source_description: "Вставьте ссылку на .json-файл",
      download_source_up_to_date: "Обновлён",
      download_source_errored: "Ошибка",
      sync_download_sources: "Синхронизировать источники",
      removed_download_source: "Источник загрузок удален",
      added_download_source: "Источник загрузок добавлен",
      download_sources_synced: "Все источники загрузок синхронизированы",
      insert_valid_json_url: "Вставьте действительный URL JSON-файла",
      found_download_option_zero: "Не найдено вариантов загрузки",
      found_download_option_one: "Найден {{countFormatted}} вариант загрузки",
      found_download_option_other: "Найдено {{countFormatted}} вариантов загрузки",
      "import": "Импортировать"
    };
    const notifications$b = {
      download_complete: "Загрузка завершена",
      game_ready_to_install: "{{title}} готова к установке",
      repack_list_updated: "Список репаков обновлен",
      repack_count_one: "{{count}} репак добавлен",
      repack_count_other: "{{count}} репаков добавлено",
      new_update_available: "Доступна версия {{version}}"
    };
    const system_tray$b = {
      open: "Открыть Hydra",
      quit: "Выйти"
    };
    const game_card$b = {
      no_downloads: "Нет доступных загрузок"
    };
    const binary_not_found_modal$b = {
      title: "Программы не установлены",
      description: "Wine или Lutris не найдены",
      instructions: "Узнайте правильный способ установить любой из них на ваш дистрибутив Linux, чтобы игра могла нормально работать"
    };
    const modal$c = {
      close: "Закрыть"
    };
    const forms$3 = {
      toggle_password_visibility: "Показывать пароль"
    };
    const user_profile$3 = {
      amount_hours: "{{amount}} часов",
      amount_minutes: "{{amount}} минут",
      last_time_played: "Последняя игра {{period}}",
      activity: "Недавняя активность",
      library: "Библиотека",
      total_play_time: "Всего сыграно: {{amount}}",
      no_recent_activity_title: "Хммм... Тут ничего нет",
      no_recent_activity_description: "Вы давно ни во что не играли. Пора это изменить!",
      display_name: "Отображаемое имя",
      saving: "Сохранение",
      save: "Сохранить",
      edit_profile: "Редактировать Профиль",
      saved_successfully: "Успешно сохранено",
      try_again: "Пожалуйста, попробуйте ещё раз",
      sign_out_modal_title: "Вы уверены?",
      cancel: "Отменить",
      successfully_signed_out: "Успешный выход из аккаунта",
      sign_out: "Выйти",
      playing_for: "Сыграно {{amount}}",
      sign_out_modal_text: "Ваша библиотека связана с текущей учетной записью. При выходе из системы ваша библиотека станет недоступна, и прогресс не будет сохранен. Выйти?"
    };
    const translation$c = {
      app: app$3,
      home: home$c,
      sidebar: sidebar$c,
      header: header$c,
      bottom_panel: bottom_panel$c,
      catalogue: catalogue$c,
      game_details: game_details$c,
      activation: activation$c,
      downloads: downloads$c,
      settings: settings$c,
      notifications: notifications$b,
      system_tray: system_tray$b,
      game_card: game_card$b,
      binary_not_found_modal: binary_not_found_modal$b,
      modal: modal$c,
      forms: forms$3,
      user_profile: user_profile$3
    };
    const home$b = {
      featured: "Öne çıkan",
      trending: "Popüler",
      surprise_me: "Şaşırt beni",
      no_results: "Sonuç bulunamadı"
    };
    const sidebar$b = {
      catalogue: "Katalog",
      downloads: "İndirmeler",
      settings: "Ayarlar",
      my_library: "Kütüphane",
      downloading_metadata: "{{title}} (Metadata indiriliyor…)",
      paused: "{{title}} (Duraklatıldı)",
      downloading: "{{title}} ({{percentage}} - İndiriliyor…)",
      filter: "Kütüphaneyi filtrele",
      home: "Ana menü"
    };
    const header$b = {
      search: "Ara",
      home: "Ana menü",
      catalogue: "Katalog",
      downloads: "İndirmeler",
      search_results: "Arama sonuçları",
      settings: "Ayarlar"
    };
    const bottom_panel$b = {
      no_downloads_in_progress: "İndirilen bir şey yok",
      downloading_metadata: "{{title}} metadatası indiriliyor…",
      downloading: "{{title}} indiriliyor… ({{percentage}} tamamlandı) - Bitiş {{eta}} - {{speed}}"
    };
    const catalogue$b = {
      next_page: "Sonraki sayfa",
      previous_page: "Önceki sayfa"
    };
    const game_details$b = {
      open_download_options: "İndirme seçeneklerini aç",
      download_options_zero: "İndirme seçeneği yok",
      download_options_one: "{{count}} indirme seçeneği",
      download_options_other: "{{count}} indirme seçeneği",
      updated_at: "{{updated_at}} güncellendi",
      install: "İndir",
      resume: "Devam et",
      pause: "Duraklat",
      cancel: "İptal et",
      remove: "Sil",
      space_left_on_disk: "Diskte {{space}} yer kaldı",
      eta: "Bitiş {{eta}}",
      downloading_metadata: "Metadata indiriliyor…",
      filter: "Repackleri filtrele",
      requirements: "Sistem gereksinimleri",
      minimum: "Minimum",
      recommended: "Önerilen",
      release_date: "{{date}} tarihinde çıktı",
      publisher: "{{publisher}} tarihinde yayınlandı",
      hours: "saatler",
      minutes: "dakikalar",
      amount_hours: "{{amount}} saat",
      amount_minutes: "{{amount}} dakika",
      accuracy: "%{{accuracy}} doğruluk",
      add_to_library: "Kütüphaneye ekle",
      remove_from_library: "Kütüphaneden kaldır",
      no_downloads: "İndirme yok",
      play_time: "{{amount}} oynandı",
      last_time_played: "Son oynanan {{period}}",
      not_played_yet: "Bu {{title}} hiç oynanmadı",
      next_suggestion: "Sıradaki öneri",
      play: "Oyna",
      deleting: "Installer siliniyor…",
      close: "Kapat",
      playing_now: "Şimdi oynanıyor",
      change: "Değiştir",
      repacks_modal_description: "İndirmek istediğiiniz repacki seçin",
      select_folder_hint: "Varsayılan klasörü değiştirmek için ulaşmanız gereken ayar",
      download_now: "Şimdi"
    };
    const activation$b = {
      title: "Hydra'yı aktif et",
      installation_id: "Kurulum ID'si:",
      enter_activation_code: "Aktifleştirme kodunuzu girin",
      message: "Bunu nerede soracağınızı bilmiyorsanız, buna sahip olmamanız gerekiyor.",
      activate: "Aktif et",
      loading: "Yükleniyor…"
    };
    const downloads$b = {
      resume: "Devam et",
      pause: "Duraklat",
      eta: "Bitiş {{eta}}",
      paused: "Duraklatıldı",
      verifying: "Doğrulanıyor…",
      completed: "Tamamlandı",
      cancel: "İptal et",
      filter: "Yüklü oyunları filtrele",
      remove: "Kaldır",
      downloading_metadata: "Metadata indiriliyor…",
      deleting: "Installer siliniyor…",
      "delete": "Installer'ı sil",
      delete_modal_title: "Emin misiniz?",
      delete_modal_description: "Bu bilgisayarınızdan tüm kurulum dosyalarını silecek",
      install: "Kur"
    };
    const settings$b = {
      downloads_path: "İndirme yolu",
      change: "Güncelle",
      notifications: "Bildirimler",
      enable_download_notifications: "Bir indirme bittiğinde",
      enable_repack_list_notifications: "Yeni bir repack eklendiğinde"
    };
    const notifications$a = {
      download_complete: "İndirme tamamlandı",
      game_ready_to_install: "{{title}} kuruluma hazır",
      repack_list_updated: "Repack listesi güncellendi",
      repack_count_one: "{{count}} yeni repack eklendi",
      repack_count_other: "{{count}} yeni repack eklendi"
    };
    const system_tray$a = {
      open: "Hydra'yı aç",
      quit: "Çık"
    };
    const game_card$a = {
      no_downloads: "İndirme mevcut değil"
    };
    const binary_not_found_modal$a = {
      title: "Programlar yüklü değil",
      description: "Sisteminizde Wine veya Lutris çalıştırılabiliri bulunamadı",
      instructions: "Oyunları düzgün şekilde çalıştırmak için Linux distronuza bunlardan birini nasıl yükleyebileceğinize bakın"
    };
    const modal$b = {
      close: "Kapat tuşu"
    };
    const translation$b = {
      home: home$b,
      sidebar: sidebar$b,
      header: header$b,
      bottom_panel: bottom_panel$b,
      catalogue: catalogue$b,
      game_details: game_details$b,
      activation: activation$b,
      downloads: downloads$b,
      settings: settings$b,
      notifications: notifications$a,
      system_tray: system_tray$a,
      game_card: game_card$a,
      binary_not_found_modal: binary_not_found_modal$a,
      modal: modal$b
    };
    const home$a = {
      featured: "Рэкамэндаванае",
      trending: "Актуальнае",
      surprise_me: "Здзіві мяне",
      no_results: "Няма вынікаў"
    };
    const sidebar$a = {
      catalogue: "Каталог",
      downloads: "Сцягванні",
      settings: "Налады",
      my_library: "Мая бібліятэка",
      downloading_metadata: "{{title}} (Сцягванне мэтаданых…)",
      paused: "{{title}} (Спынена)",
      downloading: "{{title}} ({{percentage}} - Сцягванне…)",
      filter: "Фільтар бібліятэкі",
      home: "Галоўная"
    };
    const header$a = {
      search: "Пошук",
      home: "Галоўная",
      catalogue: "Каталог",
      downloads: "Сцягванні",
      search_results: "Вынікі пошуку",
      settings: "Налады"
    };
    const bottom_panel$a = {
      no_downloads_in_progress: "Няма актыўных сцягванняў",
      downloading_metadata: "Сцягванне мэтаданых {{title}}…",
      downloading: "Сцягванне {{title}}… ({{percentage}} скончана) - Канчатак {{eta}} - {{speed}}"
    };
    const catalogue$a = {
      next_page: "Наступная старонка",
      previous_page: "Папярэдняя старонка"
    };
    const game_details$a = {
      open_download_options: "Адкрыць варыянты сцягвання",
      download_options_zero: "Няма варыянтаў сцягвання",
      download_options_one: "{{count}} варыянт сцягвання",
      download_options_other: "{{count}} варыянтаў сцягвання",
      updated_at: "Абноўлена {{updated_at}}",
      install: "Усталяваць",
      resume: "Працягнуць",
      pause: "Спыніць",
      cancel: "Скасаваць",
      remove: "Выдаліць",
      space_left_on_disk: "{{space}} засталося на дыску",
      eta: "Канчатак {{eta}}",
      downloading_metadata: "Сцягванне мэтаданых…",
      filter: "Фільтар рэпакаў",
      requirements: "Сістэмныя патрэбаванни",
      minimum: "Мінімальныя",
      recommended: "Рэкамендуемыя",
      release_date: "Выпушчана {{date}}",
      publisher: "Выдана {{publisher}}",
      hours: "гадзін",
      minutes: "хвілін",
      amount_hours: "{{amount}} гадзін",
      amount_minutes: "{{amount}} хвілін",
      accuracy: "{{accuracy}}% дакладнасць",
      add_to_library: "Дадаць да бібліятэкі",
      remove_from_library: "Выдаліць з бібліятэкі",
      no_downloads: "Няма даступных сцягванняў",
      play_time: "Гулялі {{amount}}",
      last_time_played: "Апошні раз гулялі {{period}}",
      not_played_yet: "Вы яшчэ не гулялі ў {{title}}",
      next_suggestion: "Наступная прапанова",
      play: "Гуляць",
      deleting: "Выдаленне ўсталёўшчыка…",
      close: "Закрыць",
      playing_now: "Зараз гуляе",
      change: "Змяніць",
      repacks_modal_description: "Абярыце рэпак, які хочаце сцягнуць",
      select_folder_hint: "Каб змяніць папку па змоўчанні, адкрыйце",
      download_now: "Сцягнуць зараз"
    };
    const activation$a = {
      title: "Актываваць Hydra",
      installation_id: "ID усталёўкі:",
      enter_activation_code: "Увядзіце ваш код актывацыі",
      message: "Калі вы ня ведаеце, дзе яго атрымаць, то не мусіць гэтага рабіць.",
      activate: "Актываваць",
      loading: "Загрузка…"
    };
    const downloads$a = {
      resume: "Працягнуць",
      pause: "Спыніць",
      eta: "Канчатак {{eta}}",
      paused: "Спынена",
      verifying: "Праверка…",
      completed: "Скончана",
      cancel: "Скасаваць",
      filter: "Фільтар сцягнутых гульняў",
      remove: "Выдаліць",
      downloading_metadata: "Сцягванне мэтаданых…",
      deleting: "Выдаленне ўсталёўшчыка…",
      "delete": "Выдаліць усталёўшчык",
      delete_modal_title: "Вы ўпэўнены?",
      delete_modal_description: "Гэта выдаліць усе файлы ўсталёвак з вашага кампутара",
      install: "Усталяваць"
    };
    const settings$a = {
      downloads_path: "Шлях сцягвання",
      change: "Змяніць шлях",
      notifications: "Апавяшчэнні",
      enable_download_notifications: "Па сканчэнні сцягванні",
      enable_repack_list_notifications: "Пры даданні новага рэпака",
      behavior: "Паводзіны",
      quit_app_instead_hiding: "Закрываць праграму замест таго, каб хаваць яе ў трэй",
      launch_with_system: "Запускаць праграму пры запуску сыстэмы"
    };
    const notifications$9 = {
      download_complete: "Сцягванне скончана",
      game_ready_to_install: "{{title}} гатова да ўсталёўкі",
      repack_list_updated: "Спіс рэпакаў абноўлены",
      repack_count_one: "{{count}} рэпак дададзены",
      repack_count_other: "{{count}} рэпакаў дададзена"
    };
    const system_tray$9 = {
      open: "Адкрыць Hydra",
      quit: "Выйсьці"
    };
    const game_card$9 = {
      no_downloads: "Няма даступных сцягванняў"
    };
    const binary_not_found_modal$9 = {
      title: "Праграмы не ўсталяваныя",
      description: "Выканальныя файлы Wine ці Lutris ня знойдзеныя ў вашай сістэме",
      instructions: "Даведайцеся, як правільна ўсталяваць любы з іх на вашым дыстрыбутыве Linux, каб гульня магла працаваць нармальна"
    };
    const modal$a = {
      close: "Кнопка закрыцця"
    };
    const translation$a = {
      home: home$a,
      sidebar: sidebar$a,
      header: header$a,
      bottom_panel: bottom_panel$a,
      catalogue: catalogue$a,
      game_details: game_details$a,
      activation: activation$a,
      downloads: downloads$a,
      settings: settings$a,
      notifications: notifications$9,
      system_tray: system_tray$9,
      game_card: game_card$9,
      binary_not_found_modal: binary_not_found_modal$9,
      modal: modal$a
    };
    const app$2 = {
      successfully_signed_in: "Успішний вхід в систему"
    };
    const home$9 = {
      featured: "Рекомендоване",
      trending: "У тренді",
      surprise_me: "Здивуй мене",
      no_results: "Результатів не знайдено"
    };
    const sidebar$9 = {
      catalogue: "Каталог",
      downloads: "Завантаження",
      settings: "Налаштування",
      my_library: "Бібліотека",
      downloading_metadata: "{{title}} (Завантаження метаданих…)",
      paused: "{{title}} (Призупинено)",
      downloading: "{{title}} ({{percentage}} - Завантаження…)",
      filter: "Фільтр бібліотеки",
      home: "Головна",
      game_has_no_executable: "Не було вибрано файл для запуску гри",
      queued: "{{title}} в черзі",
      sign_in: "Увійти"
    };
    const header$9 = {
      search: "Пошук",
      home: "Головна",
      catalogue: "Каталог",
      downloads: "Завантаження",
      search_results: "Результати пошуку",
      settings: "Налаштування",
      version_available_download: "Доступна версія {{version}}. Натисніть тут, щоб перезапустити та встановити.",
      version_available_install: "Доступна версія {{version}}. Натисніть тут для завантаження."
    };
    const bottom_panel$9 = {
      no_downloads_in_progress: "Немає активних завантажень",
      downloading_metadata: "Завантаження метаданих {{title}}…",
      downloading: "Завантаження {{title}}… ({{percentage}} завершено) - Закінчення {{eta}} - {{speed}}",
      calculating_eta: "Завантаження {{title}}… ({{percentage}} завершено) - Обчислення залишкового часу…"
    };
    const catalogue$9 = {
      next_page: "Наступна сторінка",
      previous_page: "Попередня сторінка"
    };
    const game_details$9 = {
      open_download_options: "Відкрити варіанти завантаження",
      download_options_zero: "Немає варіантів завантаження",
      download_options_one: "{{count}} варіант завантаження",
      download_options_other: "{{count}} варіантів завантаження",
      updated_at: "Оновлено {{updated_at}}",
      install: "Встановити",
      resume: "Відновити",
      pause: "Призупинити",
      cancel: "Скасувати",
      remove: "Видалити",
      space_left_on_disk: "{{space}} вільно на диску",
      eta: "Закінчення {{eta}}",
      downloading_metadata: "Завантаження метаданих…",
      filter: "Фільтр репаків",
      requirements: "Системні вимоги",
      minimum: "Мінімальні",
      recommended: "Рекомендовані",
      release_date: "Випущено {{date}}",
      publisher: "Видавець {{publisher}}",
      hours: "годин",
      minutes: "хвилин",
      amount_hours: "{{amount}} годин",
      amount_minutes: "{{amount}} хвилин",
      accuracy: "{{accuracy}}% точність",
      add_to_library: "Додати до бібліотеки",
      remove_from_library: "Видалити з бібліотеки",
      no_downloads: "Немає доступних завантажень",
      play_time: "Час гри: {{amount}}",
      last_time_played: "Востаннє зіграно: {{period}}",
      not_played_yet: "Ви ще не грали в {{title}}",
      next_suggestion: "Наступна пропозиція",
      play: "Грати",
      deleting: "Видалення інсталятора…",
      close: "Закрити",
      playing_now: "Поточна гра",
      change: "Змінити",
      repacks_modal_description: "Виберіть репак, який хочете завантажити",
      select_folder_hint: "Щоб змінити теку за замовчуванням, відкрийте",
      download_now: "Завантажити зараз",
      calculating_eta: "Обчислення залишкового часу…",
      create_shortcut: "Створити ярлик на робочому столі",
      danger_zone_section_description: "Видалити цю гру з вашої бібліотеки або файли скачані Hydra",
      danger_zone_section_title: "Небезпечна зона",
      download_in_progress: "Триває завантаження.",
      download_options: "Варіантів завантаження",
      download_path: "Тека для завантажень",
      download_paused: "Завантаження призупинено",
      download_settings: "Налаштування завантаження",
      downloader: "Завантажувач",
      downloads_secion_title: "Завантаження",
      downloads_section_description: "Перевірити наявність оновлень або інших версій гри",
      executable_section_description: 'Шлях до файлу, який буде запущений при натисканні на кнопку "Play"',
      executable_section_title: "Файл",
      last_downloaded_option: "Останній варіант завантаження",
      next_screenshot: "Наступний скрішнот",
      no_executable_selected: "Файл не вибрано",
      no_shop_details: "Не вдалося отримати опис",
      open_download_location: "Переглянути папку завантажень",
      open_folder: "Відкрити папку",
      open_screenshot: "Відкрити скріншот",
      options: "Налаштування",
      paused: "Призупинено",
      previous_screenshot: "Попередній скріншот",
      remove_files: "Видалити файли",
      remove_from_library_description: "{{game}} буде видалено з вашої бібліотеки",
      remove_from_library_title: "Ви впевнені?",
      screenshot: "Скріншот",
      select_executable: "Обрати"
    };
    const activation$9 = {
      title: "Активувати Hydra",
      installation_id: "ID установки:",
      enter_activation_code: "Введіть ваш активаційний код",
      message: "Якщо ви не знаєте, де його запросити, то не повинні мати його.",
      activate: "Активувати",
      loading: "Завантаження…"
    };
    const downloads$9 = {
      resume: "Продовжити",
      pause: "Призупинити",
      eta: "Закінчення {{eta}}",
      paused: "Призупинено",
      verifying: "Перевірка…",
      completed: "Завершено",
      cancel: "Скасувати",
      filter: "Фільтр завантажених ігор",
      remove: "Видалити",
      downloading_metadata: "Завантаження метаданих…",
      deleting: "Видалення інсталятора…",
      "delete": "Видалити інсталятор",
      delete_modal_title: "Ви впевнені?",
      delete_modal_description: "Це видалить усі інсталяційні файли з вашого комп'ютера",
      install: "Встановити",
      download_in_progress: "В процесі",
      downloads_completed: "Завершено",
      no_downloads_description: "Ви ще нічого не завантажили через Hydra, але ніколи не пізно почати.",
      no_downloads_title: "Тут так пусто...",
      queued: "В черзі",
      queued_downloads: "Завантаження в черзі",
      removed: "Не завантажено"
    };
    const settings$9 = {
      downloads_path: "Тека завантажень",
      change: "Змінити",
      notifications: "Повідомлення",
      enable_download_notifications: "Після завершення завантаження",
      enable_repack_list_notifications: "Коли додається новий репак",
      behavior: "Поведінка",
      quit_app_instead_hiding: "Закривати Hydra замість того, щоб згортати її в трей",
      launch_with_system: "Запускати Hydra із запуском комп'ютера",
      add_download_source: "Добавити джерело",
      add_download_source_description: "Введіть посилання на .json-файл",
      added_download_source: "Джерело для завантаження було додано",
      changes_saved: "Зміни успішно збережено",
      download_count_one: "{{countFormatted}} завантаження в списку",
      download_count_other: "{{countFormatted}} завантажень в списку",
      download_count_zero: "В списку немає завантажень",
      download_options_one: "{{countFormatted}} доступний варіант завантаження",
      download_options_other: "{{countFormatted}} доступних варіантів завантаження",
      download_options_zero: "Немає доступних завантажень",
      download_source_errored: "Помилка",
      download_source_up_to_date: "Оновлено",
      download_source_url: "Посилання на джерело",
      download_sources: "Джерела для завантаження",
      download_sources_description: "Hydra буде отримувати посилання для завантажень із цих джерел. URL має містити пряме посилання на .json-файл із посиланнями для завантажень.",
      download_sources_synced: "Всі джерела для завантаження синхронізовано",
      enable_real_debrid: "Включити Real-Debrid",
      found_download_option_one: "Знайдено {{countFormatted}} варіант завантаження",
      found_download_option_other: "Знайдено {{countFormatted}} варіантів завантаження",
      found_download_option_zero: "Немає доступних завантажень",
      general: "Основні",
      "import": "Імпортувати",
      insert_valid_json_url: "Вставте дійсний URL JSON-файлу",
      language: "Мова",
      real_debrid_api_token: "API-токен",
      real_debrid_api_token_hint: "API токен можливо отримати <0>тут</0>",
      real_debrid_api_token_label: "Real-Debrid API-токен",
      real_debrid_description: "Real-Debrid — це необмежений завантажувач, який дозволяє швидко завантажувати файли, розміщені в Інтернеті, або миттєво передавати їх у плеєр через приватну мережу, що дозволяє обходити будь-які блокування.",
      real_debrid_free_account_error: 'Акаунт "{{username}}" - не має наявної підписки. Будь ласка, оформіть підписку на Real-Debrid',
      real_debrid_invalid_token: "Невірний API-токен",
      real_debrid_linked_message: 'Акаунт "{{username}}" привязаний',
      remove_download_source: "Видалити",
      removed_download_source: "Джерело завантажень було видалено",
      save_changes: "Зберегти зміни",
      sync_download_sources: "Синхронізувати джерела",
      validate_download_source: "Перевірити"
    };
    const notifications$8 = {
      download_complete: "Завантаження завершено",
      game_ready_to_install: "{{title}} готова до встановлення",
      repack_list_updated: "Список репаків оновлено",
      repack_count_one: "{{count}} репак додано",
      repack_count_other: "{{count}} репаків додано"
    };
    const system_tray$8 = {
      open: "Відкрити Hydra",
      quit: "Вийти"
    };
    const game_card$8 = {
      no_downloads: "Немає доступних завантажень"
    };
    const binary_not_found_modal$8 = {
      title: "Програми не встановлені",
      description: "Виконувані файли Wine або Lutris не знайдено у вашій системі",
      instructions: "Дізнайтеся правильний спосіб встановити будь-який з них на ваш дистрибутив Linux, щоб гра могла нормально працювати"
    };
    const modal$9 = {
      close: "Закрити"
    };
    const forms$2 = {
      toggle_password_visibility: "Показувати пароль"
    };
    const user_profile$2 = {
      activity: "Остання активність",
      amount_hours: "{{amount}} годин",
      amount_minutes: "{{amount}} хвилин",
      cancel: "Скасувати",
      display_name: "Відображуване ім'я",
      edit_profile: "Редагувати профіль",
      last_time_played: "Остання гра {{period}}",
      library: "Бібліотека",
      no_recent_activity_description: "Ви давно не грали в ігри. Пора це змінити!",
      no_recent_activity_title: "Хммм... Тут нічого немає",
      playing_for: "Зіграно {{amount}}",
      save: "Збережено",
      saved_successfully: "Успішно збережено",
      saving: "Збереження",
      sign_out: "Вийти",
      sign_out_modal_text: "Ваша бібліотека пов'язана з поточним обліковим записом. При виході з системи ваша бібліотека буде недоступною, і прогрес не буде збережено. Продовжити вихід?",
      sign_out_modal_title: "Ви впевнені?",
      successfully_signed_out: "Успішний вихід з акаунту",
      total_play_time: "Всього зіграно: {{amount}}",
      try_again: "Будь ласка, попробуйте ще раз"
    };
    const translation$9 = {
      app: app$2,
      home: home$9,
      sidebar: sidebar$9,
      header: header$9,
      bottom_panel: bottom_panel$9,
      catalogue: catalogue$9,
      game_details: game_details$9,
      activation: activation$9,
      downloads: downloads$9,
      settings: settings$9,
      notifications: notifications$8,
      system_tray: system_tray$8,
      game_card: game_card$8,
      binary_not_found_modal: binary_not_found_modal$8,
      modal: modal$9,
      forms: forms$2,
      user_profile: user_profile$2
    };
    const app$1 = {
      successfully_signed_in: "已成功登录"
    };
    const home$8 = {
      featured: "特色推荐",
      trending: "最近热门",
      surprise_me: "向我推荐",
      no_results: "没有找到结果"
    };
    const sidebar$8 = {
      catalogue: "游戏目录",
      downloads: "下载中心",
      settings: "设置",
      my_library: "我的游戏库",
      downloading_metadata: "{{title}} (正在下载元数据…)",
      paused: "{{title}} (已暂停)",
      downloading: "{{title}} ({{percentage}} - 正在下载…)",
      filter: "筛选游戏库",
      home: "主页",
      queued: "{{title}} (已加入下载队列)",
      game_has_no_executable: "未选择游戏的可执行文件",
      sign_in: "登入"
    };
    const header$8 = {
      search: "搜索游戏",
      home: "主页",
      catalogue: "游戏目录",
      downloads: "下载中心",
      search_results: "搜索结果",
      settings: "设置",
      version_available_install: "版本 {{version}} 已可用. 点击此处重新启动并安装.",
      version_available_download: "版本 {{version}} 可用. 点击此处下载."
    };
    const bottom_panel$8 = {
      no_downloads_in_progress: "没有正在进行的下载",
      downloading_metadata: "正在下载{{title}}的元数据…",
      downloading: "正在下载{{title}}… ({{percentage}}完成) - 剩余时间{{eta}} - 速度{{speed}}",
      calculating_eta: "正在下载 {{title}}… (已完成{{percentage}}.) - 正在计算剩余时间..."
    };
    const catalogue$8 = {
      next_page: "下一页",
      previous_page: "上一页"
    };
    const game_details$8 = {
      open_download_options: "打开下载选项",
      download_options_zero: "无下载选项",
      download_options_one: "{{count}}个下载选项",
      download_options_other: "{{count}}个下载选项",
      updated_at: "更新于{{updated_at}}",
      install: "安装",
      resume: "恢复",
      pause: "暂停",
      cancel: "取消",
      remove: "移除",
      space_left_on_disk: "磁盘剩余空间{{space}}",
      eta: "预计完成时间{{eta}}",
      downloading_metadata: "正在下载元数据…",
      filter: "筛选重打包",
      requirements: "配置要求",
      minimum: "最低要求",
      recommended: "推荐要求",
      release_date: "发布于{{date}}",
      publisher: "发行商{{publisher}}",
      hours: "小时",
      minutes: "分钟",
      amount_hours: "{{amount}}小时",
      amount_minutes: "{{amount}}分钟",
      accuracy: "准确度{{accuracy}}%",
      add_to_library: "添加到游戏库",
      remove_from_library: "从游戏库移除",
      no_downloads: "没有可用的下载",
      play_time: "游戏时长{{amount}}",
      last_time_played: "上次玩{{period}}",
      not_played_yet: "您还没有玩过{{title}}",
      next_suggestion: "下一个建议",
      play: "开始游戏",
      deleting: "正在删除安装程序…",
      close: "关闭",
      playing_now: "正在游戏中",
      change: "更改",
      repacks_modal_description: "选择您想要下载的重打包",
      select_folder_hint: "要更改默认文件夹,请访问",
      download_now: "立即下载",
      previous_screenshot: "上一张截图",
      next_screenshot: "下一张截图",
      screenshot: "截图 {{number}}",
      open_screenshot: "打开截图 {{number}}",
      download_settings: "下载设置",
      downloader: "下载器",
      select_executable: "选择",
      no_executable_selected: "没有可执行文件被指定",
      open_folder: "打开目录",
      open_download_location: "查看已下载的文件",
      create_shortcut: "创建桌面快捷方式",
      remove_files: "删除文件",
      remove_from_library_title: "你确定吗？",
      remove_from_library_description: "这将会把 {{game}} 从你的库中移除",
      options: "选项",
      executable_section_title: "可执行文件",
      executable_section_description: '点击 "Play" 时将执行的文件的路径',
      downloads_secion_title: "下载",
      downloads_section_description: "查看此游戏的更新或其他版本",
      danger_zone_section_title: "危险操作",
      danger_zone_section_description: "从您的库或Hydra下载的文件中删除此游戏",
      download_in_progress: "下载进行中",
      download_paused: "下载暂停",
      last_downloaded_option: "上次下载的选项",
      create_shortcut_success: "成功创建快捷方式",
      create_shortcut_error: "创建快捷方式出错"
    };
    const activation$8 = {
      title: "激活 Hydra",
      installation_id: "安装ID:",
      enter_activation_code: "输入您的激活码",
      message: "如果你不知道在哪里请求这个,那么您将无法继续。",
      activate: "激活",
      loading: "加载中…"
    };
    const downloads$8 = {
      resume: "继续",
      pause: "暂停",
      eta: "预计完成时间{{eta}}",
      paused: "已暂停",
      verifying: "正在验证…",
      completed: "已完成",
      cancel: "取消",
      filter: "筛选已下载游戏",
      remove: "移除",
      downloading_metadata: "正在下载元数据…",
      deleting: "正在删除安装程序…",
      "delete": "移除安装程序",
      delete_modal_title: "您确定吗？",
      delete_modal_description: "这将从您的电脑上移除所有的安装文件",
      install: "安装",
      download_in_progress: "进行中",
      queued_downloads: "在队列中的下载",
      downloads_completed: "已完成",
      queued: "下载列表",
      no_downloads_title: "空空如也",
      no_downloads_description: "你还未使用Hydra下载任何游戏,但什么时候开始,都为时不晚。"
    };
    const settings$8 = {
      downloads_path: "下载路径",
      change: "更改",
      notifications: "通知",
      enable_download_notifications: "下载完成时",
      enable_repack_list_notifications: "添加新重打包时",
      real_debrid_api_token_label: "Real-Debrid API 令牌",
      quit_app_instead_hiding: "关闭Hydra而不是最小化到托盘",
      launch_with_system: "系统启动时运行 Hydra",
      general: "通用",
      behavior: "行为",
      download_sources: "下载源",
      language: "语言",
      real_debrid_api_token: "API 令牌",
      enable_real_debrid: "启用 Real-Debrid",
      real_debrid_description: "Real-Debrid 是一个无限制的下载器，允许您以最快的互联网速度即时下载文件。",
      real_debrid_invalid_token: "无效的 API 令牌",
      real_debrid_api_token_hint: "您可以从<0>这里</0>获取API密钥.",
      real_debrid_free_account_error: '账户 "{{username}}" 是免费账户。请订阅 Real-Debrid',
      real_debrid_linked_message: '账户 "{{username}}" 已链接',
      save_changes: "保存更改",
      changes_saved: "更改已成功保存",
      download_sources_description: "Hydra 将从这些源获取下载链接。源 URL 必须是直接链接到包含下载链接的 .json 文件。",
      validate_download_source: "验证",
      remove_download_source: "移除",
      add_download_source: "添加源",
      download_count_zero: "列表中无下载",
      download_count_one: "列表中有 {{countFormatted}} 个下载",
      download_count_other: "列表中有 {{countFormatted}} 个下载",
      download_options_zero: "无可用下载",
      download_options_one: "有 {{countFormatted}} 个下载可用",
      download_options_other: "有 {{countFormatted}} 个下载可用",
      download_source_url: "下载源 URL",
      add_download_source_description: "插入包含 .json 文件的 URL",
      download_source_up_to_date: "已更新",
      download_source_errored: "出错",
      sync_download_sources: "同步源",
      removed_download_source: "已移除下载源",
      added_download_source: "已添加下载源",
      download_sources_synced: "所有下载源已同步",
      insert_valid_json_url: "插入有效的 JSON 网址",
      found_download_option_zero: "未找到下载选项",
      found_download_option_one: "找到 {{countFormatted}} 个下载选项",
      found_download_option_other: "找到 {{countFormatted}} 个下载选项",
      "import": "导入"
    };
    const modal$8 = {
      close: "关闭按钮"
    };
    const forms$1 = {
      toggle_password_visibility: "切换密码可见性"
    };
    const user_profile$1 = {
      amount_hours: "{{amount}} 小时",
      amount_minutes: "{{amount}} 分钟",
      last_time_played: "上次游玩时间 {{period}}",
      activity: "近期活动",
      library: "库",
      total_play_time: "总游戏时长: {{amount}}",
      no_recent_activity_title: "Emmm… 这里暂时啥都没有",
      no_recent_activity_description: "你最近没玩过任何游戏。是时候做出改变了!",
      display_name: "昵称",
      saving: "保存中",
      save: "保存",
      edit_profile: "编辑资料",
      saved_successfully: "成功保存",
      try_again: "请重试",
      sign_out_modal_title: "你确定吗?",
      cancel: "取消",
      successfully_signed_out: "登出成功",
      sign_out: "登出",
      playing_for: "Playing for {{amount}}",
      sign_out_modal_text: "您的资料库与您当前的账户相关联。注销后，您的资料库将不再可见，任何进度也不会保存。继续退出吗？"
    };
    const translation$8 = {
      app: app$1,
      home: home$8,
      sidebar: sidebar$8,
      header: header$8,
      bottom_panel: bottom_panel$8,
      catalogue: catalogue$8,
      game_details: game_details$8,
      activation: activation$8,
      downloads: downloads$8,
      settings: settings$8,
      modal: modal$8,
      forms: forms$1,
      user_profile: user_profile$1
    };
    const home$7 = {
      featured: "Unggulan",
      trending: "Trending",
      surprise_me: "Kejutkan Saya",
      no_results: "Tidak ada hasil"
    };
    const sidebar$7 = {
      catalogue: "Katalog",
      downloads: "Unduhan",
      settings: "Pengaturan",
      my_library: "Koleksi saya",
      downloading_metadata: "{{title}} (Mengunduh metadata…)",
      paused: "{{title}} (Terhenti)",
      downloading: "{{title}} ({{percentage}} - Mengunduh…)",
      filter: "Filter koleksi",
      home: "Beranda"
    };
    const header$7 = {
      search: "Pencarian",
      home: "Beranda",
      catalogue: "Katalog",
      downloads: "Unduhan",
      search_results: "Hasil pencarian",
      settings: "Pengaturan"
    };
    const bottom_panel$7 = {
      no_downloads_in_progress: "Tidak ada unduhan berjalan",
      downloading_metadata: "Mengunduh metadata {{title}}...",
      downloading: "Mengunduh {{title}}… ({{percentage}} selesai) - Perkiraan {{eta}} - {{speed}}"
    };
    const catalogue$7 = {
      next_page: "Halaman berikutnya",
      previous_page: "Halaman sebelumnya"
    };
    const game_details$7 = {
      open_download_options: "Buka opsi unduhan",
      download_options_zero: "Tidak ada opsi unduhan",
      download_options_one: "{{count}} opsi unduhan",
      download_options_other: "{{count}} opsi unduhan",
      updated_at: "Diperbarui {{updated_at}}",
      install: "Install",
      resume: "Lanjutkan",
      pause: "Hentikan sementara",
      cancel: "Batalkan",
      remove: "Hapus",
      space_left_on_disk: "{{space}} tersisa pada disk",
      eta: "Perkiraan {{eta}}",
      downloading_metadata: "Mengunduh metadata…",
      filter: "Saring repacks",
      requirements: "Keperluan sistem",
      minimum: "Minimum",
      recommended: "Rekomendasi",
      release_date: "Dirilis pada {{date}}",
      publisher: "Dipublikasikan oleh {{publisher}}",
      hours: "jam",
      minutes: "menit",
      amount_hours: "{{amount}} jam",
      amount_minutes: "{{amount}} menit",
      accuracy: "{{accuracy}}% akurasi",
      add_to_library: "Tambahkan ke koleksi",
      remove_from_library: "Hapus dari koleksi",
      no_downloads: "Tidak ada unduhan tersedia",
      play_time: "Dimainkan selama {{amount}}",
      last_time_played: "Terakhir dimainkan {{period}}",
      not_played_yet: "Kamu belum memainkan {{title}}",
      next_suggestion: "Rekomendasi berikutnya",
      play: "Mainkan",
      deleting: "Menghapus installer…",
      close: "Tutup",
      playing_now: "Memainkan sekarang",
      change: "Ubah",
      repacks_modal_description: "Pilih repack yang kamu ingin unduh",
      select_folder_hint: "Untuk merubah folder bawaan, akses melalui",
      download_now: "Unduh sekarang"
    };
    const activation$7 = {
      title: "Aktivasi Hydra",
      installation_id: "ID instalasi:",
      enter_activation_code: "Masukkan kode aktivasi",
      message: "Jika kamu tidak tau dimana bertanya untuk ini, maka kamu tidak seharusnya memiliki ini.",
      activate: "Aktifkan",
      loading: "Memuat…"
    };
    const downloads$7 = {
      resume: "Lanjutkan",
      pause: "Hentikan sementara",
      eta: "Perkiraan {{eta}}",
      paused: "Terhenti sementara",
      verifying: "Memeriksa…",
      completed: "Selesai",
      cancel: "Batalkan",
      filter: "Saring game yang diunduh",
      remove: "Hapus",
      downloading_metadata: "Mengunduh metadata…",
      deleting: "Menghapus file instalasi…",
      "delete": "Hapus file instalasi",
      delete_modal_title: "Kamu yakin?",
      delete_modal_description: "Proses ini akan menghapus semua file instalasi dari komputer kamu",
      install: "Install"
    };
    const settings$7 = {
      downloads_path: "Lokasi unduhan",
      change: "Perbarui",
      notifications: "Pengingat",
      enable_download_notifications: "Saat unduhan selesai",
      enable_repack_list_notifications: "Saat repack terbaru ditambahkan",
      behavior: "Perilaku",
      quit_app_instead_hiding: "Tutup aplikasi alih-alih menyembunyikan aplikasi",
      launch_with_system: "Jalankan saat memulai sistem"
    };
    const notifications$7 = {
      download_complete: "Unduhan selesai",
      game_ready_to_install: "{{title}} sudah siap untuk instalasi",
      repack_list_updated: "Daftar repack diperbarui",
      repack_count_one: "{{count}} repack ditambahkan",
      repack_count_other: "{{count}} repack ditambahkan"
    };
    const system_tray$7 = {
      open: "Buka Hydra",
      quit: "Tutup"
    };
    const game_card$7 = {
      no_downloads: "Tidak ada unduhan tersedia"
    };
    const binary_not_found_modal$7 = {
      title: "Program tidak terinstal",
      description: "Wine atau Lutris exe tidak ditemukan pada sistem kamu",
      instructions: "Periksa cara instalasi yang benar pada Linux distro-mu agar game dapat dimainkan dengan benar"
    };
    const modal$7 = {
      close: "Tombol tutup"
    };
    const translation$7 = {
      home: home$7,
      sidebar: sidebar$7,
      header: header$7,
      bottom_panel: bottom_panel$7,
      catalogue: catalogue$7,
      game_details: game_details$7,
      activation: activation$7,
      downloads: downloads$7,
      settings: settings$7,
      notifications: notifications$7,
      system_tray: system_tray$7,
      game_card: game_card$7,
      binary_not_found_modal: binary_not_found_modal$7,
      modal: modal$7
    };
    const home$6 = {
      featured: "추천",
      trending: "인기",
      surprise_me: "무작위 추천",
      no_results: "결과 없음"
    };
    const sidebar$6 = {
      catalogue: "카탈로그",
      downloads: "다운로드",
      settings: "설정",
      my_library: "내 라이브러리",
      downloading_metadata: "{{title}} (메타데이터 다운로드 중…)",
      paused: "{{title}} (일시 정지됨)",
      downloading: "{{title}} ({{percentage}} - 다운로드 중…)",
      filter: "라이브러리 정렬",
      home: "홈"
    };
    const header$6 = {
      search: "게임 검색하기",
      home: "홈",
      catalogue: "카탈로그",
      downloads: "다운로드",
      search_results: "검색 결과",
      settings: "설정"
    };
    const bottom_panel$6 = {
      no_downloads_in_progress: "진행중인 다운로드 없음",
      downloading_metadata: "{{title}}의 메타데이터를 다운로드 중…",
      downloading: "{{title}}의 파일들을 다운로드 중… ({{percentage}} 완료) - 완료까지 {{eta}} - {{speed}}"
    };
    const catalogue$6 = {
      next_page: "다음 페이지",
      previous_page: "이전 페이지"
    };
    const game_details$6 = {
      open_download_options: "다운로드 선택지 열기",
      download_options_zero: "다운로드 선택지 없음",
      download_options_one: "{{count}}개의 다운로드 선택지가 존재함",
      download_options_other: "{{count}}개의 다운로드 선택지들이 존재함",
      updated_at: "{{updated_at}}에 업데이트 됨",
      install: "설치",
      resume: "재개",
      pause: "일시 정지",
      cancel: "취소",
      remove: "제거",
      space_left_on_disk: "여유 저장 용량 {{space}} 남음",
      eta: "완료까지 {{eta}}",
      downloading_metadata: "메타데이터 다운로드 중…",
      filter: "리팩들을 다음과 같이 정렬하기",
      requirements: "시스템 사양",
      minimum: "최저 사양",
      recommended: "권장 사양",
      release_date: "{{date}}에 발매됨",
      publisher: "{{publisher}} 배급",
      hours: "시",
      minutes: "분",
      amount_hours: "{{amount}} 시간",
      amount_minutes: "{{amount}} 분",
      accuracy: "정확도 {{accuracy}}%",
      add_to_library: "라이브러리에 추가",
      remove_from_library: "라이브러리에서 제거",
      no_downloads: "가능한 다운로드 없음",
      play_time: "{{amount}}동안 플레이 함",
      last_time_played: "마지막 플레이 날짜 {{period}}",
      not_played_yet: "{{title}}의 플레이 기록 아직 없음",
      next_suggestion: "다음 추천",
      play: "실행",
      deleting: "인스톨러 삭제 중…",
      close: "닫기",
      playing_now: "현재 플레이 중",
      change: "바꾸기",
      repacks_modal_description: "다운로드 할 리팩을 선택해 주세요",
      select_folder_hint: "기본 폴더를 바꾸려면 <0>설정</0>으로 가세요",
      download_now: "지금 다운로드"
    };
    const activation$6 = {
      title: "Hydra 실행",
      installation_id: "설치 ID:",
      enter_activation_code: "활성 코드를 입력하세요",
      message: "이것을 어디에서 구해야 할 지 모르겠다면 애초에 갖고 있으면 안 됩니다.",
      activate: "활성화",
      loading: "불러오는중..."
    };
    const downloads$6 = {
      resume: "재개",
      pause: "일시 정지",
      eta: "완료까지 {{eta}}",
      paused: "일시 정지됨",
      verifying: "검증중…",
      completed: "완료됨",
      cancel: "취소",
      filter: "다운로드 된 게임들을 정렬하기",
      remove: "제거하기",
      downloading_metadata: "메타데이터 다운로드 중…",
      deleting: "인스톨러 삭제 중…",
      "delete": "인스톨러 삭제하기",
      delete_modal_title: "정말로 하시겠습니까?",
      delete_modal_description: "이 기기의 모든 설치 파일들이 제거될 것입니다",
      install: "설치"
    };
    const settings$6 = {
      downloads_path: "다운로드 경로",
      change: "업데이트",
      notifications: "알림",
      enable_download_notifications: "다운로드가 완료되었을 때",
      enable_repack_list_notifications: "새 리팩이 추가되었을 때",
      quit_app_instead_hiding: "작업 표시줄 트레이로 최소화하는 대신 Hydra를 종료",
      launch_with_system: "컴퓨터가 시작되었을 때 Hydra 실행",
      general: "일반",
      behavior: "행동",
      enable_real_debrid: "Real-Debrid 활성화",
      real_debrid_api_token_hint: "API 키를 <0>이곳</0>에서 얻으세요.",
      save_changes: "변경 사항 저장"
    };
    const notifications$6 = {
      download_complete: "다운로드 완료",
      game_ready_to_install: "이제 {{title}} 설치할 수 있습니다",
      repack_list_updated: "리팩 목록 갱신됨",
      repack_count_one: "{{count}}개의 리팩이 추가됨",
      repack_count_other: "{{count}}개의 리팩들이 추가됨"
    };
    const system_tray$6 = {
      open: "Hydra 열기",
      quit: "닫기"
    };
    const game_card$6 = {
      no_downloads: "가능한 다운로드 없음"
    };
    const binary_not_found_modal$6 = {
      title: "프로그램이 설치되지 않음",
      description: "Wine 또는 Lutris 실행 파일이 시스템에서 발견되지 않았습니다",
      instructions: "게임이 정상적으로 실행될 수 있게 당신의 리눅스 배포판에 Wine 또는 Lutris를 올바르게 설치해 주세요"
    };
    const modal$6 = {
      close: "닫기 버튼"
    };
    const translation$6 = {
      home: home$6,
      sidebar: sidebar$6,
      header: header$6,
      bottom_panel: bottom_panel$6,
      catalogue: catalogue$6,
      game_details: game_details$6,
      activation: activation$6,
      downloads: downloads$6,
      settings: settings$6,
      notifications: notifications$6,
      system_tray: system_tray$6,
      game_card: game_card$6,
      binary_not_found_modal: binary_not_found_modal$6,
      modal: modal$6
    };
    const home$5 = {
      featured: "Anbefalet",
      trending: "Trender",
      surprise_me: "Overrask mig",
      no_results: "Ingen resultater fundet"
    };
    const sidebar$5 = {
      catalogue: "Katalog",
      downloads: "Downloads",
      settings: "Indstillinger",
      my_library: "Mit bibliotek",
      downloading_metadata: "{{title}} (Downloader metadata…)",
      paused: "{{title}} (Paused)",
      downloading: "{{title}} ({{percentage}} - Downloading…)",
      filter: "Filtrer bibliotek",
      home: "Hjem"
    };
    const header$5 = {
      search: "Søg spil",
      home: "Hjem",
      catalogue: "Katalog",
      downloads: "Downloads",
      search_results: "Søge resultater",
      settings: "Indstillinger"
    };
    const bottom_panel$5 = {
      no_downloads_in_progress: "Ingen downloads igang",
      downloading_metadata: "Downloader {{title}} metadata…",
      downloading: "Downloader {{title}}… ({{percentage}} færdig) - Konklusion {{eta}} - {{speed}}"
    };
    const catalogue$5 = {
      next_page: "Næste side",
      previous_page: "Tidligere side"
    };
    const game_details$5 = {
      open_download_options: "Åben download muligheder",
      download_options_zero: "Ingen download mulighed",
      download_options_one: "{{count}} download mulighed",
      download_options_other: "{{count}} download muligheder",
      updated_at: "Opdateret {{updated_at}}",
      install: "Installér",
      resume: "Fortsæt",
      pause: "Pause",
      cancel: "Annullér",
      remove: "Fjern",
      space_left_on_disk: "{{space}} tilbage på harddisken",
      eta: "Konklusion {{eta}}",
      downloading_metadata: "Downloader metadata…",
      filter: "Filtrer repacks",
      requirements: "System behov",
      minimum: "Mindste",
      recommended: "Anbefalet",
      release_date: "Offentliggjort den {{date}}",
      publisher: "Udgivet af {{publisher}}",
      hours: "timer",
      minutes: "minutter",
      amount_hours: "{{amount}} timer",
      amount_minutes: "{{amount}} minutter",
      accuracy: "{{accuracy}}% nøjagtighed",
      add_to_library: "Tilføj til bibliotek",
      remove_from_library: "Fjern fra bibliotek",
      no_downloads: "Ingen downloads tilgængelige",
      play_time: "Spillet i {{amount}}",
      last_time_played: "Sidst spillet {{period}}",
      not_played_yet: "Du har ikke spillet {{title}} endnu",
      next_suggestion: "Næste forslag",
      play: "Spil",
      deleting: "Sletter installatør…",
      close: "Luk",
      playing_now: "Spiller nu",
      change: "Ændré",
      repacks_modal_description: "Vælg den repack du vil downloade",
      select_folder_hint: "For at ændre standard mappen, gå til <0>Instillingerne</0>",
      download_now: "Download nu"
    };
    const activation$5 = {
      title: "Aktivér Hydra",
      installation_id: "Installations ID:",
      enter_activation_code: "Indtast din aktiverings kode",
      message: "Hvis du ikke ved hvor du skal spørge om dette, burde du ikke have dette.",
      activate: "Aktivér",
      loading: "Loader…"
    };
    const downloads$5 = {
      resume: "Fortsæt",
      pause: "Pause",
      eta: "Konklusion {{eta}}",
      paused: "Pauset",
      verifying: "Verificerer…",
      completed: "Færdigt",
      cancel: "Annullér",
      filter: "Filtrer downloadet spil",
      remove: "Fjern",
      downloading_metadata: "Downloader metadata…",
      deleting: "Sletter installatør…",
      "delete": "Fjern installatør",
      delete_modal_title: "Er du sikker?",
      delete_modal_description: "Dette vil fjerne alle installations filerne fra din computer",
      install: "Installér"
    };
    const settings$5 = {
      downloads_path: "Downloads sti",
      change: "Opdatering",
      notifications: "Notifikationer",
      enable_download_notifications: "Når et download bliver færdigt",
      enable_repack_list_notifications: "Når en ny repack bliver tilføjet",
      quit_app_instead_hiding: "Afslut Hydra instedet for at minimere til processlinjen",
      launch_with_system: "Åben Hydra ved start af systemet",
      general: "Generelt",
      behavior: "Opførsel",
      enable_real_debrid: "Slå Real-Debrid til",
      real_debrid_api_token_hint: "Du kan få din API nøgle <0>her</0>",
      save_changes: "Gem ændringer"
    };
    const notifications$5 = {
      download_complete: "Download færdig",
      game_ready_to_install: "{{title}} er klar til at installeret",
      repack_list_updated: "Repack liste opdateret",
      repack_count_one: "{{count}} repack tilføjet",
      repack_count_other: "{{count}} repacks tilføjet"
    };
    const system_tray$5 = {
      open: "Åben Hydra",
      quit: "Afslut"
    };
    const game_card$5 = {
      no_downloads: "Ingen downloads tilgængelig"
    };
    const binary_not_found_modal$5 = {
      title: "Programmer ikke installeret",
      description: "Wine eller Lutris eksekverbare blev ikke fundet på dit system",
      instructions: "Tjek den korrekte måde at installere nogle af dem, på din Linux distribution, så spillet kan køre normalt"
    };
    const modal$5 = {
      close: "Luk knap"
    };
    const translation$5 = {
      home: home$5,
      sidebar: sidebar$5,
      header: header$5,
      bottom_panel: bottom_panel$5,
      catalogue: catalogue$5,
      game_details: game_details$5,
      activation: activation$5,
      downloads: downloads$5,
      settings: settings$5,
      notifications: notifications$5,
      system_tray: system_tray$5,
      game_card: game_card$5,
      binary_not_found_modal: binary_not_found_modal$5,
      modal: modal$5
    };
    const home$4 = {
      featured: "مميّز",
      trending: "شائع",
      surprise_me: "فاجئني",
      no_results: "لم يتم العثور على نتائج"
    };
    const sidebar$4 = {
      catalogue: "قائمة الألعاب",
      downloads: "التحميلات",
      settings: "إعدادات",
      my_library: "مكتبتي",
      downloading_metadata: "{{title}} (جارٍ تنزيل البيانات الوصفية...)",
      paused: "{{title}} (متوقف)",
      downloading: "{{title}} ({{percentage}} - جارٍ التنزيل...)",
      filter: "بحث في المكتبة",
      home: "الرئيسية"
    };
    const header$4 = {
      search: "ابحث عن الألعاب",
      home: "الرئيسية",
      catalogue: "قائمة الألعاب",
      downloads: "التحميلات",
      search_results: "نتائج البحث",
      settings: "إعدادات"
    };
    const bottom_panel$4 = {
      no_downloads_in_progress: "لا يوجد تنزيلات جارية",
      downloading_metadata: "جارٍ تنزيل بيانات وصف {{title}}",
      downloading: "جارٍ تنزيل {{title}}… ({{percentage}} مكتملة) - الانتهاء {{eta}} - {{speed}}"
    };
    const catalogue$4 = {
      next_page: "الصفحة التالية",
      previous_page: "الصفحة السابقة"
    };
    const game_details$4 = {
      open_download_options: "افتح خيارات التنزيل",
      download_options_zero: "لا يوجد خيار تنزيل",
      download_options_one: "{{count}} خيار تنزيل",
      download_options_other: "{{count}} خيار تنزيل",
      updated_at: "تم التحديث {{updated_at}}",
      install: "تثبيت",
      resume: "استئناف",
      pause: "إيقاف",
      cancel: "إلغاء",
      remove: "إزالة",
      space_left_on_disk: "{{space}} متبقية على القرص",
      eta: "الوقت المتبقي {{eta}}",
      downloading_metadata: "جاري تنزيل البيانات الوصفية...",
      filter: "تصفية حزم إعادة التجميع",
      requirements: "متطلبات النظام",
      minimum: "الحد الأدنى",
      recommended: "موصى به",
      release_date: "تم الإصدار في {{date}}",
      publisher: "نشر بواسطة {{publisher}}",
      hours: "ساعات",
      minutes: "دقائق",
      amount_hours: "{{amount}} ساعات",
      amount_minutes: "{{amount}} دقائق",
      accuracy: "دقة {{accuracy}}%",
      add_to_library: "إضافة إلى المكتبة",
      remove_from_library: "إزالة من المكتبة",
      no_downloads: "لا توجد تنزيلات متاحة",
      play_time: "تم اللعب لمدة {{amount}}",
      last_time_played: "آخر مرة لعبت {{period}}",
      not_played_yet: "لم تلعب {{title}} بعد",
      next_suggestion: "الاقتراح التالي",
      play: "لعب",
      deleting: "جاري حذف المثبت...",
      close: "إغلاق",
      playing_now: "قيد التشغيل الآن",
      change: "تغيير",
      repacks_modal_description: "اختر الحزمة التي تريد تنزيلها",
      select_folder_hint: "لتغيير المجلد الافتراضي، انتقل إلى الإعدادات",
      download_now: "تنزيل الآن",
      no_shop_details: "لم يتم استرداد تفاصيل المتجر.",
      download_options: "خيارات التنزيل",
      download_path: "مسار التنزيل",
      previous_screenshot: "لقطة الشاشة السابقة",
      next_screenshot: "لقطة الشاشة التالية",
      screenshot: "لقطة شاشة {{number}}",
      open_screenshot: "افتح لقطة الشاشة {{number}}"
    };
    const activation$4 = {
      title: "تفعيل هايدرا",
      installation_id: "معرف التثبيت:",
      enter_activation_code: "أدخل رمز التفعيل الخاص بك",
      message: "إذا كنت لا تعرف أين تسأل عن هذا ، فلا يجب أن يكون لديك هذا.",
      activate: "تفعيل",
      loading: "جار التحميل…"
    };
    const downloads$4 = {
      resume: "استئناف",
      pause: "إيقاف مؤقت",
      eta: "الوقت المتبقي {{eta}}",
      paused: "متوقفة مؤقتًا",
      verifying: "جار التحقق…",
      completed: "اكتمل",
      cancel: "إلغاء",
      filter: "تصفية الألعاب التي تم تنزيلها",
      remove: "إزالة",
      downloading_metadata: "جار تنزيل البيانات الوصفية…",
      deleting: "جار حذف المثبت…",
      "delete": "إزالة المثبت",
      delete_modal_title: "هل أنت متأكد؟",
      delete_modal_description: "سيؤدي هذا إلى إزالة جميع ملفات التثبيت من جهاز الكمبيوتر الخاص بك",
      install: "تثبيت"
    };
    const settings$4 = {
      downloads_path: "مسار التنزيلات",
      change: "تحديث",
      notifications: "الإشعارات",
      enable_download_notifications: "عند اكتمال التنزيل",
      enable_repack_list_notifications: "عند إضافة حزمة جديدة",
      real_debrid_api_token_label: "رمز واجهة برمجة التطبيقات (API) لـReal-Debrid ",
      quit_app_instead_hiding: "إنهاء هايدرا بدلاً من التصغير الى شريط الحالة",
      launch_with_system: "تشغيل هايدرا عند بدء تشغيل النظام",
      general: "عام",
      behavior: "السلوك",
      enable_real_debrid: "تفعيل Real-Debrid ",
      real_debrid_api_token_hint: "يمكنك الحصول على مفتاح API الخاص بك هنا",
      save_changes: "حفظ التغييرات"
    };
    const notifications$4 = {
      download_complete: "تم التحميل",
      game_ready_to_install: "{{title}} جاهزة للتثبيت",
      repack_list_updated: "قائمة التجميعات المحدثة",
      repack_count_one: "{{count}} حزمة مضافة",
      repack_count_other: "{{count}} حزم مُضافة"
    };
    const system_tray$4 = {
      open: "فتح هايدرا",
      quit: "خروج"
    };
    const game_card$4 = {
      no_downloads: "لا توجد تنزيلات متاحة"
    };
    const binary_not_found_modal$4 = {
      title: "البرامج غير مثبتة",
      description: "لم يتم العثور على ملفات Wine أو Lutris التنفيذية على نظامك",
      instructions: "تحقق من الطريقة الصحيحة لتثبيت أي منها على توزيعة Linux الخاصة بك حتى تعمل اللعبة بشكل طبيعي"
    };
    const modal$4 = {
      close: "زر إغلاق"
    };
    const translation$4 = {
      home: home$4,
      sidebar: sidebar$4,
      header: header$4,
      bottom_panel: bottom_panel$4,
      catalogue: catalogue$4,
      game_details: game_details$4,
      activation: activation$4,
      downloads: downloads$4,
      settings: settings$4,
      notifications: notifications$4,
      system_tray: system_tray$4,
      game_card: game_card$4,
      binary_not_found_modal: binary_not_found_modal$4,
      modal: modal$4
    };
    const home$3 = {
      featured: "پیشنهادی",
      trending: "پرطرفدار",
      surprise_me: "سوپرایزم کن",
      no_results: "اتمام‌ای پیدا نشد"
    };
    const sidebar$3 = {
      catalogue: "کاتالوگ",
      downloads: "دانلودها",
      settings: "تنظیمات",
      my_library: "کتابخانه‌ی من",
      downloading_metadata: "{{title}} (در حال دانلود متادیتا...)",
      paused: "{{title}} (متوقف شده)",
      downloading: "{{title}} ({{percentage}} - در حال دانلود…)",
      filter: "فیلتر کردن کتابخانه",
      home: "خانه"
    };
    const header$3 = {
      search: "جستجوی  بازی‌ها",
      home: "خانه",
      catalogue: "کاتالوگ",
      downloads: "دانلود‌ها",
      search_results: "نتایج جستجو",
      settings: "تنظیمات"
    };
    const bottom_panel$3 = {
      no_downloads_in_progress: "دانلودی در حال انجام نیست",
      downloading_metadata: "درحال دانلود متادیتاهای {{title}}…",
      downloading: "در حال دانلود {{title}}… ({{percentage}} تکمیل شده) - اتمام {{eta}} - {{speed}}"
    };
    const catalogue$3 = {
      next_page: "صفحه‌ی بعدی",
      previous_page: "صفحه‌ی قبلی"
    };
    const game_details$3 = {
      open_download_options: "بازکردن آپشن‌های دانلود",
      download_options_zero: "هیچ آپشن دانلودی وجود ندارد",
      download_options_one: "{{count}} آپشن دانلود",
      download_options_other: "{{count}} آپشن دانلود",
      updated_at: "بروزرسانی شده در {{updated_at}}",
      install: "نصب",
      resume: "ادامه",
      pause: "توقف",
      cancel: "بیخیال",
      remove: "حذف",
      space_left_on_disk: "{{space}} فضا در دیسک باقی‌مانده",
      eta: "اتمام {{eta}}",
      downloading_metadata: "در حال دانلود متادیتاها…",
      filter: "فیلترکردن ریپک‌ها",
      requirements: "سیستم مورد نیاز",
      minimum: "حداقل",
      recommended: "پیشنهادی",
      release_date: "منتشر شده در {{date}}",
      publisher: "منتشر شده توسط {{publisher}}",
      hours: "ساعت",
      minutes: "دقیقه",
      amount_hours: "{{amount}} ساعت",
      amount_minutes: "{{amount}} دقیقه",
      accuracy: "{{accuracy}}% دقت",
      add_to_library: "اضافه کردن به کتابخانه",
      remove_from_library: "حذف کردن از کتابخانه",
      no_downloads: "هیچ دانلودی نیست",
      play_time: "{{amount}} بازی شده",
      last_time_played: "آخرین بار بازی شده {{period}}",
      not_played_yet: "شما هنوز {{title}} را بازی نکرده‌اید",
      next_suggestion: "پیشنهاد بعدی",
      play: "بازی",
      deleting: "پاک کردن نصب کننده",
      close: "بستن",
      playing_now: "در حال بازی",
      change: "تغییر",
      repacks_modal_description: "ریپک مورد نظر برای دانلود را انتخاب کنید",
      select_folder_hint: "برای تغییر پوشه‌ی پیش‌فرض به <0>Settings</0> بروید",
      download_now: "الان دانلود کن"
    };
    const activation$3 = {
      title: "فعال کردن هایدرا",
      installation_id: "ID نصب:",
      enter_activation_code: "کد فعال‌سازی خود را وارد کنید",
      message: "اگر نمی‌دانید از کجا باید درخواست کنید، پس نباید آن را داشته باشید.",
      activate: "فعال‌سازی",
      loading: "در حال بارگزاری…"
    };
    const downloads$3 = {
      resume: "ادامه",
      pause: "توقف",
      eta: "اتمام {{eta}}",
      paused: "متوقف شده",
      verifying: "در حال اعتبارسنجی…",
      completed: "پایان یافته",
      cancel: "لغو",
      filter: "فیلتر بازی‌های دانلود شده",
      remove: "حذف",
      downloading_metadata: "در حال دانلود متادیتاها…",
      deleting: "در حال پاک کردن اینستالر…",
      "delete": "پاک کردن",
      delete_modal_title: "مطمئنی؟",
      delete_modal_description: "این کار تمام فایل‌های اینستالر را از کامپیوتر شما حذف می‌کند",
      install: "نصف"
    };
    const settings$3 = {
      downloads_path: "مسیر دانلودها",
      change: "بروزرسانی",
      notifications: "نوتیفیکشن‌ها",
      enable_download_notifications: "زمانی که یک دانلود تمام شد",
      enable_repack_list_notifications: "زمانی که یک ریپک جدید اضافه شد",
      quit_app_instead_hiding: "به جای کوچک کردن، از هایدرا خارج شو",
      launch_with_system: "زمانی که سیستم روشن می‌شود، هایدرا را باز کن",
      general: "کلی",
      behavior: "رفتار",
      enable_real_debrid: "فعال‌سازی Real-Debrid",
      real_debrid_api_token_hint: "کلید API خود را از <ب0>اینجا</0> بگیرید.",
      save_changes: "ذخیره تغییرات"
    };
    const notifications$3 = {
      download_complete: "دانلود تمام شد",
      game_ready_to_install: "{{title}} آماده‌ی نصب است",
      repack_list_updated: "لیست ریپک‌ها بروزرسانی شد",
      repack_count_one: "{{count}} ریپک اضافه شد",
      repack_count_other: "{{count}} ریپک اضافه شد"
    };
    const system_tray$3 = {
      open: "باز کردن هایدرا",
      quit: "خروج"
    };
    const game_card$3 = {
      no_downloads: "هیچ دانلودی نیست"
    };
    const binary_not_found_modal$3 = {
      title: "نرم‌افزاری نصب نیست",
      description: "بر روی سیستم شما پیدا نشد Wine یا Lutris فایل‌های اجرایی",
      instructions: "روش صحیح نصب هر کدام از آن‌ها رو روی لینوکس خود چک کنید تا بازی بتواند به درستی اجرا شود"
    };
    const modal$3 = {
      close: "دکمه‌ی خروج"
    };
    const translation$3 = {
      home: home$3,
      sidebar: sidebar$3,
      header: header$3,
      bottom_panel: bottom_panel$3,
      catalogue: catalogue$3,
      game_details: game_details$3,
      activation: activation$3,
      downloads: downloads$3,
      settings: settings$3,
      notifications: notifications$3,
      system_tray: system_tray$3,
      game_card: game_card$3,
      binary_not_found_modal: binary_not_found_modal$3,
      modal: modal$3
    };
    const home$2 = {
      featured: "Recomandate",
      trending: "Populare",
      surprise_me: "Surprinde-mă",
      no_results: "Niciun rezultat găsit"
    };
    const sidebar$2 = {
      catalogue: "Catalog",
      downloads: "Descărcări",
      settings: "Setări",
      my_library: "Biblioteca mea",
      downloading_metadata: "{{title}} (Se descarcă metadata...)",
      paused: "{{title}} (Pauzat)",
      downloading: "{{title}} ({{percentage}} - Se descarcă...)",
      filter: "Filtrează biblioteca",
      home: "Acasă"
    };
    const header$2 = {
      search: "Caută jocuri",
      home: "Acasă",
      catalogue: "Catalog",
      downloads: "Descărcări",
      search_results: "Rezultatele căutării",
      settings: "Setări"
    };
    const bottom_panel$2 = {
      no_downloads_in_progress: "Nicio descărcare în curs",
      downloading_metadata: "Se descarcă metadata pentru {{title}}...",
      downloading: "Se descarcă {{title}}... ({{percentage}} complet) - Concluzie {{eta}} - {{speed}}",
      calculating_eta: "Se descarcă {{title}}... ({{percentage}} complet) - Calculare timp rămas..."
    };
    const catalogue$2 = {
      next_page: "Pagina următoare",
      previous_page: "Pagina anterioară"
    };
    const game_details$2 = {
      open_download_options: "Deschide opțiunile de descărcare",
      download_options_zero: "Nicio opțiune de descărcare",
      download_options_one: "{{count}} opțiune de descărcare",
      download_options_other: "{{count}} opțiuni de descărcare",
      updated_at: "Actualizat la {{updated_at}}",
      install: "Instalează",
      resume: "Reia",
      pause: "Pauză",
      cancel: "Anulează",
      remove: "Elimină",
      space_left_on_disk: "{{space}} liber pe disc",
      eta: "Concluzie {{eta}}",
      calculating_eta: "Calculare timp rămas...",
      downloading_metadata: "Se descarcă metadata...",
      filter: "Filtrează repack-urile",
      requirements: "Cerințe de sistem",
      minimum: "Minim",
      recommended: "Recomandat",
      paused: "Pauzat",
      release_date: "Lansat pe {{date}}",
      publisher: "Publicat de {{publisher}}",
      hours: "ore",
      minutes: "minute",
      amount_hours: "{{amount}} ore",
      amount_minutes: "{{amount}} minute",
      accuracy: "{{accuracy}}% acuratețe",
      add_to_library: "Adaugă în bibliotecă",
      remove_from_library: "Elimină din bibliotecă",
      no_downloads: "Nicio descărcare disponibilă",
      play_time: "Jucat timp de {{amount}}",
      last_time_played: "Ultima dată jucat {{period}}",
      not_played_yet: "Nu ai jucat încă {{title}}",
      next_suggestion: "Sugestia următoare",
      play: "Joacă",
      deleting: "Se șterge programul de instalare...",
      close: "Închide",
      playing_now: "Se joacă acum",
      change: "Schimbă",
      repacks_modal_description: "Alege repack-ul pe care vrei să-l descarci",
      select_folder_hint: "Pentru a schimba folderul predefinit, mergi la <0>Setări</0>",
      download_now: "Descarcă acum",
      no_shop_details: "Nu s-au putut obține detalii din magazin.",
      download_options: "Opțiuni de descărcare",
      download_path: "Locația de descărcare",
      previous_screenshot: "Captura de ecran anterioară",
      next_screenshot: "Captura de ecran următoare",
      screenshot: "Captură de ecran {{number}}",
      open_screenshot: "Deschide captura de ecran {{number}}",
      download_settings: "Setări de descărcare",
      downloader: "Program de descărcare"
    };
    const activation$2 = {
      title: "Activează Hydra",
      installation_id: "ID-ul de instalare:",
      enter_activation_code: "Introdu codul de activare",
      message: "Dacă nu știi de unde să ceri acest lucru, atunci nu ar trebui să-l ai.",
      activate: "Activează",
      loading: "Se încarcă..."
    };
    const downloads$2 = {
      resume: "Reia",
      pause: "Pauză",
      eta: "Concluzie {{eta}}",
      paused: "Pauzat",
      verifying: "Se verifică...",
      completed: "Completat",
      removed: "Nu este descărcat",
      cancel: "Anulează",
      filter: "Filtrează jocurile descărcate",
      remove: "Elimină",
      downloading_metadata: "Se descarcă metadata...",
      deleting: "Se șterge programul de instalare...",
      "delete": "Elimină programul de instalare",
      delete_modal_title: "Ești sigur?",
      delete_modal_description: "Aceasta va elimina toate fișierele de instalare de pe computer",
      install: "Instalează"
    };
    const settings$2 = {
      downloads_path: "Locația de descărcare",
      change: "Actualizează",
      notifications: "Notificări",
      enable_download_notifications: "Când o descărcare este completă",
      enable_repack_list_notifications: "Când un nou repack este adăugat",
      real_debrid_api_token_label: "Token API Real-Debrid",
      quit_app_instead_hiding: "Nu ascunde Hydra la închidere",
      launch_with_system: "Lansează Hydra la pornirea sistemului",
      general: "General",
      behavior: "Comportament",
      language: "Limbă",
      real_debrid_api_token: "Token API",
      enable_real_debrid: "Activează Real-Debrid",
      real_debrid_description: "Real-Debrid este un descărcător fără restricții care îți permite să descarci fișiere instantaneu și la cea mai bună viteză a internetului tău.",
      real_debrid_invalid_token: "Token API invalid",
      real_debrid_api_token_hint: "Poți obține token-ul tău API <0>aici</0>",
      real_debrid_free_account_error: 'Contul "{{username}}" este un cont gratuit. Te rugăm să te abonezi la Real-Debrid',
      real_debrid_linked_message: 'Contul "{{username}}" a fost legat',
      save_changes: "Salvează modificările",
      changes_saved: "Modificările au fost salvate cu succes"
    };
    const notifications$2 = {
      download_complete: "Descărcare completă",
      game_ready_to_install: "{{title}} este gata de instalare",
      repack_list_updated: "Lista de repack-uri a fost actualizată",
      repack_count_one: "{{count}} repack adăugat",
      repack_count_other: "{{count}} repack-uri adăugate"
    };
    const system_tray$2 = {
      open: "Deschide Hydra",
      quit: "Ieși"
    };
    const game_card$2 = {
      no_downloads: "Nicio descărcare disponibilă"
    };
    const binary_not_found_modal$2 = {
      title: "Programele nu sunt instalate",
      description: "Fișierele executabile Wine sau Lutris nu au fost găsite pe sistemul tău",
      instructions: "Verifică modul corect de instalare a oricăruia dintre acestea pe distribuția ta Linux pentru ca jocul să ruleze normal"
    };
    const modal$2 = {
      close: "Buton de închidere"
    };
    const translation$2 = {
      home: home$2,
      sidebar: sidebar$2,
      header: header$2,
      bottom_panel: bottom_panel$2,
      catalogue: catalogue$2,
      game_details: game_details$2,
      activation: activation$2,
      downloads: downloads$2,
      settings: settings$2,
      notifications: notifications$2,
      system_tray: system_tray$2,
      game_card: game_card$2,
      binary_not_found_modal: binary_not_found_modal$2,
      modal: modal$2
    };
    const home$1 = {
      featured: "Destacats",
      trending: "Populars",
      surprise_me: "Sorprèn-me",
      no_results: "No s'ha trobat res"
    };
    const sidebar$1 = {
      catalogue: "Catàleg",
      downloads: "Baixades",
      settings: "Configuració",
      my_library: "Biblioteca",
      downloading_metadata: "{{title}} (S'estan baixant les metadades…)",
      paused: "{{title}} (Pausat)",
      downloading: "{{title}} ({{percentage}} - S'està baixant…)",
      filter: "Filtra la biblioteca",
      home: "Inici"
    };
    const header$1 = {
      search: "Cerca jocs",
      home: "Inici",
      catalogue: "Catàleg",
      downloads: "Baixades",
      search_results: "Resultats de la cerca",
      settings: "Configuració",
      version_available_install: "Hi ha disponible la versió {{version}}. Feu clic aquí per a reiniciar i instal·lar-la.",
      version_available_download: "Hi ha disponible la versió {{version}}. Feu clic aquí per a baixar-la."
    };
    const bottom_panel$1 = {
      no_downloads_in_progress: "Cap baixada en curs",
      downloading_metadata: "S'estan baixant les metadades de: {{title}}…",
      downloading: "S'està baixant: {{title}}… ({{percentage}} complet) - Finalització: {{eta}} - {{speed}}"
    };
    const catalogue$1 = {
      next_page: "Pàgina següent",
      previous_page: "Pàgina anterior"
    };
    const game_details$1 = {
      open_download_options: "Obre les opcions de baixada",
      download_options_zero: "No hi ha opcions de baixada",
      download_options_one: "{{count}} opció de baixada",
      download_options_other: "{{count}} opcions de baixada",
      updated_at: "Actualitzat: {{updated_at}}",
      install: "Instal·la",
      resume: "Reprèn",
      pause: "Pausa",
      cancel: "Cancel·la",
      remove: "Elimina",
      space_left_on_disk: "{{space}} lliures al disc",
      eta: "Finalització: {{eta}}",
      downloading_metadata: "S'estan baixant les metadades…",
      filter: "Filtra els reempaquetats",
      requirements: "Requisits del sistema",
      minimum: "Mínims",
      recommended: "Recomanats",
      release_date: "Publicat el {{date}}",
      publisher: "Publicat per {{publisher}}",
      hours: "hores",
      minutes: "minuts",
      amount_hours: "{{amount}} hores",
      amount_minutes: "{{amount}} minuts",
      accuracy: "{{accuracy}}% de precisió",
      add_to_library: "Afegeix a la biblioteca",
      remove_from_library: "Elimina de la biblioteca",
      no_downloads: "No hi ha baixades disponibles",
      play_time: "Jugat durant {{amount}}",
      last_time_played: "Última partida: {{period}}",
      not_played_yet: "Encara no has jugat al {{title}}",
      next_suggestion: "Suggeriment següent",
      play: "Inicia",
      deleting: "S'està eliminant l'instal·lador…",
      close: "Tanca",
      playing_now: "S'està jugant",
      change: "Canvia",
      repacks_modal_description: "Tria quin reempaquetat vols baixar",
      select_folder_hint: "Per a canviar la carpeta predefinida, vés a la <0>Configuració</0>",
      download_now: "Baixa ara",
      no_shop_details: "No s'han pogut recuperar els detalls de la tenda.",
      download_options: "Opcions de baixada",
      download_path: "Ruta de baixada",
      previous_screenshot: "Captura anterior",
      next_screenshot: "Captura següent",
      screenshot: "Captura {{number}}",
      open_screenshot: "Obre la captura {{number}}"
    };
    const activation$1 = {
      title: "Activa l'Hydra",
      installation_id: "ID d'instal·lació:",
      enter_activation_code: "Introdueix el codi d'activació",
      message: "Si no saps on demanar-ho, no ho hauries de tenir.",
      activate: "Activa",
      loading: "S'està carregant…"
    };
    const downloads$1 = {
      resume: "Reprèn",
      pause: "Pausa",
      eta: "Finalització {{eta}}",
      paused: "Pausada",
      verifying: "S'està verificant…",
      completed: "Completada",
      cancel: "Cancel·la",
      filter: "Filtra els jocs baixats",
      remove: "Elimina",
      downloading_metadata: "S'estan baixant les metadades…",
      deleting: "S'està eliminant l'instal·lador…",
      "delete": "Elimina l'instal·lador",
      delete_modal_title: "N'estàs segur?",
      delete_modal_description: "S'eliminaran de l'ordinador tots els fitxers d'instal·lació",
      install: "Instal·la"
    };
    const settings$1 = {
      downloads_path: "Ruta de baixades",
      change: "Actualitza",
      notifications: "Notificacions",
      enable_download_notifications: "Quan finalitzi una baixada",
      enable_repack_list_notifications: "Quan s'afegeixi un nou reempaquetat",
      real_debrid_api_token_label: "Testimoni de l'API de Real Debrid",
      quit_app_instead_hiding: "Tanca l'Hydra en compte de minimitzar-la a la safata",
      launch_with_system: "Inicia l'Hydra quan s'iniciï el sistema",
      general: "General",
      behavior: "Comportament",
      enable_real_debrid: "Activa el Real Debrid",
      real_debrid_api_token_hint: "Pots obtenir la teva clau de l'API <0>aquí</0>.",
      save_changes: "Desa els canvis"
    };
    const notifications$1 = {
      download_complete: "La baixada ha finalitzat",
      game_ready_to_install: "{{title}} ja es pot instal·lar",
      repack_list_updated: "S'ha actualitzat la llista de reempaquetats",
      repack_count_one: "S'ha afegit {{count}} reempaquetat",
      repack_count_other: "S'han afegit {{count}} reempaquetats"
    };
    const system_tray$1 = {
      open: "Obre l'Hydra",
      quit: "Tanca"
    };
    const game_card$1 = {
      no_downloads: "No hi ha baixades disponibles"
    };
    const binary_not_found_modal$1 = {
      title: "Programes no instal·lats",
      description: "No s'ha trobat els executables del Wine o el Lutris al sistema.",
      instructions: "Comprova quina és la manera correcta d'instal·lar qualsevol d'ells en la teva distribució de Linux perquè el joc pugui executar-se amb normalitat."
    };
    const modal$1 = {
      close: "Botó de tancar"
    };
    const translation$1 = {
      home: home$1,
      sidebar: sidebar$1,
      header: header$1,
      bottom_panel: bottom_panel$1,
      catalogue: catalogue$1,
      game_details: game_details$1,
      activation: activation$1,
      downloads: downloads$1,
      settings: settings$1,
      notifications: notifications$1,
      system_tray: system_tray$1,
      game_card: game_card$1,
      binary_not_found_modal: binary_not_found_modal$1,
      modal: modal$1
    };
    const app = {
      successfully_signed_in: "Сәтті кіру"
    };
    const home = {
      featured: "Ұсынылған",
      trending: "Трендте",
      surprise_me: "Таңқалдыр",
      no_results: "Ештеңе табылмады"
    };
    const sidebar = {
      catalogue: "Каталог",
      downloads: "Жүктеулер",
      settings: "Параметрлер",
      my_library: "Кітапхана",
      downloading_metadata: "{{title}} (Метадеректерді жүктеу…)",
      paused: "{{title}} (Тоқтатылды)",
      downloading: "{{title}} ({{percentage}} - Жүктеу…)",
      filter: "Кітапхана фильтрі",
      home: "Басты бет",
      queued: "{{title}} (Кезекте)",
      game_has_no_executable: "Ойынды іске қосу файлы таңдалмаған",
      sign_in: "Кіру"
    };
    const header = {
      search: "Іздеу",
      home: "Басты бет",
      catalogue: "Каталог",
      downloads: "Жүктеулер",
      search_results: "Іздеу нәтижелері",
      settings: "Параметрлер",
      version_available_install: "Қол жетімді нұсқа {{version}}. Қайта іске қосу және орнату үшін мұнда басыңыз.",
      version_available_download: "Қол жетімді нұсқа {{version}}. Жүктеу үшін мұнда басыңыз."
    };
    const bottom_panel = {
      no_downloads_in_progress: "Белсенді жүктеулер жоқ",
      downloading_metadata: "Метадеректерді жүктеу {{title}}…",
      downloading: "Жүктеу {{title}}… ({{percentage}} аяқталды) - Аяқтау {{eta}} - {{speed}}",
      calculating_eta: "Жүктеу {{title}}… ({{percentage}} аяқталды) - Қалған уақытты есептеу…"
    };
    const catalogue = {
      next_page: "Келесі бет",
      previous_page: "Алдыңғы бет"
    };
    const game_details = {
      open_download_options: "Жүктеу нұсқаларын ашу",
      download_options_zero: "Жүктеу нұсқалары жоқ",
      download_options_one: "{{count}} жүктеу нұсқасы",
      download_options_other: "{{count}} жүктеу нұсқалары",
      updated_at: "Жаңартылды {{updated_at}}",
      install: "Орнату",
      resume: "Жандандыру",
      pause: "Тоқтату",
      cancel: "Болдырмау",
      remove: "Жою",
      space_left_on_disk: "{{space}} бос орын",
      eta: "Аяқтау {{eta}}",
      calculating_eta: "Қалған уақытты есептеу…",
      downloading_metadata: "Метадеректерді жүктеу…",
      filter: "Репактар фильтрі",
      requirements: "Жүйелік талаптар",
      minimum: "Минималды",
      recommended: "Ұсынылған",
      paused: "Тоқтатылды",
      release_date: "Шыққан күні {{date}}",
      publisher: "Баспагер {{publisher}}",
      hours: "сағат",
      minutes: "минут",
      amount_hours: "{{amount}} сағат",
      amount_minutes: "{{amount}} минут",
      accuracy: "дәлдік {{accuracy}}%",
      add_to_library: "Кітапханаға қосу",
      remove_from_library: "Кітапханадан жою",
      no_downloads: "Жүктеулер жоқ",
      play_time: "Ойнау уақыты {{amount}}",
      last_time_played: "Соңғы ойнаған уақыт {{period}}",
      not_played_yet: "Сіз {{title}} ойнамағансыз",
      next_suggestion: "Келесі ұсыныс",
      play: "Ойнау",
      deleting: "Орнатушыны жою…",
      close: "Жабу",
      playing_now: "Қазір ойнап жатыр",
      change: "Өзгерту",
      repacks_modal_description: "Жүктеу үшін репакты таңдаңыз",
      select_folder_hint: "Әдепкі жүктеу қалтасын өзгерту үшін <0>Параметрлер</0> ашыңыз",
      download_now: "Қазір жүктеу",
      no_shop_details: "Сипаттаманы алу мүмкін болмады",
      download_options: "Жүктеу нұсқалары",
      download_path: "Жүктеу жолы",
      previous_screenshot: "Алдыңғы скриншот",
      next_screenshot: "Келесі скриншот",
      screenshot: "Скриншот {{number}}",
      open_screenshot: "Скриншотты ашу {{number}}",
      download_settings: "Жүктеу параметрлері",
      downloader: "Жүктегіш",
      select_executable: "Таңдау",
      no_executable_selected: "Файл таңдалмаған",
      open_folder: "Қалтаны ашу",
      open_download_location: "Жүктеу қалтасын қарау",
      create_shortcut: "Жұмыс үстелінде жарлық жасау",
      remove_files: "Файлдарды жою",
      remove_from_library_title: "Сіз сенімдісіз бе?",
      remove_from_library_description: "{{game}} сіздің кітапханаңыздан жойылады.",
      options: "Параметрлер",
      executable_section_title: "Файл",
      executable_section_description: '"Ойнау" батырмасын басқанда іске қосылатын файл жолы',
      downloads_secion_title: "Жүктеулер",
      downloads_section_description: "Ойынның жаңартулары немесе басқа нұсқалары бар-жоғын тексеру",
      danger_zone_section_title: "Қауіпті аймақ",
      danger_zone_section_description: "Осы ойынды кітапханаңыздан жою немесе Hydra жүктеген файлдарды жою",
      download_in_progress: "Жүктеу жүріп жатыр",
      download_paused: "Жүктеу тоқтатылды",
      last_downloaded_option: "Соңғы жүктеу нұсқасы",
      create_shortcut_success: "Жарлық жасалды",
      create_shortcut_error: "Жарлық жасау мүмкін болмады"
    };
    const activation = {
      title: "Hydra-ны белсендіру",
      installation_id: "Орнату ID:",
      enter_activation_code: "Активтендіру кодын енгізіңіз",
      message: "Егер оның қайдан алуға болатынын білмесеңіз, сізде оның болмауы керек.",
      activate: "Белсендіру",
      loading: "Жүктеу…"
    };
    const downloads = {
      resume: "Жандандыру",
      pause: "Тоқтату",
      eta: "Аяқтау {{eta}}",
      paused: "Тоқтатылды",
      verifying: "Тексеру…",
      completed: "Аяқталды",
      removed: "Жүктелмеген",
      cancel: "Болдырмау",
      filter: "Жүктелген ойындар фильтрі",
      remove: "Жою",
      downloading_metadata: "Метадеректерді жүктеу…",
      deleting: "Орнатушыны жою…",
      "delete": "Орнатушыны жою",
      delete_modal_title: "Сіз сенімдісіз бе?",
      delete_modal_description: "Бұл барлық орнатушыларды компьютеріңізден жояды",
      install: "Орнату",
      download_in_progress: "Жүктеу жүріп жатыр",
      queued_downloads: "Кезектегі жүктеулер",
      downloads_completed: "Аяқталды",
      queued: "Кезекте",
      no_downloads_title: "Мұнда бос...",
      no_downloads_description: "Сіз Hydra арқылы әлі ештеңе жүктемегенсіз, бірақ бастау ешқашан кеш емес."
    };
    const settings = {
      downloads_path: "Жүктеу жолы",
      change: "Өзгерту",
      notifications: "Хабарламалар",
      enable_download_notifications: "Жүктеу аяқталғанда",
      enable_repack_list_notifications: "Жаңа репак қосылғанда",
      real_debrid_api_token_label: "Real-Debrid API-токен",
      quit_app_instead_hiding: "Hydra-ны трейге жасырудың орнына жабу",
      launch_with_system: "Жүйемен бірге Hydra-ны іске қосу",
      general: "Жалпы",
      behavior: "Мінез-құлық",
      download_sources: "Жүктеу көздері",
      language: "Тіл",
      real_debrid_api_token: "API Кілті",
      enable_real_debrid: "Real-Debrid-ті қосу",
      real_debrid_description: "Real-Debrid - бұл шектеусіз жүктеуші, ол интернетте орналастырылған файлдарды тез жүктеуге немесе жеке желі арқылы кез келген блоктарды айналып өтіп, оларды бірден плеерге беруге мүмкіндік береді.",
      real_debrid_invalid_token: "Қате API кілті",
      real_debrid_api_token_hint: "API кілтін <0>осы жерден</0> алуға болады",
      real_debrid_free_account_error: '"{{username}}" аккаунты жазылымға ие емес. Real-Debrid жазылымын алыңыз',
      real_debrid_linked_message: '"{{username}}" аккаунты байланған',
      save_changes: "Өзгерістерді сақтау",
      changes_saved: "Өзгерістер сәтті сақталды",
      download_sources_description: "Hydra осы көздерден жүктеу сілтемелерін алады. URL-да жүктеу сілтемелері бар .json файлына тікелей сілтеме болуы керек.",
      validate_download_source: "Тексеру",
      remove_download_source: "Жою",
      add_download_source: "Жүктеу көзін қосу",
      download_count_zero: "Жүктеулер тізімінде жоқ",
      download_count_one: "{{countFormatted}} жүктеу тізімде",
      download_count_other: "{{countFormatted}} жүктеу тізімде",
      download_options_zero: "Қолжетімді жүктеулер жоқ",
      download_options_one: "{{countFormatted}} жүктеу нұсқасы қол жетімді",
      download_options_other: "{{countFormatted}} жүктеу нұсқалары қол жетімді",
      download_source_url: "Көздің сілтемесі",
      add_download_source_description: ".json файлға сілтемені қойыңыз",
      download_source_up_to_date: "Жаңартылған",
      download_source_errored: "Қате",
      sync_download_sources: "Көздерді синхрондау",
      removed_download_source: "Жүктеу көзі жойылды",
      added_download_source: "Жүктеу көзі қосылды",
      download_sources_synced: "Барлық жүктеу көздері синхрондалды",
      insert_valid_json_url: "Жарамды JSON URL енгізіңіз",
      found_download_option_zero: "Жүктеу нұсқалары табылмады",
      found_download_option_one: "{{countFormatted}} жүктеу нұсқасы табылды",
      found_download_option_other: "{{countFormatted}} жүктеу нұсқалары табылды",
      "import": "Импорттау"
    };
    const notifications = {
      download_complete: "Жүктеу аяқталды",
      game_ready_to_install: "{{title}} орнатуға дайын",
      repack_list_updated: "Репактар тізімі жаңартылды",
      repack_count_one: "{{count}} репак қосылды",
      repack_count_other: "{{count}} репактар қосылды"
    };
    const system_tray = {
      open: "Hydra-ны ашу",
      quit: "Шығу"
    };
    const game_card = {
      no_downloads: "Жүктеулер жоқ"
    };
    const binary_not_found_modal = {
      title: "Бағдарламалар орнатылмаған",
      description: "Wine немесе Lutris табылмады",
      instructions: "Linux дистрибутивіңізге олардың кез келгенін дұрыс орнатудың жолын біліңіз осылайша ойын дұрыс жұмыс істей алады"
    };
    const modal = {
      close: "Жабу"
    };
    const forms = {
      toggle_password_visibility: "Құпиясөзді көрсету"
    };
    const user_profile = {
      amount_hours: "{{amount}} сағат",
      amount_minutes: "{{amount}} минут",
      last_time_played: "Соңғы ойын {{period}}",
      activity: "Соңғы әрекет",
      library: "Кітапхана",
      total_play_time: "Барлығы ойнаған: {{amount}}",
      no_recent_activity_title: "Хммм... Мұнда ештеңе жоқ",
      no_recent_activity_description: "Сіз ұзақ уақыт бойы ештеңе ойнаған жоқсыз. Мұны өзгерту керек!",
      display_name: "Көрсету аты",
      saving: "Сақтау",
      save: "Сақталды",
      edit_profile: "Профильді өзгерту",
      saved_successfully: "Сәтті сақталды",
      try_again: "Қайта көріңіз",
      sign_out_modal_title: "Сіз сенімдісіз бе?",
      cancel: "Болдырмау",
      successfully_signed_out: "Аккаунттан сәтті шығу",
      sign_out: "Шығу",
      playing_for: "Ойнаған {{amount}}",
      sign_out_modal_text: "Сіздің кітапханаңыз ағымдағы аккаунтпен байланысты. Жүйеден шыққанда сіздің кітапханаңыз қол жетімсіз болады және прогресс сақталмайды. Шығу?"
    };
    const translation = {
      app,
      home,
      sidebar,
      header,
      bottom_panel,
      catalogue,
      game_details,
      activation,
      downloads,
      settings,
      notifications,
      system_tray,
      game_card,
      binary_not_found_modal,
      modal,
      forms,
      user_profile
    };
    const resources = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      ar: translation$4,
      be: translation$a,
      ca: translation$1,
      da: translation$5,
      en: translation$k,
      es: translation$i,
      fa: translation$3,
      fr: translation$g,
      hu: translation$f,
      id: translation$7,
      it: translation$e,
      kk: translation,
      ko: translation$6,
      nl: translation$h,
      pl: translation$d,
      pt: translation$j,
      ro: translation$2,
      ru: translation$c,
      tr: translation$b,
      uk: translation$9,
      zh: translation$8
    }, Symbol.toStringTag, { value: "Module" }));
    function SettingsGeneral() {
      const { t: t2 } = useTranslation("settings");
      const { updateUserPreferences } = reactExports.useContext(settingsContext);
      const userPreferences = useAppSelector(
        (state) => state.userPreferences.value
      );
      const [form2, setForm] = reactExports.useState({
        downloadsPath: "",
        downloadNotificationsEnabled: false,
        repackUpdatesNotificationsEnabled: false,
        language: ""
      });
      const [languageOptions, setLanguageOptions] = reactExports.useState([]);
      const [defaultDownloadsPath, setDefaultDownloadsPath] = reactExports.useState("");
      reactExports.useEffect(() => {
        async function fetchdefaultDownloadsPath() {
          setDefaultDownloadsPath(await window.electron.getDefaultDownloadsPath());
        }
        fetchdefaultDownloadsPath();
        setLanguageOptions(
          orderBy(
            Object.keys(resources).map((language) => {
              return {
                nativeName: ISO6391.getNativeName(language),
                option: language
              };
            }),
            ["nativeName"],
            "asc"
          )
        );
      }, []);
      reactExports.useEffect(updateFormWithUserPreferences, [
        userPreferences,
        defaultDownloadsPath
      ]);
      const handleLanguageChange = (event) => {
        const value2 = event.target.value;
        handleChange({ language: value2 });
        changeLanguage(value2);
      };
      const handleChange = (values) => {
        setForm((prev) => ({ ...prev, ...values }));
        updateUserPreferences(values);
      };
      const handleChooseDownloadsPath = async () => {
        const { filePaths } = await window.electron.showOpenDialog({
          defaultPath: form2.downloadsPath,
          properties: ["openDirectory"]
        });
        if (filePaths && filePaths.length > 0) {
          const path2 = filePaths[0];
          handleChange({ downloadsPath: path2 });
        }
      };
      function updateFormWithUserPreferences() {
        if (userPreferences) {
          const parsedLanguage = userPreferences.language.split("-")[0];
          setForm((prev) => ({
            ...prev,
            downloadsPath: userPreferences.downloadsPath ?? defaultDownloadsPath,
            downloadNotificationsEnabled: userPreferences.downloadNotificationsEnabled,
            repackUpdatesNotificationsEnabled: userPreferences.repackUpdatesNotificationsEnabled,
            language: parsedLanguage
          }));
        }
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TextField,
          {
            label: t2("downloads_path"),
            value: form2.downloadsPath,
            readOnly: true,
            disabled: true,
            rightContent: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { theme: "outline", onClick: handleChooseDownloadsPath, children: t2("change") })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          SelectField,
          {
            label: t2("language"),
            value: form2.language,
            onChange: handleLanguageChange,
            options: languageOptions.map((language) => ({
              key: language.option,
              value: language.option,
              label: language.nativeName
            }))
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: t2("notifications") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            CheckboxField,
            {
              label: t2("enable_download_notifications"),
              checked: form2.downloadNotificationsEnabled,
              onChange: () => handleChange({
                downloadNotificationsEnabled: !form2.downloadNotificationsEnabled
              })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            CheckboxField,
            {
              label: t2("enable_repack_list_notifications"),
              checked: form2.repackUpdatesNotificationsEnabled,
              onChange: () => handleChange({
                repackUpdatesNotificationsEnabled: !form2.repackUpdatesNotificationsEnabled
              })
            }
          )
        ] })
      ] });
    }
    function SettingsBehavior() {
      const userPreferences = useAppSelector(
        (state) => state.userPreferences.value
      );
      const [showRunAtStartup, setShowRunAtStartup] = reactExports.useState(false);
      const { updateUserPreferences } = reactExports.useContext(settingsContext);
      const [form2, setForm] = reactExports.useState({
        preferQuitInsteadOfHiding: false,
        runAtStartup: false
      });
      const { t: t2 } = useTranslation("settings");
      reactExports.useEffect(() => {
        if (userPreferences) {
          setForm({
            preferQuitInsteadOfHiding: userPreferences.preferQuitInsteadOfHiding,
            runAtStartup: userPreferences.runAtStartup
          });
        }
      }, [userPreferences]);
      reactExports.useEffect(() => {
        window.electron.isPortableVersion().then((isPortableVersion) => {
          setShowRunAtStartup(!isPortableVersion);
        });
      }, []);
      const handleChange = (values) => {
        setForm((prev) => ({ ...prev, ...values }));
        updateUserPreferences(values);
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          CheckboxField,
          {
            label: t2("quit_app_instead_hiding"),
            checked: form2.preferQuitInsteadOfHiding,
            onChange: () => handleChange({
              preferQuitInsteadOfHiding: !form2.preferQuitInsteadOfHiding
            })
          }
        ),
        showRunAtStartup && /* @__PURE__ */ jsxRuntimeExports.jsx(
          CheckboxField,
          {
            label: t2("launch_with_system"),
            onChange: () => {
              handleChange({ runAtStartup: !form2.runAtStartup });
              window.electron.autoLaunch(!form2.runAtStartup);
            },
            checked: form2.runAtStartup
          }
        )
      ] });
    }
    var downloadSources = "dzn4vu0";
    var downloadSourceItem = createRuntimeFn({ defaultClassName: "dzn4vu1", variantClassNames: { isSyncing: { true: "dzn4vu2" } }, defaultVariants: {}, compoundVariants: [] });
    var downloadSourceItemHeader = "dzn4vu3";
    var downloadSourcesHeader = "dzn4vu4";
    var separator = "dzn4vu5";
    function AddDownloadSourceModal({
      visible,
      onClose,
      onAddDownloadSource
    }) {
      const [value2, setValue] = reactExports.useState("");
      const [isLoading, setIsLoading] = reactExports.useState(false);
      const [validationResult, setValidationResult] = reactExports.useState(null);
      const { t: t2 } = useTranslation("settings");
      const { sourceUrl } = reactExports.useContext(settingsContext);
      const handleValidateDownloadSource = reactExports.useCallback(async (url) => {
        setIsLoading(true);
        try {
          const result = await window.electron.validateDownloadSource(url);
          setValidationResult(result);
        } finally {
          setIsLoading(false);
        }
      }, []);
      reactExports.useEffect(() => {
        setValue("");
        setIsLoading(false);
        setValidationResult(null);
        if (sourceUrl) {
          setValue(sourceUrl);
          handleValidateDownloadSource(sourceUrl);
        }
      }, [visible, handleValidateDownloadSource, sourceUrl]);
      const handleAddDownloadSource = async () => {
        await window.electron.addDownloadSource(value2);
        onClose();
        onAddDownloadSource();
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Modal,
        {
          visible,
          title: t2("add_download_source"),
          description: t2("add_download_source_description"),
          onClose,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                display: "flex",
                flexDirection: "column",
                gap: `${SPACING_UNIT}px`,
                minWidth: "500px"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  TextField,
                  {
                    label: t2("download_source_url"),
                    placeholder: t2("insert_valid_json_url"),
                    value: value2,
                    onChange: (e2) => setValue(e2.target.value),
                    rightContent: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Button,
                      {
                        type: "button",
                        theme: "outline",
                        style: { alignSelf: "flex-end" },
                        onClick: () => handleValidateDownloadSource(value2),
                        disabled: isLoading || !value2,
                        children: t2("validate_download_source")
                      }
                    )
                  }
                ),
                validationResult && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    style: {
                      display: "flex",
                      justifyContent: "space-between",
                      alignItems: "center",
                      marginTop: `${SPACING_UNIT * 3}px`
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(
                        "div",
                        {
                          style: {
                            display: "flex",
                            flexDirection: "column",
                            gap: `${SPACING_UNIT / 2}px`
                          },
                          children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: validationResult?.name }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: t2("found_download_option", {
                              count: validationResult?.downloadCount,
                              countFormatted: validationResult?.downloadCount.toLocaleString()
                            }) })
                          ]
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "button", onClick: handleAddDownloadSource, children: t2("import") })
                    ]
                  }
                )
              ]
            }
          )
        }
      );
    }
    function SettingsDownloadSources() {
      const [showAddDownloadSourceModal, setShowAddDownloadSourceModal] = reactExports.useState(false);
      const [downloadSources$1, setDownloadSources] = reactExports.useState([]);
      const [isSyncingDownloadSources, setIsSyncingDownloadSources] = reactExports.useState(false);
      const { sourceUrl, clearSourceUrl } = reactExports.useContext(settingsContext);
      const { t: t2 } = useTranslation("settings");
      const { showSuccessToast } = useToast();
      const getDownloadSources = async () => {
        return window.electron.getDownloadSources().then((sources) => {
          setDownloadSources(sources);
        });
      };
      reactExports.useEffect(() => {
        getDownloadSources();
      }, []);
      reactExports.useEffect(() => {
        if (sourceUrl)
          setShowAddDownloadSourceModal(true);
      }, [sourceUrl]);
      const handleRemoveSource = async (id2) => {
        await window.electron.removeDownloadSource(id2);
        showSuccessToast(t2("removed_download_source"));
        getDownloadSources();
      };
      const handleAddDownloadSource = async () => {
        await getDownloadSources();
        showSuccessToast(t2("added_download_source"));
      };
      const syncDownloadSources = async () => {
        setIsSyncingDownloadSources(true);
        window.electron.syncDownloadSources().then(() => {
          showSuccessToast(t2("download_sources_synced"));
          getDownloadSources();
        }).finally(() => {
          setIsSyncingDownloadSources(false);
        });
      };
      const statusTitle = {
        [DownloadSourceStatus.UpToDate]: t2("download_source_up_to_date"),
        [DownloadSourceStatus.Errored]: t2("download_source_errored")
      };
      const handleModalClose = () => {
        clearSourceUrl();
        setShowAddDownloadSourceModal(false);
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          AddDownloadSourceModal,
          {
            visible: showAddDownloadSourceModal,
            onClose: handleModalClose,
            onAddDownloadSource: handleAddDownloadSource
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontFamily: '"Fira Sans"' }, children: t2("download_sources_description") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: downloadSourcesHeader, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Button,
            {
              type: "button",
              theme: "outline",
              disabled: !downloadSources$1.length || isSyncingDownloadSources,
              onClick: syncDownloadSources,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(SyncIcon, {}),
                t2("sync_download_sources")
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Button,
            {
              type: "button",
              theme: "outline",
              onClick: () => setShowAddDownloadSourceModal(true),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(PlusCircleIcon, {}),
                t2("add_download_source")
              ]
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: downloadSources, children: downloadSources$1.map((downloadSource) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "li",
          {
            className: downloadSourceItem({
              isSyncing: isSyncingDownloadSources
            }),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: downloadSourceItemHeader, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: downloadSource.name }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { children: statusTitle[downloadSource.status] }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    style: {
                      display: "flex",
                      alignItems: "center",
                      gap: `${SPACING_UNIT}px`
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: t2("download_count", {
                        count: downloadSource.downloadCount,
                        countFormatted: downloadSource.downloadCount.toLocaleString()
                      }) }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: separator }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: t2("download_options", {
                        count: downloadSource.repackCount,
                        countFormatted: downloadSource.repackCount.toLocaleString()
                      }) })
                    ]
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                TextField,
                {
                  label: t2("download_source_url"),
                  value: downloadSource.url,
                  readOnly: true,
                  theme: "dark",
                  disabled: true,
                  rightContent: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    Button,
                    {
                      type: "button",
                      theme: "outline",
                      onClick: () => handleRemoveSource(downloadSource.id),
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(NoEntryIcon, {}),
                        t2("remove_download_source")
                      ]
                    }
                  )
                }
              )
            ]
          },
          downloadSource.id
        )) })
      ] });
    }
    function Settings() {
      const { t: t2 } = useTranslation("settings");
      const categories = [
        t2("general"),
        t2("behavior"),
        t2("download_sources"),
        "Real-Debrid"
      ];
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsContextProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsContextConsumer, { children: ({ currentCategoryIndex, setCurrentCategoryIndex }) => {
        const renderCategory = () => {
          if (currentCategoryIndex === 0) {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsGeneral, {});
          }
          if (currentCategoryIndex === 1) {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsBehavior, {});
          }
          if (currentCategoryIndex === 2) {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsDownloadSources, {});
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsRealDebrid, {});
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: container, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: content, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: settingsCategories, children: categories.map((category, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              theme: currentCategoryIndex === index2 ? "primary" : "outline",
              onClick: () => setCurrentCategoryIndex(index2),
              children: category
            },
            category
          )) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: categories[currentCategoryIndex] }),
          renderCategory()
        ] }) });
      } }) });
    }
    function Catalogue() {
      const dispatch = useAppDispatch();
      const { t: t2 } = useTranslation("catalogue");
      const [searchResults, setSearchResults] = reactExports.useState([]);
      const [isLoading, setIsLoading] = reactExports.useState(false);
      const contentRef = reactExports.useRef(null);
      const cursorRef = reactExports.useRef(0);
      const navigate = useNavigate();
      const [searchParams] = useSearchParams();
      const cursor = Number(searchParams.get("cursor") ?? 0);
      const handleGameClick = (game) => {
        dispatch(clearSearch());
        navigate(buildGameDetailsPath(game));
      };
      reactExports.useEffect(() => {
        if (contentRef.current)
          contentRef.current.scrollTop = 0;
        setIsLoading(true);
        setSearchResults([]);
        window.electron.getGames(24, cursor).then(({ results, cursor: cursor2 }) => {
          return new Promise((resolve) => {
            setTimeout(() => {
              cursorRef.current = cursor2;
              setSearchResults(results);
              resolve(null);
            }, 500);
          });
        }).finally(() => {
          setIsLoading(false);
        });
      }, [dispatch, cursor, searchParams]);
      const handleNextPage = () => {
        const params = new URLSearchParams({
          cursor: cursorRef.current.toString()
        });
        navigate(`/catalogue?${params.toString()}`);
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(SkeletonTheme, { baseColor: vars.color.background, highlightColor: "#444", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "section",
          {
            style: {
              padding: `${SPACING_UNIT * 3}px ${SPACING_UNIT * 4}px`,
              display: "flex",
              width: "100%",
              justifyContent: "space-between",
              alignItems: "center",
              borderBottom: `1px solid ${vars.color.border}`
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Button,
                {
                  onClick: () => navigate(-1),
                  theme: "outline",
                  disabled: cursor === 0 || isLoading,
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowLeftIcon, {}),
                    t2("previous_page")
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { onClick: handleNextPage, theme: "outline", disabled: isLoading, children: [
                t2("next_page"),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowRightIcon, {})
              ] })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("section", { ref: contentRef, className: content$2, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: cards, children: [
          isLoading && Array.from({ length: 12 }).map((_, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { className: cardSkeleton }, index2)),
          !isLoading && searchResults.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: searchResults.map((game) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            GameCard,
            {
              game,
              onClick: () => handleGameClick(game)
            },
            game.objectID
          )) })
        ] }) })
      ] });
    }
    const store = configureStore({
      reducer: {
        search: searchSlice.reducer,
        window: windowSlice.reducer,
        library: librarySlice.reducer,
        userPreferences: userPreferencesSlice.reducer,
        download: downloadSlice.reducer,
        toast: toastSlice.reducer,
        userDetails: userDetailsSlice.reducer,
        gameRunning: gameRunningSlice.reducer
      }
    });
    var wrapper = "loh5j00";
    var profileContentBox = "loh5j01";
    var profileAvatarContainer = "loh5j02";
    var profileAvatarEditContainer = "loh5j03";
    var profileAvatar = "loh5j04";
    var profileInformation = "loh5j06";
    var profileContent = "loh5j07";
    var profileGameSection = "loh5j08";
    var contentSidebar = "loh5j09";
    var feedGameIcon = "loh5j0a";
    var libraryGameIcon = "loh5j0b";
    var feedItem = "loh5j0c";
    var gameListItem = "loh5j0d";
    var gameInformation = "loh5j0e";
    var profileHeaderSkeleton = "loh5j0f";
    var editProfileImageBadge = "loh5j0g";
    var telescopeIcon = "loh5j0h";
    var noDownloads = "loh5j0i";
    var signOutModalContent = "loh5j0j";
    var signOutModalButtonsContainer = "loh5j0k";
    var profileBackground = "loh5j0l";
    const UserSkeleton = () => {
      const { t: t2 } = useTranslation("user_profile");
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { className: profileHeaderSkeleton }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: profileContent, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: profileGameSection, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("activity") }),
            Array.from({ length: 3 }).map((_, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              Skeleton,
              {
                height: 72,
                style: { flex: "1", width: "100%" }
              },
              index2
            ))
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cn(contentSidebar, profileGameSection), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("library") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                style: {
                  display: "grid",
                  gridTemplateColumns: "repeat(4, 1fr)",
                  gap: `${SPACING_UNIT}px`
                },
                children: Array.from({ length: 8 }).map((_, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { style: { aspectRatio: "1" } }, index2))
              }
            )
          ] })
        ] })
      ] });
    };
    const UserEditProfileModal = ({
      userProfile,
      visible,
      onClose,
      updateUserProfile
    }) => {
      const { t: t2 } = useTranslation("user_profile");
      const [displayName, setDisplayName] = reactExports.useState("");
      const [newImagePath, setNewImagePath] = reactExports.useState(null);
      const [isSaving, setIsSaving] = reactExports.useState(false);
      const { patchUser } = useUserDetails();
      const { showSuccessToast, showErrorToast } = useToast();
      reactExports.useEffect(() => {
        setDisplayName(userProfile.displayName);
      }, [userProfile.displayName]);
      const handleChangeProfileAvatar = async () => {
        const { filePaths } = await window.electron.showOpenDialog({
          properties: ["openFile"],
          filters: [
            {
              name: "Image",
              extensions: ["jpg", "jpeg", "png", "webp"]
            }
          ]
        });
        if (filePaths && filePaths.length > 0) {
          const path2 = filePaths[0];
          setNewImagePath(path2);
        }
      };
      const handleSaveProfile = async (event) => {
        event.preventDefault();
        setIsSaving(true);
        patchUser(displayName, newImagePath).then(async () => {
          await updateUserProfile();
          showSuccessToast(t2("saved_successfully"));
          cleanFormAndClose();
        }).catch(() => {
          showErrorToast(t2("try_again"));
        }).finally(() => {
          setIsSaving(false);
        });
      };
      const resetModal = () => {
        setDisplayName(userProfile.displayName);
        setNewImagePath(null);
      };
      const cleanFormAndClose = () => {
        resetModal();
        onClose();
      };
      const avatarUrl = reactExports.useMemo(() => {
        if (newImagePath)
          return `local:${newImagePath}`;
        if (userProfile.profileImageUrl)
          return userProfile.profileImageUrl;
        return null;
      }, [newImagePath, userProfile.profileImageUrl]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Modal,
        {
          visible,
          title: t2("edit_profile"),
          onClose: cleanFormAndClose,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "form",
            {
              onSubmit: handleSaveProfile,
              style: {
                display: "flex",
                flexDirection: "column",
                justifyContent: "center",
                alignItems: "center",
                gap: `${SPACING_UNIT * 3}px`,
                width: "350px"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "button",
                  {
                    type: "button",
                    className: profileAvatarEditContainer,
                    onClick: handleChangeProfileAvatar,
                    children: [
                      avatarUrl ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "img",
                        {
                          className: profileAvatar,
                          alt: userProfile.displayName,
                          src: avatarUrl
                        }
                      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(PersonIcon, { size: 96 }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: editProfileImageBadge, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DeviceCameraIcon, { size: 16 }) })
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  TextField,
                  {
                    label: t2("display_name"),
                    value: displayName,
                    required: true,
                    minLength: 3,
                    containerProps: { style: { width: "100%" } },
                    onChange: (e2) => setDisplayName(e2.target.value)
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    disabled: isSaving,
                    style: { alignSelf: "end" },
                    type: "submit",
                    children: isSaving ? t2("saving") : t2("save")
                  }
                )
              ]
            }
          )
        }
      ) });
    };
    const UserSignOutModal = ({
      visible,
      onConfirm,
      onClose
    }) => {
      const { t: t2 } = useTranslation("user_profile");
      return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Modal,
        {
          visible,
          title: t2("sign_out_modal_title"),
          onClose,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: signOutModalContent, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontFamily: "Fira Sans" }, children: t2("sign_out_modal_text") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: signOutModalButtonsContainer, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: onConfirm, theme: "danger", children: t2("sign_out") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: onClose, theme: "primary", children: t2("cancel") })
            ] })
          ] })
        }
      ) });
    };
    const MAX_MINUTES_TO_SHOW_IN_PLAYTIME = 120;
    function UserContent({
      userProfile,
      updateUserProfile
    }) {
      const { t: t2, i18n } = useTranslation("user_profile");
      const { userDetails, profileBackground: profileBackground$1, signOut } = useUserDetails();
      const { showSuccessToast } = useToast();
      const [showEditProfileModal, setShowEditProfileModal] = reactExports.useState(false);
      const [showSignOutModal, setShowSignOutModal] = reactExports.useState(false);
      const { gameRunning } = useAppSelector((state) => state.gameRunning);
      const navigate = useNavigate();
      const numberFormatter = reactExports.useMemo(() => {
        return new Intl.NumberFormat(i18n.language, {
          maximumFractionDigits: 0
        });
      }, [i18n.language]);
      const { formatDistance: formatDistance2, formatDiffInMillis } = useDate();
      const formatPlayTime = () => {
        const seconds = userProfile.totalPlayTimeInSeconds;
        const minutes = seconds / 60;
        if (minutes < MAX_MINUTES_TO_SHOW_IN_PLAYTIME) {
          return t2("amount_minutes", {
            amount: minutes.toFixed(0)
          });
        }
        const hours = minutes / 60;
        return t2("amount_hours", { amount: numberFormatter.format(hours) });
      };
      const handleGameClick = (game) => {
        navigate(buildGameDetailsPath(game));
      };
      const handleEditProfile = () => {
        setShowEditProfileModal(true);
      };
      const handleConfirmSignout = async () => {
        await signOut();
        showSuccessToast(t2("successfully_signed_out"));
        navigate("/");
      };
      const isMe = userDetails?.id == userProfile.id;
      const profileContentBoxBackground = reactExports.useMemo(() => {
        if (profileBackground$1)
          return profileBackground$1;
        return void 0;
      }, [profileBackground$1]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          UserEditProfileModal,
          {
            visible: showEditProfileModal,
            onClose: () => setShowEditProfileModal(false),
            updateUserProfile,
            userProfile
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          UserSignOutModal,
          {
            visible: showSignOutModal,
            onClose: () => setShowSignOutModal(false),
            onConfirm: handleConfirmSignout
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "section",
          {
            className: profileContentBox,
            style: {
              padding: `${SPACING_UNIT * 3}px ${SPACING_UNIT * 2}px`,
              position: "relative"
            },
            children: [
              gameRunning && isMe && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "img",
                {
                  src: steamUrlBuilder.libraryHero(gameRunning.objectID),
                  alt: gameRunning.title,
                  className: profileBackground
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: {
                    background: profileContentBoxBackground,
                    position: "absolute",
                    inset: 0,
                    borderRadius: "4px"
                  }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: profileAvatarContainer, children: userProfile.profileImageUrl ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "img",
                {
                  className: profileAvatar,
                  alt: userProfile.displayName,
                  src: userProfile.profileImageUrl
                }
              ) : /* @__PURE__ */ jsxRuntimeExports.jsx(PersonIcon, { size: 72 }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: profileInformation, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { style: { fontWeight: "bold" }, children: userProfile.displayName }),
                isMe && gameRunning && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    style: {
                      display: "flex",
                      flexDirection: "column",
                      gap: `${SPACING_UNIT / 2}px`
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "div",
                        {
                          style: {
                            display: "flex",
                            flexDirection: "row",
                            gap: `${SPACING_UNIT}px`,
                            alignItems: "center"
                          },
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: buildGameDetailsPath(gameRunning), children: gameRunning.title })
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: t2("playing_for", {
                        amount: formatDiffInMillis(
                          gameRunning.sessionDurationInMillis,
                          /* @__PURE__ */ new Date()
                        )
                      }) })
                    ]
                  }
                )
              ] }),
              isMe && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: {
                    flex: 1,
                    display: "flex",
                    justifyContent: "end",
                    zIndex: 1
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: {
                        display: "flex",
                        flexDirection: "column",
                        gap: `${SPACING_UNIT}px`
                      },
                      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { theme: "outline", onClick: handleEditProfile, children: t2("edit_profile") }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          Button,
                          {
                            theme: "danger",
                            onClick: () => setShowSignOutModal(true),
                            children: t2("sign_out")
                          }
                        )
                      ] })
                    }
                  )
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: profileContent, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: profileGameSection, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("activity") }),
            !userProfile.recentGames.length ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: noDownloads, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: telescopeIcon, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TelescopeIcon, { size: 24 }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("no_recent_activity_title") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontFamily: "Fira Sans" }, children: t2("no_recent_activity_description") })
            ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                style: {
                  display: "flex",
                  flexDirection: "column",
                  gap: `${SPACING_UNIT * 2}px`
                },
                children: userProfile.recentGames.map((game) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "button",
                  {
                    className: cn(feedItem, profileContentBox),
                    onClick: () => handleGameClick(game),
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "img",
                        {
                          className: feedGameIcon,
                          src: game.cover,
                          alt: game.title
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: gameInformation, children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: game.title }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: t2("last_time_played", {
                          period: formatDistance2(
                            game.lastTimePlayed,
                            /* @__PURE__ */ new Date(),
                            {
                              addSuffix: true
                            }
                          )
                        }) })
                      ] })
                    ]
                  },
                  game.objectID
                ))
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: cn(contentSidebar, profileGameSection), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                style: {
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "space-between",
                  gap: `${SPACING_UNIT * 2}px`
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("library") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: {
                        flex: 1,
                        backgroundColor: vars.color.border,
                        height: "1px"
                      }
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { style: { fontWeight: "400" }, children: userProfile.libraryGames.length })
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: t2("total_play_time", { amount: formatPlayTime() }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                style: {
                  display: "grid",
                  gridTemplateColumns: "repeat(4, 1fr)",
                  gap: `${SPACING_UNIT}px`
                },
                children: userProfile.libraryGames.map((game) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    className: cn(gameListItem, profileContentBox),
                    onClick: () => handleGameClick(game),
                    title: game.title,
                    children: game.iconUrl ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "img",
                      {
                        className: libraryGameIcon,
                        src: game.iconUrl,
                        alt: game.title
                      }
                    ) : /* @__PURE__ */ jsxRuntimeExports.jsx(SvgSteamLogo, { className: libraryGameIcon })
                  },
                  game.objectID
                ))
              }
            )
          ] })
        ] })
      ] });
    }
    const User = () => {
      const { userId } = useParams();
      const [userProfile, setUserProfile] = reactExports.useState();
      const navigate = useNavigate();
      const dispatch = useAppDispatch();
      const getUserProfile = reactExports.useCallback(() => {
        return window.electron.getUser(userId).then((userProfile2) => {
          if (userProfile2) {
            dispatch(setHeaderTitle(userProfile2.displayName));
            setUserProfile(userProfile2);
          } else {
            navigate(-1);
          }
        });
      }, [dispatch, userId]);
      reactExports.useEffect(() => {
        getUserProfile();
      }, [getUserProfile]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SkeletonTheme, { baseColor: vars.color.background, highlightColor: "#444", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: wrapper, children: userProfile ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        UserContent,
        {
          userProfile,
          updateUserProfile: getUserProfile
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(UserSkeleton, {}) }) });
    };
    init({});
    instance.use(Browser).use(initReactI18next).init({
      resources,
      fallbackLng: "en",
      interpolation: {
        escapeValue: false
      }
    }).then(() => {
      window.electron.updateUserPreferences({ language: instance.language });
    });
    client.createRoot(document.getElementById("root")).render(
      /* @__PURE__ */ jsxRuntimeExports.jsx(React$1.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Provider_default, { store, children: /* @__PURE__ */ jsxRuntimeExports.jsx(HashRouter, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Routes, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { element: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/", Component: Home }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/catalogue", Component: Catalogue }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/downloads", Component: Downloads }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/game/:shop/:objectID", Component: GameDetails }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/search", Component: SearchResults }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/settings", Component: Settings }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/user/:userId", Component: User })
      ] }) }) }) }) })
    );
  }
});
export default require_index_001();
//# sourceMappingURL=index-krSf2oo9.js.map
